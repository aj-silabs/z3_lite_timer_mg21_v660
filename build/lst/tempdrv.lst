###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:19:57
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emdrv\tempdrv\src\tempdrv.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW533B.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emdrv\tempdrv\src\tempdrv.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"tempdrv.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0
#        -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emdrv\tempdrv\src\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\tempdrv.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\tempdrv.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emdrv\tempdrv\src\tempdrv.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief TEMPDRV API implementation.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc.  Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement.  This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          
     18          #include "em_device.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_ClearPendingIRQ(IRQn_Type)
   \                     __NVIC_ClearPendingIRQ: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xD407             BMI.N    ??__NVIC_ClearPendingIRQ_0
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0xF000 0x011F      AND      R1,R0,#0x1F
   \        0xA   0x408A             LSLS     R2,R2,R1
   \        0xC   0x....             LDR.N    R3,??DataTable13  ;; 0xe000e280
   \        0xE   0x0940             LSRS     R0,R0,#+5
   \       0x10   0xF843 0x2020      STR      R2,[R3, R0, LSL #+2]
   \                     ??__NVIC_ClearPendingIRQ_0: (+1)
   \       0x14   0x4770             BX       LR               ;; return
     19          #include "em_system.h"
     20          #include "em_emu.h"
     21          #include "string.h"
     22          
     23          #include "tempdrv.h"
     24          
     25          typedef struct {
     26            TEMPDRV_Callback_t callback;    ///< Callback function
     27            uint8_t temp;                   ///< Limit temperature (EMU value)
     28          } TEMPDRV_CallbackSet_t;
     29          
     30          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
     31          #define TEMPDRV_ERRATA_FIX
     32          #endif
     33          
     34          #ifdef TEMPDRV_ERRATA_FIX
     35          #define TEMPDRV_INT_CALLBACK_DEPTH 1
     36          #define TEMPDRV_
     37          #else
     38          #define TEMPDRV_INT_CALLBACK_DEPTH 0
     39          #endif
     40          
     41          #define TEMPDRV_CALLBACK_DEPTH (TEMPDRV_INT_CALLBACK_DEPTH + TEMPDRV_CUSTOM_CALLBACK_DEPTH)
     42          #define TEMPDRV_CUSTOM_CALLBACK_INDEX TEMPDRV_INT_CALLBACK_DEPTH
     43          
     44          #if defined(_SILICON_LABS_32B_SERIES_1)
     45          // On Series-1 devices the temperature code is inverted. (high value = low temperature)
     46          #define INCREASING_TEMPERATURE_FLAG   EMU_IF_TEMPLOW
     47          #define DECREASING_TEMPERATURE_FLAG   EMU_IF_TEMPHIGH
     48          #else
     49          // On Series-2 devices the temperature code is normal. (high value = high temperature)
     50          #define INCREASING_TEMPERATURE_FLAG   EMU_IF_TEMPHIGH
     51          #define DECREASING_TEMPERATURE_FLAG   EMU_IF_TEMPLOW
     52          #endif
     53          

   \                                 In section .bss, align 4
     54          static TEMPDRV_CallbackSet_t tempdrvHighCallbacks[TEMPDRV_CALLBACK_DEPTH];
   \                     tempdrvHighCallbacks:
   \        0x0                      DS8 40

   \                                 In section .bss, align 4
     55          static TEMPDRV_CallbackSet_t tempdrvLowCallbacks[TEMPDRV_CALLBACK_DEPTH];
   \                     tempdrvLowCallbacks:
   \        0x0                      DS8 40

   \                                 In section .bss, align 4
     56          static TEMPDRV_CallbackSet_t nullCallback = { NULL, 0 };
   \                     nullCallback:
   \        0x0                      DS8 8

   \                                 In section .bss, align 4
     57          static TEMPDRV_CallbackSet_t *highCallback;
   \                     highCallback:
   \        0x0                      DS8 4

   \                                 In section .bss, align 4
     58          static TEMPDRV_CallbackSet_t *lowCallback;
   \                     lowCallback:
   \        0x0                      DS8 4
     59          

   \                                 In section .bss, align 1
     60          static bool TEMPDRV_InitState = false;
   \                     TEMPDRV_InitState:
   \        0x0                      DS8 1

   \                                 In section .bss, align 1
     61          static bool TEMPDRV_EnableState = false;
   \                     TEMPDRV_EnableState:
   \        0x0                      DS8 1
     62          
     63          static int convertToTemp(uint32_t emu);
     64          static uint32_t convertToEmu(int temp);
     65          static void updateInterrupts(void);
     66          
     67          #if defined(_DEVINFO_CAL_TEMP_MASK)
     68          // Calibration values to be initialized in TEMPDRV_Init
     69          static int calibrationEMU;
     70          static int calibrationTEMP;
     71          // Fallback calibration values in case DI calibration data not present
     72          static uint8_t fallbackEMU = 0x90;
     73          static uint8_t fallbackTEMP = 25;
     74          #endif
     75          
     76          #if (EMU_CUSTOM_IRQ_HANDLER == false)
     77          /***************************************************************************//**
     78           * @brief
     79           *   EMU Interrupt Handler
     80           *
     81           * @details
     82           *   The EMU_IRQHandler provided by TEMPDRV will call @ref TEMPDRV_IRQ_Handler.
     83           *   Configure EMU_CUSTOM_IRQ_HANDLER = true if the application wants to
     84           *   implement its own EMU_IRQHandler. This is typically needed if one of the
     85           *   non-temperature related EMU interrupt flags are in use.
     86           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
     87          void EMU_IRQHandler(void)
     88          {
     89            TEMPDRV_IRQHandler();
   \                     EMU_IRQHandler: (+1)
   \        0x0   0xBF00             Nop      
   \        0x2                      REQUIRE TEMPDRV_IRQHandler
   \        0x2                      ;; // Fall through to label TEMPDRV_IRQHandler
     90          }
     91          #endif
     92          
     93          /***************************************************************************//**
     94           * @brief
     95           *   TEMPDRV Interrupt Handler
     96           *
     97           * @details
     98           *   This function must be called by the EMU interrupt handler in order to
     99           *   support the TEMPDRV callback mechanism.
    100           *
    101           *   This function handles the @ref EMU_IF_TEMPHIGH, @ref EMU_IF_TEMPLOW
    102           *   interrupt flags from the EMU internal temperature sensor.
    103           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    104          void TEMPDRV_IRQHandler(void)
    105          {
   \                     TEMPDRV_IRQHandler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    106            uint32_t flags = EMU_IntGetEnabled();
   \        0x2   0x....             LDR.N    R0,??DataTable13_1  ;; 0x40004064
   \        0x4   0x6842             LDR      R2,[R0, #+4]
   \        0x6   0x6801             LDR      R1,[R0, #+0]
    107            TEMPDRV_Callback_t activeCallback;
    108          
    109            if (flags & DECREASING_TEMPERATURE_FLAG) {
   \        0x8   0x....             LDR.N    R4,??DataTable13_2  ;; 0x40006064
   \        0xA   0x4011             ANDS     R1,R2,R1
   \        0xC   0x004A             LSLS     R2,R1,#+1
   \        0xE   0xD50F             BPL.N    ??TEMPDRV_IRQHandler_0
    110              if (lowCallback->callback != NULL) {
   \       0x10   0x....             LDR.N    R1,??DataTable13_3
   \       0x12   0x6809             LDR      R1,[R1, #+0]
   \       0x14   0x680A             LDR      R2,[R1, #+0]
   \       0x16   0xB13A             CBZ.N    R2,??TEMPDRV_IRQHandler_1
    111                activeCallback = lowCallback->callback;
    112                memset(lowCallback, 0, sizeof(TEMPDRV_CallbackSet_t));
   \       0x18   0x2300             MOVS     R3,#+0
   \       0x1A   0xE9C1 0x3300      STRD     R3,R3,[R1, #+0]
    113                activeCallback(TEMPDRV_GetTemp(), TEMPDRV_LIMIT_LOW);
   \       0x1E   0x6A40             LDR      R0,[R0, #+36]
    114              }
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x....'....        BL       ??Subroutine0_0
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x26   0x4790             BLX      R2
    115              EMU_IntClear(DECREASING_TEMPERATURE_FLAG);
   \                     ??TEMPDRV_IRQHandler_1: (+1)
   \       0x28   0xF04F 0x4180      MOV      R1,#+1073741824
   \       0x2C   0x6021             STR      R1,[R4, #+0]
    116            } else if (flags & INCREASING_TEMPERATURE_FLAG) {
   \       0x2E   0xE010             B.N      ??TEMPDRV_IRQHandler_2
   \                     ??TEMPDRV_IRQHandler_0: (+1)
   \       0x30   0x2900             CMP      R1,#+0
   \       0x32   0xD50E             BPL.N    ??TEMPDRV_IRQHandler_2
    117              if (highCallback->callback != NULL) {
   \       0x34   0x....             LDR.N    R1,??DataTable13_4
   \       0x36   0x6809             LDR      R1,[R1, #+0]
   \       0x38   0x680A             LDR      R2,[R1, #+0]
   \       0x3A   0xB13A             CBZ.N    R2,??TEMPDRV_IRQHandler_3
    118                activeCallback = highCallback->callback;
    119                memset(highCallback, 0, sizeof(TEMPDRV_CallbackSet_t));
   \       0x3C   0x2300             MOVS     R3,#+0
   \       0x3E   0xE9C1 0x3300      STRD     R3,R3,[R1, #+0]
    120                activeCallback(TEMPDRV_GetTemp(), TEMPDRV_LIMIT_HIGH);
   \       0x42   0x6A40             LDR      R0,[R0, #+36]
    121              }
   \       0x44   0x2101             MOVS     R1,#+1
   \       0x46   0x....'....        BL       ??Subroutine0_0
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x4A   0x4790             BLX      R2
    122              EMU_IntClear(INCREASING_TEMPERATURE_FLAG);
   \                     ??TEMPDRV_IRQHandler_3: (+1)
   \       0x4C   0xF04F 0x4000      MOV      R0,#-2147483648
   \       0x50   0x6020             STR      R0,[R4, #+0]
    123            }
    124          
    125            updateInterrupts();
   \                     ??TEMPDRV_IRQHandler_2: (+1)
   \       0x52   0xE8BD 0x4010      POP      {R4,LR}
   \       0x56   0x....             B.N      updateInterrupts
    126          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \                     ??Subroutine0_0: (+1)
   \        0x2   0x0880             LSRS     R0,R0,#+2
   \        0x4   0x3811             SUBS     R0,R0,#+17
   \        0x6   0xB240             SXTB     R0,R0
   \        0x8   0x4770             BX       LR
    127          
    128          #if defined(TEMPDRV_ERRATA_FIX)
    129          /* Errata */
    130          typedef enum ErrataState {
    131            ERRATA_LOW     = 0, /**< Low temperature <65&deg;C. */
    132            ERRATA_MID     = 1, /**< Medium temperature >65&deg;C and <80&deg;C. */
    133            ERRATA_HIGH    = 2  /**< High temperature >80&deg;C. */
    134          } ErrataState_t;
    135          
    136          // These are the temperature limits in degrees Celsius
    137          #define ERRATA_MID_LIMIT   65
    138          #define ERRATA_HIGH_LIMIT  80
    139          #define ERRATA_HYSTERESIS   8
    140          
    141          static void errataCallback(int8_t temp, TEMPDRV_LimitType_t limit);
    142          static void errataStateUpdate(int8_t temp);
    143          
    144          static TEMPDRV_CallbackSet_t errataLowTemp[3];  // Temperature decrease thresholds
    145          static TEMPDRV_CallbackSet_t errataHighTemp[3]; // Temperature increase thresholds
    146          
    147          /***************************************************************************//**
    148           * @brief
    149           *   Errata Callback
    150           *
    151           * @details
    152           *   This function is called by the TEMPDRV_IRQHandler and will change the
    153           *   state depending on the current temperature.
    154           ******************************************************************************/
    155          static void errataCallback(int8_t temp, TEMPDRV_LimitType_t limit)
    156          {
    157            (void) limit; // unused
    158            errataStateUpdate(temp);
    159          }
    160          
    161          /***************************************************************************//**
    162           * @brief
    163           *   Errata State Update
    164           *
    165           * @details
    166           *   Updates registers based on the current temperature
    167           ******************************************************************************/
    168          static void errataStateUpdate(int8_t temp)
    169          {
    170            ErrataState_t errataState;
    171            bool emuLocked = (EMU->LOCK == EMU_LOCK_LOCKKEY_LOCKED);
    172          
    173            // Figure out the current state based on temperature
    174            if (temp < ERRATA_MID_LIMIT) {
    175              errataState = ERRATA_LOW;
    176            } else if (temp < ERRATA_HIGH_LIMIT) {
    177              errataState = ERRATA_MID;
    178            } else {
    179              errataState = ERRATA_HIGH;
    180            }
    181          
    182            // Activate callback and thresholds for the current state
    183            tempdrvHighCallbacks[0] = errataHighTemp[errataState];
    184            tempdrvLowCallbacks[0] = errataLowTemp[errataState];
    185          
    186            if (emuLocked) {
    187              EMU->LOCK = EMU_LOCK_LOCKKEY_UNLOCK;
    188            }
    189          
    190            switch (errataState) {
    191              case ERRATA_LOW:
    192                EMU_SetBiasMode(emuBiasMode_1KHz);
    193                break;
    194              case ERRATA_MID:
    195                EMU_SetBiasMode(emuBiasMode_4KHz);
    196                break;
    197              case ERRATA_HIGH:
    198                EMU_SetBiasMode(emuBiasMode_Continuous);
    199                break;
    200            }
    201          
    202            if (emuLocked) {
    203              EMU->LOCK = EMU_LOCK_LOCKKEY_LOCK;
    204            }
    205          }
    206          
    207          /***************************************************************************//**
    208           * @brief
    209           *   Errata Initialization
    210           *
    211           * @details
    212           *   Initialize the temperature thresholds based on calibration values and
    213           *   initializes the errata fix based on the current temperature.
    214           ******************************************************************************/
    215          static void errataInit(void)
    216          {
    217            SYSTEM_ChipRevision_TypeDef rev;
    218            SYSTEM_ChipRevisionGet(&rev);
    219          
    220            /* Rev A temp errata handling */
    221            if (rev.major == 0x01) {
    222              uint8_t limitLow;
    223              uint8_t limitHigh;
    224          
    225              // Initialize Low temperature state [*, 65]
    226              limitHigh = convertToEmu(ERRATA_MID_LIMIT);
    227              errataHighTemp[ERRATA_LOW].temp = limitHigh;
    228              errataHighTemp[ERRATA_LOW].callback = errataCallback;
    229          
    230              // Initialize Mid temperature state [57, 80]
    231              limitLow  = convertToEmu(ERRATA_MID_LIMIT - ERRATA_HYSTERESIS);
    232              limitHigh = convertToEmu(ERRATA_HIGH_LIMIT);
    233              errataLowTemp[ERRATA_MID].temp = limitLow;
    234              errataLowTemp[ERRATA_MID].callback = errataCallback;
    235              errataHighTemp[ERRATA_MID].temp = limitHigh;
    236              errataHighTemp[ERRATA_MID].callback = errataCallback;
    237          
    238              // Initialize High temperature state [72, *]
    239              limitLow = convertToEmu(ERRATA_HIGH_LIMIT - ERRATA_HYSTERESIS);
    240              errataLowTemp[ERRATA_HIGH].temp = limitLow;
    241              errataLowTemp[ERRATA_HIGH].callback = errataCallback;
    242          
    243              errataStateUpdate(TEMPDRV_GetTemp());
    244            }
    245          }
    246          #else // TEMPDRV_ERRATA_FIX
    247          
    248          #define errataInit()
    249          
    250          #endif // TEMPDRV_ERRATA_FIX
    251          
    252          /* Internal Functions */
    253          /***************************************************************************//**
    254           * @brief
    255           *   Find an empty spot for callback in set
    256           *
    257           * @param[in] set
    258           *   Callback set to search
    259           *
    260           * @return
    261           *   index of empty space if found, -1 if none
    262           ******************************************************************************/
    263          static int8_t findCallbackSpace(TEMPDRV_CallbackSet_t *set)
    264          {
    265            uint8_t index;
    266            for (index = TEMPDRV_CUSTOM_CALLBACK_INDEX; index < TEMPDRV_CALLBACK_DEPTH; index++) {
    267              if (set[index].callback == NULL) {
    268                return index;
    269              }
    270            }
    271            // no empty space, return -1
    272            return -1;
    273          }
    274          
    275          /***************************************************************************//**
    276           * @brief
    277           *   Attempt to add a callback to a set
    278           *
    279           * @param[in] set
    280           *   Callback set to add callback to
    281           *
    282           * @param[in] temp
    283           *   Temperature to register callback at
    284           *
    285           * @param[in] callback
    286           *   Callback function
    287           *
    288           * @return
    289           *    @li @ref ECODE_EMDRV_TEMPDRV_OK on success.
    290           *    @li @ref ECODE_EMDRV_TEMPDRV_NO_SPACE if there is no space left for
    291           *        callbacks.
    292           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    293          static Ecode_t addCallback(TEMPDRV_CallbackSet_t *set,
    294                                     int8_t temp,
    295                                     TEMPDRV_Callback_t callback)
    296          {
   \                     addCallback: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    297            int8_t index = findCallbackSpace(set);
   \        0x2   0x2400             MOVS     R4,#+0
   \                     ??addCallback_0: (+1)
   \        0x4   0xB2E3             UXTB     R3,R4
   \        0x6   0xF850 0x3033      LDR      R3,[R0, R3, LSL #+3]
   \        0xA   0xB173             CBZ.N    R3,??addCallback_1
   \        0xC   0x1C64             ADDS     R4,R4,#+1
   \        0xE   0xB2E5             UXTB     R5,R4
   \       0x10   0x2D04             CMP      R5,#+4
   \       0x12   0xDDF7             BLE.N    ??addCallback_0
   \       0x14   0xE00C             B.N      ??addCallback_2
    298            if (index < 0) {
    299              return ECODE_EMDRV_TEMPDRV_NO_SPACE;
    300            }
    301            set[index].temp = convertToEmu(temp);
   \                     ??addCallback_3: (+1)
   \       0x16   0x3111             ADDS     R1,R1,#+17
   \       0x18   0xEB00 0x03C4      ADD      R3,R0,R4, LSL #+3
   \       0x1C   0x7119             STRB     R1,[R3, #+4]
    302            set[index].callback = callback;
   \       0x1E   0xF840 0x2034      STR      R2,[R0, R4, LSL #+3]
    303            updateInterrupts();
   \       0x22   0x....'....        BL       updateInterrupts
    304            return ECODE_EMDRV_TEMPDRV_OK;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??addCallback_1: (+1)
   \       0x2A   0xB264             SXTB     R4,R4
   \       0x2C   0x2C00             CMP      R4,#+0
   \       0x2E   0xD5F2             BPL.N    ??addCallback_3
   \                     ??addCallback_2: (+1)
   \       0x30   0x....             LDR.N    R0,??DataTable13_5  ;; 0xf000d005
   \       0x32   0xBD32             POP      {R1,R4,R5,PC}
    305          }
    306          
    307          /***************************************************************************//**
    308           * @brief
    309           *   Remove a callback from the set
    310           *
    311           * @param[in] set
    312           *   Callback set to remove callback from
    313           *
    314           * @param[in] callback
    315           *   Callback function
    316           *
    317           * @return
    318           *   @c true on success and @c false if the callback was not found.
    319           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    320          static bool removeCallback(TEMPDRV_CallbackSet_t *set,
    321                                     TEMPDRV_Callback_t callback)
    322          {
   \                     removeCallback: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    323            bool found = false;
   \        0x2   0x2400             MOVS     R4,#+0
    324            uint8_t index;
    325            for (index = TEMPDRV_CUSTOM_CALLBACK_INDEX; index < TEMPDRV_CALLBACK_DEPTH; index++) {
   \        0x4   0x2200             MOVS     R2,#+0
    326              if (set[index].callback == callback) {
   \                     ??removeCallback_0: (+1)
   \        0x6   0xF850 0x3032      LDR      R3,[R0, R2, LSL #+3]
   \        0xA   0x428B             CMP      R3,R1
   \        0xC   0xD106             BNE.N    ??removeCallback_1
    327                set[index].callback = NULL;
   \        0xE   0x2400             MOVS     R4,#+0
    328                set[index].temp = 0;
   \       0x10   0xEB00 0x05C2      ADD      R5,R0,R2, LSL #+3
   \       0x14   0xF840 0x4032      STR      R4,[R0, R2, LSL #+3]
   \       0x18   0x712C             STRB     R4,[R5, #+4]
    329                found = true;
   \       0x1A   0x2401             MOVS     R4,#+1
    330              }
    331            }
   \                     ??removeCallback_1: (+1)
   \       0x1C   0x1C52             ADDS     R2,R2,#+1
   \       0x1E   0x2A04             CMP      R2,#+4
   \       0x20   0xDDF1             BLE.N    ??removeCallback_0
    332            updateInterrupts();
   \       0x22   0x....'....        BL       updateInterrupts
    333            return found;
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    334          }
    335          
    336          /***************************************************************************//**
    337           * @brief
    338           *   Check if another callback has registered the same temperature
    339           *
    340           * @param[in] set
    341           *   Callback set to search
    342           *
    343           * @param[in] temp
    344           *   Temperature to match
    345           *
    346           * @return
    347           *    @c true if a duplicate is found, @c false if no duplicates is found.
    348           ******************************************************************************/
    349          static bool checkForDuplicates(TEMPDRV_CallbackSet_t *set, int8_t temp)
    350          {
    351            uint8_t index;
    352            uint8_t emu = convertToEmu(temp);
    353            for (index = TEMPDRV_CUSTOM_CALLBACK_INDEX; index < TEMPDRV_CALLBACK_DEPTH; index++) {
    354              // filter out only entries with valid callbacks
    355              if (set[index].callback != NULL) {
    356                // if duplicate temperature, return true
    357                if (set[index].temp == emu) {
    358                  return true;
    359                }
    360              }
    361            }
    362            // return false if no duplicate temperatures found
    363            return false;
    364          }
    365          
    366          /***************************************************************************//**
    367           * @brief
    368           *   Convert EMU value to degrees Celsius
    369           *
    370           * @param[in] emu
    371           *   EMU value to convert
    372           *
    373           * @return
    374           *    temperature in degrees Celsius
    375           ******************************************************************************/
    376          static int convertToTemp(uint32_t emu)
    377          {
    378          #if defined(_SILICON_LABS_32B_SERIES_2)
    379            return (int)emu - 273; // Convert from Kelvin to Celsius
    380          #else
    381            int res = (int) calibrationTEMP - ((emu * 8) / 5);
    382            // Cap conversion results at int8_t bounds
    383            if (res < -128) {
    384              res = -128;
    385            } else if (res > 127) {
    386              res = 127;
    387            }
    388          
    389            return (int8_t) res;
    390          #endif
    391          }
    392          
    393          /***************************************************************************//**
    394           * @brief
    395           *   Convert a temperature in &deg;C to an EMU sensor value
    396           *
    397           * @param[in] temp
    398           *   Temperature to convert in degrees Celsius
    399           *
    400           * @return
    401           *   EMU temperature sensor value that represents the given temperature
    402           ******************************************************************************/
    403          static uint32_t convertToEmu(int temp)
    404          {
    405          #if defined(_SILICON_LABS_32B_SERIES_2)
    406            return (uint32_t)(temp + 273); // Convert from Celsius to Kelvin
    407          #else
    408            int32_t res = (int32_t) calibrationEMU -  ((temp * 5) >> 3);
    409            // Cap conversion results at uint8_t bounds
    410            if (res > 255) {
    411              res = 255;
    412            } else if (res < 0) {
    413              res = 0;
    414            }
    415            return (uint8_t) res;
    416          #endif
    417          }
    418          
    419          /***************************************************************************//**
    420           * @brief
    421           *   Turn off and clear EMU temperature related interrupts
    422           ******************************************************************************/
    423          static void disableInterrupts(void)
    424          {
    425            EMU_IntClear(EMU_IF_TEMPLOW | EMU_IF_TEMPHIGH);
    426            EMU_IntDisable(EMU_IF_TEMPLOW | EMU_IF_TEMPHIGH);
    427          }
    428          
    429          /***************************************************************************//**
    430           * @brief
    431           *   Update interrupts based on active callbacks
    432           *
    433           * @details
    434           *   There can only be two temperature thresholds active in the EMU sensor at a
    435           *   single point in time. One threshold for increasing temperature and one
    436           *   threshold for decreasing temperature. The responsibility of this function
    437           *   is to always select which temperature thresholds that should be activated
    438           *   in the EMU sensor at any given time.
    439           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    440          static void updateInterrupts(void)
    441          {
   \                     updateInterrupts: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
    442            int index;
    443          
    444            // Find lowest temperature active high callback
    445            for (index = 0; index < TEMPDRV_CALLBACK_DEPTH; index++) {
   \        0x2   0x....             LDR.N    R1,??DataTable13_4
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x680B             LDR      R3,[R1, #+0]
   \        0x8   0x....             LDR.N    R4,??DataTable13_6
    446              // filter out only entries with valid callbacks
    447              if (tempdrvHighCallbacks[index].callback != NULL) {
   \                     ??updateInterrupts_0: (+1)
   \        0xA   0xF854 0x0032      LDR      R0,[R4, R2, LSL #+3]
   \        0xE   0xB140             CBZ.N    R0,??updateInterrupts_1
    448                if (highCallback->callback == NULL) {
   \       0x10   0x6818             LDR      R0,[R3, #+0]
   \       0x12   0xEB04 0x05C2      ADD      R5,R4,R2, LSL #+3
   \       0x16   0xB118             CBZ.N    R0,??updateInterrupts_2
    449                  highCallback = &tempdrvHighCallbacks[index];
    450                } else {
    451                  if (tempdrvHighCallbacks[index].temp > highCallback->temp) {
   \       0x18   0x7918             LDRB     R0,[R3, #+4]
   \       0x1A   0x792E             LDRB     R6,[R5, #+4]
   \       0x1C   0x42B0             CMP      R0,R6
   \       0x1E   0xD200             BCS.N    ??updateInterrupts_1
    452                    highCallback = &tempdrvHighCallbacks[index];
   \                     ??updateInterrupts_2: (+1)
   \       0x20   0x462B             MOV      R3,R5
    453                  }
    454                }
    455              }
    456            }
   \                     ??updateInterrupts_1: (+1)
   \       0x22   0x1C52             ADDS     R2,R2,#+1
   \       0x24   0x2A04             CMP      R2,#+4
   \       0x26   0xDDF0             BLE.N    ??updateInterrupts_0
   \       0x28   0x600B             STR      R3,[R1, #+0]
    457          
    458            // Find highest temperature active low callback
    459            for (index = 0; index < TEMPDRV_CALLBACK_DEPTH; index++) {
   \       0x2A   0x....             LDR.N    R2,??DataTable13_3
   \       0x2C   0x2300             MOVS     R3,#+0
   \       0x2E   0x6814             LDR      R4,[R2, #+0]
   \       0x30   0x....             LDR.N    R5,??DataTable13_7
    460              // filter out only entries with valid callbacks
    461              if (tempdrvLowCallbacks[index].callback != NULL) {
   \                     ??updateInterrupts_3: (+1)
   \       0x32   0xF855 0x0033      LDR      R0,[R5, R3, LSL #+3]
   \       0x36   0xB140             CBZ.N    R0,??updateInterrupts_4
    462                if (lowCallback->callback == NULL) {
   \       0x38   0x6820             LDR      R0,[R4, #+0]
   \       0x3A   0xEB05 0x06C3      ADD      R6,R5,R3, LSL #+3
   \       0x3E   0xB118             CBZ.N    R0,??updateInterrupts_5
    463                  lowCallback = &tempdrvLowCallbacks[index];
    464                } else {
    465                  if (tempdrvLowCallbacks[index].temp < lowCallback->temp) {
   \       0x40   0x7930             LDRB     R0,[R6, #+4]
   \       0x42   0x7927             LDRB     R7,[R4, #+4]
   \       0x44   0x42B8             CMP      R0,R7
   \       0x46   0xD200             BCS.N    ??updateInterrupts_4
    466                    lowCallback = &tempdrvLowCallbacks[index];
   \                     ??updateInterrupts_5: (+1)
   \       0x48   0x4634             MOV      R4,R6
    467                  }
    468                }
    469              }
    470            }
   \                     ??updateInterrupts_4: (+1)
   \       0x4A   0x1C5B             ADDS     R3,R3,#+1
   \       0x4C   0x2B04             CMP      R3,#+4
   \       0x4E   0xDDF0             BLE.N    ??updateInterrupts_3
   \       0x50   0x6014             STR      R4,[R2, #+0]
    471          
    472          #if defined(_SILICON_LABS_32B_SERIES_1)
    473            // On Series-1 devices the temperature code is inverted (high value = low temperature)
    474            if (highCallback->callback != NULL) {
    475              EMU->TEMPLIMITS = (EMU->TEMPLIMITS & ~_EMU_TEMPLIMITS_TEMPLOW_MASK)
    476                                | (highCallback->temp << _EMU_TEMPLIMITS_TEMPLOW_SHIFT);
    477              EMU_IntEnable(EMU_IEN_TEMPLOW);
    478            } else {
    479              EMU_IntDisable(EMU_IEN_TEMPLOW);
    480            }
    481            if (lowCallback->callback != NULL) {
    482              EMU->TEMPLIMITS = (EMU->TEMPLIMITS & ~_EMU_TEMPLIMITS_TEMPHIGH_MASK)
    483                                | (lowCallback->temp << _EMU_TEMPLIMITS_TEMPHIGH_SHIFT);
    484              EMU_IntEnable(EMU_IEN_TEMPHIGH);
    485            } else {
    486              EMU_IntDisable(EMU_IEN_TEMPHIGH);
    487            }
    488          #else
    489            // On Series-2 devices the temperature code is normal (high value = high temperature)
    490            if (highCallback->callback != NULL) {
   \       0x52   0x6809             LDR      R1,[R1, #+0]
   \       0x54   0x....             LDR.N    R3,??DataTable13_8  ;; 0x40006068
   \       0x56   0x....             LDR.N    R4,??DataTable13_9  ;; 0x40005068
   \       0x58   0x6808             LDR      R0,[R1, #+0]
   \       0x5A   0xF04F 0x4500      MOV      R5,#-2147483648
   \       0x5E   0x....             LDR.N    R6,??DataTable13_10  ;; 0x40004078
   \       0x60   0xB140             CBZ.N    R0,??updateInterrupts_6
    491              EMU->TEMPLIMITS = (EMU->TEMPLIMITS & ~_EMU_TEMPLIMITS_TEMPHIGH_MASK)
    492                                | (highCallback->temp << _EMU_TEMPLIMITS_TEMPHIGH_SHIFT);
   \       0x62   0x6837             LDR      R7,[R6, #+0]
   \       0x64   0x7908             LDRB     R0,[R1, #+4]
   \       0x66   0xF36F 0x4718      BFC      R7,#+16,#+9
   \       0x6A   0xEA47 0x4700      ORR      R7,R7,R0, LSL #+16
   \       0x6E   0x6037             STR      R7,[R6, #+0]
    493              EMU_IntEnable(EMU_IEN_TEMPHIGH);
   \       0x70   0x6025             STR      R5,[R4, #+0]
    494            } else {
   \       0x72   0xE000             B.N      ??updateInterrupts_7
    495              EMU_IntDisable(EMU_IEN_TEMPHIGH);
   \                     ??updateInterrupts_6: (+1)
   \       0x74   0x601D             STR      R5,[R3, #+0]
    496            }
    497            if (lowCallback->callback != NULL) {
   \                     ??updateInterrupts_7: (+1)
   \       0x76   0x6811             LDR      R1,[R2, #+0]
   \       0x78   0xF04F 0x4280      MOV      R2,#+1073741824
   \       0x7C   0x6808             LDR      R0,[R1, #+0]
   \       0x7E   0xB138             CBZ.N    R0,??updateInterrupts_8
    498              EMU->TEMPLIMITS = (EMU->TEMPLIMITS & ~_EMU_TEMPLIMITS_TEMPLOW_MASK)
    499                                | (lowCallback->temp << _EMU_TEMPLIMITS_TEMPLOW_SHIFT);
   \       0x80   0x6833             LDR      R3,[R6, #+0]
   \       0x82   0x7908             LDRB     R0,[R1, #+4]
   \       0x84   0x0A5B             LSRS     R3,R3,#+9
   \       0x86   0xEA40 0x2343      ORR      R3,R0,R3, LSL #+9
   \       0x8A   0x6033             STR      R3,[R6, #+0]
    500              EMU_IntEnable(EMU_IEN_TEMPLOW);
   \       0x8C   0x6022             STR      R2,[R4, #+0]
    501            } else {
   \       0x8E   0xBDF0             POP      {R4-R7,PC}
    502              EMU_IntDisable(EMU_IEN_TEMPLOW);
   \                     ??updateInterrupts_8: (+1)
   \       0x90   0x601A             STR      R2,[R3, #+0]
    503            }
    504          #endif
    505          }
   \       0x92   0xBDF0             POP      {R4-R7,PC}       ;; return
    506          
    507          /***************************************************************************//**
    508           * @brief
    509           *   Prepare calibration values for temperature conversion.
    510           ******************************************************************************/
    511          static void calibration(void)
    512          {
    513          #if defined(_DEVINFO_CAL_TEMP_MASK)
    514            uint32_t DItemp, DIemu;
    515          
    516            // Retrieve calibration data from DI page
    517            DItemp = ((DEVINFO->CAL & _DEVINFO_CAL_TEMP_MASK) >> _DEVINFO_CAL_TEMP_SHIFT);
    518            DIemu = ((DEVINFO->EMUTEMP & _DEVINFO_EMUTEMP_EMUTEMPROOM_MASK) >> _DEVINFO_EMUTEMP_EMUTEMPROOM_SHIFT);
    519          
    520            if ((DItemp == (_DEVINFO_CAL_TEMP_MASK >> _DEVINFO_CAL_TEMP_SHIFT))
    521                || (DIemu == (_DEVINFO_EMUTEMP_EMUTEMPROOM_MASK >> _DEVINFO_EMUTEMP_EMUTEMPROOM_SHIFT))) {
    522              // Missing DI page calibration data, substitute fixed values
    523              DItemp = fallbackTEMP;
    524              DIemu = fallbackEMU;
    525            }
    526          
    527            // calculate conversion offsets. Based on assumed slope of 5/8
    528            calibrationEMU = (DIemu) + ((5 * (DItemp)) / 8);
    529            calibrationTEMP = (DItemp) + (8 * (DIemu) / 5);
    530          #endif
    531          }
    532          
    533          /* Official API */
    534          /***************************************************************************//**
    535           * @brief
    536           *   Initialize the TEMP driver.
    537           *
    538           * @details
    539           *   This will clear all the registered callbacks and enable the EMU IRQ in the
    540           *   NVIC. Calling this function will also enable the EMU_E201 errata fix for
    541           *   first generation Pearl, Jade and EFR32 devices.
    542           *
    543           * @return
    544           *   @ref ECODE_EMDRV_TEMPDRV_OK on success.
    545           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    546          Ecode_t TEMPDRV_Init(void)
    547          {
   \                     TEMPDRV_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    548            // Flag up
    549            TEMPDRV_InitState = true;
   \        0x2   0x2001             MOVS     R0,#+1
   \        0x4   0x....             LDR.N    R1,??DataTable13_11
   \        0x6   0x7008             STRB     R0,[R1, #+0]
    550          
    551            // reset stack state by erasing callbacks
    552            memset(tempdrvHighCallbacks, 0, sizeof (TEMPDRV_CallbackSet_t) * TEMPDRV_CALLBACK_DEPTH);
   \        0x8   0x....'....        BL       ?Subroutine2
    553            memset(tempdrvLowCallbacks, 0, sizeof (TEMPDRV_CallbackSet_t) * TEMPDRV_CALLBACK_DEPTH);
   \                     ??CrossCallReturnLabel_7: (+1)
   \        0xC   0x....'....        BL       ?Subroutine3
    554            highCallback = &nullCallback;
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x10   0x....             LDR.N    R0,??DataTable13_12
   \       0x12   0x....             LDR.N    R1,??DataTable13_4
   \       0x14   0x6008             STR      R0,[R1, #+0]
    555            lowCallback = &nullCallback;
   \       0x16   0x....             LDR.N    R2,??DataTable13_3
   \       0x18   0x6010             STR      R0,[R2, #+0]
    556          
    557            calibration();
    558            errataInit();
    559            disableInterrupts();
   \       0x1A   0x....'....        BL       ?Subroutine1
    560            NVIC_ClearPendingIRQ(EMU_IRQn);
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x1E   0x2005             MOVS     R0,#+5
   \       0x20   0x....'....        BL       __NVIC_ClearPendingIRQ
    561            NVIC_EnableIRQ(EMU_IRQn);
   \       0x24   0x2020             MOVS     R0,#+32
   \       0x26   0x....             LDR.N    R1,??DataTable13_13  ;; 0xe000e100
   \       0x28   0x6008             STR      R0,[R1, #+0]
    562            updateInterrupts();
   \       0x2A   0x....'....        BL       updateInterrupts
    563          
    564            return ECODE_EMDRV_TEMPDRV_OK;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xBD02             POP      {R1,PC}          ;; return
    565          }
    566          
    567          /***************************************************************************//**
    568           * @brief
    569           *    De-initialize the TEMP driver.
    570           *
    571           * @details
    572           *   This will clear all the registered callbacks and disable the EMU IRQ in
    573           *   the NVIC.
    574           *
    575           * @return
    576           *    @ref ECODE_EMDRV_TEMPDRV_OK on success.
    577           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    578          Ecode_t TEMPDRV_DeInit(void)
    579          {
   \                     TEMPDRV_DeInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    580            TEMPDRV_InitState = false;
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x....             LDR.N    R1,??DataTable13_11
   \        0x6   0x7008             STRB     R0,[R1, #+0]
    581            NVIC_DisableIRQ(EMU_IRQn);
   \        0x8   0x2220             MOVS     R2,#+32
   \        0xA   0x....             LDR.N    R3,??DataTable13_14  ;; 0xe000e180
   \        0xC   0x601A             STR      R2,[R3, #+0]
   \        0xE   0xF3BF 0x8F4F      DSB      SY
   \       0x12   0xF3BF 0x8F6F      ISB      SY
    582            NVIC_ClearPendingIRQ(EMU_IRQn);
   \       0x16   0x2005             MOVS     R0,#+5
   \       0x18   0x....'....        BL       __NVIC_ClearPendingIRQ
    583            disableInterrupts();
   \       0x1C   0x....'....        BL       ?Subroutine1
    584            memset(tempdrvHighCallbacks, 0, sizeof (TEMPDRV_CallbackSet_t) * TEMPDRV_CALLBACK_DEPTH);
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x20   0x....'....        BL       ?Subroutine2
    585            memset(tempdrvLowCallbacks, 0, sizeof (TEMPDRV_CallbackSet_t) * TEMPDRV_CALLBACK_DEPTH);
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x24   0x....'....        BL       ?Subroutine3
    586            return ECODE_EMDRV_TEMPDRV_OK;
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD02             POP      {R1,PC}          ;; return
    587          }
    588          
    589          /***************************************************************************//**
    590           * @brief
    591           *   Enable or disable the TEMP driver.
    592           *
    593           * @param[in] enable
    594           *   true to enable the TEMP driver, false to disable the TEMP driver.
    595           *
    596           * @return
    597           *   @ref ECODE_EMDRV_TEMPDRV_OK on success.
    598           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    599          Ecode_t TEMPDRV_Enable(bool enable)
    600          {
   \                     TEMPDRV_Enable: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    601            if (TEMPDRV_EnableState != enable) {
   \        0x2   0x....             LDR.N    R1,??DataTable13_15
   \        0x4   0x780A             LDRB     R2,[R1, #+0]
   \        0x6   0x4282             CMP      R2,R0
   \        0x8   0xD006             BEQ.N    ??CrossCallReturnLabel_6
    602              TEMPDRV_EnableState = enable;
   \        0xA   0x7008             STRB     R0,[R1, #+0]
    603              if (enable) {
   \        0xC   0xB110             CBZ.N    R0,??TEMPDRV_Enable_0
    604                updateInterrupts();
   \        0xE   0x....'....        BL       updateInterrupts
   \       0x12   0xE001             B.N      ??CrossCallReturnLabel_6
    605              } else {
    606                disableInterrupts();
   \                     ??TEMPDRV_Enable_0: (+1)
   \       0x14   0x....'....        BL       ?Subroutine1
    607              }
    608            }
    609            return ECODE_EMDRV_TEMPDRV_OK;
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xBD02             POP      {R1,PC}          ;; return
    610          }
    611          
    612          /***************************************************************************//**
    613           * @brief
    614           *   Get the number of active callbacks for a limit.
    615           *
    616           * @param[in] limit
    617           *   Limit type, refer to @ref TEMPDRV_LimitType_t.
    618           *
    619           * @return
    620           *   Number of active callbacks
    621           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    622          uint8_t TEMPDRV_GetActiveCallbacks(TEMPDRV_LimitType_t limit)
    623          {
    624            TEMPDRV_CallbackSet_t *set;
    625          
    626            if (limit == TEMPDRV_LIMIT_HIGH) {
   \                     TEMPDRV_GetActiveCallbacks: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xD10D             BNE.N    ??TEMPDRV_GetActiveCallbacks_0
    627              // Define callback set
    628              set = tempdrvHighCallbacks;
   \        0x4   0x....             LDR.N    R2,??DataTable13_6
    629            } else if (limit == TEMPDRV_LIMIT_LOW) {
    630              // Define callback set
    631              set = tempdrvLowCallbacks;
    632            } else {
    633              // Invalid limit
    634              return 0;
    635            }
    636            uint8_t index, count = 0;
   \                     ??TEMPDRV_GetActiveCallbacks_1: (+1)
   \        0x6   0x2000             MOVS     R0,#+0
    637            for (index = TEMPDRV_CUSTOM_CALLBACK_INDEX; index < TEMPDRV_CALLBACK_DEPTH; index++) {
   \        0x8   0x2300             MOVS     R3,#+0
    638              // filter out only entries with valid callbacks
    639              if (set[index].callback != NULL) {
   \                     ??TEMPDRV_GetActiveCallbacks_2: (+1)
   \        0xA   0xB2D9             UXTB     R1,R3
   \        0xC   0xF852 0x1031      LDR      R1,[R2, R1, LSL #+3]
   \       0x10   0xB101             CBZ.N    R1,??TEMPDRV_GetActiveCallbacks_3
    640                count++;
   \       0x12   0x1C40             ADDS     R0,R0,#+1
    641              }
    642            }
   \                     ??TEMPDRV_GetActiveCallbacks_3: (+1)
   \       0x14   0x1C5B             ADDS     R3,R3,#+1
   \       0x16   0xB2D9             UXTB     R1,R3
   \       0x18   0x2905             CMP      R1,#+5
   \       0x1A   0xDBF6             BLT.N    ??TEMPDRV_GetActiveCallbacks_2
    643            return count;
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0x4770             BX       LR               ;; return
   \                     ??TEMPDRV_GetActiveCallbacks_0: (+1)
   \       0x20   0xB908             CBNZ.N   R0,??TEMPDRV_GetActiveCallbacks_4
   \       0x22   0x....             LDR.N    R2,??DataTable13_7
   \       0x24   0xE7EF             B.N      ??TEMPDRV_GetActiveCallbacks_1
   \                     ??TEMPDRV_GetActiveCallbacks_4: (+1)
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0x4770             BX       LR
    644          }
    645          
    646          /***************************************************************************//**
    647           * @brief
    648           *    Get the current temperature.
    649           *
    650           * @return
    651           *    Current temperature in degrees Celsius.
    652           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    653          int8_t TEMPDRV_GetTemp(void)
    654          {
    655            uint32_t val = (EMU->TEMP & _EMU_TEMP_TEMP_MASK)
    656                           >> _EMU_TEMP_TEMP_SHIFT;
   \                     TEMPDRV_GetTemp: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable13_16  ;; 0x40004088
   \        0x2   0x6800             LDR      R0,[R0, #+0]
    657            return convertToTemp(val);
   \        0x4   0x0880             LSRS     R0,R0,#+2
   \        0x6   0x3811             SUBS     R0,R0,#+17
   \        0x8   0xB240             SXTB     R0,R0
   \        0xA   0x4770             BX       LR               ;; return
    658          }
    659          
    660          /***************************************************************************//**
    661           * @brief
    662           *   Register a callback in the TEMP driver
    663           *
    664           * @details
    665           *   This function is used for registering an application callback when the
    666           *   temperature changes. Note that when calling this function an application
    667           *   must specify the direction of the temperature change, use
    668           *   @ref TEMPDRV_LIMIT_LOW to receive a callback when the temperature drops
    669           *   below the specified temp and use @ref TEMPDRV_LIMIT_HIGH to receive a
    670           *   callback when the temperature increases above the specified temp.
    671           *
    672           * @note
    673           *   The user registered callback will be cleared once it's called. This means
    674           *   that the callback functions are not persistent, and have to be managed by
    675           *   the application. This feature can be used to implement a user controlled
    676           *   hysteresis. So for instance to register a callback at 50&deg;C with a
    677           *   5&deg;C hysteresis you can first register a callback at 50&deg;C or above
    678           *   using this function, and when the callback fires you can use this function
    679           *   again to register a callback when the temperature decreases to 45&deg;C or
    680           *   below. Each time a callback fires you only need to call the
    681           *   @ref TEMPDRV_RegisterCallback() function, there is no need to call
    682           *   @ref TEMPDRV_UnregisterCallback().
    683           *
    684           * @details
    685           *   It's important to know the current temperature before calling this
    686           *   function. Attempting to register a callback that would fire immediately
    687           *   is not supported and will result in a return value of
    688           *   @ref ECODE_EMDRV_TEMPDRV_BAD_LIMIT. Examples of an illegal scenario would
    689           *   be to register a callback for a temperature that is higher than the current
    690           *   temperature and with a limit set to @ref TEMPDRV_LIMIT_LOW.
    691           *
    692           * @param[in] temp
    693           *   Temperature to trigger on given in number of &deg;C.
    694           *
    695           * @param[in] limit
    696           *   Limit type, refer to @ref TEMPDRV_LimitType_t. Using @ref TEMPDRV_LIMIT_LOW
    697           *   will register a callback when the EMU temperature reaches @ref temp &deg;C
    698           *   or lower, and using @ref TEMPDRV_LIMIT_HIGH will register a callback when
    699           *   the EMU temperature reaches @ref temp &deg;C or higher.
    700           *
    701           * @param[in] callback
    702           *   User defined function to call when temperature threshold is reached or passed.
    703           *
    704           * @return
    705           *   @li @ref ECODE_EMDRV_TEMPDRV_OK on success.
    706           *
    707           *   @li @ref ECODE_EMDRV_TEMPDRV_PARAM_ERROR if the callback is NULL.
    708           *
    709           *   @li @ref ECODE_EMDRV_TEMPDRV_NO_INIT if the user has forgot to call @ref
    710           *     TEMPDRV_Init() before attempting to register a callback.
    711           *
    712           *   @li @ref ECODE_EMDRV_TEMPDRV_BAD_LIMIT is returned if @ref temp is below the
    713           *     current temperature and @limit is @ref TEMPDRV_LIMIT_LOW. It is also
    714           *     returned if @ref temp is above the current temperature and @limit is
    715           *     @ref TEMPDRV_LIMIT_HIGH.
    716           *
    717           *   @li @ref ECODE_EMDRV_TEMPDRV_DUP_TEMP is returned if a duplicate callback
    718           *     is detected. A duplicate callback is if you attempt to register a new
    719           *     callback with the same @ref temp and the same @ref limit as some
    720           *     already registered callback.
    721           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    722          Ecode_t TEMPDRV_RegisterCallback(int8_t temp,
    723                                           TEMPDRV_LimitType_t limit,
    724                                           TEMPDRV_Callback_t callback)
    725          {
   \                     TEMPDRV_RegisterCallback: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4603             MOV      R3,R0
    726            TEMPDRV_CallbackSet_t *set;
    727            if (TEMPDRV_InitState == false) {
   \        0x4   0x....             LDR.N    R4,??DataTable13_11
   \        0x6   0x7820             LDRB     R0,[R4, #+0]
   \        0x8   0xB908             CBNZ.N   R0,??TEMPDRV_RegisterCallback_0
    728              return ECODE_EMDRV_TEMPDRV_NO_INIT;
   \        0xA   0x....             LDR.N    R0,??DataTable13_17  ;; 0xf000d001
   \        0xC   0xBD70             POP      {R4-R6,PC}
    729            }
    730            // cannot register null callback
    731            if (callback == NULL) {
   \                     ??TEMPDRV_RegisterCallback_0: (+1)
   \        0xE   0x0010             MOVS     R0,R2
   \       0x10   0xD024             BEQ.N    ??TEMPDRV_RegisterCallback_1
    732              return ECODE_EMDRV_TEMPDRV_PARAM_ERROR;
    733            }
    734            if (limit == TEMPDRV_LIMIT_HIGH) {
   \       0x12   0x....             LDR.N    R0,??DataTable13_16  ;; 0x40004088
   \       0x14   0x2901             CMP      R1,#+1
   \       0x16   0xD118             BNE.N    ??TEMPDRV_RegisterCallback_2
    735              // current temperature is already higher than requested temperature
    736              if (TEMPDRV_GetTemp() > temp) {
   \       0x18   0x....'....        BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x1C   0x4283             CMP      R3,R0
   \       0x1E   0xDB19             BLT.N    ??TEMPDRV_RegisterCallback_3
    737                return ECODE_EMDRV_TEMPDRV_BAD_LIMIT;
    738              }
    739              // Define callback set
    740              set = tempdrvHighCallbacks;
   \       0x20   0x....             LDR.N    R4,??DataTable13_6
    741            } else if (limit == TEMPDRV_LIMIT_LOW) {
    742              // current temperature is already lower than requested temperature
    743              if (TEMPDRV_GetTemp() < temp) {
    744                return ECODE_EMDRV_TEMPDRV_BAD_LIMIT;
    745              }
    746              // Define callback set
    747              set = tempdrvLowCallbacks;
    748            } else {
    749              // Invalid limit
    750              return ECODE_EMDRV_TEMPDRV_PARAM_ERROR;
    751            }
    752          
    753            // Cannot register duplicate temperature callback
    754            if (checkForDuplicates(set, temp) == true) {
   \                     ??TEMPDRV_RegisterCallback_4: (+1)
   \       0x22   0xF103 0x0111      ADD      R1,R3,#+17
   \       0x26   0xB2C9             UXTB     R1,R1
   \       0x28   0x2500             MOVS     R5,#+0
   \                     ??TEMPDRV_RegisterCallback_5: (+1)
   \       0x2A   0xF854 0x0035      LDR      R0,[R4, R5, LSL #+3]
   \       0x2E   0xB120             CBZ.N    R0,??TEMPDRV_RegisterCallback_6
   \       0x30   0xEB04 0x06C5      ADD      R6,R4,R5, LSL #+3
   \       0x34   0x7930             LDRB     R0,[R6, #+4]
   \       0x36   0x4288             CMP      R0,R1
   \       0x38   0xD012             BEQ.N    ??TEMPDRV_RegisterCallback_7
   \                     ??TEMPDRV_RegisterCallback_6: (+1)
   \       0x3A   0x1C6D             ADDS     R5,R5,#+1
   \       0x3C   0x2D04             CMP      R5,#+4
   \       0x3E   0xDDF4             BLE.N    ??TEMPDRV_RegisterCallback_5
    755              return ECODE_EMDRV_TEMPDRV_DUP_TEMP;
    756            }
    757          
    758            return addCallback(set, temp, callback);
   \       0x40   0x4620             MOV      R0,R4
   \       0x42   0x4619             MOV      R1,R3
   \       0x44   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x48   0x....             B.N      addCallback
   \                     ??TEMPDRV_RegisterCallback_2: (+1)
   \       0x4A   0xB939             CBNZ.N   R1,??TEMPDRV_RegisterCallback_1
   \       0x4C   0x....'....        BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x50   0x4298             CMP      R0,R3
   \       0x52   0xDA01             BGE.N    ??TEMPDRV_RegisterCallback_8
   \                     ??TEMPDRV_RegisterCallback_3: (+1)
   \       0x54   0x....             LDR.N    R0,??DataTable13_18  ;; 0xf000d003
   \       0x56   0xBD70             POP      {R4-R6,PC}
   \                     ??TEMPDRV_RegisterCallback_8: (+1)
   \       0x58   0x....             LDR.N    R4,??DataTable13_7
   \       0x5A   0xE7E2             B.N      ??TEMPDRV_RegisterCallback_4
   \                     ??TEMPDRV_RegisterCallback_1: (+1)
   \       0x5C   0x....             LDR.N    R0,??DataTable13_19  ;; 0xf000d002
   \       0x5E   0xBD70             POP      {R4-R6,PC}
   \                     ??TEMPDRV_RegisterCallback_7: (+1)
   \       0x60   0x....             LDR.N    R0,??DataTable13_20  ;; 0xf000d008
   \       0x62   0xBD70             POP      {R4-R6,PC}
    759          }
    760          
    761          /***************************************************************************//**
    762           * @brief
    763           *   Unregister a callback in the TEMP driver.
    764           *
    765           * @param[in] callback
    766           *   Callback to unregister.
    767           *
    768           * @return
    769           *   @li @ref ECODE_EMDRV_TEMPDRV_OK on success.
    770           *
    771           *   @li @ref ECODE_EMDRV_TEMPDRV_PARAM_ERROR if the callback is NULL.
    772           *
    773           *   @li @ref ECODE_EMDRV_TEMPDRV_NO_CALLBACK if the callback was not found.
    774           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    775          Ecode_t TEMPDRV_UnregisterCallback(TEMPDRV_Callback_t callback)
    776          {
   \                     TEMPDRV_UnregisterCallback: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
    777            // cannot register null callback
    778            if (callback == NULL) {
   \        0x4   0xD101             BNE.N    ??TEMPDRV_UnregisterCallback_0
    779              return ECODE_EMDRV_TEMPDRV_PARAM_ERROR;
   \        0x6   0x....             LDR.N    R0,??DataTable13_19  ;; 0xf000d002
   \        0x8   0xBD10             POP      {R4,PC}
    780            }
    781            if (removeCallback(tempdrvHighCallbacks, callback) == false
    782                && removeCallback(tempdrvLowCallbacks, callback) == false) {
   \                     ??TEMPDRV_UnregisterCallback_0: (+1)
   \        0xA   0x4621             MOV      R1,R4
   \        0xC   0x....             LDR.N    R0,??DataTable13_6
   \        0xE   0x....'....        BL       removeCallback
   \       0x12   0xB930             CBNZ.N   R0,??TEMPDRV_UnregisterCallback_1
   \       0x14   0x4621             MOV      R1,R4
   \       0x16   0x....             LDR.N    R0,??DataTable13_7
   \       0x18   0x....'....        BL       removeCallback
   \       0x1C   0xB908             CBNZ.N   R0,??TEMPDRV_UnregisterCallback_1
    783              return ECODE_EMDRV_TEMPDRV_NO_CALLBACK;
   \       0x1E   0x....             LDR.N    R0,??DataTable13_21  ;; 0xf000d004
   \       0x20   0xBD10             POP      {R4,PC}
    784            }
    785            return ECODE_EMDRV_TEMPDRV_OK;
   \                     ??TEMPDRV_UnregisterCallback_1: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xBD10             POP      {R4,PC}          ;; return
    786          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x2128             MOVS     R1,#+40
   \        0x2   0x....             LDR.N    R0,??DataTable13_7
   \        0x4   0x....'....        B.W      __aeabi_memclr4

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x2128             MOVS     R1,#+40
   \        0x2   0x....             LDR.N    R0,??DataTable13_6
   \        0x4   0x....'....        B.W      __aeabi_memclr4

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable13_2  ;; 0x40006064
   \        0x2   0xF04F 0x4140      MOV      R1,#-1073741824
   \        0x6   0x6001             STR      R1,[R0, #+0]
   \        0x8   0x6041             STR      R1,[R0, #+4]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \        0x0   0xE000'E280        DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \        0x0   0x4000'4064        DC32     0x40004064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \        0x0   0x4000'6064        DC32     0x40006064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \        0x0   0x....'....        DC32     lowCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \        0x0   0x....'....        DC32     highCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \        0x0   0xF000'D005        DC32     0xf000d005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \        0x0   0x....'....        DC32     tempdrvHighCallbacks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \        0x0   0x....'....        DC32     tempdrvLowCallbacks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_8:
   \        0x0   0x4000'6068        DC32     0x40006068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_9:
   \        0x0   0x4000'5068        DC32     0x40005068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_10:
   \        0x0   0x4000'4078        DC32     0x40004078

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_11:
   \        0x0   0x....'....        DC32     TEMPDRV_InitState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_12:
   \        0x0   0x....'....        DC32     nullCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_13:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_14:
   \        0x0   0xE000'E180        DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_15:
   \        0x0   0x....'....        DC32     TEMPDRV_EnableState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_16:
   \        0x0   0x4000'4088        DC32     0x40004088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_17:
   \        0x0   0xF000'D001        DC32     0xf000d001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_18:
   \        0x0   0xF000'D003        DC32     0xf000d003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_19:
   \        0x0   0xF000'D002        DC32     0xf000d002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_20:
   \        0x0   0xF000'D008        DC32     0xf000d008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_21:
   \        0x0   0xF000'D004        DC32     0xf000d004
    787          
    788          /* *INDENT-OFF* */
    789          /******** THE REST OF THE FILE IS DOCUMENTATION ONLY !**********************//**
    790           * @addtogroup emdrv
    791           * @{
    792           * @addtogroup TEMPDRV
    793           * @brief TEMPDRV Temperature Sensor Driver
    794           * @{
    795          
    796             @details
    797          
    798             The source files for the TEMP driver library resides in the
    799             emdrv/tempdrv folder, and consists of tempdrv.c and tempdrv.h.
    800          
    801             @li @ref tempdrv_intro
    802             @li @ref tempdrv_conf
    803             @li @ref tempdrv_api
    804          
    805             @n @section tempdrv_intro Introduction
    806          
    807             TEMPDRV gives the user a nice interface to the EMU internal temperature sensor
    808             which is present on the EFR32 and some EFM32 devices. The TEMPDRV supports
    809             application specific callbacks at given temperature thresholds. The EMU
    810             internal temperature sensor is running in EM0-EM4H and is capable of waking
    811             up the core on temperature change. The EMU temperature sensor is running
    812             continuously and measurements are taken every 250 ms.
    813          
    814             @note The TEMPDRV is using the EMU peripheral and not the ADC peripheral.
    815             The ADC contains another internal temperature sensor which is not touched
    816             by the TEMPDRV.
    817          
    818             The TEMPDRV also provides an important errata fix for the EFR32 first
    819             generation devices when operating at high temperature environments (above
    820             50&deg;C). The errata document for the EFR32 describes the errata which is
    821             called "EMU_E201 - High Temperature Operation". To implement the errata fix
    822             in a user application it is enough to include the TEMPDRV and call
    823             @ref TEMPDRV_Init() at the start of the program. This will activate the errata
    824             fix code which is modifying registers based on changes in the EMU temperature.
    825          
    826             @n @section tempdrv_conf Configuration Options
    827          
    828             Some properties of the TEMPDRV driver are compile-time configurable. These
    829             properties are set in a file named @ref tempdrv_config.h. A template for this
    830             file, containing default values, resides in the emdrv/tempdrv/config folder.
    831             To configure TEMPDRV for your application, provide your own configuration file.
    832             These are the available configuration parameters with default values defined.
    833             @verbatim
    834          
    835            // Callback table depth (for high and low callbacks each)
    836            #define TEMPDRV_CALLBACK_DEPTH 5
    837          
    838            // Allow temperature sensor to wake the device up from EM4
    839            #define TEMPDRV_EM4WAKEUP false
    840          
    841            // Allow TEMPDRV to define the EMU_IRQ_Handler. Enable if EMU_IRQ_Handler is
    842            // defined elsewhere.
    843            #define EMU_CUSTOM_IRQ_HANDLER false
    844             @endverbatim
    845          
    846             Callback table depth determines the number of concurrent callbacks that can be
    847             registered at a single time. The depth applies to each limit, so depth of 5
    848             allows up to 5 high and 5 low callbacks to be registered.
    849             There are no run-time configuration options for TEMPDRV.
    850          
    851             @n @section tempdrv_api The API
    852          
    853             This section contain brief descriptions of the functions in the API. You will
    854             find detailed information on input and output parameters and return values by
    855             clicking on the function names. Most functions return an error
    856             code, @ref ECODE_EMDRV_TEMPDRV_OK is returned on success,
    857             see @ref ecode.h and @ref tempdrv.h for other error codes.
    858          
    859             Your application code must include one header file: @em tempdrv.h.
    860          
    861             @ref TEMPDRV_Init(), @ref TEMPDRV_DeInit() @n
    862              These functions initializes or deinitializes the TEMPDRV driver. This will
    863              erase any registered callbacks and disabled all interrupts. Typically
    864              @htmlonly TEMPDRV_Init() @endhtmlonly is called once in your startup code.
    865          
    866             @ref TEMPDRV_Enable() @n
    867              Enable or disable the temperature driver without losing any registered
    868              callbacks.
    869          
    870             @ref TEMPDRV_GetTemp() @n
    871              Get the current temperature in degrees Celsius. This measurement is based on
    872              a conversion from the EMU temperature sensor and calibration data that is
    873              stored in the DI page.
    874          
    875             @ref TEMPDRV_RegisterCallback(), @ref TEMPDRV_UnregisterCallback() @n
    876              Callbacks can be registered for rising or falling thresholds and will called
    877              as soon as the temperature matches the specified threshold. Multiple
    878              callbacks at the same temperature are not permitted, nor are mismatches
    879              between temperature and limit (e. g temperature is lower than current but
    880              the limit is set to high). Additionally, unregistering a callback will remove
    881              all entries of matching callbacks.
    882          
    883             @n @section tempdrv_example Example
    884             @verbatim
    885          #include "tempdrv.h"
    886          
    887          boolean flag = false;
    888          
    889          void callback(int8_t temp, TEMPDRV_LimitType_t limit)
    890          {
    891            flag = true;
    892          }
    893          
    894          int main(void)
    895          {
    896            TEMPDRV_Init();
    897          
    898            // Register a callback at 10 degrees above current temperature
    899            TEMPDRV_RegisterCallback(TEMPDRV_GetTemp()+10, TEMPDRV_LIMIT_HIGH, callback);
    900          
    901            while (flag==false) {};
    902          }
    903             @endverbatim
    904          
    905           * @} end group TEMPDRV *******************************************************
    906           * @} end group emdrv ****************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   EMU_IRQHandler
         0   -> TEMPDRV_IRQHandler
       8   TEMPDRV_DeInit
         8   -> __NVIC_ClearPendingIRQ
         8   -> __aeabi_memclr4
       8   TEMPDRV_Enable
         8   -> updateInterrupts
       0   TEMPDRV_GetActiveCallbacks
       0   TEMPDRV_GetTemp
       8   TEMPDRV_IRQHandler
         8   -- Indirect call
         0   -> updateInterrupts
       8   TEMPDRV_Init
         8   -> __NVIC_ClearPendingIRQ
         8   -> __aeabi_memclr4
         8   -> updateInterrupts
      16   TEMPDRV_RegisterCallback
         0   -> addCallback
       8   TEMPDRV_UnregisterCallback
         8   -> removeCallback
       0   __NVIC_ClearPendingIRQ
      16   addCallback
        16   -> updateInterrupts
      16   removeCallback
        16   -> updateInterrupts
      20   updateInterrupts


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_11
       4  ??DataTable13_12
       4  ??DataTable13_13
       4  ??DataTable13_14
       4  ??DataTable13_15
       4  ??DataTable13_16
       4  ??DataTable13_17
       4  ??DataTable13_18
       4  ??DataTable13_19
       4  ??DataTable13_2
       4  ??DataTable13_20
       4  ??DataTable13_21
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
      10  ?Subroutine0
      12  ?Subroutine1
       8  ?Subroutine2
       8  ?Subroutine3
       2  EMU_IRQHandler
      44  TEMPDRV_DeInit
      28  TEMPDRV_Enable
       1  TEMPDRV_EnableState
      42  TEMPDRV_GetActiveCallbacks
      12  TEMPDRV_GetTemp
      88  TEMPDRV_IRQHandler
      50  TEMPDRV_Init
       1  TEMPDRV_InitState
     100  TEMPDRV_RegisterCallback
      38  TEMPDRV_UnregisterCallback
      22  __NVIC_ClearPendingIRQ
      52  addCallback
       4  highCallback
       4  lowCallback
       8  nullCallback
      42  removeCallback
      40  tempdrvHighCallbacks
      40  tempdrvLowCallbacks
     148  updateInterrupts

 
  98 bytes in section .bss
 794 bytes in section .text
 
 794 bytes of CODE memory
  98 bytes of DATA memory

Errors: none
Warnings: none
