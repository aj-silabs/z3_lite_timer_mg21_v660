###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:38
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\sl_crypto\src\cryptoacc_aes.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW21FC.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\sl_crypto\src\cryptoacc_aes.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"cryptoacc_aes.c\"" -D PSSTORE_SIZE=0 -D
#        LONGTOKEN_SIZE=0 -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\sl_crypto\src\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\cryptoacc_aes.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\cryptoacc_aes.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\sl_crypto\src\cryptoacc_aes.c
      1          /*
      2           *  AES abstraction based on the CRYPTOACC peripheral on Silabs devices.
      3           *
      4           *  Copyright (C) 2017, Silicon Labs, http://www.silabs.com
      5           *  SPDX-License-Identifier: Apache-2.0
      6           *
      7           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
      8           *  not use this file except in compliance with the License.
      9           *  You may obtain a copy of the License at
     10           *
     11           *  http://www.apache.org/licenses/LICENSE-2.0
     12           *
     13           *  Unless required by applicable law or agreed to in writing, software
     14           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     15           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     16           *  See the License for the specific language governing permissions and
     17           *  limitations under the License.
     18           */
     19          
     20          /*
     21           * This file includes alternative plugin implementations of various
     22           * functions in aes.c using the Secure Element accelerator incorporated
     23           * in MCU devices from Silicon Laboratories.
     24           */
     25          
     26          /*
     27           *  The AES block cipher was designed by Vincent Rijmen and Joan Daemen.
     28           *
     29           *  http://csrc.nist.gov/encryption/aes/rijndael/Rijndael.pdf
     30           *  http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf
     31           */
     32          
     33          #include "em_device.h"
     34          
     35          #if defined(CRYPTOACC_PRESENT)
     36          
     37          #if !defined(MBEDTLS_CONFIG_FILE)
     38          #include "mbedtls/config.h"
     39          #else
     40          #include MBEDTLS_CONFIG_FILE
     41          #endif
     42          
     43          #if defined(MBEDTLS_AES_C)
     44          #if defined(MBEDTLS_AES_ALT)
     45          #include "cryptoacc_management.h"
     46          #include "sx_aes.h"
     47          #include "sx_errors.h"
     48          #include "cryptolib_def.h"
     49          #include "mbedtls/aes.h"
     50          #include <string.h>
     51          
     52          /*
     53           * Initialize AES context
     54           */
     55          void mbedtls_aes_init( mbedtls_aes_context *ctx )
     56          {
     57              if( ctx == NULL ) {
     58                  return;
     59              }
     60          
     61              memset( ctx, 0, sizeof( mbedtls_aes_context ) );
     62          }
     63          
     64          /*
     65           * Clear AES context
     66           */
     67          void mbedtls_aes_free( mbedtls_aes_context *ctx )
     68          {
     69              if( ctx == NULL ) {
     70                  return;
     71              }
     72          
     73              memset( ctx, 0, sizeof( mbedtls_aes_context ) );
     74          }
     75          
     76          /*
     77           * AES key schedule (encryption)
     78           */
     79          int mbedtls_aes_setkey_enc( mbedtls_aes_context *ctx,
     80                                      const unsigned char *key,
     81                                      unsigned int keybits )
     82          {
     83              if( ctx == NULL || key == NULL ) {
     84                  return( MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH );
     85              }
     86          
     87              memset( ctx, 0, sizeof( mbedtls_aes_context ) );
     88          
     89              if ( ( 128UL != keybits ) && ( 192UL != keybits ) && ( 256UL != keybits ) ) {
     90                  /* Unsupported key size */
     91                  return( MBEDTLS_ERR_AES_INVALID_KEY_LENGTH );
     92              }
     93          
     94              ctx->keybits = keybits;
     95              memcpy(ctx->key, key, keybits/8);
     96          
     97              return 0;
     98          }
     99          
    100          /*
    101           * AES key schedule (decryption)
    102           */
    103          int mbedtls_aes_setkey_dec( mbedtls_aes_context *ctx,
    104                                      const unsigned char *key,
    105                                      unsigned int keybits )
    106          {
    107              return mbedtls_aes_setkey_enc(ctx, key, keybits);
    108          }
    109          
    110          /*
    111           * AES-ECB block encryption/decryption
    112           */
    113          int mbedtls_aes_crypt_ecb( mbedtls_aes_context *ctx,
    114                                     int mode,
    115                                     const unsigned char input[16],
    116                                     unsigned char output[16] )
    117          {
    118              int status;
    119              uint32_t sx_ret;
    120              sx_aes_mode_t dir = mode == MBEDTLS_AES_ENCRYPT ? ENC : DEC;
    121              block_t key;
    122              block_t data_in;
    123              block_t data_out;
    124          
    125              if( ctx == NULL || input == NULL || output == NULL ) {
    126                  return ( MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH );
    127              }
    128          
    129              if ( ctx->keybits != 128UL &&
    130          	 ctx->keybits != 192UL &&
    131          	 ctx->keybits != 256UL ) {
    132                  return MBEDTLS_ERR_AES_INVALID_KEY_LENGTH;
    133              }
    134          
    135              key = block_t_convert(ctx->key, ctx->keybits / 8);
    136              data_in = block_t_convert(input, 16);
    137              data_out = block_t_convert(output, 16);
    138          
    139              status = cryptoacc_management_acquire();
    140              if (status != 0) {
    141                  return status;
    142              }
    143              sx_ret = sx_aes_blk(ECB, dir, CTX_WHOLE, key, NULL_blk, NULL_blk, data_in,
    144          			data_out, NULL_blk, NULL_blk, NULL_blk, NULL_blk);
    145              cryptoacc_management_release();
    146          
    147              if (sx_ret != CRYPTOLIB_SUCCESS) {
    148                  return MBEDTLS_ERR_AES_HW_ACCEL_FAILED;
    149              }
    150              else {
    151                  return 0;
    152              }
    153          }
    154          
    155          #if defined(MBEDTLS_CIPHER_MODE_CBC)
    156          
    157          /*
    158           * AES-CBC buffer encryption/decryption
    159           */
    160          int mbedtls_aes_crypt_cbc( mbedtls_aes_context *ctx,
    161                                     int mode,
    162                                     size_t length,
    163                                     unsigned char iv[16],
    164                                     const unsigned char *input,
    165                                     unsigned char *output )
    166          {
    167              int status;
    168              uint32_t sx_ret;
    169              sx_aes_mode_t dir = mode == MBEDTLS_AES_ENCRYPT ? ENC : DEC;
    170              block_t key;
    171              block_t iv_block;
    172              block_t data_in;
    173              block_t data_out;
    174          
    175              if( ctx == NULL || input == NULL || output == NULL || iv == NULL ) {
    176                  return ( MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH );
    177              }
    178          
    179              /* Input length must be a multiple of 16 bytes which is the AES block
    180                 length. */
    181              if( length & 0xf ) {
    182                  return( MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH );
    183              }
    184          
    185              if ( ctx->keybits != 128UL &&
    186          	 ctx->keybits != 192UL &&
    187          	 ctx->keybits != 256UL) {
    188                  return MBEDTLS_ERR_AES_INVALID_KEY_LENGTH;
    189              }
    190          
    191              key = block_t_convert(ctx->key, ctx->keybits / 8);
    192              iv_block = block_t_convert(iv, 16);
    193              data_in = block_t_convert(input, length);
    194              data_out = block_t_convert(output, length);
    195          
    196              status = cryptoacc_management_acquire();
    197              if (status != 0) {
    198                  return status;
    199              }
    200              sx_ret = sx_aes_blk(CBC, dir, CTX_MIDDLE, key, NULL_blk, iv_block, data_in,
    201          			data_out, NULL_blk, NULL_blk, iv_block, NULL_blk);
    202              cryptoacc_management_release();
    203          
    204              if (sx_ret != CRYPTOLIB_SUCCESS) {
    205                  return MBEDTLS_ERR_AES_HW_ACCEL_FAILED;
    206              }
    207              else {
    208                  return 0;
    209              }
    210          }
    211          #endif /* MBEDTLS_CIPHER_MODE_CBC */
    212          
    213          #if defined(MBEDTLS_CIPHER_MODE_CFB)
    214          /*
    215           * AES-CFB128 buffer encryption/decryption
    216           */
    217          int mbedtls_aes_crypt_cfb128( mbedtls_aes_context *ctx,
    218                                        int mode,
    219                                        size_t length,
    220                                        size_t *iv_off,
    221                                        unsigned char iv[16],
    222                                        const unsigned char *input,
    223                                        unsigned char *output )
    224          {
    225              int status;
    226              size_t n = iv_off ? *iv_off : 0;
    227              size_t processed = 0;
    228              uint32_t sx_ret = CRYPTOLIB_SUCCESS;
    229              sx_aes_mode_t dir = mode == MBEDTLS_AES_ENCRYPT ? ENC : DEC;
    230              block_t key;
    231              block_t iv_block;
    232              block_t data_in;
    233              block_t data_out;
    234          
    235              if( ctx == NULL || input == NULL || output == NULL || iv == NULL ) {
    236                  return ( MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH );
    237              }
    238          
    239              if ( ctx->keybits != 128UL &&
    240          	 ctx->keybits != 192UL &&
    241          	 ctx->keybits != 256UL) {
    242                  return MBEDTLS_ERR_AES_INVALID_KEY_LENGTH;
    243              }
    244          
    245              key = block_t_convert(ctx->key, ctx->keybits / 8);
    246              iv_block = block_t_convert(iv, 16);
    247              while ( processed < length ) {
    248                  if ( n > 0 ) {
    249                      /* start by filling up the IV */
    250                      if( mode == MBEDTLS_AES_ENCRYPT ) {
    251                          iv[n] = output[processed] = (unsigned char)( iv[n] ^ input[processed] );
    252                      } else {
    253                          int c = input[processed];
    254                          output[processed] = (unsigned char)( c ^ iv[n] );
    255                          iv[n] = (unsigned char) c;
    256                      }
    257                      n = ( n + 1 ) & 0x0F;
    258                      processed++;
    259                      continue;
    260                  } else {
    261                      /* process one ore more blocks of data */
    262                      size_t iterations = (length - processed) / 16;
    263          
    264                      if ( iterations > 0 ) {
    265                          data_in = block_t_convert(&input[processed], iterations * 16);
    266                          data_out = block_t_convert(&output[processed], iterations * 16);
    267          
    268                          status = cryptoacc_management_acquire();
    269                          if (status != 0) {
    270                              return status;
    271                          }
    272          		        sx_ret = sx_aes_blk(CFB, dir, CTX_MIDDLE, key, NULL_blk,
    273          				                    iv_block, data_in, data_out,
    274          				                    NULL_blk, NULL_blk, iv_block, NULL_blk);
    275               	        cryptoacc_management_release();
    276          
    277                          processed += iterations * 16;
    278                      }
    279          
    280                      if (sx_ret != CRYPTOLIB_SUCCESS) {
    281            	            return MBEDTLS_ERR_AES_HW_ACCEL_FAILED;
    282          	        }
    283          
    284                      while ( length - processed > 0 ) {
    285                          if ( n == 0 ) {
    286                              // Need to update the IV but don't have a full block of input to pass to the SE
    287                              mbedtls_aes_crypt_ecb(ctx, MBEDTLS_AES_ENCRYPT, iv, iv);
    288                          }
    289                          /* Save remainder to iv */
    290                          if( mode == MBEDTLS_AES_ENCRYPT ) {
    291                              iv[n] = output[processed] = (unsigned char)( iv[n] ^ input[processed] );
    292                          } else {
    293                              int c = input[processed];
    294                              output[processed] = (unsigned char)( c ^ iv[n] );
    295                              iv[n] = (unsigned char) c;
    296                          }
    297                          n = ( n + 1 ) & 0x0F;
    298                          processed++;
    299                      }
    300                  }
    301              }
    302          
    303              if ( iv_off ) {
    304                  *iv_off = n;
    305              }
    306          
    307              return 0;
    308          }
    309          
    310          /*
    311           * AES-CFB8 buffer encryption/decryption
    312           */
    313          int mbedtls_aes_crypt_cfb8( mbedtls_aes_context *ctx,
    314                                      int mode,
    315                                      size_t length,
    316                                      unsigned char iv[16],
    317                                      const unsigned char *input,
    318                                      unsigned char *output )
    319          {
    320              unsigned char c;
    321              unsigned char ov[17];
    322              int ret = 0;
    323          
    324              if( ctx == NULL || input == NULL || output == NULL || iv == NULL ) {
    325                  return ( MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH );
    326              }
    327          
    328              if ( ctx->keybits != 128UL &&
    329          	 ctx->keybits != 192UL &&
    330          	 ctx->keybits != 256UL) {
    331                  return MBEDTLS_ERR_AES_INVALID_KEY_LENGTH;
    332              }
    333          
    334              while( length-- )
    335              {
    336                  memcpy( ov, iv, 16 );
    337                  if ( (ret = mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv ))
    338          	     != 0 ) {
    339                      return ret;
    340                  }
    341          
    342                  if( mode == MBEDTLS_AES_DECRYPT )
    343                      ov[16] = *input;
    344          
    345                  c = *output++ = (unsigned char)( iv[0] ^ *input++ );
    346          
    347                  if( mode == MBEDTLS_AES_ENCRYPT )
    348                      ov[16] = c;
    349          
    350                  memcpy( iv, ov + 1, 16 );
    351              }
    352          
    353              return ret;
    354          }
    355          #endif /*MBEDTLS_CIPHER_MODE_CFB */
    356          
    357          #if defined(MBEDTLS_CIPHER_MODE_CTR)
    358          /*
    359           * AES-CTR buffer encryption/decryption
    360           */
    361          int mbedtls_aes_crypt_ctr( mbedtls_aes_context *ctx,
    362                                     size_t length,
    363                                     size_t *nc_off,
    364                                     unsigned char nonce_counter[16],
    365                                     unsigned char stream_block[16],
    366                                     const unsigned char *input,
    367                                     unsigned char *output )
    368          {
    369              int status;
    370              size_t n = nc_off ? *nc_off : 0;
    371              size_t processed = 0;
    372              uint32_t sx_ret = CRYPTOLIB_SUCCESS;
    373              sx_aes_mode_t dir = ENC;
    374              block_t key;
    375              block_t iv_block;
    376              block_t data_in;
    377              block_t data_out;
    378          
    379              if( ctx == NULL || input == NULL || output == NULL ||
    380          	nonce_counter == NULL || stream_block == NULL ) {
    381                  return ( MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH );
    382              }
    383          
    384              if ( ctx->keybits != 128UL &&
    385          	 ctx->keybits != 192UL &&
    386          	 ctx->keybits != 256UL) {
    387                  return MBEDTLS_ERR_AES_INVALID_KEY_LENGTH;
    388              }
    389          
    390              key = block_t_convert(ctx->key, ctx->keybits / 8);
    391              iv_block = block_t_convert(nonce_counter, 16);
    392          
    393              while ( processed < length ) {
    394                  if ( n > 0 ) {
    395                      /* start by filling up the IV */
    396                      output[processed] = (unsigned char)( input[processed] ^ stream_block[n] );
    397                      n = ( n + 1 ) & 0x0F;
    398                      processed++;
    399                      continue;
    400                  } else {
    401                      /* process one or more blocks of data */
    402                      size_t iterations = (length - processed) / 16;
    403          
    404                      if ( iterations > 0 ) {
    405                          data_in = block_t_convert(&input[processed], iterations * 16);
    406                          data_out = block_t_convert(&output[processed], iterations * 16);
    407          
    408                          status = cryptoacc_management_acquire();
    409                          if (status != 0) {
    410                              return status;
    411                          }
    412                          sx_ret = sx_aes_blk(CTR, dir, CTX_MIDDLE, key, NULL_blk,
    413          				                    iv_block, data_in, data_out,
    414          				                    NULL_blk, NULL_blk, iv_block, NULL_blk);
    415                          cryptoacc_management_release();
    416          
    417                          processed += iterations * 16;
    418                      }
    419          
    420                      if (sx_ret != CRYPTOLIB_SUCCESS) {
    421            	            return MBEDTLS_ERR_AES_HW_ACCEL_FAILED;
    422          	        }
    423          
    424                      while ( length - processed > 0 ) {
    425                          if ( n == 0 ) {
    426                              // Get a new stream block
    427                              mbedtls_aes_crypt_ecb(ctx, MBEDTLS_AES_ENCRYPT,
    428          					  nonce_counter, stream_block);
    429                              // increment nonce counter...
    430                              for(size_t i = 0; i < 16; i++) {
    431                                  nonce_counter[15-i] = nonce_counter[15-i] + 1;
    432                                  if ( nonce_counter[15-i] != 0 ) {
    433                                      break;
    434                                  }
    435                              }
    436                          }
    437                          /* Save remainder to iv */
    438                          output[processed] = (unsigned char)( input[processed] ^ stream_block[n] );
    439                          n = ( n + 1 ) & 0x0F;
    440                          processed++;
    441                      }
    442                  }
    443              }
    444          
    445              if ( nc_off ) {
    446                  *nc_off = n;
    447              }
    448          
    449              return 0;
    450          }
    451          #endif /* MBEDTLS_CIPHER_MODE_CTR */
    452          
    453          #endif /* MBEDTLS_AES_ALT */
    454          
    455          #endif /* MBEDTLS_AES_C */
    456          
    457          #endif /* CRYPTOACC_PRESENT */


 
 
 0 bytes of memory

Errors: none
Warnings: none
