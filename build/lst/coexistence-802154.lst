###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:28
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\coexistence-802154.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EWF657.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\coexistence-802154.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"coexistence-802154.c\"" -D PSSTORE_SIZE=0 -D
#        LONGTOKEN_SIZE=0 -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\coexistence-802154.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\coexistence-802154.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\coexistence-802154.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief 802.15.4 Specific Radio Coexistence callbacks
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc. Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement. This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          
     18          #ifndef SIMULATION_DEVICE
     19          #include PLATFORM_HEADER
     20          
     21          #include "stack/include/ember.h"
     22          #include "stack/include/ember-types.h"
     23          #include "include/error.h"
     24          #include "hal/hal.h"
     25          #endif // SIMULATION_DEVICE
     26          
     27          #include "coexistence-hal.h"
     28          #include "coexistence/protocol/ieee802154/coexistence-802154.h"
     29          #include "coexistence/protocol/ieee802154/coulomb-counter-802154.h"
     30          
     31          #ifdef RTOS
     32            #include "rtos/rtos.h"
     33          #endif
     34          
     35          #if defined(DEBUG_PTA) || defined(RHO_GPIO) || defined(BSP_COEX_RHO_PORT)
     36          #define COEX_RHO_SUPPORT 1
     37          #endif //defined(DEBUG_PTA) || defined(RHO_GPIO) || defined(BSP_COEX_RHO_PORT)
     38          
     39          #if defined(DEBUG_PTA) || defined(PTA_REQ_GPIO) || defined(BSP_COEX_REQ_PORT) \
     40            || defined(PTA_GNT_GPIO) || defined(BSP_COEX_GNT_PORT)
     41          #define COEX_SUPPORT 1
     42          #endif //defined(DEBUG_PTA) || defined(PTA_REQ_GPIO) || defined(BSP_COEX_REQ_PORT)
     43          //|| defined(PTA_GNT_GPIO) || defined(BSP_COEX_GNT_PORT)
     44          
     45          #if HAL_COEX_ACKHOLDOFF || defined(RHO_GPIO)
     46            #define DEFAULT_PTA_OPT_ACK_HOLDOFF PTA_OPT_ACK_HOLDOFF
     47          #else //!(HAL_COEX_ACKHOLDOFF || defined(RHO_GPIO))
     48            #define DEFAULT_PTA_OPT_ACK_HOLDOFF PTA_OPT_DISABLED
     49          #endif //HAL_COEX_ACKHOLDOFF || defined(RHO_GPIO)
     50          
     51          #if HAL_COEX_TX_ABORT
     52            #define DEFAULT_PTA_OPT_ABORT_TX PTA_OPT_ABORT_TX
     53          #else //!HAL_COEX_TX_ABORT
     54            #define DEFAULT_PTA_OPT_ABORT_TX PTA_OPT_DISABLED
     55          #endif //HAL_COEX_TX_ABORT
     56          
     57          #if HAL_COEX_TX_HIPRI
     58            #define DEFAULT_PTA_OPT_TX_HIPRI PTA_OPT_TX_HIPRI
     59          #else //!HAL_COEX_TX_HIPRI
     60            #define DEFAULT_PTA_OPT_TX_HIPRI PTA_OPT_DISABLED
     61          #endif //HAL_COEX_TX_HIPRI
     62          
     63          #if HAL_COEX_RX_HIPRI
     64            #define DEFAULT_PTA_OPT_RX_HIPRI PTA_OPT_RX_HIPRI
     65          #else //!HAL_COEX_RX_HIPRI
     66            #define DEFAULT_PTA_OPT_RX_HIPRI PTA_OPT_DISABLED
     67          #endif //HAL_COEX_RX_HIPRI
     68          
     69          #if HAL_COEX_RETRYRX_HIPRI
     70            #define DEFAULT_PTA_OPT_RX_RETRY_HIPRI PTA_OPT_RX_RETRY_HIPRI
     71          #else //!HAL_COEX_RETRYRX_HIPRI
     72            #define DEFAULT_PTA_OPT_RX_RETRY_HIPRI PTA_OPT_DISABLED
     73          #endif //HAL_COEX_RETRYRX_HIPRI
     74          
     75          #if HAL_COEX_LONG_REQ
     76            #define DEFAULT_PTA_OPT_LONG_REQ PTA_OPT_LONG_REQ
     77          #else //!HAL_COEX_LONG_REQ
     78            #define DEFAULT_PTA_OPT_LONG_REQ PTA_OPT_DISABLED
     79          #endif //HAL_COEX_LONG_REQ
     80          
     81          #if HAL_COEX_TOGGLE_REQ_ON_MACRETRANSMIT
     82            #define DEFAULT_PTA_OPT_TOGGLE_REQ_ON_MACRETRANSMIT PTA_OPT_TOGGLE_REQ_ON_MACRETRANSMIT
     83          #else //!HAL_COEX_TOGGLE_REQ_ON_MACRETRANSMIT
     84            #define DEFAULT_PTA_OPT_TOGGLE_REQ_ON_MACRETRANSMIT PTA_OPT_DISABLED
     85          #endif //HAL_COEX_TOGGLE_REQ_ON_MACRETRANSMIT
     86          
     87          #if defined(BSP_COEX_RHO_PORT) || (defined(RADIO_HOLDOFF) && defined(RHO_GPIO))
     88            #define DEFAULT_PTA_OPT_RHO_ENABLED PTA_OPT_RHO_ENABLED
     89          #else //(!defined(BSP_COEX_RHO_PORT) || (defined(RADIO_HOLDOFF) && defined(RHO_GPIO)))
     90            #define DEFAULT_PTA_OPT_RHO_ENABLED PTA_OPT_DISABLED
     91          #endif //defined(BSP_COEX_RHO_PORT) || (defined(RADIO_HOLDOFF) && defined(RHO_GPIO))
     92          
     93          #if HAL_COEX_RETRYRX_TIMEOUT
     94            #define DEFAULT_PTA_OPT_RX_RETRY_TIMEOUT_MS HAL_COEX_RETRYRX_TIMEOUT
     95          #else //!HAL_COEX_RETRYRX_TIMEOUT
     96            #define DEFAULT_PTA_OPT_RX_RETRY_TIMEOUT_MS PTA_OPT_DISABLED
     97          #endif //HAL_COEX_RETRYRX_TIMEOUT
     98          
     99          #if HAL_COEX_RETRYRX_ENABLE
    100            #define DEFAULT_PTA_OPT_RX_RETRY_REQ PTA_OPT_RX_RETRY_REQ
    101          #else //!HAL_COEX_RETRYRX_ENABLE
    102            #define DEFAULT_PTA_OPT_RX_RETRY_REQ PTA_OPT_DISABLED
    103          #endif //HAL_COEX_RETRYRX_TIMEOUT
    104          
    105          #if HAL_COEX_CCA_THRESHOLD
    106            #define DEFAULT_PTA_OPT_CCA_THRESHOLD \
    107            ((HAL_COEX_CCA_THRESHOLD << 20) & PTA_OPT_CCA_THRESHOLD)
    108          #else //!HAL_COEX_CCA_THRESHOLD
    109            #define DEFAULT_PTA_OPT_CCA_THRESHOLD PTA_OPT_DISABLED
    110          #endif  //HAL_COEX_CCA_THRESHOLD
    111          
    112          #if HAL_COEX_MAC_FAIL_THRESHOLD
    113            #define DEFAULT_PTA_OPT_MAC_FAIL_THRESHOLD \
    114            ((HAL_COEX_MAC_FAIL_THRESHOLD << 25) & PTA_OPT_MAC_FAIL_THRESHOLD)
    115          #else //!HAL_COEX_MAC_FAIL_THRESHOLD
    116            #define DEFAULT_PTA_OPT_MAC_FAIL_THRESHOLD PTA_OPT_DISABLED
    117          #endif  //HAL_COEX_MAC_FAIL_THRESHOLD
    118          
    119          #define DEFAULT_PTA_OPT_FORCE_HOLDOFF PTA_OPT_DISABLED
    120          #define DEFAULT_PTA_OPT_MAC_HOLDOFF   PTA_OPT_DISABLED
    121          
    122          #define DEFAULT_PTA_OPTIONS (0U                                            \
    123                                       | DEFAULT_PTA_OPT_RX_RETRY_TIMEOUT_MS         \
    124                                       | DEFAULT_PTA_OPT_ACK_HOLDOFF                 \
    125                                       | DEFAULT_PTA_OPT_ABORT_TX                    \
    126                                       | DEFAULT_PTA_OPT_TX_HIPRI                    \
    127                                       | DEFAULT_PTA_OPT_RX_HIPRI                    \
    128                                       | DEFAULT_PTA_OPT_RX_RETRY_HIPRI              \
    129                                       | DEFAULT_PTA_OPT_RX_RETRY_REQ                \
    130                                       | DEFAULT_PTA_OPT_RHO_ENABLED                 \
    131                                       | DEFAULT_PTA_OPT_TOGGLE_REQ_ON_MACRETRANSMIT \
    132                                       | DEFAULT_PTA_OPT_FORCE_HOLDOFF               \
    133                                       | DEFAULT_PTA_OPT_MAC_HOLDOFF                 \
    134                                       | DEFAULT_PTA_OPT_CCA_THRESHOLD               \
    135                                       | DEFAULT_PTA_OPT_MAC_FAIL_THRESHOLD          \
    136                                       | DEFAULT_PTA_OPT_LONG_REQ                    \
    137                                       )
    138          
    139          #if defined(BSP_COEX_REQ_PORT) || defined(PTA_REQ_GPIO)
    140            #define PUBLIC_PTA_OPT_RX_RETRY_TIMEOUT_MS \
    141            PTA_OPT_RX_RETRY_TIMEOUT_MS
    142            #define PUBLIC_PTA_OPT_RX_RETRY_REQ \
    143            PTA_OPT_RX_RETRY_REQ
    144            #define PUBLIC_PTA_OPT_TOGGLE_REQ_ON_MACRETRANSMIT \
    145            PTA_OPT_TOGGLE_REQ_ON_MACRETRANSMIT
    146            #define PUBLIC_PTA_OPT_FORCE_HOLDOFF PTA_OPT_FORCE_HOLDOFF
    147            #define PUBLIC_PTA_OPT_MAC_HOLDOFF PTA_OPT_MAC_HOLDOFF
    148            #define PUBLIC_PTA_OPT_REQ_FILTER_PASS PTA_OPT_REQ_FILTER_PASS
    149          #else //!defined(BSP_COEX_REQ_PORT) && !defined(PTA_REQ_GPIO)
    150            #define PUBLIC_PTA_OPT_RX_RETRY_TIMEOUT_MS \
    151            PTA_OPT_DISABLED
    152            #define PUBLIC_PTA_OPT_RX_RETRY_REQ \
    153            PTA_OPT_DISABLED
    154            #define PUBLIC_PTA_OPT_TOGGLE_REQ_ON_MACRETRANSMIT \
    155            PTA_OPT_DISABLED
    156            #define PUBLIC_PTA_OPT_FORCE_HOLDOFF PTA_OPT_DISABLED
    157            #define PUBLIC_PTA_OPT_MAC_HOLDOFF PTA_OPT_DISABLED
    158            #define PUBLIC_PTA_OPT_REQ_FILTER_PASS PTA_OPT_DISABLED
    159          #endif
    160          
    161          #if defined(BSP_COEX_PRI_PORT) || defined(PTA_PRI_GPIO)
    162            #define PUBLIC_PTA_OPT_TX_HIPRI          PTA_OPT_TX_HIPRI
    163            #define PUBLIC_PTA_OPT_RX_HIPRI          PTA_OPT_RX_HIPRI
    164            #define PUBLIC_PTA_OPT_RX_RETRY_HIPRI    PTA_OPT_RX_RETRY_HIPRI
    165            #define PUBLIC_PTA_OPT_HIPRI_FILTER_PASS PTA_OPT_HIPRI_FILTER_PASS
    166          #else //!defined(BSP_COEX_PRI_PORT) && !defined(PTA_PRI_GPIO)
    167            #define PUBLIC_PTA_OPT_TX_HIPRI          PTA_OPT_DISABLED
    168            #define PUBLIC_PTA_OPT_RX_HIPRI          PTA_OPT_DISABLED
    169            #define PUBLIC_PTA_OPT_RX_RETRY_HIPRI    PTA_OPT_DISABLED
    170            #define PUBLIC_PTA_OPT_HIPRI_FILTER_PASS PTA_OPT_DISABLED
    171          #endif
    172          
    173          #if defined(BSP_COEX_RHO_PORT) || defined(RHO_GPIO)
    174            #define PUBLIC_PTA_OPT_RHO_ENABLED PTA_OPT_RHO_ENABLED
    175          #else //!(defined(BSP_COEX_RHO_PORT) || defined(RHO_GPIO))
    176            #define PUBLIC_PTA_OPT_RHO_ENABLED PTA_OPT_DISABLED
    177          #endif //defined(BSP_COEX_RHO_PORT) || defined(RHO_GPIO)
    178          
    179          #define PUBLIC_PTA_OPT_ACK_HOLDOFF PTA_OPT_ACK_HOLDOFF
    180          #define PUBLIC_PTA_OPT_ABORT_TX    PTA_OPT_ABORT_TX
    181          
    182          #if HAL_COEX_PRIORITY_ESCALATION_ENABLE
    183          #define PUBLIC_PTA_OPT_CCA_THRESHOLD PTA_OPT_CCA_THRESHOLD
    184          #define PUBLIC_PTA_OPT_MAC_RETRY_THRESHOLD PTA_OPT_MAC_RETRY_THRESHOLD
    185          #define PUBLIC_PTA_OPT_MAC_FAIL_THRESHOLD PTA_OPT_MAC_FAIL_THRESHOLD
    186          #else //!HAL_COEX_PRIORITY_ESCALATION_ENABLE
    187          #define PUBLIC_PTA_OPT_CCA_THRESHOLD PTA_OPT_DISABLED
    188          #define PUBLIC_PTA_OPT_MAC_RETRY_THRESHOLD PTA_OPT_DISABLED
    189          #define PUBLIC_PTA_OPT_MAC_FAIL_THRESHOLD PTA_OPT_DISABLED
    190          #endif //HAL_COEX_PRIORITY_ESCALATION_ENABLE
    191          
    192          // Public PTA options can be modified using public PTA APIs
    193          #define PUBLIC_PTA_OPTIONS (0U                                           \
    194                                      | PUBLIC_PTA_OPT_RX_RETRY_TIMEOUT_MS         \
    195                                      | PUBLIC_PTA_OPT_ACK_HOLDOFF                 \
    196                                      | PUBLIC_PTA_OPT_ABORT_TX                    \
    197                                      | PUBLIC_PTA_OPT_TX_HIPRI                    \
    198                                      | PUBLIC_PTA_OPT_RX_HIPRI                    \
    199                                      | PUBLIC_PTA_OPT_RX_RETRY_HIPRI              \
    200                                      | PUBLIC_PTA_OPT_RX_RETRY_REQ                \
    201                                      | PUBLIC_PTA_OPT_RHO_ENABLED                 \
    202                                      | PUBLIC_PTA_OPT_TOGGLE_REQ_ON_MACRETRANSMIT \
    203                                      | PUBLIC_PTA_OPT_FORCE_HOLDOFF               \
    204                                      | PUBLIC_PTA_OPT_MAC_HOLDOFF                 \
    205                                      | PUBLIC_PTA_OPT_REQ_FILTER_PASS             \
    206                                      | PUBLIC_PTA_OPT_HIPRI_FILTER_PASS           \
    207                                      | PUBLIC_PTA_OPT_CCA_THRESHOLD               \
    208                                      | PUBLIC_PTA_OPT_MAC_RETRY_THRESHOLD         \
    209                                      | PUBLIC_PTA_OPT_MAC_FAIL_THRESHOLD          \
    210                                      )
    211          // Constant PTA options can not be modified using public PTA APIs
    212          #define CONST_PTA_OPTIONS (~(PUBLIC_PTA_OPTIONS))
    213          
    214          #ifndef DEFAULT_PTA_OPTIONS
    215            #define DEFAULT_PTA_OPTIONS PTA_OPT_DISABLED
    216          #endif
    217          #ifndef CONST_PTA_OPTIONS
    218            #define CONST_PTA_OPTIONS (~PTA_OPT_DISABLED)
    219          #endif
    220          
    221          #if !defined(BSP_COEX_PHY_SELECT_PORT)         \
    222            && (HAL_COEX_DEFAULT_PHY_SELECT_TIMEOUT > 0) \
    223            && (HAL_COEX_DEFAULT_PHY_SELECT_TIMEOUT < 255)
    224          #error "Select BSP_COEX_PHY_SELECT GPIO before enabling COEX PHY select timeout!"
    225          #endif
    226          
    227          extern void emPhyCancelTransmit(void);
    228          void halStackRadioHoldOffPowerDown(void); // fwd ref
    229          void halStackRadioHoldOffPowerUp(void);   // fwd ref
    230          
    231          extern void emRadioEnablePta(bool enabled);
    232          extern void emRadioHoldOffIsr(bool active);
    233          
    234          #define PHY_IS_RAIL_BASED (PHY_RAIL || PHY_DUALRAIL)
    235          #define USE_MULTITIMER PHY_IS_RAIL_BASED
    236          
    237          #if HAL_ANTDIV_RX_RUNTIME_PHY_SELECT
    238          extern bool halAntDivRxPhyChanged(void);
    239          #else //!HAL_ANTDIV_RX_RUNTIME_PHY_SELECT
    240          #define halAntDivRxPhyChanged() (false)
    241          #endif //HAL_ANTDIV_RX_RUNTIME_PHY_SELECT
    242          
    243          #define RUNTIME_PHY_SELECT          \
    244            (HAL_ANTDIV_RX_RUNTIME_PHY_SELECT \
    245             || HAL_COEX_RUNTIME_PHY_SELECT)  \
    246          
    247          #define COEX_STACK_EVENT_SUPPORT \
    248            (COEX_SUPPORT                  \
    249             || COEX_RHO_SUPPORT           \
    250             || RUNTIME_PHY_SELECT)        \
    251          
    252          #if HAL_COEX_PHY_ENABLED
    253          static uint8_t phySelectTimeoutMs = PTA_PHY_SELECT_TIMEOUT_MAX;
    254          #else //!HAL_COEX_PHY_ENABLED

   \                                 In section .bss, align 1
   \        0x0                      DS8 1
    255          static uint8_t phySelectTimeoutMs = 0U;
    256          #endif //HAL_COEX_PHY_ENABLED
    257          
    258          #if COEX_STACK_EVENT_SUPPORT
    259          static bool coexInitialized = false;
    260          #endif //COEX_STACK_EVENT_SUPPORT
    261          
    262          #if RUNTIME_PHY_SELECT
    263          
    264          #include "rail_types.h"
    265          static void checkPhySelectTimer(void);
    266          
    267          // This is grody, but it beats making the PHY need to know about all
    268          // the Coex PHYs.  Borrow from unreleased phy/phy.h:
    269          enum {
    270            EMBER_RADIO_POWER_MODE_RX_ON,
    271            EMBER_RADIO_POWER_MODE_OFF
    272          };
    273          typedef uint8_t RadioPowerMode;
    274          extern bool halCoexPhySelectedCoex;
    275          extern RAIL_Handle_t emPhyRailHandle;
    276          #if     PHY_DUAL
    277          // Map to native PHY only
    278          #define emPhyGetChannelPageInUse emPhy0_emPhyGetChannelPageInUse
    279          #define emRadioGetIdleMode       emPhy0_emRadioGetIdleMode
    280          #define emRadioSetIdleMode       emPhy0_emRadioSetIdleMode
    281          #endif//PHY_DUAL
    282          extern uint8_t emPhyGetChannelPageInUse(void);
    283          extern RadioPowerMode emRadioGetIdleMode(void);
    284          extern EmberStatus emRadioSetIdleMode(RadioPowerMode mode);
    285          extern RAIL_Status_t halPluginConfig2p4GHzRadio(RAIL_Handle_t railHandle);
    286          
    287          #if     HAL_COEX_PHY_ENABLED
    288          static volatile bool halCoexNewPhySelectedCoex = true;
    289          #else//!HAL_COEX_PHY_ENABLED
    290          static volatile bool halCoexNewPhySelectedCoex = false;
    291          #endif//HAL_COEX_PHY_ENABLED
    292          static uint8_t blockPhySwitch = 0U;
    293          #define BLOCK_SWITCH_RX 0x01u
    294          #define BLOCK_SWITCH_TX 0x02u
    295          #define setBlockPhySwitch(dir, boolval)   \
    296            do {                                    \
    297              if (boolval) {                        \
    298                blockPhySwitch |= (dir);            \
    299              } else {                              \
    300                blockPhySwitch &= (uint8_t) ~(dir); \
    301              }                                     \
    302            } while (false)
    303          
    304          static bool checkPhySwitch(void)
    305          {
    306            if ((halAntDivRxPhyChanged()
    307                 || (halCoexNewPhySelectedCoex != halCoexPhySelectedCoex))
    308                && (blockPhySwitch == 0U)
    309                && coexInitialized
    310                && (emPhyRailHandle != NULL)) {
    311              //@TODO: Ascertain radio is OFF, RXWARM, or RXSEARCH only.
    312              halCoexPhySelectedCoex = halCoexNewPhySelectedCoex;
    313              if (emPhyGetChannelPageInUse() == 0) { // Using 2.4GHz band
    314                RadioPowerMode currentMode = emRadioGetIdleMode();
    315                (void) emRadioSetIdleMode(EMBER_RADIO_POWER_MODE_OFF);
    316                (void) halPluginConfig2p4GHzRadio(emPhyRailHandle);
    317                (void) emRadioSetIdleMode(currentMode);
    318              } else {
    319                // Defer proper PHY selection to when the 2.4GHz band is next used
    320              }
    321              return true;
    322            }
    323            return false;
    324          }
    325          
    326          #else//!RUNTIME_PHY_SELECT
    327          
    328          #define setBlockPhySwitch(dir, boolval) /*no-op*/
    329          #define checkPhySwitch() (false)
    330          
    331          #endif//RUNTIME_PHY_SELECT
    332          
    333          #if COEX_STACK_EVENT_SUPPORT
    334          static HalPtaOptions halPtaOptions = DEFAULT_PTA_OPTIONS;
    335          static void configRandomDelay(void);
    336          static void coexEventsCb(COEX_Events_t events);
    337          
    338          static void eventsCb(COEX_Events_t events)
    339          {
    340            if ((events & COEX_EVENT_HOLDOFF_CHANGED) != 0U) {
    341              emRadioHoldOffIsr((COEX_GetOptions() & COEX_OPTION_HOLDOFF_ACTIVE) != 0U);
    342            }
    343           #if     HAL_COEX_RUNTIME_PHY_SELECT
    344            if ((events & COEX_EVENT_PHY_SELECT_CHANGED) != 0U) {
    345              checkPhySelectTimer();
    346            }
    347           #endif//HAL_COEX_RUNTIME_PHY_SELECT
    348            coexEventsCb(events);
    349          }
    350          
    351          static void COEX_802154_Init(void)
    352          {
    353            if (coexInitialized) {
    354              return;
    355            }
    356            configRandomDelay();
    357            COEX_SetRadioCallback(&eventsCb);
    358            COEX_HAL_Init();
    359            coexInitialized = true;
    360          #if HAL_COEX_PWM_DEFAULT_ENABLED
    361            halPtaSetRequestPwm(COEX_REQ_PWM
    362                                | (HAL_COEX_PWM_PRIORITY << COEX_REQ_HIPRI_SHIFT),
    363                                NULL,
    364                                HAL_COEX_PWM_REQ_DUTYCYCLE,
    365                                HAL_COEX_PWM_REQ_PERIOD);
    366          #endif // HAL_COEX_PWM_DEFAULT_ENABLED
    367          #if HAL_COEX_RUNTIME_PHY_SELECT
    368            halPtaSetPhySelectTimeout(HAL_COEX_DEFAULT_PHY_SELECT_TIMEOUT);
    369          #endif //HAL_COEX_RUNTIME_PHY_SELECT
    370          }
    371          
    372          #define MAP_COEX_OPTION(coexOpt, halPtaOpt) \
    373            (mapCoexOption(&coexOptions, coexOpt, options, halPtaOpt))
    374          
    375          static void mapCoexOption(COEX_Options_t *coexOptions, COEX_Options_t coexOpt,
    376                                    HalPtaOptions options, HalPtaOptions halPtaOpt)
    377          {
    378            if ((options & halPtaOpt) != 0U) {
    379              *coexOptions |= coexOpt;
    380            } else {
    381              *coexOptions &= ~coexOpt;
    382            }
    383          }
    384          
    385          // Public API
    386          
    387          EmberStatus halPtaSetBool(HalPtaOptions option, bool value)
    388          {
    389            HalPtaOptions ptaOptions = halPtaGetOptions();
    390            ptaOptions = value ? (ptaOptions | option) : (ptaOptions & (~option));
    391            return halPtaSetOptions(ptaOptions);
    392          }
    393          
    394          HalPtaOptions halPtaGetOptions(void)
    395          {
    396            return halPtaOptions;
    397          }
    398          
    399          EmberStatus halPtaSetOptions(HalPtaOptions options)
    400          {
    401            EmberStatus status = EMBER_ERR_FATAL;
    402            COEX_802154_Init();
    403            COEX_Options_t coexOptions = COEX_GetOptions();
    404          
    405          #ifndef DEBUG_PTA
    406            if ((options & CONST_PTA_OPTIONS) != (DEFAULT_PTA_OPTIONS & CONST_PTA_OPTIONS)) {
    407              //Return error if any options argument is unsupported or constant
    408              return EMBER_BAD_ARGUMENT;
    409            }
    410          #endif //!DEBUG_PTA
    411          
    412            if (((~halPtaOptions) & options & PTA_OPT_FORCE_HOLDOFF) != 0U) {
    413              //Cancel all requests if force holdoff is enabled
    414              //All future requests will be blocked until force holdoff is disabled
    415              (void) halPtaSetTxRequest(PTA_REQ_OFF, NULL);
    416              (void) halPtaSetRxRequest(PTA_REQ_OFF, NULL);
    417            }
    418            MAP_COEX_OPTION(COEX_OPTION_TX_ABORT, PTA_OPT_ABORT_TX);
    419            MAP_COEX_OPTION(COEX_OPTION_RHO_ENABLED, PTA_OPT_RHO_ENABLED);
    420          
    421            if (COEX_SetOptions(coexOptions)) {
    422              halPtaOptions = options;
    423              status = EMBER_SUCCESS;
    424            }
    425            return status;
    426          }
    427          #else //!COEX_STACK_EVENT_SUPPORT
    428          

   \                                 In section .text, align 2, keep-with-next
    429          EmberStatus halPtaSetBool(HalPtaOptions option, bool value)
    430          {
    431            UNUSED_VAR(option);
    432            UNUSED_VAR(value);
    433            return EMBER_ERR_FATAL;
   \                     halPtaSetBool: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x4770             BX       LR               ;; return
    434          }
    435          

   \                                 In section .text, align 2, keep-with-next
    436          HalPtaOptions halPtaGetOptions(void)
    437          {
    438            return PTA_OPT_DISABLED;
   \                     halPtaGetOptions: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR               ;; return
    439          }
    440          

   \                                 In section .text, align 2, keep-with-next
    441          EmberStatus halPtaSetOptions(HalPtaOptions options)
    442          {
    443            UNUSED_VAR(options);
    444            return EMBER_ERR_FATAL;
   \                     halPtaSetOptions: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x4770             BX       LR               ;; return
    445          }
    446          #endif //COEX_STACK_EVENT_SUPPORT
    447          
    448          #ifdef BSP_COEX_PRI_PORT
    449          EmberStatus halPtaSetDirectionalPriorityPulseWidth(uint8_t pulseWidthUs)
    450          {
    451            return COEX_HAL_SetDpPulseWidth(pulseWidthUs)
    452                   ? EMBER_SUCCESS : EMBER_ERR_FATAL;
    453          }
    454          
    455          uint8_t halPtaGetDirectionalPriorityPulseWidth(void)
    456          {
    457            return COEX_HAL_GetDpPulseWidth();
    458          }
    459          #else //BSP_COEX_PRI_PORT

   \                                 In section .text, align 2, keep-with-next
    460          EmberStatus halPtaSetDirectionalPriorityPulseWidth(uint8_t pulseWidthUs)
    461          {
    462            UNUSED_VAR(pulseWidthUs);
    463            return EMBER_ERR_FATAL;
   \                     halPtaSetDirectionalPriorityPulseWidth: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x4770             BX       LR               ;; return
    464          }
    465          

   \                                 In section .text, align 2, keep-with-next
    466          uint8_t halPtaGetDirectionalPriorityPulseWidth(void)
    467          {
    468            return 0;
   \                     halPtaGetDirectionalPriorityPulseWidth: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR               ;; return
    469          }
    470          #endif //BSP_COEX_PRI_PORT
    471          
    472          #if     COEX_SUPPORT
    473          static void emCoexCounter(COEX_Events_t events);
    474          static COEX_ReqState_t txReq;
    475          static COEX_ReqState_t rxReq;
    476          
    477          #if     PHY_IS_RAIL_BASED
    478          #include "rail.h"
    479          static EmberStatus cancelTransmit(void)
    480          {
    481            extern RAIL_Handle_t emPhyRailHandle;
    482            return (RAIL_StopTx(emPhyRailHandle, RAIL_STOP_MODE_ACTIVE) == RAIL_STATUS_NO_ERROR)
    483                   ? EMBER_SUCCESS : EMBER_ERR_FATAL;
    484          }
    485          #else//!PHY_IS_RAIL_BASED
    486          static EmberStatus cancelTransmit(void)
    487          {
    488            emPhyCancelTransmit();
    489            return EMBER_SUCCESS;
    490          }
    491          #endif//PHY_IS_RAIL_BASED
    492          
    493          static void coexEventsCb(COEX_Events_t events)
    494          {
    495            if ((events & COEX_EVENT_COEX_CHANGED) != 0U) {
    496              emRadioEnablePta((COEX_GetOptions() & COEX_OPTION_COEX_ENABLED) != 0U);
    497            }
    498            if ((events & COEX_EVENT_GRANT_RELEASED) != 0U
    499                && (COEX_GetOptions() & COEX_OPTION_TX_ABORT) != 0U
    500                && (txReq.coexReq & COEX_REQ_ON) != 0U) {
    501              if (cancelTransmit() == EMBER_SUCCESS) {
    502                events |= COEX_EVENT_TX_ABORTED;
    503              }
    504            }
    505            emCoexCounter(events);
    506          }
    507          
    508          // Certain radios may want to override this with their own
    509          WEAK(void emRadioEnablePta(bool enabled))
    510          {
    511            UNUSED_VAR(enabled);
    512          }
    513          
    514          #define coexCounterType(type) ((events & COEX_EVENT_PRIORITY_ASSERTED) != 0U \
    515                                         ? (EMBER_COUNTER_PTA_HI_PRI_ ## type)         \
    516                                         : (EMBER_COUNTER_PTA_LO_PRI_ ## type))
    517          
    518          #ifdef EMBER_STACK_IP
    519            #define coexCounter(type, data) \
    520            emberCounterHandler(coexCounterType(type), data)
    521          #elif defined(EMBER_STACK_CONNECT)
    522            #define coexCounter(type, data) //no-op
    523          #else // must be EMBER_STACK_ZIGBEE
    524          extern void emCallCounterHandler(EmberCounterType type, uint8_t data);
    525            #define coexCounter(type, data) \
    526            emCallCounterHandler(coexCounterType(type), data)
    527          #endif //EMBER_STACK_IP
    528          
    529          static void emCoexCounter(COEX_Events_t events)
    530          {
    531            if ((events & COEX_EVENT_REQUEST_RELEASED) != 0U) {
    532              coexCounter(REQUESTED, 1);
    533            }
    534            if ((events & COEX_EVENT_REQUEST_DENIED) != 0U) {
    535              coexCounter(DENIED, 1);
    536            } else if ((events & COEX_EVENT_TX_ABORTED) != 0U) {
    537              coexCounter(TX_ABORTED, 1);
    538            } else {
    539              // Request not denied
    540            }
    541          }
    542          
    543          // Certain radios may want to override this with their own
    544          WEAK(void emPhyCancelTransmit(void))
    545          {
    546          }
    547          
    548          #if HAL_COEX_PRIORITY_ESCALATION_ENABLE || defined(DEBUG_PTA)
    549          
    550          static uint8_t ptaCcaFailEscalate = 0U;
    551          static uint8_t ptaMacFailEscalate = 0U;
    552          static bool priorityEscalated = false;
    553          
    554          static void escalatePriority(uint8_t *counter, uint8_t threshold)
    555          {
    556            if (((halPtaGetOptions() & PTA_OPT_TX_HIPRI) == 0U)
    557                && (threshold > 0U)) {
    558              ++(*counter);
    559              if (threshold <= (*counter)) {
    560                priorityEscalated = true;
    561              }
    562            }
    563          }
    564          
    565          static void deescalatePriority(void)
    566          {
    567            if (priorityEscalated) {
    568              ptaCcaFailEscalate = 0U;
    569              ptaMacFailEscalate = 0U;
    570              priorityEscalated = false;
    571            }
    572          }
    573          
    574          #else //!(HAL_COEX_PRIORITY_ESCALATION_ENABLE || defined(DEBUG_PTA))
    575          
    576          #define escalatePriority(counter, threshold)  /* no-op */
    577          #define deescalatePriority()                  /* no-op */
    578          
    579          #endif //HAL_COEX_PRIORITY_ESCALATION_ENABLE || defined(DEBUG_PTA)
    580          
    581          // PTA MAC/PHY Event Handling
    582          
    583          #define PTA_RX_TIMEOUT_US 10000u
    584          #define PTA_RX_RETRY_US (1000u * halPtaGetOptionMask(PTA_OPT_RX_RETRY_TIMEOUT_MS, \
    585                                                               PTA_OPT_SHIFT_RX_RETRY_TIMEOUT_MS))
    586          
    587          #if     USE_MULTITIMER
    588          
    589          static void setTimer(RAIL_MultiTimer_t *timer,
    590                               uint32_t time,
    591                               RAIL_MultiTimerCallback_t cb)
    592          {
    593            if (!RAIL_IsMultiTimerRunning(timer)) {
    594              RAIL_SetMultiTimer(timer,
    595                                 time,
    596                                 RAIL_TIME_DELAY,
    597                                 cb,
    598                                 NULL);
    599            }
    600          }
    601          
    602          static void cancelTimer(RAIL_MultiTimer_t *timer)
    603          {
    604            (void) RAIL_CancelMultiTimer(timer);
    605          }
    606          
    607          static RAIL_MultiTimer_t ptaRxTimer;
    608          static RAIL_MultiTimer_t ptaRxRetryTimer;
    609          
    610          #if HAL_COEX_RUNTIME_PHY_SELECT
    611          static RAIL_MultiTimer_t ptaPhySelectTimer;
    612          static void ptaPhySelectTimerCb(RAIL_MultiTimer_t *tmr,
    613                                          RAIL_Time_t expectedTimeOfEvent,
    614                                          void *cbArg)
    615          {
    616            UNUSED_VAR(tmr);
    617            UNUSED_VAR(expectedTimeOfEvent);
    618            UNUSED_VAR(cbArg);
    619            cancelTimer(&ptaPhySelectTimer);
    620            halCoexNewPhySelectedCoex = false;
    621          }
    622          
    623          static void checkPhySelectTimer(void)
    624          {
    625            if ((COEX_GetOptions() & COEX_OPTION_PHY_SELECT) != 0U) {
    626              RAIL_CancelMultiTimer(&ptaPhySelectTimer);
    627              halCoexNewPhySelectedCoex = true;
    628            } else {
    629              setTimer(&ptaPhySelectTimer, phySelectTimeoutMs, &ptaPhySelectTimerCb);
    630            }
    631          }
    632          #endif //HAL_COEX_RUNTIME_PHY_SELECT
    633          
    634          static void ptaRxTimerCb(RAIL_MultiTimer_t *tmr,
    635                                   RAIL_Time_t expectedTimeOfEvent,
    636                                   void *cbArg)
    637          {
    638            UNUSED_VAR(tmr);
    639            UNUSED_VAR(expectedTimeOfEvent);
    640            UNUSED_VAR(cbArg);
    641            cancelTimer(&ptaRxTimer);
    642            cancelTimer(&ptaRxRetryTimer);
    643            (void) halPtaSetRxRequest(PTA_REQ_OFF, NULL);
    644          }
    645          
    646          // Both timers do the same thing, and cancel each other
    647          #define ptaRxRetryTimerCb ptaRxTimerCb
    648          
    649          #define checkTimers() /*no-op*/
    650          
    651          #else//!USE_MULTITIMER
    652          
    653          static void setTimer(int32_t *timer, uint32_t time, uint16_t *timeout)
    654          {
    655            *timer = -1;
    656            *timeout = (uint16_t) (time / 1000u); // Micro to milliseconds
    657            *timer = (int32_t) halCommonGetInt16uMillisecondTick();
    658          }
    659          
    660          static void cancelTimer(int32_t *timer)
    661          {
    662            *timer = -1;
    663          }
    664          
    665          static int32_t ptaRxTimer = -1;
    666          static uint16_t ptaRxTimerCb = 0;
    667          static int32_t ptaRxRetryTimer = -1;
    668          static uint16_t ptaRxRetryTimerCb = 0;
    669          
    670          static bool isPtaTimerExpired(int32_t timerMs, uint16_t timeoutMs)
    671          {
    672            return (timerMs >= 0)
    673                   && (elapsedTimeInt16u((uint16_t)timerMs,
    674                                         halCommonGetInt16uMillisecondTick()) > timeoutMs);
    675          }
    676          
    677          static void checkTimers(void)
    678          {
    679            if (isPtaTimerExpired(ptaRxTimer, ptaRxTimerCb)
    680                || isPtaTimerExpired(ptaRxRetryTimer, ptaRxRetryTimerCb)) {
    681              // Both timers do the same thing, and cancel each other
    682              cancelTimer(&ptaRxTimer);
    683              cancelTimer(&ptaRxRetryTimer);
    684              (void) halPtaSetRxRequest(PTA_REQ_OFF, NULL);
    685            }
    686          }
    687          
    688          #endif//USE_MULTITIMER
    689          
    690          halPtaStackStatus_t halPtaStackEvent(halPtaStackEvent_t ptaStackEvent,
    691                                               uint32_t supplement)
    692          {
    693            halPtaStackStatus_t status = PTA_STACK_STATUS_SUCCESS;
    694            bool isReceivingFrame = false;
    695          
    696            switch (ptaStackEvent) {
    697              case PTA_STACK_EVENT_TICK:
    698                if (halPtaIsEnabled()) {
    699                  checkTimers();
    700                }
    701                (void) checkPhySwitch();
    702                break;
    703          
    704              // RX events:
    705              case PTA_STACK_EVENT_RX_STARTED:
    706                if (halPtaIsEnabled()) {
    707                  isReceivingFrame = (bool) supplement;
    708                  if (isReceivingFrame) {
    709                    (void) halPtaSetRxRequest(halPtaFrameDetectReq(), NULL);
    710                    cancelTimer(&ptaRxRetryTimer);
    711                    setTimer(&ptaRxTimer, PTA_RX_TIMEOUT_US, &ptaRxTimerCb);
    712                  }
    713                }
    714                setBlockPhySwitch(BLOCK_SWITCH_RX, true);
    715                break;
    716          
    717              case PTA_STACK_EVENT_RX_ACCEPTED:
    718                if (halPtaIsEnabled()) {
    719                  isReceivingFrame = (bool) supplement;
    720                  if (isReceivingFrame) {
    721                    halPtaReq_t filterPass = halPtaFilterPassReq();
    722                    if (filterPass != halPtaFrameDetectReq()) {
    723                      (void) halPtaSetRxRequest(filterPass, NULL);
    724                    }
    725                  }
    726                }
    727                setBlockPhySwitch(BLOCK_SWITCH_RX, true);
    728                break;
    729          
    730              case PTA_STACK_EVENT_RX_ACKING:
    731                // Defer Rx PTA cancellation to RX_ACK_* events
    732                setBlockPhySwitch(BLOCK_SWITCH_RX, true);
    733                break;
    734          
    735              case PTA_STACK_EVENT_RX_CORRUPTED:
    736              case PTA_STACK_EVENT_RX_ACK_BLOCKED:
    737              case PTA_STACK_EVENT_RX_ACK_ABORTED:
    738                if (halPtaIsEnabled()) {
    739                  if ((halPtaGetOptions() & PTA_OPT_RX_RETRY_REQ) != 0U) {
    740                    cancelTimer(&ptaRxTimer);
    741                    // Assert request and start rx retry timer.
    742                    (void) halPtaSetRxRequest(PTA_REQ_ON | PTA_RX_RETRY_PRI, NULL);
    743                    setTimer(&ptaRxRetryTimer, PTA_RX_RETRY_US, &ptaRxRetryTimerCb);
    744                    break;
    745                  }
    746                }
    747              // FALLTHROUGH
    748          
    749              case PTA_STACK_EVENT_RX_FILTERED:
    750              case PTA_STACK_EVENT_RX_ENDED:
    751              case PTA_STACK_EVENT_RX_ACK_SENT:
    752                isReceivingFrame = (bool) supplement;
    753              // FALLTHROUGH
    754          
    755              case PTA_STACK_EVENT_RX_IDLED:
    756                if (halPtaIsEnabled()) {
    757                  cancelTimer(&ptaRxTimer);
    758                  cancelTimer(&ptaRxRetryTimer);
    759                  if (!isReceivingFrame) {
    760                    (void) halPtaSetRxRequest(PTA_REQ_OFF, NULL);
    761                  }
    762                }
    763                setBlockPhySwitch(BLOCK_SWITCH_RX, isReceivingFrame);
    764                break;
    765          
    766              // TX events:
    767              case PTA_STACK_EVENT_TX_PENDED_MAC:
    768                if (halPtaIsEnabled()) {
    769                  halPtaCb_t cb = (halPtaCb_t) supplement;
    770                  HalPtaOptions ptaOptions = halPtaGetOptions();
    771                  if ((ptaOptions & PTA_OPT_MAC_AND_FORCE_HOLDOFFS) == PTA_OPT_MAC_AND_FORCE_HOLDOFFS) {
    772                    // Tell caller NOT to transmit
    773                    status = PTA_STACK_STATUS_HOLDOFF;
    774                  } else if (((ptaOptions & PTA_OPT_MAC_AND_FORCE_HOLDOFFS) == PTA_OPT_MAC_HOLDOFF)
    775                             && (cb != NULL)) {
    776                    // Assert Tx REQUEST  and wait for GRANT
    777                    halPtaSetTxRequest(PTA_REQ_ON | PTA_TX_PRI | PTA_REQCB_GRANTED, cb);
    778                    status = PTA_STACK_STATUS_CB_PENDING;
    779                  } else {
    780                    // No callback - proceed with a normal transmit
    781                  }
    782                }
    783                break;
    784          
    785              case PTA_STACK_EVENT_TX_PENDED_PHY:
    786                if (halPtaIsEnabled()) {
    787                  bool isCcaTransmit = (bool) supplement;
    788                  if (isCcaTransmit && ((halPtaGetOptions() & PTA_OPT_LONG_REQ) == 0U)) {
    789                    // Defer Tx req to CCA_SOON event
    790                  } else {
    791                    halPtaSetTxRequest(PTA_REQ_ON | PTA_TX_PRI, NULL);
    792                  }
    793                }
    794                setBlockPhySwitch(BLOCK_SWITCH_TX, true);
    795                break;
    796          
    797              case PTA_STACK_EVENT_TX_CCA_SOON:
    798                if (halPtaIsEnabled()) {
    799                  (void) halPtaSetTxRequest(PTA_REQ_ON | PTA_TX_PRI, NULL);
    800                }
    801                break;
    802          
    803              case PTA_STACK_EVENT_TX_CCA_BUSY:
    804                if (halPtaIsEnabled()) {
    805                  bool isNextCcaImminent = (bool) supplement;
    806                  if (!isNextCcaImminent) {
    807                    (void) halPtaSetTxRequest(PTA_REQ_OFF, NULL);
    808                  }
    809                }
    810                break;
    811          
    812              case PTA_STACK_EVENT_TX_STARTED:
    813              case PTA_STACK_EVENT_TX_ACK_WAITING:
    814                // Currently these events are advisory and leave TX REQ asserted
    815                break;
    816          
    817              case PTA_STACK_EVENT_TX_ACK_RECEIVED:
    818                if (halPtaIsEnabled()) {
    819                  bool hasFramePending = (bool) supplement;
    820                  (void) hasFramePending;
    821                  (void) halPtaSetTxRequest(PTA_REQ_OFF, NULL);
    822                  deescalatePriority();
    823                }
    824                setBlockPhySwitch(BLOCK_SWITCH_TX, false);
    825                break;
    826          
    827              case PTA_STACK_EVENT_TX_ACK_TIMEDOUT:
    828                if (halPtaIsEnabled()) {
    829                  uint8_t macRetries = (uint8_t) supplement;
    830                  if ((macRetries == 0) || halPtaGetTxReqRelease()) {
    831                    (void) halPtaSetTxRequest(PTA_REQ_OFF, NULL);
    832                    if (macRetries == 0) {
    833                      escalatePriority(&ptaMacFailEscalate,
    834                                       halPtaGetMacFailCounterThreshold());
    835                    }
    836                  } else {
    837                    // Hold Tx REQ for a MAC retransmit
    838                  }
    839                }
    840                setBlockPhySwitch(BLOCK_SWITCH_TX, false);
    841                break;
    842          
    843              case PTA_STACK_EVENT_TX_BLOCKED:
    844              case PTA_STACK_EVENT_TX_ABORTED:
    845                if (halPtaIsEnabled()) {
    846                  (void) halPtaSetTxRequest(PTA_REQ_OFF, NULL);
    847                  bool pktRequestedAck = (bool) supplement;
    848                  if (pktRequestedAck) {
    849                    if (ptaStackEvent == PTA_STACK_EVENT_TX_BLOCKED) {
    850                      escalatePriority(&ptaCcaFailEscalate,
    851                                       halPtaGetCcaCounterThreshold());
    852                    }
    853                    escalatePriority(&ptaMacFailEscalate,
    854                                     halPtaGetMacFailCounterThreshold());
    855                  }
    856                }
    857                setBlockPhySwitch(BLOCK_SWITCH_TX, false);
    858                break;
    859          
    860              case PTA_STACK_EVENT_TX_ENDED:
    861              case PTA_STACK_EVENT_TX_IDLED:
    862                if (halPtaIsEnabled()) {
    863                  (void) halPtaSetTxRequest(PTA_REQ_OFF, NULL);
    864                }
    865                setBlockPhySwitch(BLOCK_SWITCH_TX, false);
    866                break;
    867          
    868              default:
    869                break;
    870            }
    871            #if EMBER_AF_PLUGIN_COULOMB_COUNTER
    872            // Set the state w.r.t Coulomb Counter
    873            halCoulombCounterEvent(ptaStackEvent);
    874            #endif
    875            return status;
    876          }
    877          
    878          static void randomDelayCallback(uint16_t randomDelayMaskUs)
    879          {
    880            halCommonDelayMicroseconds(halCommonGetRandom() & randomDelayMaskUs);
    881          }
    882          static void configRandomDelay(void)
    883          {
    884            COEX_SetRandomDelayCallback(&randomDelayCallback);
    885          }
    886          
    887          static EmberStatus halInternalPtaSetRequest(COEX_ReqState_t *coexReqState,
    888                                                      COEX_Req_t coexReq,
    889                                                      COEX_ReqCb_t coexCb)
    890          {
    891            // if force holdoff is enabled, don't set request
    892            return (((halPtaOptions & PTA_OPT_FORCE_HOLDOFF) == 0U)
    893                    && COEX_SetRequest(coexReqState, coexReq, coexCb))
    894                   ? EMBER_SUCCESS : EMBER_ERR_FATAL;
    895          }
    896          
    897          halPtaReq_t halPtaFrameDetectReq(void)
    898          {
    899            HalPtaOptions options = halPtaGetOptions();
    900            halPtaReq_t syncDet = PTA_REQ_OFF;
    901            if (halPtaIsEnabled() && (options & PTA_OPT_REQ_FILTER_PASS) == 0) {
    902              syncDet |= PTA_REQ_ON;
    903              if ((options & PTA_OPT_RX_HIPRI) != 0U) {
    904                syncDet |= PTA_REQ_HIPRI;
    905              }
    906            }
    907            return syncDet;
    908          }
    909          
    910          halPtaReq_t halPtaFilterPassReq(void)
    911          {
    912            HalPtaOptions options = halPtaGetOptions();
    913            halPtaReq_t filterPass = PTA_REQ_OFF;
    914            if (halPtaIsEnabled()) {
    915              filterPass |= PTA_REQ_ON;
    916              if (options & (PTA_OPT_RX_HIPRI | PTA_OPT_HIPRI_FILTER_PASS)) {
    917                filterPass |= PTA_REQ_HIPRI;
    918              }
    919            }
    920            return filterPass;
    921          }
    922          
    923          EmberStatus halPtaSetTxRequest(COEX_Req_t coexReq, COEX_ReqCb_t coexCb)
    924          {
    925          #if HAL_COEX_PRIORITY_ESCALATION_ENABLE || defined(DEBUG_PTA)
    926            if (((coexReq & COEX_REQ_ON) != 0U) && priorityEscalated) {
    927              coexReq |= COEX_REQ_HIPRI;
    928            }
    929          #endif // HAL_COEX_PRIORITY_ESCALATION_ENABLE || defined(DEBUG_PTA)
    930            return halInternalPtaSetRequest(&txReq, coexReq, coexCb);
    931          }
    932          
    933          EmberStatus halPtaSetRxRequest(COEX_Req_t coexReq, COEX_ReqCb_t coexCb)
    934          {
    935            return halInternalPtaSetRequest(&rxReq, coexReq, coexCb);
    936          }
    937          
    938          EmberStatus halPtaSetEnable(bool enabled)
    939          {
    940            COEX_Options_t coexOptions = COEX_GetOptions();
    941          
    942            if (enabled) {
    943              coexOptions |= COEX_OPTION_COEX_ENABLED;
    944            } else {
    945              coexOptions &= ~COEX_OPTION_COEX_ENABLED;
    946            }
    947            return COEX_SetOptions(coexOptions)
    948                   ? EMBER_SUCCESS : EMBER_ERR_FATAL;
    949          }
    950          
    951          bool halPtaIsEnabled(void)
    952          {
    953            return (COEX_GetOptions() & COEX_OPTION_COEX_ENABLED) != 0U;
    954          }
    955          
    956          #else // !COEX_REQ_SUPPORT
    957          #if COEX_RHO_SUPPORT
    958          static void configRandomDelay(void)
    959          {
    960          }
    961          static void coexEventsCb(COEX_Events_t events)
    962          {
    963            UNUSED_VAR(events);
    964          }
    965          #endif //!COEX_RHO_SUPPORT
    966          

   \                                 In section .text, align 2, keep-with-next
    967          halPtaReq_t halPtaFrameDetectReq(void)
    968          {
    969            return PTA_REQ_OFF;
   \                     halPtaFrameDetectReq: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR               ;; return
    970          }
    971          

   \                                 In section .text, align 2, keep-with-next
    972          halPtaReq_t halPtaFilterPassReq(void)
    973          {
    974            return PTA_REQ_OFF;
   \                     halPtaFilterPassReq: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR               ;; return
    975          }
    976          

   \                                 In section .text, align 2, keep-with-next
    977          EmberStatus halPtaSetTxRequest(COEX_Req_t coexReq, COEX_ReqCb_t coexCb)
    978          {
    979            UNUSED_VAR(coexReq);
    980            UNUSED_VAR(coexCb);
    981            return EMBER_ERR_FATAL;
   \                     halPtaSetTxRequest: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x4770             BX       LR               ;; return
    982          }
    983          

   \                                 In section .text, align 2, keep-with-next
    984          EmberStatus halPtaSetRxRequest(COEX_Req_t coexReq, COEX_ReqCb_t coexCb)
    985          {
    986            UNUSED_VAR(coexReq);
    987            UNUSED_VAR(coexCb);
    988            return EMBER_ERR_FATAL;
   \                     halPtaSetRxRequest: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x4770             BX       LR               ;; return
    989          }
    990          

   \                                 In section .text, align 2, keep-with-next
    991          EmberStatus halPtaSetEnable(bool enabled)
    992          {
    993            UNUSED_VAR(enabled);
    994            return EMBER_ERR_FATAL;
   \                     halPtaSetEnable: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x4770             BX       LR               ;; return
    995          }
    996          

   \                                 In section .text, align 2, keep-with-next
    997          bool halPtaIsEnabled(void)
    998          {
    999            return false;
   \                     halPtaIsEnabled: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR               ;; return
   1000          }
   1001          

   \                                 In section .text, align 2, keep-with-next
   1002          halPtaStackStatus_t halPtaStackEvent(halPtaStackEvent_t ptaStackEvent,
   1003                                               uint32_t supplement)
   1004          {
   1005            UNUSED_VAR(supplement);
   1006            UNUSED_VAR(ptaStackEvent);
   1007           #if RUNTIME_PHY_SELECT
   1008            switch (ptaStackEvent) {
   1009              case PTA_STACK_EVENT_TICK:
   1010                (void) checkPhySwitch();
   1011                break;
   1012          
   1013              // RX events:
   1014              case PTA_STACK_EVENT_RX_STARTED:
   1015              case PTA_STACK_EVENT_RX_ACCEPTED:
   1016              case PTA_STACK_EVENT_RX_ACKING:
   1017                setBlockPhySwitch(BLOCK_SWITCH_RX, true);
   1018                break;
   1019              case PTA_STACK_EVENT_RX_CORRUPTED:
   1020              case PTA_STACK_EVENT_RX_ACK_BLOCKED:
   1021              case PTA_STACK_EVENT_RX_ACK_ABORTED:
   1022              case PTA_STACK_EVENT_RX_FILTERED:
   1023              case PTA_STACK_EVENT_RX_ENDED:
   1024              case PTA_STACK_EVENT_RX_ACK_SENT:
   1025                isReceivingFrame = (bool) supplement;
   1026              // FALLTHROUGH
   1027              case PTA_STACK_EVENT_RX_IDLED:
   1028                setBlockPhySwitch(BLOCK_SWITCH_RX, isReceivingFrame);
   1029                break;
   1030          
   1031              // TX events:
   1032              case PTA_STACK_EVENT_TX_PENDED_MAC:
   1033                break;
   1034              case PTA_STACK_EVENT_TX_PENDED_PHY:
   1035                setBlockPhySwitch(BLOCK_SWITCH_TX, true);
   1036                break;
   1037              case PTA_STACK_EVENT_TX_CCA_SOON:
   1038              case PTA_STACK_EVENT_TX_CCA_BUSY:
   1039              case PTA_STACK_EVENT_TX_STARTED:
   1040              case PTA_STACK_EVENT_TX_ACK_WAITING:
   1041                break;
   1042              case PTA_STACK_EVENT_TX_ACK_RECEIVED:
   1043              case PTA_STACK_EVENT_TX_ACK_TIMEDOUT:
   1044              case PTA_STACK_EVENT_TX_BLOCKED:
   1045              case PTA_STACK_EVENT_TX_ABORTED:
   1046              case PTA_STACK_EVENT_TX_ENDED:
   1047              case PTA_STACK_EVENT_TX_IDLED:
   1048                setBlockPhySwitch(BLOCK_SWITCH_TX, false);
   1049                break;
   1050              default:
   1051                break;
   1052            }
   1053           #endif//RUNTIME_PHY_SELECT
   1054          
   1055           #ifdef EMBER_AF_PLUGIN_COULOMB_COUNTER
   1056            // Set the state w.r.t Coulomb Counter
   1057            halCoulombCounterEvent(ptaStackEvent);
   1058           #endif//EMBER_AF_PLUGIN_COULOMB_COUNTER
   1059          
   1060            return PTA_STACK_STATUS_SUCCESS;
   \                     halPtaStackEvent: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR               ;; return
   1061          }
   1062          #endif//COEX_SUPPORT
   1063          
   1064          #if     USE_MULTITIMER && COEX_SUPPORT
   1065          static COEX_ReqState_t pwmReq;
   1066          static RAIL_MultiTimer_t pwmRequestTimer;
   1067          static COEX_ReqCb_t pwmReqCb;
   1068          static bool pwmIsAsserted;
   1069          static HalPtaPwmArgs_t pwmArgs;
   1070          static uint32_t pwmOnUs;
   1071          static uint32_t pwmOffUs;
   1072          
   1073          const HalPtaPwmArgs_t *halPtaGetRequestPwmArgs(void)
   1074          {
   1075            return &pwmArgs;
   1076          }
   1077          
   1078          static void pwmRequestTimerCb(RAIL_MultiTimer_t *tmr,
   1079                                        RAIL_Time_t expectedTimeOfEvent,
   1080                                        void *cbArg)
   1081          {
   1082            UNUSED_VAR(expectedTimeOfEvent);
   1083            UNUSED_VAR(cbArg);
   1084            RAIL_Time_t delay;
   1085            COEX_Req_t coexReq;
   1086          
   1087            if (pwmIsAsserted) {
   1088              coexReq = PTA_REQ_OFF;
   1089              delay = pwmOffUs;
   1090            } else {
   1091              coexReq = pwmArgs.req;
   1092              delay = pwmOnUs;
   1093            }
   1094            halInternalPtaSetRequest(&pwmReq, coexReq, pwmReqCb);
   1095            pwmIsAsserted = !pwmIsAsserted;
   1096            RAIL_SetMultiTimer(tmr,
   1097                               delay,
   1098                               RAIL_TIME_DELAY,
   1099                               &pwmRequestTimerCb,
   1100                               NULL);
   1101          }
   1102          
   1103          // (dutyCycle/100{percent})*(periodHalfMs/2)*1000{milliseconds/microseconds}
   1104          #define DUTY_CYCLE_TO_US (1000 / 100 / 2)
   1105          
   1106          EmberStatus halPtaSetRequestPwm(halPtaReq_t ptaReq,
   1107                                          halPtaCb_t ptaCb,
   1108                                          uint8_t dutyCycle,
   1109                                          uint8_t periodHalfMs)
   1110          {
   1111            if (dutyCycle > 100) {
   1112              return EMBER_BAD_ARGUMENT;
   1113            }
   1114            pwmArgs.dutyCycle = dutyCycle;
   1115            pwmArgs.periodHalfMs = periodHalfMs;
   1116            pwmArgs.req = ptaReq;
   1117            if (periodHalfMs == 0 || dutyCycle == 0 || ptaReq == PTA_REQ_OFF) {
   1118              RAIL_CancelMultiTimer(&pwmRequestTimer);
   1119              halInternalPtaSetRequest(&pwmReq, PTA_REQ_OFF, ptaCb);
   1120            } else if (dutyCycle == 100) {
   1121              RAIL_CancelMultiTimer(&pwmRequestTimer);
   1122              halInternalPtaSetRequest(&pwmReq, pwmArgs.req, ptaCb);
   1123            } else {
   1124              pwmReqCb = ptaCb;
   1125              pwmIsAsserted = false;
   1126              pwmOnUs = dutyCycle * periodHalfMs * DUTY_CYCLE_TO_US;
   1127              pwmOffUs = (100 - dutyCycle) * periodHalfMs * DUTY_CYCLE_TO_US;
   1128              pwmRequestTimerCb(&pwmRequestTimer, 0, NULL);
   1129            }
   1130            return EMBER_SUCCESS;
   1131          }
   1132          
   1133          #else//!(USE_MULTITIMER && COEX_SUPPORT)
   1134          

   \                                 In section .text, align 2, keep-with-next
   1135          EmberStatus halPtaSetRequestPwm(halPtaReq_t ptaReq,
   1136                                          halPtaCb_t ptaCb,
   1137                                          uint8_t dutyCycle,
   1138                                          uint8_t periodHalfMs)
   1139          {
   1140            UNUSED_VAR(ptaReq);
   1141            UNUSED_VAR(ptaCb);
   1142            UNUSED_VAR(dutyCycle);
   1143            UNUSED_VAR(periodHalfMs);
   1144            return EMBER_ERR_FATAL;
   \                     halPtaSetRequestPwm: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x4770             BX       LR               ;; return
   1145          }
   1146          

   \                                 In section .text, align 2, keep-with-next
   1147          const HalPtaPwmArgs_t *halPtaGetRequestPwmArgs(void)
   1148          {
   1149            return NULL;
   \                     halPtaGetRequestPwmArgs: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR               ;; return
   1150          }
   1151          
   1152          #endif//(USE_MULTITIMER && COEX_SUPPORT)
   1153          
   1154          #if     COEX_RHO_SUPPORT
   1155          
   1156          bool halGetRadioHoldOff(void)
   1157          {
   1158            return (COEX_GetOptions() & COEX_OPTION_RHO_ENABLED) != 0U;
   1159          }
   1160          
   1161          EmberStatus halSetRadioHoldOff(bool enabled)
   1162          {
   1163            return halPtaSetBool(PTA_OPT_RHO_ENABLED, enabled);
   1164          }
   1165          
   1166          void halStackRadioHoldOffPowerDown(void)
   1167          {
   1168            setCoexPowerState(false);
   1169          }
   1170          
   1171          void halStackRadioHoldOffPowerUp(void)
   1172          {
   1173            setCoexPowerState(true);
   1174          }
   1175          
   1176          #else//!COEX_RHO_SUPPORT
   1177          
   1178          // Stub RHO implementation
   1179          

   \                                 In section .text, align 2, keep-with-next
   1180          bool halGetRadioHoldOff(void)
   1181          {
   1182            return false;
   \                     halGetRadioHoldOff: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR               ;; return
   1183          }
   1184          

   \                                 In section .text, align 2, keep-with-next
   1185          EmberStatus halSetRadioHoldOff(bool enabled)
   1186          {
   1187            UNUSED_VAR(enabled);
   1188            return EMBER_ERR_FATAL;
   \                     halSetRadioHoldOff: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x4770             BX       LR               ;; return
   1189          }
   1190          

   \                                 In section .text, align 2, keep-with-next
   1191          void halStackRadioHoldOffPowerDown(void)
   1192          {
   1193          }
   \                     halStackRadioHoldOffPowerDown: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1194          

   \                                 In section .text, align 2, keep-with-next
   1195          void halStackRadioHoldOffPowerUp(void)
   1196          {
   1197          }
   \                     halStackRadioHoldOffPowerUp: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1198          
   1199          #endif//COEX_RHO_SUPPORT
   1200          

   \                                 In section .text, align 2, keep-with-next
   1201          EmberStatus halPtaSetPhySelectTimeout(uint8_t timeoutMs)
   1202          {
   1203          #if HAL_COEX_RUNTIME_PHY_SELECT
   1204            if (phySelectTimeoutMs != timeoutMs) {
   1205              phySelectTimeoutMs = timeoutMs;
   1206              if (timeoutMs == 0U) {
   1207                RAIL_CancelMultiTimer(&ptaPhySelectTimer);
   1208                halCoexNewPhySelectedCoex = false;
   1209              } else if (timeoutMs == PTA_PHY_SELECT_TIMEOUT_MAX) {
   1210                RAIL_CancelMultiTimer(&ptaPhySelectTimer);
   1211                halCoexNewPhySelectedCoex = true;
   1212              } else {
   1213          #ifdef BSP_COEX_PHY_SELECT_PORT
   1214                return EMBER_SUCCESS;
   1215          #else //!BSP_COEX_PHY_SELECT_PORT
   1216                return EMBER_BAD_ARGUMENT;
   1217          #endif //BSP_COEX_PHY_SELECT_PORT
   1218              }
   1219            }
   1220            return EMBER_SUCCESS;
   1221          #else //HAL_COEX_PHY_ENABLED
   1222            return (timeoutMs == phySelectTimeoutMs) ? EMBER_SUCCESS : EMBER_BAD_ARGUMENT;
   \                     halPtaSetPhySelectTimeout: (+1)
   \        0x0   0xB100             CBZ.N    R0,??halPtaSetPhySelectTimeout_0
   \        0x2   0x2002             MOVS     R0,#+2
   \                     ??halPtaSetPhySelectTimeout_0: (+1)
   \        0x4   0x4770             BX       LR               ;; return
   1223          #endif //HAL_COEX_RUNTIME_PHY_SELECT
   1224          }
   1225          

   \                                 In section .text, align 2, keep-with-next
   1226          uint8_t halPtaGetPhySelectTimeout(void)
   1227          {
   1228            return phySelectTimeoutMs;
   \                     halPtaGetPhySelectTimeout: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR               ;; return
   1229          }
   1230          
   1231          #if HAL_COEX_OVERRIDE_GPIO_INPUT
   1232          bool halPtaGetGpioInputOverride(halPtaGpioIndex_t gpioIndex)
   1233          {
   1234            return COEX_GetGpioInputOverride((COEX_GpioIndex_t)(gpioIndex + 1));
   1235          }
   1236          
   1237          EmberStatus halPtaSetGpioInputOverride(halPtaGpioIndex_t gpioIndex,
   1238                                                 bool enabled)
   1239          {
   1240            return COEX_SetGpioInputOverride((COEX_GpioIndex_t)(gpioIndex + 1), enabled)
   1241                   ? EMBER_SUCCESS : EMBER_BAD_ARGUMENT;
   1242          }
   1243          #else //!HAL_COEX_OVERRIDE_GPIO_INPUT

   \                                 In section .text, align 2, keep-with-next
   1244          bool halPtaGetGpioInputOverride(halPtaGpioIndex_t gpioIndex)
   1245          {
   1246            UNUSED_VAR(gpioIndex);
   1247            return false;
   \                     halPtaGetGpioInputOverride: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x4770             BX       LR               ;; return
   1248          }
   1249          

   \                                 In section .text, align 2, keep-with-next
   1250          EmberStatus halPtaSetGpioInputOverride(halPtaGpioIndex_t gpioIndex,
   1251                                                 bool enabled)
   1252          {
   1253            UNUSED_VAR(gpioIndex);
   1254            UNUSED_VAR(enabled);
   1255            return EMBER_ERR_FATAL;
   \                     halPtaSetGpioInputOverride: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x4770             BX       LR               ;; return
   1256          }
   1257          #endif //HAL_COEX_OVERRIDE_GPIO_INPUT

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   halGetRadioHoldOff
       0   halPtaFilterPassReq
       0   halPtaFrameDetectReq
       0   halPtaGetDirectionalPriorityPulseWidth
       0   halPtaGetGpioInputOverride
       0   halPtaGetOptions
       0   halPtaGetPhySelectTimeout
       0   halPtaGetRequestPwmArgs
       0   halPtaIsEnabled
       0   halPtaSetBool
       0   halPtaSetDirectionalPriorityPulseWidth
       0   halPtaSetEnable
       0   halPtaSetGpioInputOverride
       0   halPtaSetOptions
       0   halPtaSetPhySelectTimeout
       0   halPtaSetRequestPwm
       0   halPtaSetRxRequest
       0   halPtaSetTxRequest
       0   halPtaStackEvent
       0   halSetRadioHoldOff
       0   halStackRadioHoldOffPowerDown
       0   halStackRadioHoldOffPowerUp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  halGetRadioHoldOff
       4  halPtaFilterPassReq
       4  halPtaFrameDetectReq
       4  halPtaGetDirectionalPriorityPulseWidth
       4  halPtaGetGpioInputOverride
       4  halPtaGetOptions
       4  halPtaGetPhySelectTimeout
       4  halPtaGetRequestPwmArgs
       4  halPtaIsEnabled
       4  halPtaSetBool
       4  halPtaSetDirectionalPriorityPulseWidth
       4  halPtaSetEnable
       4  halPtaSetGpioInputOverride
       4  halPtaSetOptions
       6  halPtaSetPhySelectTimeout
       4  halPtaSetRequestPwm
       4  halPtaSetRxRequest
       4  halPtaSetTxRequest
       4  halPtaStackEvent
       4  halSetRadioHoldOff
       2  halStackRadioHoldOffPowerDown
       2  halStackRadioHoldOffPowerUp
       1  phySelectTimeoutMs

 
  1 byte  in section .bss
 86 bytes in section .text
 
 86 bytes of CODE memory
  1 byte  of DATA memory

Errors: none
Warnings: none
