###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:24
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\camellia.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EWE7D8.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\camellia.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"camellia.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0
#        -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\camellia.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\camellia.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\camellia.c
      1          /***************************************************************************//**
      2           * # License
      3           *
      4           * The licensor of this software is Silicon Laboratories Inc. Your use of this
      5           * software is governed by the terms of Silicon Labs Master Software License
      6           * Agreement (MSLA) available at
      7           * www.silabs.com/about-us/legal/master-software-license-agreement. This
      8           * software is Third Party Software licensed by Silicon Labs from a third party
      9           * and is governed by the sections of the MSLA applicable to Third Party
     10           * Software and the additional terms set forth below.
     11           *
     12           ******************************************************************************/
     13          /*
     14           *  Camellia implementation
     15           *
     16           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
     17           *  SPDX-License-Identifier: Apache-2.0
     18           *
     19           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
     20           *  not use this file except in compliance with the License.
     21           *  You may obtain a copy of the License at
     22           *
     23           *  http://www.apache.org/licenses/LICENSE-2.0
     24           *
     25           *  Unless required by applicable law or agreed to in writing, software
     26           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     27           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     28           *  See the License for the specific language governing permissions and
     29           *  limitations under the License.
     30           *
     31           *  This file is part of mbed TLS (https://tls.mbed.org)
     32           */
     33          /*
     34           *  The Camellia block cipher was designed by NTT and Mitsubishi Electric
     35           *  Corporation.
     36           *
     37           *  http://info.isl.ntt.co.jp/crypt/eng/camellia/dl/01espec.pdf
     38           */
     39          
     40          #if !defined(MBEDTLS_CONFIG_FILE)
     41          #include "mbedtls/config.h"
     42          #else
     43          #include MBEDTLS_CONFIG_FILE
     44          #endif
     45          
     46          #if defined(MBEDTLS_CAMELLIA_C)
     47          
     48          #include "mbedtls/camellia.h"
     49          
     50          #include <string.h>
     51          
     52          #if defined(MBEDTLS_SELF_TEST)
     53          #if defined(MBEDTLS_PLATFORM_C)
     54          #include "mbedtls/platform.h"
     55          #else
     56          #include <stdio.h>
     57          #define mbedtls_printf printf
     58          #endif /* MBEDTLS_PLATFORM_C */
     59          #endif /* MBEDTLS_SELF_TEST */
     60          
     61          #if !defined(MBEDTLS_CAMELLIA_ALT)
     62          
     63          /* Implementation that should never be optimized out by the compiler */
     64          static void mbedtls_zeroize( void *v, size_t n ) {
     65              volatile unsigned char *p = (unsigned char*)v; while( n-- ) *p++ = 0;
     66          }
     67          
     68          /*
     69           * 32-bit integer manipulation macros (big endian)
     70           */
     71          #ifndef GET_UINT32_BE
     72          #define GET_UINT32_BE(n,b,i)                            \
     73          {                                                       \
     74              (n) = ( (uint32_t) (b)[(i)    ] << 24 )             \
     75                  | ( (uint32_t) (b)[(i) + 1] << 16 )             \
     76                  | ( (uint32_t) (b)[(i) + 2] <<  8 )             \
     77                  | ( (uint32_t) (b)[(i) + 3]       );            \
     78          }
     79          #endif
     80          
     81          #ifndef PUT_UINT32_BE
     82          #define PUT_UINT32_BE(n,b,i)                            \
     83          {                                                       \
     84              (b)[(i)    ] = (unsigned char) ( (n) >> 24 );       \
     85              (b)[(i) + 1] = (unsigned char) ( (n) >> 16 );       \
     86              (b)[(i) + 2] = (unsigned char) ( (n) >>  8 );       \
     87              (b)[(i) + 3] = (unsigned char) ( (n)       );       \
     88          }
     89          #endif
     90          
     91          static const unsigned char SIGMA_CHARS[6][8] =
     92          {
     93              { 0xa0, 0x9e, 0x66, 0x7f, 0x3b, 0xcc, 0x90, 0x8b },
     94              { 0xb6, 0x7a, 0xe8, 0x58, 0x4c, 0xaa, 0x73, 0xb2 },
     95              { 0xc6, 0xef, 0x37, 0x2f, 0xe9, 0x4f, 0x82, 0xbe },
     96              { 0x54, 0xff, 0x53, 0xa5, 0xf1, 0xd3, 0x6f, 0x1c },
     97              { 0x10, 0xe5, 0x27, 0xfa, 0xde, 0x68, 0x2d, 0x1d },
     98              { 0xb0, 0x56, 0x88, 0xc2, 0xb3, 0xe6, 0xc1, 0xfd }
     99          };
    100          
    101          #if defined(MBEDTLS_CAMELLIA_SMALL_MEMORY)
    102          
    103          static const unsigned char FSb[256] =
    104          {
    105              112,130, 44,236,179, 39,192,229,228,133, 87, 53,234, 12,174, 65,
    106               35,239,107,147, 69, 25,165, 33,237, 14, 79, 78, 29,101,146,189,
    107              134,184,175,143,124,235, 31,206, 62, 48,220, 95, 94,197, 11, 26,
    108              166,225, 57,202,213, 71, 93, 61,217,  1, 90,214, 81, 86,108, 77,
    109              139, 13,154,102,251,204,176, 45,116, 18, 43, 32,240,177,132,153,
    110              223, 76,203,194, 52,126,118,  5,109,183,169, 49,209, 23,  4,215,
    111               20, 88, 58, 97,222, 27, 17, 28, 50, 15,156, 22, 83, 24,242, 34,
    112              254, 68,207,178,195,181,122,145, 36,  8,232,168, 96,252,105, 80,
    113              170,208,160,125,161,137, 98,151, 84, 91, 30,149,224,255,100,210,
    114               16,196,  0, 72,163,247,117,219,138,  3,230,218,  9, 63,221,148,
    115              135, 92,131,  2,205, 74,144, 51,115,103,246,243,157,127,191,226,
    116               82,155,216, 38,200, 55,198, 59,129,150,111, 75, 19,190, 99, 46,
    117              233,121,167,140,159,110,188,142, 41,245,249,182, 47,253,180, 89,
    118              120,152,  6,106,231, 70,113,186,212, 37,171, 66,136,162,141,250,
    119              114,  7,185, 85,248,238,172, 10, 54, 73, 42,104, 60, 56,241,164,
    120               64, 40,211,123,187,201, 67,193, 21,227,173,244,119,199,128,158
    121          };
    122          
    123          #define SBOX1(n) FSb[(n)]
    124          #define SBOX2(n) (unsigned char)((FSb[(n)] >> 7 ^ FSb[(n)] << 1) & 0xff)
    125          #define SBOX3(n) (unsigned char)((FSb[(n)] >> 1 ^ FSb[(n)] << 7) & 0xff)
    126          #define SBOX4(n) FSb[((n) << 1 ^ (n) >> 7) &0xff]
    127          
    128          #else /* MBEDTLS_CAMELLIA_SMALL_MEMORY */
    129          
    130          static const unsigned char FSb[256] =
    131          {
    132           112, 130,  44, 236, 179,  39, 192, 229, 228, 133,  87,  53, 234,  12, 174,  65,
    133            35, 239, 107, 147,  69,  25, 165,  33, 237,  14,  79,  78,  29, 101, 146, 189,
    134           134, 184, 175, 143, 124, 235,  31, 206,  62,  48, 220,  95,  94, 197,  11,  26,
    135           166, 225,  57, 202, 213,  71,  93,  61, 217,   1,  90, 214,  81,  86, 108,  77,
    136           139,  13, 154, 102, 251, 204, 176,  45, 116,  18,  43,  32, 240, 177, 132, 153,
    137           223,  76, 203, 194,  52, 126, 118,   5, 109, 183, 169,  49, 209,  23,   4, 215,
    138            20,  88,  58,  97, 222,  27,  17,  28,  50,  15, 156,  22,  83,  24, 242,  34,
    139           254,  68, 207, 178, 195, 181, 122, 145,  36,   8, 232, 168,  96, 252, 105,  80,
    140           170, 208, 160, 125, 161, 137,  98, 151,  84,  91,  30, 149, 224, 255, 100, 210,
    141            16, 196,   0,  72, 163, 247, 117, 219, 138,   3, 230, 218,   9,  63, 221, 148,
    142           135,  92, 131,   2, 205,  74, 144,  51, 115, 103, 246, 243, 157, 127, 191, 226,
    143            82, 155, 216,  38, 200,  55, 198,  59, 129, 150, 111,  75,  19, 190,  99,  46,
    144           233, 121, 167, 140, 159, 110, 188, 142,  41, 245, 249, 182,  47, 253, 180,  89,
    145           120, 152,   6, 106, 231,  70, 113, 186, 212,  37, 171,  66, 136, 162, 141, 250,
    146           114,   7, 185,  85, 248, 238, 172,  10,  54,  73,  42, 104,  60,  56, 241, 164,
    147           64,  40, 211, 123, 187, 201,  67, 193,  21, 227, 173, 244, 119, 199, 128, 158
    148          };
    149          
    150          static const unsigned char FSb2[256] =
    151          {
    152           224,   5,  88, 217, 103,  78, 129, 203, 201,  11, 174, 106, 213,  24,  93, 130,
    153            70, 223, 214,  39, 138,  50,  75,  66, 219,  28, 158, 156,  58, 202,  37, 123,
    154            13, 113,  95,  31, 248, 215,  62, 157, 124,  96, 185, 190, 188, 139,  22,  52,
    155            77, 195, 114, 149, 171, 142, 186, 122, 179,   2, 180, 173, 162, 172, 216, 154,
    156            23,  26,  53, 204, 247, 153,  97,  90, 232,  36,  86,  64, 225,  99,   9,  51,
    157           191, 152, 151, 133, 104, 252, 236,  10, 218, 111,  83,  98, 163,  46,   8, 175,
    158            40, 176, 116, 194, 189,  54,  34,  56, 100,  30,  57,  44, 166,  48, 229,  68,
    159           253, 136, 159, 101, 135, 107, 244,  35,  72,  16, 209,  81, 192, 249, 210, 160,
    160            85, 161,  65, 250,  67,  19, 196,  47, 168, 182,  60,  43, 193, 255, 200, 165,
    161            32, 137,   0, 144,  71, 239, 234, 183,  21,   6, 205, 181,  18, 126, 187,  41,
    162            15, 184,   7,   4, 155, 148,  33, 102, 230, 206, 237, 231,  59, 254, 127, 197,
    163           164,  55, 177,  76, 145, 110, 141, 118,   3,  45, 222, 150,  38, 125, 198,  92,
    164           211, 242,  79,  25,  63, 220, 121,  29,  82, 235, 243, 109,  94, 251, 105, 178,
    165           240,  49,  12, 212, 207, 140, 226, 117, 169,  74,  87, 132,  17,  69,  27, 245,
    166           228,  14, 115, 170, 241, 221,  89,  20, 108, 146,  84, 208, 120, 112, 227,  73,
    167           128,  80, 167, 246, 119, 147, 134, 131,  42, 199,  91, 233, 238, 143,   1,  61
    168          };
    169          
    170          static const unsigned char FSb3[256] =
    171          {
    172            56,  65,  22, 118, 217, 147,  96, 242, 114, 194, 171, 154, 117,   6,  87, 160,
    173           145, 247, 181, 201, 162, 140, 210, 144, 246,   7, 167,  39, 142, 178,  73, 222,
    174            67,  92, 215, 199,  62, 245, 143, 103,  31,  24, 110, 175,  47, 226, 133,  13,
    175            83, 240, 156, 101, 234, 163, 174, 158, 236, 128,  45, 107, 168,  43,  54, 166,
    176           197, 134,  77,  51, 253, 102,  88, 150,  58,   9, 149,  16, 120, 216,  66, 204,
    177           239,  38, 229,  97,  26,  63,  59, 130, 182, 219, 212, 152, 232, 139,   2, 235,
    178            10,  44,  29, 176, 111, 141, 136,  14,  25, 135,  78,  11, 169,  12, 121,  17,
    179           127,  34, 231,  89, 225, 218,  61, 200,  18,   4, 116,  84,  48, 126, 180,  40,
    180            85, 104,  80, 190, 208, 196,  49, 203,  42, 173,  15, 202, 112, 255,  50, 105,
    181             8,  98,   0,  36, 209, 251, 186, 237,  69, 129, 115, 109, 132, 159, 238,  74,
    182           195,  46, 193,   1, 230,  37,  72, 153, 185, 179, 123, 249, 206, 191, 223, 113,
    183            41, 205, 108,  19, 100, 155,  99, 157, 192,  75, 183, 165, 137,  95, 177,  23,
    184           244, 188, 211,  70, 207,  55,  94,  71, 148, 250, 252,  91, 151, 254,  90, 172,
    185            60,  76,   3,  53, 243,  35, 184,  93, 106, 146, 213,  33,  68,  81, 198, 125,
    186            57, 131, 220, 170, 124, 119,  86,   5,  27, 164,  21,  52,  30,  28, 248,  82,
    187            32,  20, 233, 189, 221, 228, 161, 224, 138, 241, 214, 122, 187, 227,  64,  79
    188          };
    189          
    190          static const unsigned char FSb4[256] =
    191          {
    192           112,  44, 179, 192, 228,  87, 234, 174,  35, 107,  69, 165, 237,  79,  29, 146,
    193           134, 175, 124,  31,  62, 220,  94,  11, 166,  57, 213,  93, 217,  90,  81, 108,
    194           139, 154, 251, 176, 116,  43, 240, 132, 223, 203,  52, 118, 109, 169, 209,   4,
    195            20,  58, 222,  17,  50, 156,  83, 242, 254, 207, 195, 122,  36, 232,  96, 105,
    196           170, 160, 161,  98,  84,  30, 224, 100,  16,   0, 163, 117, 138, 230,   9, 221,
    197           135, 131, 205, 144, 115, 246, 157, 191,  82, 216, 200, 198, 129, 111,  19,  99,
    198           233, 167, 159, 188,  41, 249,  47, 180, 120,   6, 231, 113, 212, 171, 136, 141,
    199           114, 185, 248, 172,  54,  42,  60, 241,  64, 211, 187,  67,  21, 173, 119, 128,
    200           130, 236,  39, 229, 133,  53,  12,  65, 239, 147,  25,  33,  14,  78, 101, 189,
    201           184, 143, 235, 206,  48,  95, 197,  26, 225, 202,  71,  61,   1, 214,  86,  77,
    202            13, 102, 204,  45,  18,  32, 177, 153,  76, 194, 126,   5, 183,  49,  23, 215,
    203            88,  97,  27,  28,  15,  22,  24,  34,  68, 178, 181, 145,   8, 168, 252,  80,
    204           208, 125, 137, 151,  91, 149, 255, 210, 196,  72, 247, 219,   3, 218,  63, 148,
    205            92,   2,  74,  51, 103, 243, 127, 226, 155,  38,  55,  59, 150,  75, 190,  46,
    206           121, 140, 110, 142, 245, 182, 253,  89, 152, 106,  70, 186,  37,  66, 162, 250,
    207            7,  85, 238,  10,  73, 104,  56, 164,  40, 123, 201, 193, 227, 244, 199, 158
    208          };
    209          
    210          #define SBOX1(n) FSb[(n)]
    211          #define SBOX2(n) FSb2[(n)]
    212          #define SBOX3(n) FSb3[(n)]
    213          #define SBOX4(n) FSb4[(n)]
    214          
    215          #endif /* MBEDTLS_CAMELLIA_SMALL_MEMORY */
    216          
    217          static const unsigned char shifts[2][4][4] =
    218          {
    219              {
    220                  { 1, 1, 1, 1 }, /* KL */
    221                  { 0, 0, 0, 0 }, /* KR */
    222                  { 1, 1, 1, 1 }, /* KA */
    223                  { 0, 0, 0, 0 }  /* KB */
    224              },
    225              {
    226                  { 1, 0, 1, 1 }, /* KL */
    227                  { 1, 1, 0, 1 }, /* KR */
    228                  { 1, 1, 1, 0 }, /* KA */
    229                  { 1, 1, 0, 1 }  /* KB */
    230              }
    231          };
    232          
    233          static const signed char indexes[2][4][20] =
    234          {
    235              {
    236                  {  0,  1,  2,  3,  8,  9, 10, 11, 38, 39,
    237                    36, 37, 23, 20, 21, 22, 27, -1, -1, 26 }, /* KL -> RK */
    238                  { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    239                    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, /* KR -> RK */
    240                  {  4,  5,  6,  7, 12, 13, 14, 15, 16, 17,
    241                    18, 19, -1, 24, 25, -1, 31, 28, 29, 30 }, /* KA -> RK */
    242                  { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    243                    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }  /* KB -> RK */
    244              },
    245              {
    246                  {  0,  1,  2,  3, 61, 62, 63, 60, -1, -1,
    247                    -1, -1, 27, 24, 25, 26, 35, 32, 33, 34 }, /* KL -> RK */
    248                  { -1, -1, -1, -1,  8,  9, 10, 11, 16, 17,
    249                    18, 19, -1, -1, -1, -1, 39, 36, 37, 38 }, /* KR -> RK */
    250                  { -1, -1, -1, -1, 12, 13, 14, 15, 58, 59,
    251                    56, 57, 31, 28, 29, 30, -1, -1, -1, -1 }, /* KA -> RK */
    252                  {  4,  5,  6,  7, 65, 66, 67, 64, 20, 21,
    253                    22, 23, -1, -1, -1, -1, 43, 40, 41, 42 }  /* KB -> RK */
    254              }
    255          };
    256          
    257          static const signed char transposes[2][20] =
    258          {
    259              {
    260                  21, 22, 23, 20,
    261                  -1, -1, -1, -1,
    262                  18, 19, 16, 17,
    263                  11,  8,  9, 10,
    264                  15, 12, 13, 14
    265              },
    266              {
    267                  25, 26, 27, 24,
    268                  29, 30, 31, 28,
    269                  18, 19, 16, 17,
    270                  -1, -1, -1, -1,
    271                  -1, -1, -1, -1
    272              }
    273          };
    274          
    275          /* Shift macro for 128 bit strings with rotation smaller than 32 bits (!) */
    276          #define ROTL(DEST, SRC, SHIFT)                                      \
    277          {                                                                   \
    278              (DEST)[0] = (SRC)[0] << (SHIFT) ^ (SRC)[1] >> (32 - (SHIFT));   \
    279              (DEST)[1] = (SRC)[1] << (SHIFT) ^ (SRC)[2] >> (32 - (SHIFT));   \
    280              (DEST)[2] = (SRC)[2] << (SHIFT) ^ (SRC)[3] >> (32 - (SHIFT));   \
    281              (DEST)[3] = (SRC)[3] << (SHIFT) ^ (SRC)[0] >> (32 - (SHIFT));   \
    282          }
    283          
    284          #define FL(XL, XR, KL, KR)                                          \
    285          {                                                                   \
    286              (XR) = ((((XL) & (KL)) << 1) | (((XL) & (KL)) >> 31)) ^ (XR);   \
    287              (XL) = ((XR) | (KR)) ^ (XL);                                    \
    288          }
    289          
    290          #define FLInv(YL, YR, KL, KR)                                       \
    291          {                                                                   \
    292              (YL) = ((YR) | (KR)) ^ (YL);                                    \
    293              (YR) = ((((YL) & (KL)) << 1) | (((YL) & (KL)) >> 31)) ^ (YR);   \
    294          }
    295          
    296          #define SHIFT_AND_PLACE(INDEX, OFFSET)                      \
    297          {                                                           \
    298              TK[0] = KC[(OFFSET) * 4 + 0];                           \
    299              TK[1] = KC[(OFFSET) * 4 + 1];                           \
    300              TK[2] = KC[(OFFSET) * 4 + 2];                           \
    301              TK[3] = KC[(OFFSET) * 4 + 3];                           \
    302                                                                      \
    303              for( i = 1; i <= 4; i++ )                               \
    304                  if( shifts[(INDEX)][(OFFSET)][i -1] )               \
    305                      ROTL(TK + i * 4, TK, ( 15 * i ) % 32);          \
    306                                                                      \
    307              for( i = 0; i < 20; i++ )                               \
    308                  if( indexes[(INDEX)][(OFFSET)][i] != -1 ) {         \
    309                      RK[indexes[(INDEX)][(OFFSET)][i]] = TK[ i ];    \
    310                  }                                                   \
    311          }
    312          
    313          static void camellia_feistel( const uint32_t x[2], const uint32_t k[2],
    314                                        uint32_t z[2])
    315          {
    316              uint32_t I0, I1;
    317              I0 = x[0] ^ k[0];
    318              I1 = x[1] ^ k[1];
    319          
    320              I0 = ((uint32_t) SBOX1((I0 >> 24) & 0xFF) << 24) |
    321                   ((uint32_t) SBOX2((I0 >> 16) & 0xFF) << 16) |
    322                   ((uint32_t) SBOX3((I0 >>  8) & 0xFF) <<  8) |
    323                   ((uint32_t) SBOX4((I0      ) & 0xFF)      );
    324              I1 = ((uint32_t) SBOX2((I1 >> 24) & 0xFF) << 24) |
    325                   ((uint32_t) SBOX3((I1 >> 16) & 0xFF) << 16) |
    326                   ((uint32_t) SBOX4((I1 >>  8) & 0xFF) <<  8) |
    327                   ((uint32_t) SBOX1((I1      ) & 0xFF)      );
    328          
    329              I0 ^= (I1 << 8) | (I1 >> 24);
    330              I1 ^= (I0 << 16) | (I0 >> 16);
    331              I0 ^= (I1 >> 8) | (I1 << 24);
    332              I1 ^= (I0 >> 8) | (I0 << 24);
    333          
    334              z[0] ^= I1;
    335              z[1] ^= I0;
    336          }
    337          
    338          void mbedtls_camellia_init( mbedtls_camellia_context *ctx )
    339          {
    340              memset( ctx, 0, sizeof( mbedtls_camellia_context ) );
    341          }
    342          
    343          void mbedtls_camellia_free( mbedtls_camellia_context *ctx )
    344          {
    345              if( ctx == NULL )
    346                  return;
    347          
    348              mbedtls_zeroize( ctx, sizeof( mbedtls_camellia_context ) );
    349          }
    350          
    351          /*
    352           * Camellia key schedule (encryption)
    353           */
    354          int mbedtls_camellia_setkey_enc( mbedtls_camellia_context *ctx, const unsigned char *key,
    355                                   unsigned int keybits )
    356          {
    357              int idx;
    358              size_t i;
    359              uint32_t *RK;
    360              unsigned char t[64];
    361              uint32_t SIGMA[6][2];
    362              uint32_t KC[16];
    363              uint32_t TK[20];
    364          
    365              RK = ctx->rk;
    366          
    367              memset( t, 0, 64 );
    368              memset( RK, 0, sizeof(ctx->rk) );
    369          
    370              switch( keybits )
    371              {
    372                  case 128: ctx->nr = 3; idx = 0; break;
    373                  case 192:
    374                  case 256: ctx->nr = 4; idx = 1; break;
    375                  default : return( MBEDTLS_ERR_CAMELLIA_INVALID_KEY_LENGTH );
    376              }
    377          
    378              for( i = 0; i < keybits / 8; ++i )
    379                  t[i] = key[i];
    380          
    381              if( keybits == 192 ) {
    382                  for( i = 0; i < 8; i++ )
    383                      t[24 + i] = ~t[16 + i];
    384              }
    385          
    386              /*
    387               * Prepare SIGMA values
    388               */
    389              for( i = 0; i < 6; i++ ) {
    390                  GET_UINT32_BE( SIGMA[i][0], SIGMA_CHARS[i], 0 );
    391                  GET_UINT32_BE( SIGMA[i][1], SIGMA_CHARS[i], 4 );
    392              }
    393          
    394              /*
    395               * Key storage in KC
    396               * Order: KL, KR, KA, KB
    397               */
    398              memset( KC, 0, sizeof(KC) );
    399          
    400              /* Store KL, KR */
    401              for( i = 0; i < 8; i++ )
    402                  GET_UINT32_BE( KC[i], t, i * 4 );
    403          
    404              /* Generate KA */
    405              for( i = 0; i < 4; ++i )
    406                  KC[8 + i] = KC[i] ^ KC[4 + i];
    407          
    408              camellia_feistel( KC + 8, SIGMA[0], KC + 10 );
    409              camellia_feistel( KC + 10, SIGMA[1], KC + 8 );
    410          
    411              for( i = 0; i < 4; ++i )
    412                  KC[8 + i] ^= KC[i];
    413          
    414              camellia_feistel( KC + 8, SIGMA[2], KC + 10 );
    415              camellia_feistel( KC + 10, SIGMA[3], KC + 8 );
    416          
    417              if( keybits > 128 ) {
    418                  /* Generate KB */
    419                  for( i = 0; i < 4; ++i )
    420                      KC[12 + i] = KC[4 + i] ^ KC[8 + i];
    421          
    422                  camellia_feistel( KC + 12, SIGMA[4], KC + 14 );
    423                  camellia_feistel( KC + 14, SIGMA[5], KC + 12 );
    424              }
    425          
    426              /*
    427               * Generating subkeys
    428               */
    429          
    430              /* Manipulating KL */
    431              SHIFT_AND_PLACE( idx, 0 );
    432          
    433              /* Manipulating KR */
    434              if( keybits > 128 ) {
    435                  SHIFT_AND_PLACE( idx, 1 );
    436              }
    437          
    438              /* Manipulating KA */
    439              SHIFT_AND_PLACE( idx, 2 );
    440          
    441              /* Manipulating KB */
    442              if( keybits > 128 ) {
    443                  SHIFT_AND_PLACE( idx, 3 );
    444              }
    445          
    446              /* Do transpositions */
    447              for( i = 0; i < 20; i++ ) {
    448                  if( transposes[idx][i] != -1 ) {
    449                      RK[32 + 12 * idx + i] = RK[transposes[idx][i]];
    450                  }
    451              }
    452          
    453              return( 0 );
    454          }
    455          
    456          /*
    457           * Camellia key schedule (decryption)
    458           */
    459          int mbedtls_camellia_setkey_dec( mbedtls_camellia_context *ctx, const unsigned char *key,
    460                                   unsigned int keybits )
    461          {
    462              int idx, ret;
    463              size_t i;
    464              mbedtls_camellia_context cty;
    465              uint32_t *RK;
    466              uint32_t *SK;
    467          
    468              mbedtls_camellia_init( &cty );
    469          
    470              /* Also checks keybits */
    471              if( ( ret = mbedtls_camellia_setkey_enc( &cty, key, keybits ) ) != 0 )
    472                  goto exit;
    473          
    474              ctx->nr = cty.nr;
    475              idx = ( ctx->nr == 4 );
    476          
    477              RK = ctx->rk;
    478              SK = cty.rk + 24 * 2 + 8 * idx * 2;
    479          
    480              *RK++ = *SK++;
    481              *RK++ = *SK++;
    482              *RK++ = *SK++;
    483              *RK++ = *SK++;
    484          
    485              for( i = 22 + 8 * idx, SK -= 6; i > 0; i--, SK -= 4 )
    486              {
    487                  *RK++ = *SK++;
    488                  *RK++ = *SK++;
    489              }
    490          
    491              SK -= 2;
    492          
    493              *RK++ = *SK++;
    494              *RK++ = *SK++;
    495              *RK++ = *SK++;
    496              *RK++ = *SK++;
    497          
    498          exit:
    499              mbedtls_camellia_free( &cty );
    500          
    501              return( ret );
    502          }
    503          
    504          /*
    505           * Camellia-ECB block encryption/decryption
    506           */
    507          int mbedtls_camellia_crypt_ecb( mbedtls_camellia_context *ctx,
    508                              int mode,
    509                              const unsigned char input[16],
    510                              unsigned char output[16] )
    511          {
    512              int NR;
    513              uint32_t *RK, X[4];
    514          
    515              ( (void) mode );
    516          
    517              NR = ctx->nr;
    518              RK = ctx->rk;
    519          
    520              GET_UINT32_BE( X[0], input,  0 );
    521              GET_UINT32_BE( X[1], input,  4 );
    522              GET_UINT32_BE( X[2], input,  8 );
    523              GET_UINT32_BE( X[3], input, 12 );
    524          
    525              X[0] ^= *RK++;
    526              X[1] ^= *RK++;
    527              X[2] ^= *RK++;
    528              X[3] ^= *RK++;
    529          
    530              while( NR ) {
    531                  --NR;
    532                  camellia_feistel( X, RK, X + 2 );
    533                  RK += 2;
    534                  camellia_feistel( X + 2, RK, X );
    535                  RK += 2;
    536                  camellia_feistel( X, RK, X + 2 );
    537                  RK += 2;
    538                  camellia_feistel( X + 2, RK, X );
    539                  RK += 2;
    540                  camellia_feistel( X, RK, X + 2 );
    541                  RK += 2;
    542                  camellia_feistel( X + 2, RK, X );
    543                  RK += 2;
    544          
    545                  if( NR ) {
    546                      FL(X[0], X[1], RK[0], RK[1]);
    547                      RK += 2;
    548                      FLInv(X[2], X[3], RK[0], RK[1]);
    549                      RK += 2;
    550                  }
    551              }
    552          
    553              X[2] ^= *RK++;
    554              X[3] ^= *RK++;
    555              X[0] ^= *RK++;
    556              X[1] ^= *RK++;
    557          
    558              PUT_UINT32_BE( X[2], output,  0 );
    559              PUT_UINT32_BE( X[3], output,  4 );
    560              PUT_UINT32_BE( X[0], output,  8 );
    561              PUT_UINT32_BE( X[1], output, 12 );
    562          
    563              return( 0 );
    564          }
    565          
    566          #if defined(MBEDTLS_CIPHER_MODE_CBC)
    567          /*
    568           * Camellia-CBC buffer encryption/decryption
    569           */
    570          int mbedtls_camellia_crypt_cbc( mbedtls_camellia_context *ctx,
    571                              int mode,
    572                              size_t length,
    573                              unsigned char iv[16],
    574                              const unsigned char *input,
    575                              unsigned char *output )
    576          {
    577              int i;
    578              unsigned char temp[16];
    579          
    580              if( length % 16 )
    581                  return( MBEDTLS_ERR_CAMELLIA_INVALID_INPUT_LENGTH );
    582          
    583              if( mode == MBEDTLS_CAMELLIA_DECRYPT )
    584              {
    585                  while( length > 0 )
    586                  {
    587                      memcpy( temp, input, 16 );
    588                      mbedtls_camellia_crypt_ecb( ctx, mode, input, output );
    589          
    590                      for( i = 0; i < 16; i++ )
    591                          output[i] = (unsigned char)( output[i] ^ iv[i] );
    592          
    593                      memcpy( iv, temp, 16 );
    594          
    595                      input  += 16;
    596                      output += 16;
    597                      length -= 16;
    598                  }
    599              }
    600              else
    601              {
    602                  while( length > 0 )
    603                  {
    604                      for( i = 0; i < 16; i++ )
    605                          output[i] = (unsigned char)( input[i] ^ iv[i] );
    606          
    607                      mbedtls_camellia_crypt_ecb( ctx, mode, output, output );
    608                      memcpy( iv, output, 16 );
    609          
    610                      input  += 16;
    611                      output += 16;
    612                      length -= 16;
    613                  }
    614              }
    615          
    616              return( 0 );
    617          }
    618          #endif /* MBEDTLS_CIPHER_MODE_CBC */
    619          
    620          #if defined(MBEDTLS_CIPHER_MODE_CFB)
    621          /*
    622           * Camellia-CFB128 buffer encryption/decryption
    623           */
    624          int mbedtls_camellia_crypt_cfb128( mbedtls_camellia_context *ctx,
    625                                 int mode,
    626                                 size_t length,
    627                                 size_t *iv_off,
    628                                 unsigned char iv[16],
    629                                 const unsigned char *input,
    630                                 unsigned char *output )
    631          {
    632              int c;
    633              size_t n = *iv_off;
    634          
    635              if( mode == MBEDTLS_CAMELLIA_DECRYPT )
    636              {
    637                  while( length-- )
    638                  {
    639                      if( n == 0 )
    640                          mbedtls_camellia_crypt_ecb( ctx, MBEDTLS_CAMELLIA_ENCRYPT, iv, iv );
    641          
    642                      c = *input++;
    643                      *output++ = (unsigned char)( c ^ iv[n] );
    644                      iv[n] = (unsigned char) c;
    645          
    646                      n = ( n + 1 ) & 0x0F;
    647                  }
    648              }
    649              else
    650              {
    651                  while( length-- )
    652                  {
    653                      if( n == 0 )
    654                          mbedtls_camellia_crypt_ecb( ctx, MBEDTLS_CAMELLIA_ENCRYPT, iv, iv );
    655          
    656                      iv[n] = *output++ = (unsigned char)( iv[n] ^ *input++ );
    657          
    658                      n = ( n + 1 ) & 0x0F;
    659                  }
    660              }
    661          
    662              *iv_off = n;
    663          
    664              return( 0 );
    665          }
    666          #endif /* MBEDTLS_CIPHER_MODE_CFB */
    667          
    668          #if defined(MBEDTLS_CIPHER_MODE_CTR)
    669          /*
    670           * Camellia-CTR buffer encryption/decryption
    671           */
    672          int mbedtls_camellia_crypt_ctr( mbedtls_camellia_context *ctx,
    673                                 size_t length,
    674                                 size_t *nc_off,
    675                                 unsigned char nonce_counter[16],
    676                                 unsigned char stream_block[16],
    677                                 const unsigned char *input,
    678                                 unsigned char *output )
    679          {
    680              int c, i;
    681              size_t n = *nc_off;
    682          
    683              while( length-- )
    684              {
    685                  if( n == 0 ) {
    686                      mbedtls_camellia_crypt_ecb( ctx, MBEDTLS_CAMELLIA_ENCRYPT, nonce_counter,
    687                                          stream_block );
    688          
    689                      for( i = 16; i > 0; i-- )
    690                          if( ++nonce_counter[i - 1] != 0 )
    691                              break;
    692                  }
    693                  c = *input++;
    694                  *output++ = (unsigned char)( c ^ stream_block[n] );
    695          
    696                  n = ( n + 1 ) & 0x0F;
    697              }
    698          
    699              *nc_off = n;
    700          
    701              return( 0 );
    702          }
    703          #endif /* MBEDTLS_CIPHER_MODE_CTR */
    704          #endif /* !MBEDTLS_CAMELLIA_ALT */
    705          
    706          #if defined(MBEDTLS_SELF_TEST)
    707          
    708          /*
    709           * Camellia test vectors from:
    710           *
    711           * http://info.isl.ntt.co.jp/crypt/eng/camellia/technology.html:
    712           *   http://info.isl.ntt.co.jp/crypt/eng/camellia/dl/cryptrec/intermediate.txt
    713           *   http://info.isl.ntt.co.jp/crypt/eng/camellia/dl/cryptrec/t_camellia.txt
    714           *                      (For each bitlength: Key 0, Nr 39)
    715           */
    716          #define CAMELLIA_TESTS_ECB  2
    717          
    718          static const unsigned char camellia_test_ecb_key[3][CAMELLIA_TESTS_ECB][32] =
    719          {
    720              {
    721                  { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    722                    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
    723                  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    724                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
    725              },
    726              {
    727                  { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    728                    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    729                    0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77 },
    730                  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    731                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    732                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
    733              },
    734              {
    735                  { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    736                    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    737                    0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
    738                    0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff },
    739                  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    740                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    741                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    742                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
    743              },
    744          };
    745          
    746          static const unsigned char camellia_test_ecb_plain[CAMELLIA_TESTS_ECB][16] =
    747          {
    748              { 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    749                0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10 },
    750              { 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    751                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
    752          };
    753          
    754          static const unsigned char camellia_test_ecb_cipher[3][CAMELLIA_TESTS_ECB][16] =
    755          {
    756              {
    757                  { 0x67, 0x67, 0x31, 0x38, 0x54, 0x96, 0x69, 0x73,
    758                    0x08, 0x57, 0x06, 0x56, 0x48, 0xea, 0xbe, 0x43 },
    759                  { 0x38, 0x3C, 0x6C, 0x2A, 0xAB, 0xEF, 0x7F, 0xDE,
    760                    0x25, 0xCD, 0x47, 0x0B, 0xF7, 0x74, 0xA3, 0x31 }
    761              },
    762              {
    763                  { 0xb4, 0x99, 0x34, 0x01, 0xb3, 0xe9, 0x96, 0xf8,
    764                    0x4e, 0xe5, 0xce, 0xe7, 0xd7, 0x9b, 0x09, 0xb9 },
    765                  { 0xD1, 0x76, 0x3F, 0xC0, 0x19, 0xD7, 0x7C, 0xC9,
    766                    0x30, 0xBF, 0xF2, 0xA5, 0x6F, 0x7C, 0x93, 0x64 }
    767              },
    768              {
    769                  { 0x9a, 0xcc, 0x23, 0x7d, 0xff, 0x16, 0xd7, 0x6c,
    770                    0x20, 0xef, 0x7c, 0x91, 0x9e, 0x3a, 0x75, 0x09 },
    771                  { 0x05, 0x03, 0xFB, 0x10, 0xAB, 0x24, 0x1E, 0x7C,
    772                    0xF4, 0x5D, 0x8C, 0xDE, 0xEE, 0x47, 0x43, 0x35 }
    773              }
    774          };
    775          
    776          #if defined(MBEDTLS_CIPHER_MODE_CBC)
    777          #define CAMELLIA_TESTS_CBC  3
    778          
    779          static const unsigned char camellia_test_cbc_key[3][32] =
    780          {
    781                  { 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,
    782                    0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C }
    783              ,
    784                  { 0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52,
    785                    0xC8, 0x10, 0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5,
    786                    0x62, 0xF8, 0xEA, 0xD2, 0x52, 0x2C, 0x6B, 0x7B }
    787              ,
    788                  { 0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE,
    789                    0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81,
    790                    0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7,
    791                    0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4 }
    792          };
    793          
    794          static const unsigned char camellia_test_cbc_iv[16] =
    795          
    796              { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    797                0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F }
    798          ;
    799          
    800          static const unsigned char camellia_test_cbc_plain[CAMELLIA_TESTS_CBC][16] =
    801          {
    802              { 0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,
    803                0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A },
    804              { 0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C,
    805                0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51 },
    806              { 0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11,
    807                0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF }
    808          
    809          };
    810          
    811          static const unsigned char camellia_test_cbc_cipher[3][CAMELLIA_TESTS_CBC][16] =
    812          {
    813              {
    814                  { 0x16, 0x07, 0xCF, 0x49, 0x4B, 0x36, 0xBB, 0xF0,
    815                    0x0D, 0xAE, 0xB0, 0xB5, 0x03, 0xC8, 0x31, 0xAB },
    816                  { 0xA2, 0xF2, 0xCF, 0x67, 0x16, 0x29, 0xEF, 0x78,
    817                    0x40, 0xC5, 0xA5, 0xDF, 0xB5, 0x07, 0x48, 0x87 },
    818                  { 0x0F, 0x06, 0x16, 0x50, 0x08, 0xCF, 0x8B, 0x8B,
    819                    0x5A, 0x63, 0x58, 0x63, 0x62, 0x54, 0x3E, 0x54 }
    820              },
    821              {
    822                  { 0x2A, 0x48, 0x30, 0xAB, 0x5A, 0xC4, 0xA1, 0xA2,
    823                    0x40, 0x59, 0x55, 0xFD, 0x21, 0x95, 0xCF, 0x93 },
    824                  { 0x5D, 0x5A, 0x86, 0x9B, 0xD1, 0x4C, 0xE5, 0x42,
    825                    0x64, 0xF8, 0x92, 0xA6, 0xDD, 0x2E, 0xC3, 0xD5 },
    826                  { 0x37, 0xD3, 0x59, 0xC3, 0x34, 0x98, 0x36, 0xD8,
    827                    0x84, 0xE3, 0x10, 0xAD, 0xDF, 0x68, 0xC4, 0x49 }
    828              },
    829              {
    830                  { 0xE6, 0xCF, 0xA3, 0x5F, 0xC0, 0x2B, 0x13, 0x4A,
    831                    0x4D, 0x2C, 0x0B, 0x67, 0x37, 0xAC, 0x3E, 0xDA },
    832                  { 0x36, 0xCB, 0xEB, 0x73, 0xBD, 0x50, 0x4B, 0x40,
    833                    0x70, 0xB1, 0xB7, 0xDE, 0x2B, 0x21, 0xEB, 0x50 },
    834                  { 0xE3, 0x1A, 0x60, 0x55, 0x29, 0x7D, 0x96, 0xCA,
    835                    0x33, 0x30, 0xCD, 0xF1, 0xB1, 0x86, 0x0A, 0x83 }
    836              }
    837          };
    838          #endif /* MBEDTLS_CIPHER_MODE_CBC */
    839          
    840          #if defined(MBEDTLS_CIPHER_MODE_CTR)
    841          /*
    842           * Camellia-CTR test vectors from:
    843           *
    844           * http://www.faqs.org/rfcs/rfc5528.html
    845           */
    846          
    847          static const unsigned char camellia_test_ctr_key[3][16] =
    848          {
    849              { 0xAE, 0x68, 0x52, 0xF8, 0x12, 0x10, 0x67, 0xCC,
    850                0x4B, 0xF7, 0xA5, 0x76, 0x55, 0x77, 0xF3, 0x9E },
    851              { 0x7E, 0x24, 0x06, 0x78, 0x17, 0xFA, 0xE0, 0xD7,
    852                0x43, 0xD6, 0xCE, 0x1F, 0x32, 0x53, 0x91, 0x63 },
    853              { 0x76, 0x91, 0xBE, 0x03, 0x5E, 0x50, 0x20, 0xA8,
    854                0xAC, 0x6E, 0x61, 0x85, 0x29, 0xF9, 0xA0, 0xDC }
    855          };
    856          
    857          static const unsigned char camellia_test_ctr_nonce_counter[3][16] =
    858          {
    859              { 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
    860                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    861              { 0x00, 0x6C, 0xB6, 0xDB, 0xC0, 0x54, 0x3B, 0x59,
    862                0xDA, 0x48, 0xD9, 0x0B, 0x00, 0x00, 0x00, 0x01 },
    863              { 0x00, 0xE0, 0x01, 0x7B, 0x27, 0x77, 0x7F, 0x3F,
    864                0x4A, 0x17, 0x86, 0xF0, 0x00, 0x00, 0x00, 0x01 }
    865          };
    866          
    867          static const unsigned char camellia_test_ctr_pt[3][48] =
    868          {
    869              { 0x53, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x20, 0x62,
    870                0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x6D, 0x73, 0x67 },
    871          
    872              { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    873                0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    874                0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    875                0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F },
    876          
    877              { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    878                0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    879                0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    880                0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
    881                0x20, 0x21, 0x22, 0x23 }
    882          };
    883          
    884          static const unsigned char camellia_test_ctr_ct[3][48] =
    885          {
    886              { 0xD0, 0x9D, 0xC2, 0x9A, 0x82, 0x14, 0x61, 0x9A,
    887                0x20, 0x87, 0x7C, 0x76, 0xDB, 0x1F, 0x0B, 0x3F },
    888              { 0xDB, 0xF3, 0xC7, 0x8D, 0xC0, 0x83, 0x96, 0xD4,
    889                0xDA, 0x7C, 0x90, 0x77, 0x65, 0xBB, 0xCB, 0x44,
    890                0x2B, 0x8E, 0x8E, 0x0F, 0x31, 0xF0, 0xDC, 0xA7,
    891                0x2C, 0x74, 0x17, 0xE3, 0x53, 0x60, 0xE0, 0x48 },
    892              { 0xB1, 0x9D, 0x1F, 0xCD, 0xCB, 0x75, 0xEB, 0x88,
    893                0x2F, 0x84, 0x9C, 0xE2, 0x4D, 0x85, 0xCF, 0x73,
    894                0x9C, 0xE6, 0x4B, 0x2B, 0x5C, 0x9D, 0x73, 0xF1,
    895                0x4F, 0x2D, 0x5D, 0x9D, 0xCE, 0x98, 0x89, 0xCD,
    896                0xDF, 0x50, 0x86, 0x96 }
    897          };
    898          
    899          static const int camellia_test_ctr_len[3] =
    900              { 16, 32, 36 };
    901          #endif /* MBEDTLS_CIPHER_MODE_CTR */
    902          
    903          /*
    904           * Checkup routine
    905           */
    906          int mbedtls_camellia_self_test( int verbose )
    907          {
    908              int i, j, u, v;
    909              unsigned char key[32];
    910              unsigned char buf[64];
    911              unsigned char src[16];
    912              unsigned char dst[16];
    913          #if defined(MBEDTLS_CIPHER_MODE_CBC)
    914              unsigned char iv[16];
    915          #endif
    916          #if defined(MBEDTLS_CIPHER_MODE_CTR)
    917              size_t offset, len;
    918              unsigned char nonce_counter[16];
    919              unsigned char stream_block[16];
    920          #endif
    921          
    922              mbedtls_camellia_context ctx;
    923          
    924              memset( key, 0, 32 );
    925          
    926              for( j = 0; j < 6; j++ ) {
    927                  u = j >> 1;
    928              v = j & 1;
    929          
    930              if( verbose != 0 )
    931                  mbedtls_printf( "  CAMELLIA-ECB-%3d (%s): ", 128 + u * 64,
    932                                   (v == MBEDTLS_CAMELLIA_DECRYPT) ? "dec" : "enc");
    933          
    934              for( i = 0; i < CAMELLIA_TESTS_ECB; i++ ) {
    935                  memcpy( key, camellia_test_ecb_key[u][i], 16 + 8 * u );
    936          
    937                  if( v == MBEDTLS_CAMELLIA_DECRYPT ) {
    938                      mbedtls_camellia_setkey_dec( &ctx, key, 128 + u * 64 );
    939                      memcpy( src, camellia_test_ecb_cipher[u][i], 16 );
    940                      memcpy( dst, camellia_test_ecb_plain[i], 16 );
    941                  } else { /* MBEDTLS_CAMELLIA_ENCRYPT */
    942                      mbedtls_camellia_setkey_enc( &ctx, key, 128 + u * 64 );
    943                      memcpy( src, camellia_test_ecb_plain[i], 16 );
    944                      memcpy( dst, camellia_test_ecb_cipher[u][i], 16 );
    945                  }
    946          
    947                  mbedtls_camellia_crypt_ecb( &ctx, v, src, buf );
    948          
    949                  if( memcmp( buf, dst, 16 ) != 0 )
    950                  {
    951                      if( verbose != 0 )
    952                          mbedtls_printf( "failed\n" );
    953          
    954                      return( 1 );
    955                  }
    956              }
    957          
    958              if( verbose != 0 )
    959                  mbedtls_printf( "passed\n" );
    960              }
    961          
    962              if( verbose != 0 )
    963                  mbedtls_printf( "\n" );
    964          
    965          #if defined(MBEDTLS_CIPHER_MODE_CBC)
    966              /*
    967               * CBC mode
    968               */
    969              for( j = 0; j < 6; j++ )
    970              {
    971                  u = j >> 1;
    972                  v = j  & 1;
    973          
    974                  if( verbose != 0 )
    975                      mbedtls_printf( "  CAMELLIA-CBC-%3d (%s): ", 128 + u * 64,
    976                                       ( v == MBEDTLS_CAMELLIA_DECRYPT ) ? "dec" : "enc" );
    977          
    978                  memcpy( src, camellia_test_cbc_iv, 16 );
    979                  memcpy( dst, camellia_test_cbc_iv, 16 );
    980                  memcpy( key, camellia_test_cbc_key[u], 16 + 8 * u );
    981          
    982                  if( v == MBEDTLS_CAMELLIA_DECRYPT ) {
    983                      mbedtls_camellia_setkey_dec( &ctx, key, 128 + u * 64 );
    984                  } else {
    985                      mbedtls_camellia_setkey_enc( &ctx, key, 128 + u * 64 );
    986                  }
    987          
    988                  for( i = 0; i < CAMELLIA_TESTS_CBC; i++ ) {
    989          
    990                      if( v == MBEDTLS_CAMELLIA_DECRYPT ) {
    991                          memcpy( iv , src, 16 );
    992                          memcpy( src, camellia_test_cbc_cipher[u][i], 16 );
    993                          memcpy( dst, camellia_test_cbc_plain[i], 16 );
    994                      } else { /* MBEDTLS_CAMELLIA_ENCRYPT */
    995                          memcpy( iv , dst, 16 );
    996                          memcpy( src, camellia_test_cbc_plain[i], 16 );
    997                          memcpy( dst, camellia_test_cbc_cipher[u][i], 16 );
    998                      }
    999          
   1000                      mbedtls_camellia_crypt_cbc( &ctx, v, 16, iv, src, buf );
   1001          
   1002                      if( memcmp( buf, dst, 16 ) != 0 )
   1003                      {
   1004                          if( verbose != 0 )
   1005                              mbedtls_printf( "failed\n" );
   1006          
   1007                          return( 1 );
   1008                      }
   1009                  }
   1010          
   1011                  if( verbose != 0 )
   1012                      mbedtls_printf( "passed\n" );
   1013              }
   1014          #endif /* MBEDTLS_CIPHER_MODE_CBC */
   1015          
   1016              if( verbose != 0 )
   1017                  mbedtls_printf( "\n" );
   1018          
   1019          #if defined(MBEDTLS_CIPHER_MODE_CTR)
   1020              /*
   1021               * CTR mode
   1022               */
   1023              for( i = 0; i < 6; i++ )
   1024              {
   1025                  u = i >> 1;
   1026                  v = i  & 1;
   1027          
   1028                  if( verbose != 0 )
   1029                      mbedtls_printf( "  CAMELLIA-CTR-128 (%s): ",
   1030                                       ( v == MBEDTLS_CAMELLIA_DECRYPT ) ? "dec" : "enc" );
   1031          
   1032                  memcpy( nonce_counter, camellia_test_ctr_nonce_counter[u], 16 );
   1033                  memcpy( key, camellia_test_ctr_key[u], 16 );
   1034          
   1035                  offset = 0;
   1036                  mbedtls_camellia_setkey_enc( &ctx, key, 128 );
   1037          
   1038                  if( v == MBEDTLS_CAMELLIA_DECRYPT )
   1039                  {
   1040                      len = camellia_test_ctr_len[u];
   1041                      memcpy( buf, camellia_test_ctr_ct[u], len );
   1042          
   1043                      mbedtls_camellia_crypt_ctr( &ctx, len, &offset, nonce_counter, stream_block,
   1044                                          buf, buf );
   1045          
   1046                      if( memcmp( buf, camellia_test_ctr_pt[u], len ) != 0 )
   1047                      {
   1048                          if( verbose != 0 )
   1049                              mbedtls_printf( "failed\n" );
   1050          
   1051                          return( 1 );
   1052                      }
   1053                  }
   1054                  else
   1055                  {
   1056                      len = camellia_test_ctr_len[u];
   1057                      memcpy( buf, camellia_test_ctr_pt[u], len );
   1058          
   1059                      mbedtls_camellia_crypt_ctr( &ctx, len, &offset, nonce_counter, stream_block,
   1060                                          buf, buf );
   1061          
   1062                      if( memcmp( buf, camellia_test_ctr_ct[u], len ) != 0 )
   1063                      {
   1064                          if( verbose != 0 )
   1065                              mbedtls_printf( "failed\n" );
   1066          
   1067                          return( 1 );
   1068                      }
   1069                  }
   1070          
   1071                  if( verbose != 0 )
   1072                      mbedtls_printf( "passed\n" );
   1073              }
   1074          
   1075              if( verbose != 0 )
   1076                  mbedtls_printf( "\n" );
   1077          #endif /* MBEDTLS_CIPHER_MODE_CTR */
   1078          
   1079              return( 0 );
   1080          }
   1081          
   1082          #endif /* MBEDTLS_SELF_TEST */
   1083          
   1084          #endif /* MBEDTLS_CAMELLIA_C */


 
 
 0 bytes of memory

Errors: none
Warnings: none
