###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:46
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\ecdsa.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW3DB3.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\ecdsa.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"ecdsa.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0 -D
#        LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D EMBER_AF_USE_HWCONF
#        -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\ecdsa.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\ecdsa.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\ecdsa.c
      1          /***************************************************************************//**
      2           * # License
      3           *
      4           * The licensor of this software is Silicon Laboratories Inc. Your use of this
      5           * software is governed by the terms of Silicon Labs Master Software License
      6           * Agreement (MSLA) available at
      7           * www.silabs.com/about-us/legal/master-software-license-agreement. This
      8           * software is Third Party Software licensed by Silicon Labs from a third party
      9           * and is governed by the sections of the MSLA applicable to Third Party
     10           * Software and the additional terms set forth below.
     11           *
     12           ******************************************************************************/
     13          /*
     14           *  Elliptic curve DSA
     15           *
     16           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
     17           *  SPDX-License-Identifier: Apache-2.0
     18           *
     19           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
     20           *  not use this file except in compliance with the License.
     21           *  You may obtain a copy of the License at
     22           *
     23           *  http://www.apache.org/licenses/LICENSE-2.0
     24           *
     25           *  Unless required by applicable law or agreed to in writing, software
     26           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     27           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     28           *  See the License for the specific language governing permissions and
     29           *  limitations under the License.
     30           *
     31           *  This file is part of mbed TLS (https://tls.mbed.org)
     32           */
     33          
     34          /*
     35           * References:
     36           *
     37           * SEC1 http://www.secg.org/index.php?action=secg,docs_secg
     38           */
     39          
     40          #if !defined(MBEDTLS_CONFIG_FILE)
     41          #include "mbedtls/config.h"
     42          #else
     43          #include MBEDTLS_CONFIG_FILE
     44          #endif
     45          
     46          #if defined(MBEDTLS_ECDSA_C)
     47          
     48          #include "mbedtls/ecdsa.h"
     49          #include "mbedtls/asn1write.h"
     50          
     51          #include <string.h>
     52          
     53          #if defined(MBEDTLS_ECDSA_DETERMINISTIC)
     54          #include "mbedtls/hmac_drbg.h"
     55          #endif
     56          
     57          /*
     58           * Derive a suitable integer for group grp from a buffer of length len
     59           * SEC1 4.1.3 step 5 aka SEC1 4.1.4 step 3
     60           */
     61          #if !defined(MBEDTLS_ECDSA_SIGN_ALT) || !defined(MBEDTLS_ECDSA_VERIFY_ALT) \
     62            || defined(MBEDTLS_ECDSA_DETERMINISTIC)
     63          static int derive_mpi( const mbedtls_ecp_group *grp, mbedtls_mpi *x,
     64                                 const unsigned char *buf, size_t blen )
     65          {
     66              int ret;
     67              size_t n_size = ( grp->nbits + 7 ) / 8;
     68              size_t use_size = blen > n_size ? n_size : blen;
     69          
     70              MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( x, buf, use_size ) );
     71              if( use_size * 8 > grp->nbits )
     72                  MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( x, use_size * 8 - grp->nbits ) );
     73          
     74              /* While at it, reduce modulo N */
     75              if( mbedtls_mpi_cmp_mpi( x, &grp->N ) >= 0 )
     76                  MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( x, x, &grp->N ) );
     77          
     78          cleanup:
     79              return( ret );
     80          }
     81          #endif
     82          
     83          #if !defined(MBEDTLS_ECDSA_SIGN_ALT)
     84          /*
     85           * Compute ECDSA signature of a hashed message (SEC1 4.1.3)
     86           * Obviously, compared to SEC1 4.1.3, we skip step 4 (hash message)
     87           */
     88          int mbedtls_ecdsa_sign( mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s,
     89                          const mbedtls_mpi *d, const unsigned char *buf, size_t blen,
     90                          int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
     91          {
     92              int ret, key_tries, sign_tries, blind_tries;
     93              mbedtls_ecp_point R;
     94              mbedtls_mpi k, e, t;
     95          
     96              /* Fail cleanly on curves such as Curve25519 that can't be used for ECDSA */
     97              if( grp->N.p == NULL )
     98                  return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
     99          
    100              /* Make sure d is in range 1..n-1 */
    101              if( mbedtls_mpi_cmp_int( d, 1 ) < 0 || mbedtls_mpi_cmp_mpi( d, &grp->N ) >= 0 )
    102                  return( MBEDTLS_ERR_ECP_INVALID_KEY );
    103          
    104              mbedtls_ecp_point_init( &R );
    105              mbedtls_mpi_init( &k ); mbedtls_mpi_init( &e ); mbedtls_mpi_init( &t );
    106          
    107              sign_tries = 0;
    108              do
    109              {
    110                  /*
    111                   * Steps 1-3: generate a suitable ephemeral keypair
    112                   * and set r = xR mod n
    113                   */
    114                  key_tries = 0;
    115                  do
    116                  {
    117                      MBEDTLS_MPI_CHK( mbedtls_ecp_gen_keypair( grp, &k, &R, f_rng, p_rng ) );
    118                      MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( r, &R.X, &grp->N ) );
    119          
    120                      if( key_tries++ > 10 )
    121                      {
    122                          ret = MBEDTLS_ERR_ECP_RANDOM_FAILED;
    123                          goto cleanup;
    124                      }
    125                  }
    126                  while( mbedtls_mpi_cmp_int( r, 0 ) == 0 );
    127          
    128                  /*
    129                   * Step 5: derive MPI from hashed message
    130                   */
    131                  MBEDTLS_MPI_CHK( derive_mpi( grp, &e, buf, blen ) );
    132          
    133                  /*
    134                   * Generate a random value to blind inv_mod in next step,
    135                   * avoiding a potential timing leak.
    136                   */
    137                  blind_tries = 0;
    138                  do
    139                  {
    140                      size_t n_size = ( grp->nbits + 7 ) / 8;
    141                      MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &t, n_size, f_rng, p_rng ) );
    142                      MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &t, 8 * n_size - grp->nbits ) );
    143          
    144                      /* See mbedtls_ecp_gen_keypair() */
    145                      if( ++blind_tries > 30 )
    146                          return( MBEDTLS_ERR_ECP_RANDOM_FAILED );
    147                  }
    148                  while( mbedtls_mpi_cmp_int( &t, 1 ) < 0 ||
    149                         mbedtls_mpi_cmp_mpi( &t, &grp->N ) >= 0 );
    150          
    151                  /*
    152                   * Step 6: compute s = (e + r * d) / k = t (e + rd) / (kt) mod n
    153                   */
    154                  MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( s, r, d ) );
    155                  MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &e, &e, s ) );
    156                  MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &e, &e, &t ) );
    157                  MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &k, &k, &t ) );
    158                  MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( s, &k, &grp->N ) );
    159                  MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( s, s, &e ) );
    160                  MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( s, s, &grp->N ) );
    161          
    162                  if( sign_tries++ > 10 )
    163                  {
    164                      ret = MBEDTLS_ERR_ECP_RANDOM_FAILED;
    165                      goto cleanup;
    166                  }
    167              }
    168              while( mbedtls_mpi_cmp_int( s, 0 ) == 0 );
    169          
    170          cleanup:
    171              mbedtls_ecp_point_free( &R );
    172              mbedtls_mpi_free( &k ); mbedtls_mpi_free( &e ); mbedtls_mpi_free( &t );
    173          
    174              return( ret );
    175          }
    176          #endif /* MBEDTLS_ECDSA_SIGN_ALT */
    177          
    178          #if defined(MBEDTLS_ECDSA_DETERMINISTIC)
    179          /*
    180           * Deterministic signature wrapper
    181           */
    182          int mbedtls_ecdsa_sign_det( mbedtls_ecp_group *grp, mbedtls_mpi *r, mbedtls_mpi *s,
    183                              const mbedtls_mpi *d, const unsigned char *buf, size_t blen,
    184                              mbedtls_md_type_t md_alg )
    185          {
    186              int ret;
    187              mbedtls_hmac_drbg_context rng_ctx;
    188              unsigned char data[2 * MBEDTLS_ECP_MAX_BYTES];
    189              size_t grp_len = ( grp->nbits + 7 ) / 8;
    190              const mbedtls_md_info_t *md_info;
    191              mbedtls_mpi h;
    192          
    193              if( ( md_info = mbedtls_md_info_from_type( md_alg ) ) == NULL )
    194                  return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
    195          
    196              mbedtls_mpi_init( &h );
    197              mbedtls_hmac_drbg_init( &rng_ctx );
    198          
    199              /* Use private key and message hash (reduced) to initialize HMAC_DRBG */
    200              MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( d, data, grp_len ) );
    201              MBEDTLS_MPI_CHK( derive_mpi( grp, &h, buf, blen ) );
    202              MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &h, data + grp_len, grp_len ) );
    203              mbedtls_hmac_drbg_seed_buf( &rng_ctx, md_info, data, 2 * grp_len );
    204          
    205              ret = mbedtls_ecdsa_sign( grp, r, s, d, buf, blen,
    206                                mbedtls_hmac_drbg_random, &rng_ctx );
    207          
    208          cleanup:
    209              mbedtls_hmac_drbg_free( &rng_ctx );
    210              mbedtls_mpi_free( &h );
    211          
    212              return( ret );
    213          }
    214          #endif /* MBEDTLS_ECDSA_DETERMINISTIC */
    215          
    216          #if !defined(MBEDTLS_ECDSA_VERIFY_ALT)
    217          /*
    218           * Verify ECDSA signature of hashed message (SEC1 4.1.4)
    219           * Obviously, compared to SEC1 4.1.3, we skip step 2 (hash message)
    220           */
    221          int mbedtls_ecdsa_verify( mbedtls_ecp_group *grp,
    222                            const unsigned char *buf, size_t blen,
    223                            const mbedtls_ecp_point *Q, const mbedtls_mpi *r, const mbedtls_mpi *s)
    224          {
    225              int ret;
    226              mbedtls_mpi e, s_inv, u1, u2;
    227              mbedtls_ecp_point R;
    228          
    229              mbedtls_ecp_point_init( &R );
    230              mbedtls_mpi_init( &e ); mbedtls_mpi_init( &s_inv ); mbedtls_mpi_init( &u1 ); mbedtls_mpi_init( &u2 );
    231          
    232              /* Fail cleanly on curves such as Curve25519 that can't be used for ECDSA */
    233              if( grp->N.p == NULL )
    234                  return( MBEDTLS_ERR_ECP_BAD_INPUT_DATA );
    235          
    236              /*
    237               * Step 1: make sure r and s are in range 1..n-1
    238               */
    239              if( mbedtls_mpi_cmp_int( r, 1 ) < 0 || mbedtls_mpi_cmp_mpi( r, &grp->N ) >= 0 ||
    240                  mbedtls_mpi_cmp_int( s, 1 ) < 0 || mbedtls_mpi_cmp_mpi( s, &grp->N ) >= 0 )
    241              {
    242                  ret = MBEDTLS_ERR_ECP_VERIFY_FAILED;
    243                  goto cleanup;
    244              }
    245          
    246              /*
    247               * Additional precaution: make sure Q is valid
    248               */
    249              MBEDTLS_MPI_CHK( mbedtls_ecp_check_pubkey( grp, Q ) );
    250          
    251              /*
    252               * Step 3: derive MPI from hashed message
    253               */
    254              MBEDTLS_MPI_CHK( derive_mpi( grp, &e, buf, blen ) );
    255          
    256              /*
    257               * Step 4: u1 = e / s mod n, u2 = r / s mod n
    258               */
    259              MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &s_inv, s, &grp->N ) );
    260          
    261              MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &u1, &e, &s_inv ) );
    262              MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &u1, &u1, &grp->N ) );
    263          
    264              MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &u2, r, &s_inv ) );
    265              MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &u2, &u2, &grp->N ) );
    266          
    267              /*
    268               * Step 5: R = u1 G + u2 Q
    269               *
    270               * Since we're not using any secret data, no need to pass a RNG to
    271               * mbedtls_ecp_mul() for countermesures.
    272               */
    273              MBEDTLS_MPI_CHK( mbedtls_ecp_muladd( grp, &R, &u1, &grp->G, &u2, Q ) );
    274          
    275              if( mbedtls_ecp_is_zero( &R ) )
    276              {
    277                  ret = MBEDTLS_ERR_ECP_VERIFY_FAILED;
    278                  goto cleanup;
    279              }
    280          
    281              /*
    282               * Step 6: convert xR to an integer (no-op)
    283               * Step 7: reduce xR mod n (gives v)
    284               */
    285              MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &R.X, &R.X, &grp->N ) );
    286          
    287              /*
    288               * Step 8: check if v (that is, R.X) is equal to r
    289               */
    290              if( mbedtls_mpi_cmp_mpi( &R.X, r ) != 0 )
    291              {
    292                  ret = MBEDTLS_ERR_ECP_VERIFY_FAILED;
    293                  goto cleanup;
    294              }
    295          
    296          cleanup:
    297              mbedtls_ecp_point_free( &R );
    298              mbedtls_mpi_free( &e ); mbedtls_mpi_free( &s_inv ); mbedtls_mpi_free( &u1 ); mbedtls_mpi_free( &u2 );
    299          
    300              return( ret );
    301          }
    302          #endif /* MBEDTLS_ECDSA_VERIFY_ALT */
    303          
    304          /*
    305           * Convert a signature (given by context) to ASN.1
    306           */
    307          static int ecdsa_signature_to_asn1( const mbedtls_mpi *r, const mbedtls_mpi *s,
    308                                              unsigned char *sig, size_t *slen )
    309          {
    310              int ret;
    311              unsigned char buf[MBEDTLS_ECDSA_MAX_LEN];
    312              unsigned char *p = buf + sizeof( buf );
    313              size_t len = 0;
    314          
    315              MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_mpi( &p, buf, s ) );
    316              MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_mpi( &p, buf, r ) );
    317          
    318              MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_len( &p, buf, len ) );
    319              MBEDTLS_ASN1_CHK_ADD( len, mbedtls_asn1_write_tag( &p, buf,
    320                                                 MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) );
    321          
    322              memcpy( sig, p, len );
    323              *slen = len;
    324          
    325              return( 0 );
    326          }
    327          
    328          /*
    329           * Compute and write signature
    330           */
    331          int mbedtls_ecdsa_write_signature( mbedtls_ecdsa_context *ctx, mbedtls_md_type_t md_alg,
    332                                     const unsigned char *hash, size_t hlen,
    333                                     unsigned char *sig, size_t *slen,
    334                                     int (*f_rng)(void *, unsigned char *, size_t),
    335                                     void *p_rng )
    336          {
    337              int ret;
    338              mbedtls_mpi r, s;
    339          
    340              mbedtls_mpi_init( &r );
    341              mbedtls_mpi_init( &s );
    342          
    343          #if defined(MBEDTLS_ECDSA_DETERMINISTIC)
    344              (void) f_rng;
    345              (void) p_rng;
    346          
    347              MBEDTLS_MPI_CHK( mbedtls_ecdsa_sign_det( &ctx->grp, &r, &s, &ctx->d,
    348                                       hash, hlen, md_alg ) );
    349          #else
    350              (void) md_alg;
    351          
    352              MBEDTLS_MPI_CHK( mbedtls_ecdsa_sign( &ctx->grp, &r, &s, &ctx->d,
    353                                   hash, hlen, f_rng, p_rng ) );
    354          #endif
    355          
    356              MBEDTLS_MPI_CHK( ecdsa_signature_to_asn1( &r, &s, sig, slen ) );
    357          
    358          cleanup:
    359              mbedtls_mpi_free( &r );
    360              mbedtls_mpi_free( &s );
    361          
    362              return( ret );
    363          }
    364          
    365          #if ! defined(MBEDTLS_DEPRECATED_REMOVED) && \
    366              defined(MBEDTLS_ECDSA_DETERMINISTIC)
    367          int mbedtls_ecdsa_write_signature_det( mbedtls_ecdsa_context *ctx,
    368                                         const unsigned char *hash, size_t hlen,
    369                                         unsigned char *sig, size_t *slen,
    370                                         mbedtls_md_type_t md_alg )
    371          {
    372              return( mbedtls_ecdsa_write_signature( ctx, md_alg, hash, hlen, sig, slen,
    373                                             NULL, NULL ) );
    374          }
    375          #endif
    376          
    377          /*
    378           * Read and check signature
    379           */
    380          int mbedtls_ecdsa_read_signature( mbedtls_ecdsa_context *ctx,
    381                                    const unsigned char *hash, size_t hlen,
    382                                    const unsigned char *sig, size_t slen )
    383          {
    384              int ret;
    385              unsigned char *p = (unsigned char *) sig;
    386              const unsigned char *end = sig + slen;
    387              size_t len;
    388              mbedtls_mpi r, s;
    389          
    390              mbedtls_mpi_init( &r );
    391              mbedtls_mpi_init( &s );
    392          
    393              if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
    394                              MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
    395              {
    396                  ret += MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    397                  goto cleanup;
    398              }
    399          
    400              if( p + len != end )
    401              {
    402                  ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA +
    403                        MBEDTLS_ERR_ASN1_LENGTH_MISMATCH;
    404                  goto cleanup;
    405              }
    406          
    407              if( ( ret = mbedtls_asn1_get_mpi( &p, end, &r ) ) != 0 ||
    408                  ( ret = mbedtls_asn1_get_mpi( &p, end, &s ) ) != 0 )
    409              {
    410                  ret += MBEDTLS_ERR_ECP_BAD_INPUT_DATA;
    411                  goto cleanup;
    412              }
    413          
    414              if( ( ret = mbedtls_ecdsa_verify( &ctx->grp, hash, hlen,
    415                                        &ctx->Q, &r, &s ) ) != 0 )
    416                  goto cleanup;
    417          
    418              /* At this point we know that the buffer starts with a valid signature.
    419               * Return 0 if the buffer just contains the signature, and a specific
    420               * error code if the valid signature is followed by more data. */
    421              if( p != end )
    422                  ret = MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH;
    423          
    424          cleanup:
    425              mbedtls_mpi_free( &r );
    426              mbedtls_mpi_free( &s );
    427          
    428              return( ret );
    429          }
    430          
    431          #if !defined(MBEDTLS_ECDSA_GENKEY_ALT)
    432          /*
    433           * Generate key pair
    434           */
    435          int mbedtls_ecdsa_genkey( mbedtls_ecdsa_context *ctx, mbedtls_ecp_group_id gid,
    436                            int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    437          {
    438              int ret = 0;
    439              ret = mbedtls_ecp_group_load( &ctx->grp, gid );
    440              if( ret != 0 )
    441                  return( ret );
    442          
    443             return( mbedtls_ecp_gen_keypair( &ctx->grp, &ctx->d,
    444                                              &ctx->Q, f_rng, p_rng ) );
    445          }
    446          #endif /* MBEDTLS_ECDSA_GENKEY_ALT */
    447          
    448          /*
    449           * Set context from an mbedtls_ecp_keypair
    450           */
    451          int mbedtls_ecdsa_from_keypair( mbedtls_ecdsa_context *ctx, const mbedtls_ecp_keypair *key )
    452          {
    453              int ret;
    454          
    455              if( ( ret = mbedtls_ecp_group_copy( &ctx->grp, &key->grp ) ) != 0 ||
    456                  ( ret = mbedtls_mpi_copy( &ctx->d, &key->d ) ) != 0 ||
    457                  ( ret = mbedtls_ecp_copy( &ctx->Q, &key->Q ) ) != 0 )
    458              {
    459                  mbedtls_ecdsa_free( ctx );
    460              }
    461          
    462              return( ret );
    463          }
    464          
    465          /*
    466           * Initialize context
    467           */
    468          void mbedtls_ecdsa_init( mbedtls_ecdsa_context *ctx )
    469          {
    470              mbedtls_ecp_keypair_init( ctx );
    471          }
    472          
    473          /*
    474           * Free context
    475           */
    476          void mbedtls_ecdsa_free( mbedtls_ecdsa_context *ctx )
    477          {
    478              mbedtls_ecp_keypair_free( ctx );
    479          }
    480          
    481          #endif /* MBEDTLS_ECDSA_C */


 
 
 0 bytes of memory

Errors: none
Warnings: none
