###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:14
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\protocol\zigbee\app\framework\util\attribute-storage.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EWB81F.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\protocol\zigbee\app\framework\util\attribute-storage.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"attribute-storage.c\"" -D PSSTORE_SIZE=0 -D
#        LONGTOKEN_SIZE=0 -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\protocol\zigbee\app\framework\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\attribute-storage.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\attribute-storage.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\protocol\zigbee\app\framework\util\attribute-storage.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Contains the per-endpoint configuration of attribute tables.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc. Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement. This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          
     18          #include "app/framework/include/af.h"
     19          #include "attribute-storage.h"
     20          #include "common.h"
     21          
     22          #include "znet-bookkeeping.h"
     23          
     24          //------------------------------------------------------------------------------
     25          // Globals
     26          // This is not declared CONST in order to handle dynamic endpoint information
     27          // retrieved from tokens.

   \                                 In section .bss, align 4
     28          EmberAfDefinedEndpoint emAfEndpoints[MAX_ENDPOINT_COUNT];
   \                     emAfEndpoints:
   \        0x0                      DS8 48
     29          
     30          #if (ATTRIBUTE_MAX_SIZE == 0)
     31          #define ACTUAL_ATTRIBUTE_SIZE 1
     32          #else
     33          #define ACTUAL_ATTRIBUTE_SIZE ATTRIBUTE_MAX_SIZE
     34          #endif
     35          

   \                                 In section .bss, align 4
     36          uint8_t attributeData[ACTUAL_ATTRIBUTE_SIZE];
   \                     attributeData:
   \        0x0                      DS8 160
     37          
     38          #if (!defined(ATTRIBUTE_SINGLETONS_SIZE)) \
     39            || (ATTRIBUTE_SINGLETONS_SIZE == 0)
     40          #define ACTUAL_SINGLETONS_SIZE 1
     41          #else
     42          #define ACTUAL_SINGLETONS_SIZE ATTRIBUTE_SINGLETONS_SIZE
     43          #endif

   \                                 In section .bss, align 4
     44          uint8_t singletonAttributeData[ACTUAL_SINGLETONS_SIZE];
   \                     singletonAttributeData:
   \        0x0                      DS8 192
     45          

   \                                 In section .bss, align 1
     46          uint8_t emberEndpointCount = 0;
   \                     emberEndpointCount:
   \        0x0                      DS8 1
     47          
     48          // If we have attributes that are more than 2 bytes, then
     49          // we need this data block for the defaults
     50          #ifdef GENERATED_DEFAULTS

   \                                 In section .rodata, align 4
     51          const uint8_t generatedDefaults[]               = GENERATED_DEFAULTS;
   \                     generatedDefaults:
   \        0x0   0x2F 0xAC          DC8 47, 172, 9, 255, 255, 255, 90, 105, 103, 66, 101, 101, 65, 108, 108
   \              0x09 0xFF    
   \              0xFF 0xFF    
   \              0x5A 0x69    
   \              0x67 0x42    
   \              0x65 0x65    
   \              0x41 0x6C    
   \              0x6C         
   \        0xF   0x69 0x61          DC8 105, 97, 110, 99, 101, 48, 57, 0, 0
   \              0x6E 0x63    
   \              0x65 0x30    
   \              0x39 0x00    
   \              0x00         
     52          #endif // GENERATED_DEFAULTS
     53          
     54          #ifdef GENERATED_MIN_MAX_DEFAULTS
     55          const EmberAfAttributeMinMaxValue minMaxDefaults[]          = GENERATED_MIN_MAX_DEFAULTS;
     56          #endif //GENERATED_MIN_MAX_DEFAULTS
     57          
     58          #ifdef GENERATED_FUNCTION_ARRAYS

   \                                 In section .rodata, align 4
     59          GENERATED_FUNCTION_ARRAYS
   \                     emberAfFuncArrayIdentifyClusterServer:
   \        0x0   0x....'....        DC32 emberAfIdentifyClusterServerInitCallback
   \        0x4   0x....'....        DC32 emberAfIdentifyClusterServerAttributeChangedCallback

   \                                 In section .rodata, align 4
   \   __absolute void (*)(void) const emberAfFuncArrayGroupsClusterServer[1]
   \                     emberAfFuncArrayGroupsClusterServer:
   \        0x0   0x....'....        DC32 emberAfGroupsClusterServerInitCallback

   \                                 In section .rodata, align 4
   \   __absolute void (*)(void) const emberAfFuncArrayScenesClusterServer[1]
   \                     emberAfFuncArrayScenesClusterServer:
   \        0x0   0x....'....        DC32 emberAfScenesClusterServerInitCallback

   \                                 In section .rodata, align 4
   \   __absolute void (*)(void) const emberAfFuncArrayOnOffClusterServer[1]
   \                     emberAfFuncArrayOnOffClusterServer:
   \        0x0   0x....'....        DC32 emberAfOnOffClusterServerInitCallback

   \                                 In section .rodata, align 4
   \   __absolute void (*)(void) const emberAfFuncArrayLevelControlClusterServer[1]
   \                     emberAfFuncArrayLevelControlClusterServer:
   \        0x0   0x....'....        DC32 emberAfLevelControlClusterServerInitCallback

   \                                 In section .rodata, align 4
   \   __absolute void (*)(void) const emberAfFuncArrayColorControlClusterServer[1]
   \                     emberAfFuncArrayColorControlClusterServer:
   \        0x0   0x....'....        DC32 emberAfColorControlClusterServerInitCallback
     60          #endif
     61          
     62          #ifdef EMBER_AF_SUPPORT_COMMAND_DISCOVERY

   \                                 In section .rodata, align 4
     63          const EmberAfCommandMetadata generatedCommands[] = GENERATED_COMMANDS;
   \                     generatedCommands:
   \        0x0   0x0000             DC16 0
   \        0x2   0x00 0x08          DC8 0, 8
   \        0x4   0x0003             DC16 3
   \        0x6   0x00 0x02          DC8 0, 2
   \        0x8   0x0003             DC16 3
   \        0xA   0x00 0x08          DC8 0, 8
   \        0xC   0x0003             DC16 3
   \        0xE   0x01 0x08          DC8 1, 8
   \       0x10   0x0003             DC16 3
   \       0x12   0x40 0x08          DC8 64, 8
   \       0x14   0x0004             DC16 4
   \       0x16   0x00 0x02          DC8 0, 2
   \       0x18   0x0004             DC16 4
   \       0x1A   0x00 0x08          DC8 0, 8
   \       0x1C   0x0004             DC16 4
   \       0x1E   0x01 0x02          DC8 1, 2
   \       0x20   0x0004             DC16 4
   \       0x22   0x01 0x08          DC8 1, 8
   \       0x24   0x0004             DC16 4
   \       0x26   0x02 0x02          DC8 2, 2
   \       0x28   0x0004             DC16 4
   \       0x2A   0x02 0x08          DC8 2, 8
   \       0x2C   0x0004             DC16 4
   \       0x2E   0x03 0x02          DC8 3, 2
   \       0x30   0x0004             DC16 4
   \       0x32   0x03 0x08          DC8 3, 8
   \       0x34   0x0004             DC16 4
   \       0x36   0x04 0x08          DC8 4, 8
   \       0x38   0x0004             DC16 4
   \       0x3A   0x05 0x08          DC8 5, 8
   \       0x3C   0x0005             DC16 5
   \       0x3E   0x00 0x02          DC8 0, 2
   \       0x40   0x0005             DC16 5
   \       0x42   0x00 0x08          DC8 0, 8
   \       0x44   0x0005             DC16 5
   \       0x46   0x01 0x02          DC8 1, 2
   \       0x48   0x0005             DC16 5
   \       0x4A   0x01 0x08          DC8 1, 8
   \       0x4C   0x0005             DC16 5
   \       0x4E   0x02 0x02          DC8 2, 2
   \       0x50   0x0005             DC16 5
   \       0x52   0x02 0x08          DC8 2, 8
   \       0x54   0x0005             DC16 5
   \       0x56   0x03 0x02          DC8 3, 2
   \       0x58   0x0005             DC16 5
   \       0x5A   0x03 0x08          DC8 3, 8
   \       0x5C   0x0005             DC16 5
   \       0x5E   0x04 0x02          DC8 4, 2
   \       0x60   0x0005             DC16 5
   \       0x62   0x04 0x08          DC8 4, 8
   \       0x64   0x0005             DC16 5
   \       0x66   0x05 0x08          DC8 5, 8
   \       0x68   0x0005             DC16 5
   \       0x6A   0x06 0x02          DC8 6, 2
   \       0x6C   0x0005             DC16 5
   \       0x6E   0x06 0x08          DC8 6, 8
   \       0x70   0x0005             DC16 5
   \       0x72   0x40 0x08          DC8 64, 8
   \       0x74   0x0005             DC16 5
   \       0x76   0x41 0x08          DC8 65, 8
   \       0x78   0x0005             DC16 5
   \       0x7A   0x42 0x08          DC8 66, 8
   \       0x7C   0x0006             DC16 6
   \       0x7E   0x00 0x08          DC8 0, 8
   \       0x80   0x0006             DC16 6
   \       0x82   0x01 0x08          DC8 1, 8
   \       0x84   0x0006             DC16 6
   \       0x86   0x02 0x08          DC8 2, 8
   \       0x88   0x0006             DC16 6
   \       0x8A   0x40 0x08          DC8 64, 8
   \       0x8C   0x0006             DC16 6
   \       0x8E   0x41 0x08          DC8 65, 8
   \       0x90   0x0006             DC16 6
   \       0x92   0x42 0x08          DC8 66, 8
   \       0x94   0x0008             DC16 8
   \       0x96   0x00 0x08          DC8 0, 8
   \       0x98   0x0008             DC16 8
   \       0x9A   0x01 0x08          DC8 1, 8
   \       0x9C   0x0008             DC16 8
   \       0x9E   0x02 0x08          DC8 2, 8
   \       0xA0   0x0008             DC16 8
   \       0xA2   0x03 0x08          DC8 3, 8
   \       0xA4   0x0008             DC16 8
   \       0xA6   0x04 0x08          DC8 4, 8
   \       0xA8   0x0008             DC16 8
   \       0xAA   0x05 0x08          DC8 5, 8
   \       0xAC   0x0008             DC16 8
   \       0xAE   0x06 0x08          DC8 6, 8
   \       0xB0   0x0008             DC16 8
   \       0xB2   0x07 0x08          DC8 7, 8
   \       0xB4   0x0021             DC16 33
   \       0xB6   0x00 0x04          DC8 0, 4
   \       0xB8   0x0021             DC16 33
   \       0xBA   0x01 0x04          DC8 1, 4
   \       0xBC   0x0021             DC16 33
   \       0xBE   0x02 0x04          DC8 2, 4
   \       0xC0   0x0021             DC16 33
   \       0xC2   0x06 0x04          DC8 6, 4
   \       0xC4   0x0021             DC16 33
   \       0xC6   0x0A 0x04          DC8 10, 4
   \       0xC8   0x0021             DC16 33
   \       0xCA   0x0B 0x04          DC8 11, 4
   \       0xCC   0x0300             DC16 768
   \       0xCE   0x00 0x08          DC8 0, 8
   \       0xD0   0x0300             DC16 768
   \       0xD2   0x01 0x08          DC8 1, 8
   \       0xD4   0x0300             DC16 768
   \       0xD6   0x02 0x08          DC8 2, 8
   \       0xD8   0x0300             DC16 768
   \       0xDA   0x03 0x08          DC8 3, 8
   \       0xDC   0x0300             DC16 768
   \       0xDE   0x04 0x08          DC8 4, 8
   \       0xE0   0x0300             DC16 768
   \       0xE2   0x05 0x08          DC8 5, 8
   \       0xE4   0x0300             DC16 768
   \       0xE6   0x06 0x08          DC8 6, 8
   \       0xE8   0x0300             DC16 768
   \       0xEA   0x07 0x08          DC8 7, 8
   \       0xEC   0x0300             DC16 768
   \       0xEE   0x08 0x08          DC8 8, 8
   \       0xF0   0x0300             DC16 768
   \       0xF2   0x09 0x08          DC8 9, 8
   \       0xF4   0x0300             DC16 768
   \       0xF6   0x0A 0x08          DC8 10, 8
   \       0xF8   0x0300             DC16 768
   \       0xFA   0x47 0x08          DC8 71, 8
   \       0xFC   0x0300             DC16 768
   \       0xFE   0x4B 0x08          DC8 75, 8
   \      0x100   0x0300             DC16 768
   \      0x102   0x4C 0x08          DC8 76, 8
   \      0x104   0x1000             DC16 4096
   \      0x106   0x01 0x02          DC8 1, 2
   \      0x108   0x1000             DC16 4096
   \      0x10A   0x03 0x02          DC8 3, 2
   \      0x10C   0x1000             DC16 4096
   \      0x10E   0x11 0x02          DC8 17, 2
   \      0x110   0x1000             DC16 4096
   \      0x112   0x13 0x02          DC8 19, 2
   \      0x114   0x1000             DC16 4096
   \      0x116   0x15 0x02          DC8 21, 2
   \      0x118   0x1000             DC16 4096
   \      0x11A   0x40 0x02          DC8 64, 2
   \      0x11C   0x1000             DC16 4096
   \      0x11E   0x41 0x02          DC8 65, 2
   \      0x120   0x1000             DC16 4096
   \      0x122   0x41 0x08          DC8 65, 8
   \      0x124   0x1000             DC16 4096
   \      0x126   0x42 0x02          DC8 66, 2
   \      0x128   0x1000             DC16 4096
   \      0x12A   0x42 0x08          DC8 66, 8

   \                                 In section .rodata, align 4
     64          const EmberAfManufacturerCodeEntry commandManufacturerCodes[] = GENERATED_COMMAND_MANUFACTURER_CODES;
   \                     commandManufacturerCodes:
   \        0x0   0x0000 0x0000      DC16 0, 0

   \                                 In section .rodata, align 2
     65          const uint16_t commandManufacturerCodeCount = GENERATED_COMMAND_MANUFACTURER_CODE_COUNT;
   \                     commandManufacturerCodeCount:
   \        0x0   0x0000             DC16 0
     66          #endif
     67          

   \                                 In section .rodata, align 4
     68          const EmberAfAttributeMetadata generatedAttributes[] = GENERATED_ATTRIBUTES;
   \                     generatedAttributes:
   \        0x0   0x0000             DC16 0
   \        0x2   0x20 0x01          DC8 32, 1, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \        0x8   0x0000'0003        DC32 3H
   \        0xC   0x0001             DC16 1
   \        0xE   0x20 0x01          DC8 32, 1, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \       0x14   0x0000'0000        DC32 0H
   \       0x18   0x0002             DC16 2
   \       0x1A   0x20 0x01          DC8 32, 1, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \       0x20   0x0000'0000        DC32 0H
   \       0x24   0x0003             DC16 3
   \       0x26   0x20 0x01          DC8 32, 1, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \       0x2C   0x0000'0000        DC32 0H
   \       0x30   0x0004             DC16 4
   \       0x32   0x42 0x21          DC8 66, 33, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \       0x38   0x0000'0000        DC32 0H
   \       0x3C   0x0005             DC16 5
   \       0x3E   0x42 0x21          DC8 66, 33, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \       0x44   0x0000'0000        DC32 0H
   \       0x48   0x0006             DC16 6
   \       0x4A   0x42 0x11          DC8 66, 17, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \       0x50   0x0000'0000        DC32 0H
   \       0x54   0x0007             DC16 7
   \       0x56   0x30 0x01          DC8 48, 1, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \       0x5C   0x0000'0000        DC32 0H
   \       0x60   0x0008             DC16 8
   \       0x62   0x30 0x01          DC8 48, 1, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \       0x68   0x0000'00FF        DC32 0FFH
   \       0x6C   0x0009             DC16 9
   \       0x6E   0x30 0x01          DC8 48, 1, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \       0x74   0x0000'00FF        DC32 0FFH
   \       0x78   0x000A             DC16 10
   \       0x7A   0x41 0x11          DC8 65, 17, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \       0x80   0x0000'0000        DC32 0H
   \       0x84   0x000B             DC16 11
   \       0x86   0x42 0x41          DC8 66, 65, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \       0x8C   0x0000'0000        DC32 0H
   \       0x90   0x4000             DC16 16384
   \       0x92   0x42 0x11          DC8 66, 17, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \       0x98   0x0000'0000        DC32 0H
   \       0x9C   0xFFFD             DC16 65533
   \       0x9E   0x21 0x02          DC8 33, 2, 32, 0, 0, 0
   \              0x20 0x00    
   \              0x00 0x00    
   \       0xA4   0x0000'0001        DC32 1H
   \       0xA8   0x0000             DC16 0
   \       0xAA   0x21 0x02          DC8 33, 2, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x00    
   \       0xB0   0x0000'0000        DC32 0H
   \       0xB4   0xFFFD             DC16 65533
   \       0xB6   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \       0xBC   0x0000'0001        DC32 1H
   \       0xC0   0x0000             DC16 0
   \       0xC2   0x18 0x01          DC8 24, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \       0xC8   0x0000'0000        DC32 0H
   \       0xCC   0xFFFD             DC16 65533
   \       0xCE   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \       0xD4   0x0000'0001        DC32 1H
   \       0xD8   0x0000             DC16 0
   \       0xDA   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \       0xE0   0x0000'0000        DC32 0H
   \       0xE4   0x0001             DC16 1
   \       0xE6   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \       0xEC   0x0000'0000        DC32 0H
   \       0xF0   0x0002             DC16 2
   \       0xF2   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \       0xF8   0x0000'0000        DC32 0H
   \       0xFC   0x0003             DC16 3
   \       0xFE   0x10 0x01          DC8 16, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x104   0x0000'0000        DC32 0H
   \      0x108   0x0004             DC16 4
   \      0x10A   0x18 0x01          DC8 24, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x110   0x0000'0000        DC32 0H
   \      0x114   0xFFFD             DC16 65533
   \      0x116   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x11C   0x0000'0001        DC32 1H
   \      0x120   0x0000             DC16 0
   \      0x122   0x10 0x01          DC8 16, 1, 2, 0, 0, 0
   \              0x02 0x00    
   \              0x00 0x00    
   \      0x128   0x0000'0000        DC32 0H
   \      0x12C   0x4000             DC16 16384
   \      0x12E   0x10 0x01          DC8 16, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x134   0x0000'0001        DC32 1H
   \      0x138   0x4001             DC16 16385
   \      0x13A   0x21 0x02          DC8 33, 2, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x00    
   \      0x140   0x0000'0000        DC32 0H
   \      0x144   0x4002             DC16 16386
   \      0x146   0x21 0x02          DC8 33, 2, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x00    
   \      0x14C   0x0000'0000        DC32 0H
   \      0x150   0x4003             DC16 16387
   \      0x152   0x30 0x01          DC8 48, 1, 3, 0, 0, 0
   \              0x03 0x00    
   \              0x00 0x00    
   \      0x158   0x0000'00FF        DC32 0FFH
   \      0x15C   0xFFFD             DC16 65533
   \      0x15E   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x164   0x0000'0001        DC32 1H
   \      0x168   0x0000             DC16 0
   \      0x16A   0x20 0x01          DC8 32, 1, 2, 0, 0, 0
   \              0x02 0x00    
   \              0x00 0x00    
   \      0x170   0x0000'0000        DC32 0H
   \      0x174   0x0001             DC16 1
   \      0x176   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x17C   0x0000'0000        DC32 0H
   \      0x180   0x000F             DC16 15
   \      0x182   0x18 0x01          DC8 24, 1, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x00    
   \      0x188   0x0000'0000        DC32 0H
   \      0x18C   0x4000             DC16 16384
   \      0x18E   0x20 0x01          DC8 32, 1, 3, 0, 0, 0
   \              0x03 0x00    
   \              0x00 0x00    
   \      0x194   0x0000'0033        DC32 33H
   \      0x198   0xFFFD             DC16 65533
   \      0x19A   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x1A0   0x0000'0001        DC32 1H
   \      0x1A4   0x0010             DC16 16
   \      0x1A6   0x20 0x01          DC8 32, 1, 64, 0, 0, 0
   \              0x40 0x00    
   \              0x00 0x00    
   \      0x1AC   0x0000'0014        DC32 14H
   \      0x1B0   0x0011             DC16 17
   \      0x1B2   0x43 0x02          DC8 67, 2, 64, 0, 0, 0
   \              0x40 0x00    
   \              0x00 0x00    
   \      0x1B8   0x0000'0000        DC32 0H
   \      0x1BC   0x0016             DC16 22
   \      0x1BE   0x1A 0x03          DC8 26, 3, 64, 0, 0, 0
   \              0x40 0x00    
   \              0x00 0x00    
   \      0x1C4   0x....'....        DC32 generatedDefaults
   \      0x1C8   0x0017             DC16 23
   \      0x1CA   0x1A 0x03          DC8 26, 3, 64, 0, 0, 0
   \              0x40 0x00    
   \              0x00 0x00    
   \      0x1D0   0x....'....        DC32 generatedDefaults + 3H
   \      0x1D4   0x0022             DC16 34
   \      0x1D6   0xF1 0x10          DC8 241, 16, 65, 0, 0, 0
   \              0x41 0x00    
   \              0x00 0x00    
   \      0x1DC   0x....'....        DC32 generatedDefaults + 6H
   \      0x1E0   0xFFFD             DC16 65533
   \      0x1E2   0x21 0x02          DC8 33, 2, 64, 0, 0, 0
   \              0x40 0x00    
   \              0x00 0x00    
   \      0x1E8   0x0000'0001        DC32 1H
   \      0x1EC   0x0000             DC16 0
   \      0x1EE   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x1F4   0x0000'0000        DC32 0H
   \      0x1F8   0x0001             DC16 1
   \      0x1FA   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x200   0x0000'0000        DC32 0H
   \      0x204   0x0002             DC16 2
   \      0x206   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x20C   0x0000'0000        DC32 0H
   \      0x210   0x0003             DC16 3
   \      0x212   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x218   0x0000'616B        DC32 616BH
   \      0x21C   0x0004             DC16 4
   \      0x21E   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x224   0x0000'607D        DC32 607DH
   \      0x228   0x0007             DC16 7
   \      0x22A   0x21 0x02          DC8 33, 2, 2, 0, 0, 0
   \              0x02 0x00    
   \              0x00 0x00    
   \      0x230   0x0000'00FA        DC32 0FAH
   \      0x234   0x0008             DC16 8
   \      0x236   0x30 0x01          DC8 48, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x23C   0x0000'0001        DC32 1H
   \      0x240   0x000F             DC16 15
   \      0x242   0x18 0x01          DC8 24, 1, 1, 0, 0, 0
   \              0x01 0x00    
   \              0x00 0x00    
   \      0x248   0x0000'0000        DC32 0H
   \      0x24C   0x0010             DC16 16
   \      0x24E   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x254   0x0000'0000        DC32 0H
   \      0x258   0x0011             DC16 17
   \      0x25A   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x260   0x0000'0000        DC32 0H
   \      0x264   0x0012             DC16 18
   \      0x266   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x26C   0x0000'0000        DC32 0H
   \      0x270   0x0013             DC16 19
   \      0x272   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x278   0x0000'0000        DC32 0H
   \      0x27C   0x0015             DC16 21
   \      0x27E   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x284   0x0000'0000        DC32 0H
   \      0x288   0x0016             DC16 22
   \      0x28A   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x290   0x0000'0000        DC32 0H
   \      0x294   0x0017             DC16 23
   \      0x296   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x29C   0x0000'0000        DC32 0H
   \      0x2A0   0x0019             DC16 25
   \      0x2A2   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x2A8   0x0000'0000        DC32 0H
   \      0x2AC   0x001A             DC16 26
   \      0x2AE   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x2B4   0x0000'0000        DC32 0H
   \      0x2B8   0x001B             DC16 27
   \      0x2BA   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x2C0   0x0000'0000        DC32 0H
   \      0x2C4   0x0020             DC16 32
   \      0x2C6   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x2CC   0x0000'0000        DC32 0H
   \      0x2D0   0x0021             DC16 33
   \      0x2D2   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x2D8   0x0000'0000        DC32 0H
   \      0x2DC   0x0022             DC16 34
   \      0x2DE   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x2E4   0x0000'0000        DC32 0H
   \      0x2E8   0x0024             DC16 36
   \      0x2EA   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x2F0   0x0000'0000        DC32 0H
   \      0x2F4   0x0025             DC16 37
   \      0x2F6   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x2FC   0x0000'0000        DC32 0H
   \      0x300   0x0026             DC16 38
   \      0x302   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x308   0x0000'0000        DC32 0H
   \      0x30C   0x0028             DC16 40
   \      0x30E   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x314   0x0000'0000        DC32 0H
   \      0x318   0x0029             DC16 41
   \      0x31A   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x320   0x0000'0000        DC32 0H
   \      0x324   0x002A             DC16 42
   \      0x326   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x32C   0x0000'0000        DC32 0H
   \      0x330   0x4000             DC16 16384
   \      0x332   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x338   0x0000'0000        DC32 0H
   \      0x33C   0x4001             DC16 16385
   \      0x33E   0x30 0x01          DC8 48, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x344   0x0000'0001        DC32 1H
   \      0x348   0x4002             DC16 16386
   \      0x34A   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x350   0x0000'0000        DC32 0H
   \      0x354   0x4003             DC16 16387
   \      0x356   0x20 0x01          DC8 32, 1, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x35C   0x0000'0000        DC32 0H
   \      0x360   0x4004             DC16 16388
   \      0x362   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x368   0x0000'0019        DC32 19H
   \      0x36C   0x4005             DC16 16389
   \      0x36E   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x374   0x0000'2300        DC32 2300H
   \      0x378   0x4006             DC16 16390
   \      0x37A   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x380   0x0000'0000        DC32 0H
   \      0x384   0x400A             DC16 16394
   \      0x386   0x19 0x02          DC8 25, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x38C   0x0000'0000        DC32 0H
   \      0x390   0x400B             DC16 16395
   \      0x392   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x398   0x0000'0000        DC32 0H
   \      0x39C   0x400C             DC16 16396
   \      0x39E   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x3A4   0x0000'FEFF        DC32 0FEFFH
   \      0x3A8   0x400D             DC16 16397
   \      0x3AA   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x3B0   0x0000'0000        DC32 0H
   \      0x3B4   0x4010             DC16 16400
   \      0x3B6   0x21 0x02          DC8 33, 2, 3, 0, 0, 0
   \              0x03 0x00    
   \              0x00 0x00    
   \      0x3BC   0x0000'4444        DC32 4444H
   \      0x3C0   0xFFFD             DC16 65533
   \      0x3C2   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x3C8   0x0000'0001        DC32 1H
   \      0x3CC   0xFFFD             DC16 65533
   \      0x3CE   0x21 0x02          DC8 33, 2, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \      0x3D4   0x0000'0001        DC32 1H

   \                                 In section .rodata, align 4
     69          const EmberAfCluster generatedClusters[]          = GENERATED_CLUSTERS;
   \                     generatedClusters:
   \        0x0   0x0000             DC16 0
   \        0x2   0x00 0x00          DC8 0, 0
   \        0x4   0x....'....        DC32 generatedAttributes
   \        0x8   0x000E 0x0000      DC16 14, 0
   \        0xC   0x40 0x00          DC8 64, 0, 0, 0
   \              0x00 0x00    
   \       0x10   0x0000'0000        DC32 0H
   \       0x14   0x0003             DC16 3
   \       0x16   0x00 0x00          DC8 0, 0
   \       0x18   0x....'....        DC32 generatedAttributes + 0A8H
   \       0x1C   0x0002 0x0004      DC16 2, 4
   \       0x20   0x43 0x00          DC8 67, 0, 0, 0
   \              0x00 0x00    
   \       0x24   0x....'....        DC32 emberAfFuncArrayIdentifyClusterServer
   \       0x28   0x0004             DC16 4
   \       0x2A   0x00 0x00          DC8 0, 0
   \       0x2C   0x....'....        DC32 generatedAttributes + 0C0H
   \       0x30   0x0002 0x0003      DC16 2, 3
   \       0x34   0x41 0x00          DC8 65, 0, 0, 0
   \              0x00 0x00    
   \       0x38   0x....'....        DC32 emberAfFuncArrayGroupsClusterServer
   \       0x3C   0x0005             DC16 5
   \       0x3E   0x00 0x00          DC8 0, 0
   \       0x40   0x....'....        DC32 generatedAttributes + 0D8H
   \       0x44   0x0006 0x0008      DC16 6, 8
   \       0x48   0x41 0x00          DC8 65, 0, 0, 0
   \              0x00 0x00    
   \       0x4C   0x....'....        DC32 emberAfFuncArrayScenesClusterServer
   \       0x50   0x0006             DC16 6
   \       0x52   0x00 0x00          DC8 0, 0
   \       0x54   0x....'....        DC32 generatedAttributes + 120H
   \       0x58   0x0006 0x0009      DC16 6, 9
   \       0x5C   0x41 0x00          DC8 65, 0, 0, 0
   \              0x00 0x00    
   \       0x60   0x....'....        DC32 emberAfFuncArrayOnOffClusterServer
   \       0x64   0x0008             DC16 8
   \       0x66   0x00 0x00          DC8 0, 0
   \       0x68   0x....'....        DC32 generatedAttributes + 168H
   \       0x6C   0x0005 0x0007      DC16 5, 7
   \       0x70   0x41 0x00          DC8 65, 0, 0, 0
   \              0x00 0x00    
   \       0x74   0x....'....        DC32 emberAfFuncArrayLevelControlClusterServer
   \       0x78   0x0000             DC16 0
   \       0x7A   0x00 0x00          DC8 0, 0
   \       0x7C   0x....'....        DC32 generatedAttributes
   \       0x80   0x000E 0x0000      DC16 14, 0
   \       0x84   0x40 0x00          DC8 64, 0, 0, 0
   \              0x00 0x00    
   \       0x88   0x0000'0000        DC32 0H
   \       0x8C   0x0003             DC16 3
   \       0x8E   0x00 0x00          DC8 0, 0
   \       0x90   0x....'....        DC32 generatedAttributes + 0A8H
   \       0x94   0x0002 0x0004      DC16 2, 4
   \       0x98   0x43 0x00          DC8 67, 0, 0, 0
   \              0x00 0x00    
   \       0x9C   0x....'....        DC32 emberAfFuncArrayIdentifyClusterServer
   \       0xA0   0x0004             DC16 4
   \       0xA2   0x00 0x00          DC8 0, 0
   \       0xA4   0x....'....        DC32 generatedAttributes + 0C0H
   \       0xA8   0x0002 0x0003      DC16 2, 3
   \       0xAC   0x41 0x00          DC8 65, 0, 0, 0
   \              0x00 0x00    
   \       0xB0   0x....'....        DC32 emberAfFuncArrayGroupsClusterServer
   \       0xB4   0x0005             DC16 5
   \       0xB6   0x00 0x00          DC8 0, 0
   \       0xB8   0x....'....        DC32 generatedAttributes + 0D8H
   \       0xBC   0x0006 0x0008      DC16 6, 8
   \       0xC0   0x41 0x00          DC8 65, 0, 0, 0
   \              0x00 0x00    
   \       0xC4   0x....'....        DC32 emberAfFuncArrayScenesClusterServer
   \       0xC8   0x0006             DC16 6
   \       0xCA   0x00 0x00          DC8 0, 0
   \       0xCC   0x....'....        DC32 generatedAttributes + 120H
   \       0xD0   0x0006 0x0009      DC16 6, 9
   \       0xD4   0x41 0x00          DC8 65, 0, 0, 0
   \              0x00 0x00    
   \       0xD8   0x....'....        DC32 emberAfFuncArrayOnOffClusterServer
   \       0xDC   0x0008             DC16 8
   \       0xDE   0x00 0x00          DC8 0, 0
   \       0xE0   0x....'....        DC32 generatedAttributes + 168H
   \       0xE4   0x0005 0x0007      DC16 5, 7
   \       0xE8   0x41 0x00          DC8 65, 0, 0, 0
   \              0x00 0x00    
   \       0xEC   0x....'....        DC32 emberAfFuncArrayLevelControlClusterServer
   \       0xF0   0x0300             DC16 768
   \       0xF2   0x00 0x00          DC8 0, 0
   \       0xF4   0x....'....        DC32 generatedAttributes + 1ECH
   \       0xF8   0x0028 0x0042      DC16 40, 66
   \       0xFC   0x41 0x00          DC8 65, 0, 0, 0
   \              0x00 0x00    
   \      0x100   0x....'....        DC32 emberAfFuncArrayColorControlClusterServer
   \      0x104   0x1000             DC16 4096
   \      0x106   0x00 0x00          DC8 0, 0
   \      0x108   0x....'....        DC32 generatedAttributes + 3CCH
   \      0x10C   0x0001 0x0002      DC16 1, 2
   \      0x110   0x40 0x00          DC8 64, 0, 0, 0
   \              0x00 0x00    
   \      0x114   0x0000'0000        DC32 0H
   \      0x118   0x0021             DC16 33
   \      0x11A   0x00 0x00          DC8 0, 0
   \      0x11C   0x....'....        DC32 generatedAttributes + 1A4H
   \      0x120   0x0006 0x001B      DC16 6, 27
   \      0x124   0x80 0x00          DC8 128, 0, 0, 0
   \              0x00 0x00    
   \      0x128   0x0000'0000        DC32 0H

   \                                 In section .rodata, align 4
     70          const EmberAfEndpointType generatedEmberAfEndpointTypes[]   = GENERATED_ENDPOINT_TYPES;
   \                     generatedEmberAfEndpointTypes:
   \        0x0   0x....'....        DC32 generatedClusters
   \        0x4   0x06 0x00          DC8 6, 0
   \        0x6   0x001F             DC16 31
   \        0x8   0x....'....        DC32 generatedClusters + 78H
   \        0xC   0x08 0x00          DC8 8, 0
   \        0xE   0x0063             DC16 99
   \       0x10   0x....'....        DC32 generatedClusters + 118H
   \       0x14   0x01 0x00          DC8 1, 0
   \       0x16   0x001B             DC16 27

   \                                 In section .rodata, align 2
     71          const EmAfZigbeeProNetwork emAfZigbeeProNetworks[] = EM_AF_GENERATED_ZIGBEE_PRO_NETWORKS;
   \                     emAfZigbeeProNetworks:
   \        0x0   0x02 0x05          DC8 2, 5
     72          

   \                                 In section .rodata, align 4
     73          const EmberAfManufacturerCodeEntry clusterManufacturerCodes[] = GENERATED_CLUSTER_MANUFACTURER_CODES;
   \                     clusterManufacturerCodes:
   \        0x0   0x0000 0x0000      DC16 0, 0

   \                                 In section .rodata, align 2
     74          const uint16_t clusterManufacturerCodeCount = GENERATED_CLUSTER_MANUFACTURER_CODE_COUNT;
   \                     clusterManufacturerCodeCount:
   \        0x0   0x0000             DC16 0

   \                                 In section .rodata, align 4
     75          const EmberAfManufacturerCodeEntry attributeManufacturerCodes[] = GENERATED_ATTRIBUTE_MANUFACTURER_CODES;
   \                     attributeManufacturerCodes:
   \        0x0   0x0000 0x0000      DC16 0, 0

   \                                 In section .rodata, align 2
     76          const uint16_t attributeManufacturerCodeCount = GENERATED_ATTRIBUTE_MANUFACTURER_CODE_COUNT;
   \                     attributeManufacturerCodeCount:
   \        0x0   0x0000             DC16 0
     77          
     78          #if !defined(EMBER_SCRIPTED_TEST)
     79          #define endpointNumber(x)        fixedEndpoints[x]
     80          #define endpointProfileId(x)     fixedProfileIds[x]
     81          #define endpointDeviceId(x)      fixedDeviceIds[x]
     82          #define endpointDeviceVersion(x) fixedDeviceVersions[x]
     83          // Added 'Macro' to silence MISRA warning about conflict with synonymous vars.
     84          #define endpointTypeMacro(x)     (EmberAfEndpointType*)&(generatedEmberAfEndpointTypes[fixedEmberAfEndpointTypes[x]])
     85          #define endpointNetworkIndex(x)  fixedNetworks[x]
     86          #endif
     87          
     88          //------------------------------------------------------------------------------
     89          // Forward declarations
     90          
     91          // Returns endpoint index within a given cluster
     92          static uint8_t findClusterEndpointIndex(uint8_t endpoint, EmberAfClusterId clusterId, uint8_t mask, uint16_t manufacturerCode);
     93          
     94          //------------------------------------------------------------------------------
     95          
     96          // Initial configuration

   \                                 In section .text, align 2, keep-with-next
     97          void emberAfEndpointConfigure(void)
     98          {
     99            uint8_t ep;
    100          
    101          #if !defined(EMBER_SCRIPTED_TEST)
    102            uint8_t fixedEndpoints[] = FIXED_ENDPOINT_ARRAY;
   \                     emberAfEndpointConfigure: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable17
   \        0x4   0xB5F0             PUSH     {R4-R7,LR}
   \        0x6   0x680A             LDR      R2,[R1, #+0]
   \        0x8   0xB088             SUB      SP,SP,#+32
    103            uint16_t fixedProfileIds[] = FIXED_PROFILE_IDS;
    104            uint16_t fixedDeviceIds[] = FIXED_DEVICE_IDS;
   \        0xA   0x....'....        LDR.W    R1,??DataTable17_1
   \        0xE   0xA803             ADD      R0,SP,#+12
   \       0x10   0x6002             STR      R2,[R0, #+0]
   \       0x12   0xE9D1 0x2700      LDRD     R2,R7,[R1, #+0]
    105            uint8_t fixedDeviceVersions[] = FIXED_DEVICE_VERSIONS;
    106            uint8_t fixedEmberAfEndpointTypes[] = FIXED_ENDPOINT_TYPES;
   \       0x16   0x....'....        LDR.W    R1,??DataTable17_2
   \       0x1A   0x....'....        LDR.W    R4,??DataTable17_3
   \       0x1E   0xA804             ADD      R0,SP,#+16
   \       0x20   0xE9D4 0x5600      LDRD     R5,R6,[R4, #+0]
   \       0x24   0xE9C0 0x2700      STRD     R2,R7,[R0, #+0]
   \       0x28   0x680A             LDR      R2,[R1, #+0]
   \       0x2A   0xA801             ADD      R0,SP,#+4
   \       0x2C   0xAB06             ADD      R3,SP,#+24
   \       0x2E   0x6002             STR      R2,[R0, #+0]
   \       0x30   0xE9C3 0x5600      STRD     R5,R6,[R3, #+0]
    107            uint8_t fixedNetworks[] = FIXED_NETWORKS;
    108          #endif
    109          
    110            emberEndpointCount = FIXED_ENDPOINT_COUNT;
   \       0x34   0x2003             MOVS     R0,#+3
   \       0x36   0x....'....        LDR.W    R1,??DataTable17_4
   \       0x3A   0xAB02             ADD      R3,SP,#+8
   \       0x3C   0x2400             MOVS     R4,#+0
   \       0x3E   0x7008             STRB     R0,[R1, #+0]
   \       0x40   0x601C             STR      R4,[R3, #+0]
   \       0x42   0x9400             STR      R4,[SP, #+0]
    111            for ( ep = 0; ep < FIXED_ENDPOINT_COUNT; ep++ ) {
   \       0x44   0x2100             MOVS     R1,#+0
   \       0x46   0x....'....        LDR.W    R0,??DataTable17_5
   \       0x4A   0xAE06             ADD      R6,SP,#+24
    112              emAfEndpoints[ep].endpoint      = endpointNumber(ep);
   \                     ??emberAfEndpointConfigure_0: (+1)
   \       0x4C   0x....'....        LDR.W    R2,??DataTable17_6
   \       0x50   0xAC03             ADD      R4,SP,#+12
   \       0x52   0xEB02 0x1201      ADD      R2,R2,R1, LSL #+4
   \       0x56   0x5C65             LDRB     R5,[R4, R1]
    113              emAfEndpoints[ep].profileId     = endpointProfileId(ep);
    114              emAfEndpoints[ep].deviceId      = endpointDeviceId(ep);
   \       0x58   0xAC04             ADD      R4,SP,#+16
   \       0x5A   0x7015             STRB     R5,[R2, #+0]
   \       0x5C   0xF836 0x3011      LDRH     R3,[R6, R1, LSL #+1]
   \       0x60   0x8053             STRH     R3,[R2, #+2]
   \       0x62   0xF834 0x3011      LDRH     R3,[R4, R1, LSL #+1]
    115              emAfEndpoints[ep].deviceVersion = endpointDeviceVersion(ep);
   \       0x66   0xAC02             ADD      R4,SP,#+8
   \       0x68   0x8093             STRH     R3,[R2, #+4]
   \       0x6A   0x5C65             LDRB     R5,[R4, R1]
    116              emAfEndpoints[ep].endpointType  = endpointTypeMacro(ep);
   \       0x6C   0xAB01             ADD      R3,SP,#+4
   \       0x6E   0x7195             STRB     R5,[R2, #+6]
   \       0x70   0x5C5C             LDRB     R4,[R3, R1]
   \       0x72   0xEB00 0x05C4      ADD      R5,R0,R4, LSL #+3
   \       0x76   0x6095             STR      R5,[R2, #+8]
    117              emAfEndpoints[ep].networkIndex  = endpointNetworkIndex(ep);
   \       0x78   0xF81D 0x4001      LDRB     R4,[SP, R1]
    118              emAfEndpoints[ep].bitmask = EMBER_AF_ENDPOINT_ENABLED;
   \       0x7C   0x2501             MOVS     R5,#+1
    119            }
   \       0x7E   0x1C49             ADDS     R1,R1,#+1
   \       0x80   0x7314             STRB     R4,[R2, #+12]
   \       0x82   0x7355             STRB     R5,[R2, #+13]
   \       0x84   0x2902             CMP      R1,#+2
   \       0x86   0xDDE1             BLE.N    ??emberAfEndpointConfigure_0
    120          }
   \       0x88   0xB008             ADD      SP,SP,#+32
   \       0x8A   0xBDF0             POP      {R4-R7,PC}       ;; return
    121          

   \                                 In section .text, align 2, keep-with-next
    122          void emberAfSetEndpointCount(uint8_t dynamicEndpointCount)
    123          {
    124            emberEndpointCount = FIXED_ENDPOINT_COUNT + dynamicEndpointCount;
   \                     emberAfSetEndpointCount: (+1)
   \        0x0   0x1CC0             ADDS     R0,R0,#+3
   \        0x2   0x....'....        LDR.W    R1,??DataTable17_4
   \        0x6   0x7008             STRB     R0,[R1, #+0]
    125          }
   \        0x8   0x4770             BX       LR               ;; return
    126          

   \                                 In section .text, align 2, keep-with-next
    127          uint8_t emberAfFixedEndpointCount(void)
    128          {
    129            return FIXED_ENDPOINT_COUNT;
   \                     emberAfFixedEndpointCount: (+1)
   \        0x0   0x2003             MOVS     R0,#+3
   \        0x2   0x4770             BX       LR               ;; return
    130          }
    131          

   \                                 In section .text, align 2, keep-with-next
    132          uint8_t emberAfEndpointCount(void)
    133          {
    134            return emberEndpointCount;
   \                     emberAfEndpointCount: (+1)
   \        0x0   0x....'....        LDR.W    R0,??DataTable17_4
   \        0x4   0x7800             LDRB     R0,[R0, #+0]
   \        0x6   0x4770             BX       LR               ;; return
    135          }
    136          

   \                                 In section .text, align 2, keep-with-next
    137          bool emberAfEndpointIndexIsEnabled(uint8_t index)
    138          {
    139            return (emAfEndpoints[index].bitmask & EMBER_AF_ENDPOINT_ENABLED);
   \                     emberAfEndpointIndexIsEnabled: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable17_6
   \        0x4   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \        0x8   0x7B40             LDRB     R0,[R0, #+13]
   \        0xA   0xF000 0x0001      AND      R0,R0,#0x1
   \        0xE   0x4770             BX       LR               ;; return
    140          }
    141          
    142          // some data types (like strings) are sent OTA in human readable order
    143          // (how they are read) instead of little endian as the data types are.

   \                                 In section .text, align 2, keep-with-next
    144          bool emberAfIsThisDataTypeAStringType(EmberAfAttributeType dataType)
    145          {
    146            return (dataType == ZCL_OCTET_STRING_ATTRIBUTE_TYPE
    147                    || dataType == ZCL_CHAR_STRING_ATTRIBUTE_TYPE
    148                    || dataType == ZCL_LONG_OCTET_STRING_ATTRIBUTE_TYPE
    149                    || dataType == ZCL_LONG_CHAR_STRING_ATTRIBUTE_TYPE);
   \                     emberAfIsThisDataTypeAStringType: (+1)
   \        0x0   0x2841             CMP      R0,#+65
   \        0x2   0xBF18             IT       NE 
   \        0x4   0x2842             CMPNE    R0,#+66
   \        0x6   0xD003             BEQ.N    ??emberAfIsThisDataTypeAStringType_0
   \        0x8   0x2843             CMP      R0,#+67
   \        0xA   0xBF18             IT       NE 
   \        0xC   0x2844             CMPNE    R0,#+68
   \        0xE   0xD101             BNE.N    ??emberAfIsThisDataTypeAStringType_1
   \                     ??emberAfIsThisDataTypeAStringType_0: (+1)
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x4770             BX       LR
   \                     ??emberAfIsThisDataTypeAStringType_1: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0x4770             BX       LR               ;; return
    150          }
    151          

   \                                 In section .text, align 2, keep-with-next
    152          bool emberAfIsStringAttributeType(EmberAfAttributeType attributeType)
    153          {
    154            return (attributeType == ZCL_OCTET_STRING_ATTRIBUTE_TYPE
    155                    || attributeType == ZCL_CHAR_STRING_ATTRIBUTE_TYPE);
   \                     emberAfIsStringAttributeType: (+1)
   \        0x0   0x2841             CMP      R0,#+65
   \        0x2   0xBF18             IT       NE 
   \        0x4   0x2842             CMPNE    R0,#+66
   \        0x6   0xD101             BNE.N    ??emberAfIsStringAttributeType_0
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0x4770             BX       LR
   \                     ??emberAfIsStringAttributeType_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR               ;; return
    156          }
    157          

   \                                 In section .text, align 2, keep-with-next
    158          bool emberAfIsLongStringAttributeType(EmberAfAttributeType attributeType)
    159          {
    160            return (attributeType == ZCL_LONG_OCTET_STRING_ATTRIBUTE_TYPE
    161                    || attributeType == ZCL_LONG_CHAR_STRING_ATTRIBUTE_TYPE);
   \                     emberAfIsLongStringAttributeType: (+1)
   \        0x0   0x2843             CMP      R0,#+67
   \        0x2   0xBF18             IT       NE 
   \        0x4   0x2844             CMPNE    R0,#+68
   \        0x6   0xD101             BNE.N    ??emberAfIsLongStringAttributeType_0
   \        0x8   0x2001             MOVS     R0,#+1
   \        0xA   0x4770             BX       LR
   \                     ??emberAfIsLongStringAttributeType_0: (+1)
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x4770             BX       LR               ;; return
    162          }
    163          
    164          // This function is used to call the per-cluster default response callback

   \                                 In section .text, align 2, keep-with-next
    165          void emberAfClusterDefaultResponseWithMfgCodeCallback(uint8_t endpoint,
    166                                                                EmberAfClusterId clusterId,
    167                                                                uint8_t commandId,
    168                                                                EmberAfStatus status,
    169                                                                uint8_t clientServerMask,
    170                                                                uint16_t manufacturerCode)
    171          {
   \                     emberAfClusterDefaultResponseWithMfgCodeCallback: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4615             MOV      R5,R2
   \        0x4   0x461E             MOV      R6,R3
   \        0x6   0x9A06             LDR      R2,[SP, #+24]
   \        0x8   0x9B07             LDR      R3,[SP, #+28]
   \        0xA   0x4604             MOV      R4,R0
    172            EmberAfCluster *cluster = emberAfFindClusterWithMfgCode(endpoint,
    173                                                                    clusterId,
    174                                                                    clientServerMask,
    175                                                                    manufacturerCode);
   \        0xC   0x....'....        BL       emberAfFindClusterWithMfgCode
    176            if (cluster != NULL) {
   \       0x10   0xB160             CBZ.N    R0,??emberAfClusterDefaultResponseWithMfgCodeCallb_0
    177              EmberAfGenericClusterFunction f =
    178                emberAfFindClusterFunction(cluster,
    179                                           CLUSTER_MASK_DEFAULT_RESPONSE_FUNCTION);
   \       0x12   0x2104             MOVS     R1,#+4
   \       0x14   0x....'....        BL       emberAfFindClusterFunction
   \       0x18   0x0007             MOVS     R7,R0
    180              if (f != NULL) {
   \       0x1A   0xD007             BEQ.N    ??emberAfClusterDefaultResponseWithMfgCodeCallb_0
    181                emberAfPushEndpointNetworkIndex(endpoint);
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x....'....        BL       emberAfPushEndpointNetworkIndex
    182                ((EmberAfDefaultResponseFunction)f)(endpoint, commandId, status);
   \       0x22   0x4632             MOV      R2,R6
   \       0x24   0x4629             MOV      R1,R5
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x47B8             BLX      R7
    183                emberAfPopNetworkIndex();
   \       0x2A   0x....             B.N      ?Subroutine0
    184              }
    185            }
    186          }
   \                     ??emberAfClusterDefaultResponseWithMfgCodeCallb_0: (+1)
   \       0x2C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \        0x4   0x....'....        B.W      emberAfPopNetworkIndex
    187          
    188          // This function is used to call the per-cluster default response callback, and
    189          // wraps the emberAfClusterDefaultResponseWithMfgCodeCallback with a
    190          // EMBER_AF_NULL_MANUFACTURER_CODE.

   \                                 In section .text, align 2, keep-with-next
    191          void emberAfClusterDefaultResponseCallback(uint8_t endpoint,
    192                                                     EmberAfClusterId clusterId,
    193                                                     uint8_t commandId,
    194                                                     EmberAfStatus status,
    195                                                     uint8_t clientServerMask)
    196          {
   \                     emberAfClusterDefaultResponseCallback: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x9C06             LDR      R4,[SP, #+24]
    197            emberAfClusterDefaultResponseWithMfgCodeCallback(endpoint,
    198                                                             clusterId,
    199                                                             commandId,
    200                                                             status,
    201                                                             clientServerMask,
    202                                                             EMBER_AF_NULL_MANUFACTURER_CODE);
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x9501             STR      R5,[SP, #+4]
   \        0x8   0x9400             STR      R4,[SP, #+0]
   \        0xA   0x....'....        BL       emberAfClusterDefaultResponseWithMfgCodeCallback
    203          }
   \        0xE   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    204          
    205          // This function is used to call the per-cluster message sent callback

   \                                 In section .text, align 2, keep-with-next
    206          void emberAfClusterMessageSentWithMfgCodeCallback(EmberOutgoingMessageType type,
    207                                                            uint16_t indexOrDestination,
    208                                                            EmberApsFrame *apsFrame,
    209                                                            uint16_t msgLen,
    210                                                            uint8_t *message,
    211                                                            EmberStatus status,
    212                                                            uint16_t mfgCode)
    213          {
   \                     emberAfClusterMessageSentWithMfgCodeCallback: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x0014             MOVS     R4,R2
   \        0x6   0x4681             MOV      R9,R0
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x461F             MOV      R7,R3
    214            if (apsFrame != NULL && message != NULL && msgLen != 0) {
   \        0xC   0xBF1C             ITT      NE 
   \        0xE   0x9D0A             LDRNE    R5,[SP, #+40]
   \       0x10   0x2D00             CMPNE    R5,#+0
   \       0x12   0xD01F             BEQ.N    ??emberAfClusterMessageSentWithMfgCodeCallback_0
   \       0x14   0xB1F7             CBZ.N    R7,??emberAfClusterMessageSentWithMfgCodeCallback_0
    215              EmberAfCluster *cluster = emberAfFindClusterWithMfgCode(apsFrame->sourceEndpoint,
    216                                                                      apsFrame->clusterId,
    217                                                                      (((message[0]
    218                                                                         & ZCL_FRAME_CONTROL_DIRECTION_MASK)
    219                                                                        == ZCL_FRAME_CONTROL_SERVER_TO_CLIENT)
    220                                                                       ? CLUSTER_MASK_SERVER
    221                                                                       : CLUSTER_MASK_CLIENT),
    222                                                                      mfgCode);
   \       0x16   0x7828             LDRB     R0,[R5, #+0]
   \       0x18   0x9B0C             LDR      R3,[SP, #+48]
   \       0x1A   0x0701             LSLS     R1,R0,#+28
   \       0x1C   0x8861             LDRH     R1,[R4, #+2]
   \       0x1E   0x7920             LDRB     R0,[R4, #+4]
   \       0x20   0xBF4C             ITE      MI 
   \       0x22   0x2240             MOVMI    R2,#+64
   \       0x24   0x2280             MOVPL    R2,#+128
   \       0x26   0x....'....        BL       emberAfFindClusterWithMfgCode
    223              if (cluster != NULL) {
   \       0x2A   0xB198             CBZ.N    R0,??emberAfClusterMessageSentWithMfgCodeCallback_0
    224                EmberAfGenericClusterFunction f =
    225                  emberAfFindClusterFunction(cluster,
    226                                             CLUSTER_MASK_MESSAGE_SENT_FUNCTION);
   \       0x2C   0x2108             MOVS     R1,#+8
   \       0x2E   0x....'....        BL       emberAfFindClusterFunction
   \       0x32   0x4682             MOV      R10,R0
    227                if (f != NULL) {
   \       0x34   0xB170             CBZ.N    R0,??emberAfClusterMessageSentWithMfgCodeCallback_0
    228                  emberAfPushEndpointNetworkIndex(apsFrame->sourceEndpoint);
   \       0x36   0x7920             LDRB     R0,[R4, #+4]
   \       0x38   0x9E0B             LDR      R6,[SP, #+44]
   \       0x3A   0x....'....        BL       emberAfPushEndpointNetworkIndex
    229                  ((EmberAfMessageSentFunction)f)(type,
    230                                                  indexOrDestination,
    231                                                  apsFrame,
    232                                                  msgLen,
    233                                                  message,
    234                                                  status);
   \       0x3E   0x9500             STR      R5,[SP, #+0]
   \       0x40   0x9601             STR      R6,[SP, #+4]
   \       0x42   0x463B             MOV      R3,R7
   \       0x44   0x4622             MOV      R2,R4
   \       0x46   0x4641             MOV      R1,R8
   \       0x48   0x4648             MOV      R0,R9
   \       0x4A   0x47D0             BLX      R10
    235                  emberAfPopNetworkIndex();
   \       0x4C   0xE8BD 0x47F3      POP      {R0,R1,R4-R10,LR}
   \       0x50   0x....'....        B.W      emberAfPopNetworkIndex
    236                }
    237              }
    238            }
    239          }
   \                     ??emberAfClusterMessageSentWithMfgCodeCallback_0: (+1)
   \       0x54   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
    240          
    241          // This function is used to call the per-cluster message sent callback, and
    242          // wraps the emberAfClusterMessageSentWithMfgCodeCallback with a
    243          // EMBER_AF_NULL_MANUFACTURER_CODE.

   \                                 In section .text, align 2, keep-with-next
    244          void emberAfClusterMessageSentCallback(EmberOutgoingMessageType type,
    245                                                 uint16_t indexOrDestination,
    246                                                 EmberApsFrame *apsFrame,
    247                                                 uint16_t msgLen,
    248                                                 uint8_t *message,
    249                                                 EmberStatus status)
    250          {
   \                     emberAfClusterMessageSentCallback: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x9D08             LDR      R5,[SP, #+32]
   \        0x4   0x9C09             LDR      R4,[SP, #+36]
    251            emberAfClusterMessageSentWithMfgCodeCallback(type,
    252                                                         indexOrDestination,
    253                                                         apsFrame,
    254                                                         msgLen,
    255                                                         message,
    256                                                         status,
    257                                                         EMBER_AF_NULL_MANUFACTURER_CODE);
   \        0x6   0x2600             MOVS     R6,#+0
   \        0x8   0x9602             STR      R6,[SP, #+8]
   \        0xA   0x9401             STR      R4,[SP, #+4]
   \        0xC   0x9500             STR      R5,[SP, #+0]
   \        0xE   0x....'....        BL       emberAfClusterMessageSentWithMfgCodeCallback
    258          }
   \       0x12   0xBD7F             POP      {R0-R6,PC}       ;; return
    259          
    260          // This function is used to call the per-cluster attribute changed callback

   \                                 In section .text, align 2, keep-with-next
    261          void emAfClusterAttributeChangedCallback(uint8_t endpoint,
    262                                                   EmberAfClusterId clusterId,
    263                                                   EmberAfAttributeId attributeId,
    264                                                   uint8_t clientServerMask,
    265                                                   uint16_t manufacturerCode)
    266          {
   \                     emAfClusterAttributeChangedCallback: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x9C06             LDR      R4,[SP, #+24]
   \        0x4   0x4616             MOV      R6,R2
   \        0x6   0x461A             MOV      R2,R3
   \        0x8   0x4605             MOV      R5,R0
    267            EmberAfCluster *cluster = emberAfFindClusterWithMfgCode(endpoint,
    268                                                                    clusterId,
    269                                                                    clientServerMask,
    270                                                                    manufacturerCode);
   \        0xA   0x4623             MOV      R3,R4
   \        0xC   0x....'....        BL       emberAfFindClusterWithMfgCode
    271            if (cluster != NULL) {
   \       0x10   0xB1D0             CBZ.N    R0,??emAfClusterAttributeChangedCallback_0
    272              if (manufacturerCode == EMBER_AF_NULL_MANUFACTURER_CODE) {
   \       0x12   0x0021             MOVS     R1,R4
   \       0x14   0xD10B             BNE.N    ??emAfClusterAttributeChangedCallback_1
    273                EmberAfGenericClusterFunction f =
    274                  emberAfFindClusterFunction(cluster,
    275                                             CLUSTER_MASK_ATTRIBUTE_CHANGED_FUNCTION);
   \       0x16   0x2102             MOVS     R1,#+2
   \       0x18   0x....'....        BL       emberAfFindClusterFunction
   \       0x1C   0x0004             MOVS     R4,R0
    276                if (f != NULL) {
   \       0x1E   0xD013             BEQ.N    ??emAfClusterAttributeChangedCallback_0
    277                  emberAfPushEndpointNetworkIndex(endpoint);
   \       0x20   0x4628             MOV      R0,R5
   \       0x22   0x....'....        BL       emberAfPushEndpointNetworkIndex
    278                  ((EmberAfClusterAttributeChangedCallback)f)(endpoint, attributeId);
   \       0x26   0x4631             MOV      R1,R6
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x47A0             BLX      R4
    279                  emberAfPopNetworkIndex();
   \       0x2C   0xE00B             B.N      ??emAfClusterAttributeChangedCallback_2
    280                }
    281              } else {
    282                EmberAfGenericClusterFunction f =
    283                  emberAfFindClusterFunction(cluster,
    284                                             CLUSTER_MASK_MANUFACTURER_SPECIFIC_ATTRIBUTE_CHANGED_FUNCTION);
   \                     ??emAfClusterAttributeChangedCallback_1: (+1)
   \       0x2E   0x2110             MOVS     R1,#+16
   \       0x30   0x....'....        BL       emberAfFindClusterFunction
   \       0x34   0x0007             MOVS     R7,R0
    285                if (f != NULL) {
   \       0x36   0xD007             BEQ.N    ??emAfClusterAttributeChangedCallback_0
    286                  emberAfPushEndpointNetworkIndex(endpoint);
   \       0x38   0x4628             MOV      R0,R5
   \       0x3A   0x....'....        BL       emberAfPushEndpointNetworkIndex
    287                  ((EmberAfManufacturerSpecificClusterAttributeChangedCallback)f)(endpoint,
    288                                                                                  attributeId,
    289                                                                                  manufacturerCode);
   \       0x3E   0x4622             MOV      R2,R4
   \       0x40   0x4631             MOV      R1,R6
   \       0x42   0x4628             MOV      R0,R5
   \       0x44   0x47B8             BLX      R7
    290                  emberAfPopNetworkIndex();
    291                }
    292              }
    293            }
   \                     ??emAfClusterAttributeChangedCallback_2: (+1)
   \       0x46   0x....             B.N      ?Subroutine0
    294          }
   \                     ??emAfClusterAttributeChangedCallback_0: (+1)
   \       0x48   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    295          
    296          // This function is used to call the per-cluster pre-attribute changed callback

   \                                 In section .text, align 2, keep-with-next
    297          EmberAfStatus emAfClusterPreAttributeChangedCallback(uint8_t endpoint,
    298                                                               EmberAfClusterId clusterId,
    299                                                               EmberAfAttributeId attributeId,
    300                                                               uint8_t clientServerMask,
    301                                                               uint16_t manufacturerCode,
    302                                                               EmberAfAttributeType attributeType,
    303                                                               uint8_t size,
    304                                                               uint8_t* value)
    305          {
   \                     emAfClusterPreAttributeChangedCallback: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x9C08             LDR      R4,[SP, #+32]
   \        0x6   0x4690             MOV      R8,R2
   \        0x8   0x461A             MOV      R2,R3
   \        0xA   0x4606             MOV      R6,R0
    306            EmberAfCluster *cluster = emberAfFindClusterWithMfgCode(endpoint,
    307                                                                    clusterId,
    308                                                                    clientServerMask,
    309                                                                    manufacturerCode);
   \        0xC   0x4623             MOV      R3,R4
   \        0xE   0x....'....        BL       emberAfFindClusterWithMfgCode
    310            if (cluster == NULL) {
   \       0x12   0xB908             CBNZ.N   R0,??emAfClusterPreAttributeChangedCallback_0
    311              return EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE;
   \       0x14   0x2086             MOVS     R0,#+134
   \       0x16   0xE016             B.N      ??emAfClusterPreAttributeChangedCallback_1
    312            } else {
    313              EmberAfStatus status = EMBER_ZCL_STATUS_SUCCESS;
   \                     ??emAfClusterPreAttributeChangedCallback_0: (+1)
   \       0x18   0x2500             MOVS     R5,#+0
    314              if (manufacturerCode == EMBER_AF_NULL_MANUFACTURER_CODE) {
   \       0x1A   0xB99C             CBNZ.N   R4,??emAfClusterPreAttributeChangedCallback_2
    315                EmberAfGenericClusterFunction f =
    316                  emberAfFindClusterFunction(cluster,
    317                                             CLUSTER_MASK_PRE_ATTRIBUTE_CHANGED_FUNCTION);
   \       0x1C   0x2120             MOVS     R1,#+32
   \       0x1E   0x....'....        BL       emberAfFindClusterFunction
   \       0x22   0x4681             MOV      R9,R0
    318                if (f != NULL) {
   \       0x24   0xB170             CBZ.N    R0,??emAfClusterPreAttributeChangedCallback_2
   \       0x26   0x9F0B             LDR      R7,[SP, #+44]
   \       0x28   0x9C0A             LDR      R4,[SP, #+40]
   \       0x2A   0x9D09             LDR      R5,[SP, #+36]
    319                  emberAfPushEndpointNetworkIndex(endpoint);
   \       0x2C   0x4630             MOV      R0,R6
   \       0x2E   0x....'....        BL       emberAfPushEndpointNetworkIndex
    320                  status = ((EmberAfClusterPreAttributeChangedCallback)f)(endpoint,
    321                                                                          attributeId,
    322                                                                          attributeType,
    323                                                                          size,
    324                                                                          value);
   \       0x32   0x9700             STR      R7,[SP, #+0]
   \       0x34   0x4623             MOV      R3,R4
   \       0x36   0x462A             MOV      R2,R5
   \       0x38   0x4641             MOV      R1,R8
   \       0x3A   0x4630             MOV      R0,R6
   \       0x3C   0x47C8             BLX      R9
   \       0x3E   0x4605             MOV      R5,R0
    325                  emberAfPopNetworkIndex();
   \       0x40   0x....'....        BL       emberAfPopNetworkIndex
    326                }
    327              }
    328              return status;
   \                     ??emAfClusterPreAttributeChangedCallback_2: (+1)
   \       0x44   0x4628             MOV      R0,R5
   \                     ??emAfClusterPreAttributeChangedCallback_1: (+1)
   \       0x46   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    329            }
    330          }
    331          

   \                                 In section .text, align 2, keep-with-next
    332          static void initializeEndpoint(EmberAfDefinedEndpoint* definedEndpoint)
    333          {
   \                     initializeEndpoint: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
    334            uint8_t clusterIndex;
    335            EmberAfEndpointType* epType = definedEndpoint->endpointType;
    336            emberAfPushEndpointNetworkIndex(definedEndpoint->endpoint);
   \        0x4   0x7820             LDRB     R0,[R4, #+0]
   \        0x6   0x68A5             LDR      R5,[R4, #+8]
   \        0x8   0x2600             MOVS     R6,#+0
   \        0xA   0x....'....        BL       emberAfPushEndpointNetworkIndex
    337            for ( clusterIndex = 0;
   \        0xE   0xE011             B.N      ??initializeEndpoint_0
    338                  clusterIndex < epType->clusterCount;
    339                  clusterIndex++ ) {
    340              EmberAfCluster *cluster = &(epType->cluster[clusterIndex]);
   \                     ??initializeEndpoint_1: (+1)
   \       0x10   0xB2F1             UXTB     R1,R6
   \       0x12   0x2214             MOVS     R2,#+20
   \       0x14   0x6828             LDR      R0,[R5, #+0]
   \       0x16   0x4351             MULS     R1,R2,R1
   \       0x18   0x1847             ADDS     R7,R0,R1
    341              EmberAfGenericClusterFunction f;
    342              emberAfClusterInitCallback(definedEndpoint->endpoint, cluster->clusterId);
   \       0x1A   0x8839             LDRH     R1,[R7, #+0]
   \       0x1C   0x7820             LDRB     R0,[R4, #+0]
   \       0x1E   0x....'....        BL       emberAfClusterInitCallback
    343              f = emberAfFindClusterFunction(cluster, CLUSTER_MASK_INIT_FUNCTION);
   \       0x22   0x2101             MOVS     R1,#+1
   \       0x24   0x4638             MOV      R0,R7
   \       0x26   0x....'....        BL       emberAfFindClusterFunction
   \       0x2A   0x0001             MOVS     R1,R0
    344              if ( f != NULL ) {
   \       0x2C   0xBF1C             ITT      NE 
    345                ((EmberAfInitFunction)f)(definedEndpoint->endpoint);
   \       0x2E   0x7820             LDRBNE   R0,[R4, #+0]
   \       0x30   0x4788             BLXNE    R1
    346              }
    347            }
   \       0x32   0x1C76             ADDS     R6,R6,#+1
   \                     ??initializeEndpoint_0: (+1)
   \       0x34   0x7929             LDRB     R1,[R5, #+4]
   \       0x36   0xB2F0             UXTB     R0,R6
   \       0x38   0x4288             CMP      R0,R1
   \       0x3A   0xD3E9             BCC.N    ??initializeEndpoint_1
    348            emberAfPopNetworkIndex();
   \       0x3C                      REQUIRE ?Subroutine0
   \       0x3C                      ;; // Fall through to label ?Subroutine0
    349          }
    350          
    351          // Calls the init functions.

   \                                 In section .text, align 2, keep-with-next
    352          void emAfCallInits(void)
    353          {
   \                     emAfCallInits: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    354            uint8_t index;
    355            for ( index = 0; index < emberAfEndpointCount(); index++ ) {
   \        0x2   0x2400             MOVS     R4,#+0
   \        0x4   0x....'....        LDR.W    R5,??DataTable17_4
   \        0x8   0xE00A             B.N      ??emAfCallInits_0
    356              if (emberAfEndpointIndexIsEnabled(index)) {
   \                     ??emAfCallInits_1: (+1)
   \        0xA   0x....'....        LDR.W    R0,??DataTable19
   \        0xE   0x0621             LSLS     R1,R4,#+24
   \       0x10   0xEB00 0x5011      ADD      R0,R0,R1, LSR #+20
   \       0x14   0x7B42             LDRB     R2,[R0, #+13]
   \       0x16   0x07D1             LSLS     R1,R2,#+31
   \       0x18   0xBF48             IT       MI 
    357                initializeEndpoint(&(emAfEndpoints[index]));
   \       0x1A   0x....'....        BLMI     initializeEndpoint
    358              }
    359            }
   \       0x1E   0x1C64             ADDS     R4,R4,#+1
   \                     ??emAfCallInits_0: (+1)
   \       0x20   0x7829             LDRB     R1,[R5, #+0]
   \       0x22   0xB2E0             UXTB     R0,R4
   \       0x24   0x4288             CMP      R0,R1
   \       0x26   0xD3F0             BCC.N    ??emAfCallInits_1
    360          }
   \       0x28   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    361          
    362          // Returns the pointer to metadata, or null if it is not found

   \                                 In section .text, align 2, keep-with-next
    363          EmberAfAttributeMetadata *emberAfLocateAttributeMetadata(uint8_t endpoint,
    364                                                                   EmberAfClusterId clusterId,
    365                                                                   EmberAfAttributeId attributeId,
    366                                                                   uint8_t mask,
    367                                                                   uint16_t manufacturerCode)
    368          {
   \                     emberAfLocateAttributeMetadata: (+1)
   \        0x0   0xB55C             PUSH     {R2-R4,R6,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x9C0A             LDR      R4,[SP, #+40]
    369            EmberAfAttributeMetadata *metadata = NULL;
   \        0x6   0x2600             MOVS     R6,#+0
    370            EmberAfAttributeSearchRecord record;
    371            record.endpoint = endpoint;
   \        0x8   0xF88D 0x0008      STRB     R0,[SP, #+8]
    372            record.clusterId = clusterId;
   \        0xC   0xF8AD 0x100A      STRH     R1,[SP, #+10]
    373            record.clusterMask = mask;
   \       0x10   0xF88D 0x300C      STRB     R3,[SP, #+12]
    374            record.attributeId = attributeId;
   \       0x14   0xF8AD 0x200E      STRH     R2,[SP, #+14]
   \       0x18   0x9601             STR      R6,[SP, #+4]
    375            record.manufacturerCode = manufacturerCode;
   \       0x1A   0xF8AD 0x4010      STRH     R4,[SP, #+16]
    376            emAfReadOrWriteAttribute(&record,
    377                                     &metadata,
    378                                     NULL,   // buffer
    379                                     0,      // buffer size
    380                                     false); // write?
   \       0x1E   0x9600             STR      R6,[SP, #+0]
   \       0x20   0x2300             MOVS     R3,#+0
   \       0x22   0x2200             MOVS     R2,#+0
   \       0x24   0xA901             ADD      R1,SP,#+4
   \       0x26   0xA802             ADD      R0,SP,#+8
   \       0x28   0x....'....        BL       emAfReadOrWriteAttribute
    381            return metadata;
   \       0x2C   0x9801             LDR      R0,[SP, #+4]
   \       0x2E   0xB007             ADD      SP,SP,#+28
   \       0x30   0xBD50             POP      {R4,R6,PC}       ;; return
    382          }
    383          
    384          static uint8_t* singletonAttributeLocation(EmberAfAttributeMetadata *am)
    385          {
    386            EmberAfAttributeMetadata *m = (EmberAfAttributeMetadata *)&(generatedAttributes[0]);
    387            uint16_t index = 0;
    388            while ( m < am ) {
    389              if ((m->mask & ATTRIBUTE_MASK_SINGLETON) != 0U) {
    390                index += m->size;
    391              }
    392              m++;
    393            }
    394            return (uint8_t *)(singletonAttributeData + index);
    395          }
    396          
    397          // This function does mem copy, but smartly, which means that if the type is a
    398          // string, it will copy as much as it can.
    399          // If src == NULL, then this method will set memory to zeroes

   \                                 In section .text, align 2, keep-with-next
    400          static EmberAfStatus typeSensitiveMemCopy(uint8_t* dest,
    401                                                    uint8_t* src,
    402                                                    EmberAfAttributeMetadata * am,
    403                                                    bool write,
    404                                                    uint16_t readLength)
    405          {
   \                     typeSensitiveMemCopy: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x9D06             LDR      R5,[SP, #+24]
   \        0x4   0x461C             MOV      R4,R3
    406            EmberAfAttributeType attributeType = am->attributeType;
   \        0x6   0x7896             LDRB     R6,[R2, #+2]
    407            uint16_t size = (readLength == 0) ? am->size : readLength;
   \        0x8   0x002B             MOVS     R3,R5
   \        0xA   0xBF08             IT       EQ 
   \        0xC   0x78D3             LDRBEQ   R3,[R2, #+3]
    408          
    409            if (emberAfIsStringAttributeType(attributeType)) {
   \        0xE   0x2E41             CMP      R6,#+65
   \       0x10   0xBF18             IT       NE 
   \       0x12   0x2E42             CMPNE    R6,#+66
   \       0x14   0xD006             BEQ.N    ??typeSensitiveMemCopy_0
    410              emberAfCopyString(dest, src, size - 1);
    411            } else if (emberAfIsLongStringAttributeType(attributeType)) {
   \       0x16   0x2E43             CMP      R6,#+67
   \       0x18   0xD109             BNE.N    ??typeSensitiveMemCopy_1
    412              emberAfCopyLongString(dest, src, size - 2);
   \                     ??typeSensitiveMemCopy_2: (+1)
   \       0x1A   0x1E9A             SUBS     R2,R3,#+2
   \       0x1C   0xB292             UXTH     R2,R2
   \       0x1E   0x....'....        BL       emberAfCopyLongString
   \       0x22   0xE016             B.N      ??typeSensitiveMemCopy_3
    413            } else {
   \                     ??typeSensitiveMemCopy_0: (+1)
   \       0x24   0x1E5A             SUBS     R2,R3,#+1
   \       0x26   0xB2D2             UXTB     R2,R2
   \       0x28   0x....'....        BL       emberAfCopyString
   \       0x2C   0xE011             B.N      ??typeSensitiveMemCopy_3
   \                     ??typeSensitiveMemCopy_1: (+1)
   \       0x2E   0x2E44             CMP      R6,#+68
   \       0x30   0xD0F3             BEQ.N    ??typeSensitiveMemCopy_2
    414              if (!write && readLength != 0 && readLength < am->size) {
   \       0x32   0xB934             CBNZ.N   R4,??typeSensitiveMemCopy_4
   \       0x34   0x002C             MOVS     R4,R5
   \       0x36   0xD004             BEQ.N    ??typeSensitiveMemCopy_4
   \       0x38   0x78D2             LDRB     R2,[R2, #+3]
   \       0x3A   0x4295             CMP      R5,R2
   \       0x3C   0xD201             BCS.N    ??typeSensitiveMemCopy_4
    415                return EMBER_ZCL_STATUS_INSUFFICIENT_SPACE;
   \       0x3E   0x2089             MOVS     R0,#+137
   \       0x40   0xBD76             POP      {R1,R2,R4-R6,PC}
    416              }
    417              if ( src == NULL ) {
   \                     ??typeSensitiveMemCopy_4: (+1)
   \       0x42   0x2900             CMP      R1,#+0
   \       0x44   0x461A             MOV      R2,R3
   \       0x46   0xD102             BNE.N    ??typeSensitiveMemCopy_5
    418                MEMSET(dest, 0, size);
   \       0x48   0x....'....        BL       halCommonMemSet
   \       0x4C   0xE001             B.N      ??typeSensitiveMemCopy_3
    419              } else {
    420                MEMMOVE(dest, src, size);
   \                     ??typeSensitiveMemCopy_5: (+1)
   \       0x4E   0x....'....        BL       halCommonMemMove
    421              }
    422            }
    423            return EMBER_ZCL_STATUS_SUCCESS;
   \                     ??typeSensitiveMemCopy_3: (+1)
   \       0x52   0x2000             MOVS     R0,#+0
   \       0x54   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    424          }
    425          
    426          // Returns the manufacturer code or ::EMBER_AF_NULL_MANUFACTURER_CODE if none
    427          // could be found.

   \                                 In section .text, align 2, keep-with-next
    428          static uint16_t getManufacturerCode(EmberAfManufacturerCodeEntry *codes,
    429                                              uint16_t codeTableSize,
    430                                              uint16_t tableIndex)
    431          {
   \                     getManufacturerCode: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    432            uint16_t i;
    433            for (i = 0; i < codeTableSize; i++) {
   \        0x2   0x2300             MOVS     R3,#+0
   \        0x4   0xE001             B.N      ??getManufacturerCode_0
    434              if (codes->index == tableIndex) {
    435                return codes->manufacturerCode;
    436              }
    437              codes++;
   \                     ??getManufacturerCode_1: (+1)
   \        0x6   0x1D00             ADDS     R0,R0,#+4
   \        0x8   0x1C5B             ADDS     R3,R3,#+1
   \                     ??getManufacturerCode_0: (+1)
   \        0xA   0xB29C             UXTH     R4,R3
   \        0xC   0x428C             CMP      R4,R1
   \        0xE   0xD204             BCS.N    ??getManufacturerCode_2
   \       0x10   0x8804             LDRH     R4,[R0, #+0]
   \       0x12   0x4294             CMP      R4,R2
   \       0x14   0xD1F7             BNE.N    ??getManufacturerCode_1
   \       0x16   0x8840             LDRH     R0,[R0, #+2]
   \       0x18   0xBD10             POP      {R4,PC}
    438            }
    439            return EMBER_AF_NULL_MANUFACTURER_CODE;
   \                     ??getManufacturerCode_2: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xBD10             POP      {R4,PC}          ;; return
    440          }
    441          
    442          // This function basically wraps getManufacturerCode with the parameters
    443          // associating an attributes metadata with its code.

   \                                 In section .text, align 2, keep-with-next
    444          uint16_t emberAfGetMfgCode(EmberAfAttributeMetadata *metadata)
    445          {
    446            return getManufacturerCode((EmberAfManufacturerCodeEntry *) attributeManufacturerCodes,
    447                                       attributeManufacturerCodeCount,
    448                                       (metadata - generatedAttributes));
   \                     emberAfGetMfgCode: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable19_1
   \        0x4   0x1A40             SUBS     R0,R0,R1
   \        0x6   0x220C             MOVS     R2,#+12
   \        0x8   0xFB90 0xF2F2      SDIV     R2,R0,R2
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x....'....        LDR.W    R0,??DataTable19_2
   \       0x12   0x....             B.N      ?Subroutine1
    449          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xB292             UXTH     R2,R2
   \        0x2   0x....             B.N      getManufacturerCode
    450          

   \                                 In section .text, align 2, keep-with-next
    451          uint16_t emAfGetManufacturerCodeForAttribute(EmberAfCluster *cluster,
    452                                                       EmberAfAttributeMetadata *attMetaData)
    453          {
    454            return (emberAfClusterIsManufacturerSpecific(cluster)
    455                    ? emAfGetManufacturerCodeForCluster(cluster)
    456                    : emberAfGetMfgCode(attMetaData));
   \                     emAfGetManufacturerCodeForAttribute: (+1)
   \        0x0   0x8802             LDRH     R2,[R0, #+0]
   \        0x2   0xF5B2 0x4F7C      CMP      R2,#+64512
   \        0x6   0xBFA8             IT       GE 
   \        0x8   0x....'....        BGE.W    emAfGetManufacturerCodeForCluster
   \        0xC   0x4608             MOV      R0,R1
   \        0xE   0x....             B.N      emberAfGetMfgCode
    457          }
    458          

   \                                 In section .text, align 2, keep-with-next
    459          uint16_t emAfGetManufacturerCodeForCluster(EmberAfCluster *cluster)
    460          {
    461            return getManufacturerCode((EmberAfManufacturerCodeEntry *)clusterManufacturerCodes,
    462                                       clusterManufacturerCodeCount,
    463                                       (cluster - generatedClusters));
   \                     emAfGetManufacturerCodeForCluster: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable19_3
   \        0x4   0x1A40             SUBS     R0,R0,R1
   \        0x6   0x2214             MOVS     R2,#+20
   \        0x8   0xFB90 0xF2F2      SDIV     R2,R0,R2
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x....'....        LDR.W    R0,??DataTable19_4
   \       0x12                      REQUIRE ?Subroutine1
   \       0x12                      ;; // Fall through to label ?Subroutine1
    464          }
    465          
    466          /**
    467           * @brief Matches a cluster based on cluster id, direction and manufacturer code.
    468           *   This function assumes that the passed cluster's endpoint already
    469           *   matches the endpoint of the EmberAfAttributeSearchRecord.
    470           *
    471           * Cluster's match if:
    472           *   1. Cluster ids match AND
    473           *   2. Cluster directions match as defined by cluster->mask
    474           *        and attRecord->clusterMask AND
    475           *   3. If the clusters are mf specific, their mfg codes match.
    476           */

   \                                 In section .text, align 2, keep-with-next
    477          bool emAfMatchCluster(EmberAfCluster *cluster,
    478                                EmberAfAttributeSearchRecord *attRecord)
    479          {
   \                     emAfMatchCluster: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x460C             MOV      R4,R1
    480            return (cluster->clusterId == attRecord->clusterId
    481                    && cluster->mask & attRecord->clusterMask
    482                    && (!emberAfClusterIsManufacturerSpecific(cluster)
    483                        || (emAfGetManufacturerCodeForCluster(cluster)
    484                            == attRecord->manufacturerCode)));
   \        0x4   0x8801             LDRH     R1,[R0, #+0]
   \        0x6   0x8862             LDRH     R2,[R4, #+2]
   \        0x8   0x4291             CMP      R1,R2
   \        0xA   0xD10D             BNE.N    ??emAfMatchCluster_0
   \        0xC   0x7B03             LDRB     R3,[R0, #+12]
   \        0xE   0x7922             LDRB     R2,[R4, #+4]
   \       0x10   0x4213             TST      R3,R2
   \       0x12   0xD009             BEQ.N    ??emAfMatchCluster_0
   \       0x14   0xF5B1 0x4F7C      CMP      R1,#+64512
   \       0x18   0xDB04             BLT.N    ??emAfMatchCluster_1
   \       0x1A   0x....'....        BL       emAfGetManufacturerCodeForCluster
   \       0x1E   0x8921             LDRH     R1,[R4, #+8]
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD101             BNE.N    ??emAfMatchCluster_0
   \                     ??emAfMatchCluster_1: (+1)
   \       0x24   0x2001             MOVS     R0,#+1
   \       0x26   0xBD10             POP      {R4,PC}
   \                     ??emAfMatchCluster_0: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0xBD10             POP      {R4,PC}          ;; return
    485          }
    486          
    487          /**
    488           * @brief Matches an attribute based on attribute id and manufacturer code.
    489           *   This function assumes that the passed cluster already matches the
    490           *   clusterId, direction and mf specificity of the passed
    491           *   EmberAfAttributeSearchRecord.
    492           *
    493           * Note: If both the attribute and cluster are manufacturer specific,
    494           *   the cluster's mf code gets precedence.
    495           *
    496           * Attributes match if:
    497           *   1. Att ids match AND
    498           *      a. cluster IS mf specific OR
    499           *      b. both stored and saught attributes are NOT mf specific OR
    500           *      c. stored att IS mf specific AND mfg codes match.
    501           */

   \                                 In section .text, align 2, keep-with-next
    502          bool emAfMatchAttribute(EmberAfCluster *cluster,
    503                                  EmberAfAttributeMetadata *am,
    504                                  EmberAfAttributeSearchRecord *attRecord)
    505          {
   \                     emAfMatchAttribute: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4614             MOV      R4,R2
    506            return (am->attributeId == attRecord->attributeId
    507                    && (emberAfClusterIsManufacturerSpecific(cluster)
    508                        || (emAfGetManufacturerCodeForAttribute(cluster, am)
    509                            == attRecord->manufacturerCode)));
   \        0x4   0x880A             LDRH     R2,[R1, #+0]
   \        0x6   0x88E3             LDRH     R3,[R4, #+6]
   \        0x8   0x429A             CMP      R2,R3
   \        0xA   0xD10A             BNE.N    ??emAfMatchAttribute_0
   \        0xC   0x8802             LDRH     R2,[R0, #+0]
   \        0xE   0xF5B2 0x4F7C      CMP      R2,#+64512
   \       0x12   0xDA04             BGE.N    ??emAfMatchAttribute_1
   \       0x14   0x....'....        BL       emAfGetManufacturerCodeForAttribute
   \       0x18   0x8921             LDRH     R1,[R4, #+8]
   \       0x1A   0x4288             CMP      R0,R1
   \       0x1C   0xD101             BNE.N    ??emAfMatchAttribute_0
   \                     ??emAfMatchAttribute_1: (+1)
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xBD10             POP      {R4,PC}
   \                     ??emAfMatchAttribute_0: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0xBD10             POP      {R4,PC}          ;; return
    510          }
    511          
    512          // The callbacks to read and write externals have the same signature, so it is
    513          // easy to use function pointers to call the right one.  This typedef covers
    514          // both and makes the code a bit easier to read.
    515          typedef EmberAfStatus (*ExternalReadWriteCallback)(uint8_t, EmberAfClusterId, EmberAfAttributeMetadata *, uint16_t, uint8_t *);
    516          
    517          // When reading non-string attributes, this function returns an error when destination
    518          // buffer isn't large enough to accommodate the attribute type.  For strings, the
    519          // function will copy at most readLength bytes.  This means the resulting string
    520          // may be truncated.  The length byte(s) in the resulting string will reflect
    521          // any truncation.  If readLength is zero, we are working with backwards-
    522          // compatibility wrapper functions and we just cross our fingers and hope for
    523          // the best.
    524          //
    525          // When writing attributes, readLength is ignored.  For non-string attributes,
    526          // this function assumes the source buffer is the same size as the attribute
    527          // type.  For strings, the function will copy as many bytes as will fit in the
    528          // attribute.  This means the resulting string may be truncated.  The length
    529          // byte(s) in the resulting string will reflect any truncated.

   \                                 In section .text, align 2, keep-with-next
    530          EmberAfStatus emAfReadOrWriteAttribute(EmberAfAttributeSearchRecord *attRecord,
    531                                                 EmberAfAttributeMetadata **metadata,
    532                                                 uint8_t *buffer,
    533                                                 uint16_t readLength,
    534                                                 bool write)
    535          {
   \                     emAfReadOrWriteAttribute: (+1)
   \        0x0   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \        0x4   0xB082             SUB      SP,SP,#+8
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x469A             MOV      R10,R3
    536            uint8_t i;
    537            uint16_t attributeOffsetIndex = 0;
   \        0xA   0x2500             MOVS     R5,#+0
    538          
    539            for (i = 0; i < emberAfEndpointCount(); i++) {
   \        0xC   0x2700             MOVS     R7,#+0
   \        0xE   0xE003             B.N      ??emAfReadOrWriteAttribute_0
    540              if (emAfEndpoints[i].endpoint == attRecord->endpoint) {
    541                EmberAfEndpointType *endpointType = emAfEndpoints[i].endpointType;
    542                uint8_t clusterIndex;
    543                if (!emberAfEndpointIndexIsEnabled(i)) {
    544                  continue;
    545                }
    546                for (clusterIndex = 0;
    547                     clusterIndex < endpointType->clusterCount;
    548                     clusterIndex++) {
    549                  EmberAfCluster *cluster = &(endpointType->cluster[clusterIndex]);
    550                  if (emAfMatchCluster(cluster, attRecord)) { // Got the cluster
    551                    uint16_t attrIndex;
    552                    for (attrIndex = 0;
    553                         attrIndex < cluster->attributeCount;
    554                         attrIndex++) {
    555                      EmberAfAttributeMetadata *am = &(cluster->attributes[attrIndex]);
    556                      if (emAfMatchAttribute(cluster,
    557                                             am,
    558                                             attRecord)) { // Got the attribute
    559                        // If passed metadata location is not null, populate
    560                        if (metadata != NULL) {
    561                          *metadata = am;
    562                        }
    563          
    564                        {
    565                          uint8_t *attributeLocation = (am->mask & ATTRIBUTE_MASK_SINGLETON
    566                                                        ? singletonAttributeLocation(am)
    567                                                        : attributeData + attributeOffsetIndex);
    568                          uint8_t *src, *dst;
    569                          ExternalReadWriteCallback callback;
    570                          if (write) {
    571                            src = buffer;
    572                            dst = attributeLocation;
    573                            callback = emberAfExternalAttributeWriteCallback;
    574                            if (!emberAfAttributeWriteAccessCallback(attRecord->endpoint,
    575                                                                     attRecord->clusterId,
    576                                                                     emAfGetManufacturerCodeForAttribute(cluster, am),
    577                                                                     am->attributeId)) {
    578                              return EMBER_ZCL_STATUS_NOT_AUTHORIZED;
    579                            }
    580                          } else {
    581                            if (buffer == NULL) {
    582                              return EMBER_ZCL_STATUS_SUCCESS;
    583                            }
    584          
    585                            src = attributeLocation;
    586                            dst = buffer;
    587                            callback = emberAfExternalAttributeReadCallback;
    588                            if (!emberAfAttributeReadAccessCallback(attRecord->endpoint,
    589                                                                    attRecord->clusterId,
    590                                                                    emAfGetManufacturerCodeForAttribute(cluster, am),
    591                                                                    am->attributeId)) {
    592                              return EMBER_ZCL_STATUS_NOT_AUTHORIZED;
    593                            }
    594                          }
    595          
    596                          return (am->mask & ATTRIBUTE_MASK_EXTERNAL_STORAGE
    597                                  ? (*callback)(attRecord->endpoint,
    598                                                attRecord->clusterId,
    599                                                am,
    600                                                emAfGetManufacturerCodeForAttribute(cluster, am),
    601                                                buffer)
    602                                  : typeSensitiveMemCopy(dst,
    603                                                         src,
    604                                                         am,
    605                                                         write,
    606                                                         readLength));
    607                        }
    608                      } else { // Not the attribute we are looking for
    609                        // Increase the index if attribute is not externally stored
    610                        if (!(am->mask & ATTRIBUTE_MASK_EXTERNAL_STORAGE)
    611                            && !(am->mask & ATTRIBUTE_MASK_SINGLETON) ) {
    612                          attributeOffsetIndex += emberAfAttributeSize(am);
    613                        }
    614                      }
    615                    }
    616                  } else { // Not the cluster we are looking for
    617                    attributeOffsetIndex += cluster->clusterSize;
    618                  }
    619                }
    620              } else { // Not the endpoint we are looking for
    621                attributeOffsetIndex += emAfEndpoints[i].endpointType->endpointSize;
   \                     ??emAfReadOrWriteAttribute_1: (+1)
   \       0x10   0x88C8             LDRH     R0,[R1, #+6]
   \       0x12   0x1945             ADDS     R5,R0,R5
    622              }
   \                     ??emAfReadOrWriteAttribute_2: (+1)
   \       0x14   0x1C7F             ADDS     R7,R7,#+1
   \       0x16   0xB2FF             UXTB     R7,R7
   \                     ??emAfReadOrWriteAttribute_0: (+1)
   \       0x18   0x....'....        LDR.W    R1,??DataTable17_4
   \       0x1C   0x780A             LDRB     R2,[R1, #+0]
   \       0x1E   0x4297             CMP      R7,R2
   \       0x20   0xF080 0x80A3      BCS.W    ??emAfReadOrWriteAttribute_3
   \       0x24   0x....'....        LDR.W    R0,??DataTable17_6
   \       0x28   0xEB00 0x1007      ADD      R0,R0,R7, LSL #+4
   \       0x2C   0x7823             LDRB     R3,[R4, #+0]
   \       0x2E   0x7802             LDRB     R2,[R0, #+0]
   \       0x30   0x6881             LDR      R1,[R0, #+8]
   \       0x32   0x429A             CMP      R2,R3
   \       0x34   0xD1EC             BNE.N    ??emAfReadOrWriteAttribute_1
   \       0x36   0x9100             STR      R1,[SP, #+0]
   \       0x38   0x7B40             LDRB     R0,[R0, #+13]
   \       0x3A   0x07C1             LSLS     R1,R0,#+31
   \       0x3C   0xD5EA             BPL.N    ??emAfReadOrWriteAttribute_2
   \       0x3E   0xF04F 0x0800      MOV      R8,#+0
   \       0x42   0xE004             B.N      ??emAfReadOrWriteAttribute_4
   \                     ??emAfReadOrWriteAttribute_5: (+1)
   \       0x44   0xF8B9 0x000A      LDRH     R0,[R9, #+10]
   \       0x48   0x1945             ADDS     R5,R0,R5
   \                     ??emAfReadOrWriteAttribute_6: (+1)
   \       0x4A   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??emAfReadOrWriteAttribute_4: (+1)
   \       0x4E   0x9900             LDR      R1,[SP, #+0]
   \       0x50   0xFA5F 0xF088      UXTB     R0,R8
   \       0x54   0x790A             LDRB     R2,[R1, #+4]
   \       0x56   0x4290             CMP      R0,R2
   \       0x58   0xD2DC             BCS.N    ??emAfReadOrWriteAttribute_2
   \       0x5A   0x680A             LDR      R2,[R1, #+0]
   \       0x5C   0xFA5F 0xF188      UXTB     R1,R8
   \       0x60   0x2014             MOVS     R0,#+20
   \       0x62   0x4348             MULS     R0,R0,R1
   \       0x64   0x4621             MOV      R1,R4
   \       0x66   0xEB02 0x0900      ADD      R9,R2,R0
   \       0x6A   0x4648             MOV      R0,R9
   \       0x6C   0x....'....        BL       emAfMatchCluster
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xD0E7             BEQ.N    ??emAfReadOrWriteAttribute_5
   \       0x74   0xF04F 0x0B00      MOV      R11,#+0
   \       0x78   0xE007             B.N      ??emAfReadOrWriteAttribute_7
   \                     ??emAfReadOrWriteAttribute_8: (+1)
   \       0x7A   0x7930             LDRB     R0,[R6, #+4]
   \       0x7C   0xF10B 0x0B01      ADD      R11,R11,#+1
   \       0x80   0xF010 0x0F30      TST      R0,#0x30
   \       0x84   0xBF04             ITT      EQ 
   \       0x86   0x78F0             LDRBEQ   R0,[R6, #+3]
   \       0x88   0x1945             ADDEQ    R5,R0,R5
   \                     ??emAfReadOrWriteAttribute_7: (+1)
   \       0x8A   0xF8B9 0x1008      LDRH     R1,[R9, #+8]
   \       0x8E   0xFA1F 0xF08B      UXTH     R0,R11
   \       0x92   0x4288             CMP      R0,R1
   \       0x94   0xD2D9             BCS.N    ??emAfReadOrWriteAttribute_6
   \       0x96   0xFA1F 0xF28B      UXTH     R2,R11
   \       0x9A   0x210C             MOVS     R1,#+12
   \       0x9C   0xF8D9 0x0004      LDR      R0,[R9, #+4]
   \       0xA0   0x434A             MULS     R2,R1,R2
   \       0xA2   0x1886             ADDS     R6,R0,R2
   \       0xA4   0x4622             MOV      R2,R4
   \       0xA6   0x4631             MOV      R1,R6
   \       0xA8   0x4648             MOV      R0,R9
   \       0xAA   0x....'....        BL       emAfMatchAttribute
   \       0xAE   0x2800             CMP      R0,#+0
   \       0xB0   0xD0E3             BEQ.N    ??emAfReadOrWriteAttribute_8
   \       0xB2   0x9803             LDR      R0,[SP, #+12]
   \       0xB4   0x4627             MOV      R7,R4
   \       0xB6   0x4634             MOV      R4,R6
   \       0xB8   0xB100             CBZ.N    R0,??emAfReadOrWriteAttribute_9
   \       0xBA   0x6004             STR      R4,[R0, #+0]
   \                     ??emAfReadOrWriteAttribute_9: (+1)
   \       0xBC   0x7920             LDRB     R0,[R4, #+4]
   \       0xBE   0x0681             LSLS     R1,R0,#+26
   \       0xC0   0xD510             BPL.N    ??emAfReadOrWriteAttribute_10
   \       0xC2   0x....'....        LDR.W    R0,??DataTable19_1
   \       0xC6   0x2100             MOVS     R1,#+0
   \       0xC8   0xE005             B.N      ??emAfReadOrWriteAttribute_11
   \                     ??emAfReadOrWriteAttribute_12: (+1)
   \       0xCA   0x7902             LDRB     R2,[R0, #+4]
   \       0xCC   0x0693             LSLS     R3,R2,#+26
   \       0xCE   0xBF44             ITT      MI 
   \       0xD0   0x78C2             LDRBMI   R2,[R0, #+3]
   \       0xD2   0x1851             ADDMI    R1,R2,R1
   \       0xD4   0x300C             ADDS     R0,R0,#+12
   \                     ??emAfReadOrWriteAttribute_11: (+1)
   \       0xD6   0x42A0             CMP      R0,R4
   \       0xD8   0xD3F7             BCC.N    ??emAfReadOrWriteAttribute_12
   \       0xDA   0x....'....        LDR.W    R0,??DataTable19_5
   \       0xDE   0xB289             UXTH     R1,R1
   \       0xE0   0x1846             ADDS     R6,R0,R1
   \       0xE2   0xE003             B.N      ??emAfReadOrWriteAttribute_13
   \                     ??emAfReadOrWriteAttribute_10: (+1)
   \       0xE4   0x....'....        LDR.W    R1,??DataTable19_6
   \       0xE8   0xB2AD             UXTH     R5,R5
   \       0xEA   0x194E             ADDS     R6,R1,R5
   \                     ??emAfReadOrWriteAttribute_13: (+1)
   \       0xEC   0xF8DD 0x8038      LDR      R8,[SP, #+56]
   \       0xF0   0x9D04             LDR      R5,[SP, #+16]
   \       0xF2   0x4640             MOV      R0,R8
   \       0xF4   0xF1B8 0x0F00      CMP      R8,#+0
   \       0xF8   0xD01B             BEQ.N    ??emAfReadOrWriteAttribute_14
   \       0xFA   0x9501             STR      R5,[SP, #+4]
   \       0xFC   0x4621             MOV      R1,R4
   \       0xFE   0x4648             MOV      R0,R9
   \      0x100   0x....'....        BL       emAfGetManufacturerCodeForAttribute
   \      0x104   0x4602             MOV      R2,R0
   \      0x106   0x8823             LDRH     R3,[R4, #+0]
   \      0x108   0x8879             LDRH     R1,[R7, #+2]
   \      0x10A   0x7838             LDRB     R0,[R7, #+0]
   \      0x10C   0x....'....        LDR.W    R11,??DataTable19_7
   \      0x110   0x....'....        BL       emberAfAttributeWriteAccessCallback
   \      0x114   0xB1F0             CBZ.N    R0,??emAfReadOrWriteAttribute_15
   \                     ??emAfReadOrWriteAttribute_16: (+1)
   \      0x116   0x7920             LDRB     R0,[R4, #+4]
   \      0x118   0x06C1             LSLS     R1,R0,#+27
   \      0x11A   0xD51D             BPL.N    ??emAfReadOrWriteAttribute_17
   \      0x11C   0x4621             MOV      R1,R4
   \      0x11E   0x4648             MOV      R0,R9
   \      0x120   0x....'....        BL       emAfGetManufacturerCodeForAttribute
   \      0x124   0x9500             STR      R5,[SP, #+0]
   \      0x126   0x4603             MOV      R3,R0
   \      0x128   0x8879             LDRH     R1,[R7, #+2]
   \      0x12A   0x7838             LDRB     R0,[R7, #+0]
   \      0x12C   0x4622             MOV      R2,R4
   \      0x12E   0x47D8             BLX      R11
   \      0x130   0xE01C             B.N      ??emAfReadOrWriteAttribute_18
   \                     ??emAfReadOrWriteAttribute_14: (+1)
   \      0x132   0xB1DD             CBZ.N    R5,??emAfReadOrWriteAttribute_18
   \      0x134   0x4621             MOV      R1,R4
   \      0x136   0x4648             MOV      R0,R9
   \      0x138   0x9601             STR      R6,[SP, #+4]
   \      0x13A   0x....'....        BL       emAfGetManufacturerCodeForAttribute
   \      0x13E   0x4602             MOV      R2,R0
   \      0x140   0x8823             LDRH     R3,[R4, #+0]
   \      0x142   0x8879             LDRH     R1,[R7, #+2]
   \      0x144   0x7838             LDRB     R0,[R7, #+0]
   \      0x146   0x462E             MOV      R6,R5
   \      0x148   0x....'....        LDR.W    R11,??DataTable19_8
   \      0x14C   0x....'....        BL       emberAfAttributeReadAccessCallback
   \      0x150   0x2800             CMP      R0,#+0
   \      0x152   0xD1E0             BNE.N    ??emAfReadOrWriteAttribute_16
   \                     ??emAfReadOrWriteAttribute_15: (+1)
   \      0x154   0x207E             MOVS     R0,#+126
   \      0x156   0xE009             B.N      ??emAfReadOrWriteAttribute_18
    623            }
   \                     ??emAfReadOrWriteAttribute_17: (+1)
   \      0x158   0x9901             LDR      R1,[SP, #+4]
   \      0x15A   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \      0x15E   0x4643             MOV      R3,R8
   \      0x160   0x4622             MOV      R2,R4
   \      0x162   0x4630             MOV      R0,R6
   \      0x164   0x....'....        BL       typeSensitiveMemCopy
   \      0x168   0xE000             B.N      ??emAfReadOrWriteAttribute_18
    624            return EMBER_ZCL_STATUS_UNSUPPORTED_ATTRIBUTE; // Sorry, attribute was not found.
   \                     ??emAfReadOrWriteAttribute_3: (+1)
   \      0x16A   0x2086             MOVS     R0,#+134
   \                     ??emAfReadOrWriteAttribute_18: (+1)
   \      0x16C   0xB005             ADD      SP,SP,#+20
   \      0x16E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    625          }
    626          
    627          // Check if a cluster is implemented or not. If yes, the cluster is returned.
    628          // If the cluster is not manufacturerSpecific [ClusterId < FC00] then
    629          // manufacturerCode argument is ignored otherwise checked.
    630          //
    631          // mask = 0 -> find either client or server
    632          // mask = CLUSTER_MASK_CLIENT -> find client
    633          // mask = CLUSTER_MASK_SERVER -> find server

   \                                 In section .text, align 2, keep-with-next
    634          EmberAfCluster *emberAfFindClusterInTypeWithMfgCode(EmberAfEndpointType *endpointType,
    635                                                              EmberAfClusterId clusterId,
    636                                                              EmberAfClusterMask mask,
    637                                                              uint16_t manufacturerCode)
    638          {
   \                     emberAfFindClusterInTypeWithMfgCode: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x4699             MOV      R9,R3
    639            uint8_t i;
    640            for (i = 0; i < endpointType->clusterCount; i++) {
   \        0xC   0x2500             MOVS     R5,#+0
   \                     ??emberAfFindClusterInTypeWithMfgCode_0: (+1)
   \        0xE   0x7921             LDRB     R1,[R4, #+4]
   \       0x10   0xB2E8             UXTB     R0,R5
   \       0x12   0x4288             CMP      R0,R1
   \       0x14   0xD221             BCS.N    ??emberAfFindClusterInTypeWithMfgCode_1
    641              EmberAfCluster *cluster = &(endpointType->cluster[i]);
   \       0x16   0xB2EA             UXTB     R2,R5
   \       0x18   0x2314             MOVS     R3,#+20
   \       0x1A   0x6820             LDR      R0,[R4, #+0]
   \       0x1C   0x435A             MULS     R2,R3,R2
   \       0x1E   0x1887             ADDS     R7,R0,R2
    642              if (cluster->clusterId == clusterId
    643                  && (mask == 0
    644                      || (mask == CLUSTER_MASK_CLIENT && emberAfClusterIsClient(cluster))
    645                      || (mask == CLUSTER_MASK_SERVER && emberAfClusterIsServer(cluster)))
    646                  && (!emberAfClusterIsManufacturerSpecific(cluster)
    647                      || (emAfGetManufacturerCodeForCluster(cluster)
    648                          == manufacturerCode)
    649                      // For compatibility with older stack api, we ignore manufacturer code here
    650                      // if the manufacturerCode == EMBER_AF_NULL_MANUFACTURER_CODE
    651                      || manufacturerCode == EMBER_AF_NULL_MANUFACTURER_CODE)) {
   \       0x20   0x8838             LDRH     R0,[R7, #+0]
   \       0x22   0x4540             CMP      R0,R8
   \       0x24   0xD117             BNE.N    ??emberAfFindClusterInTypeWithMfgCode_2
   \       0x26   0x0031             MOVS     R1,R6
   \       0x28   0xD00A             BEQ.N    ??emberAfFindClusterInTypeWithMfgCode_3
   \       0x2A   0x2E80             CMP      R6,#+128
   \       0x2C   0xD103             BNE.N    ??emberAfFindClusterInTypeWithMfgCode_4
   \       0x2E   0x7B39             LDRB     R1,[R7, #+12]
   \       0x30   0x060A             LSLS     R2,R1,#+24
   \       0x32   0xD405             BMI.N    ??emberAfFindClusterInTypeWithMfgCode_3
   \       0x34   0xE00F             B.N      ??emberAfFindClusterInTypeWithMfgCode_2
   \                     ??emberAfFindClusterInTypeWithMfgCode_4: (+1)
   \       0x36   0x2E40             CMP      R6,#+64
   \       0x38   0xD10D             BNE.N    ??emberAfFindClusterInTypeWithMfgCode_2
   \       0x3A   0x7B39             LDRB     R1,[R7, #+12]
   \       0x3C   0x064A             LSLS     R2,R1,#+25
   \       0x3E   0xD50A             BPL.N    ??emberAfFindClusterInTypeWithMfgCode_2
   \                     ??emberAfFindClusterInTypeWithMfgCode_3: (+1)
   \       0x40   0xF5B0 0x4F7C      CMP      R0,#+64512
   \       0x44   0xDB0C             BLT.N    ??emberAfFindClusterInTypeWithMfgCode_5
   \       0x46   0x4638             MOV      R0,R7
   \       0x48   0x....'....        BL       emAfGetManufacturerCodeForCluster
   \       0x4C   0x4548             CMP      R0,R9
   \       0x4E   0xBF18             IT       NE 
   \       0x50   0xEA5F 0x0009      MOVSNE   R0,R9
   \       0x54   0xD004             BEQ.N    ??emberAfFindClusterInTypeWithMfgCode_5
   \                     ??emberAfFindClusterInTypeWithMfgCode_2: (+1)
   \       0x56   0x1C6D             ADDS     R5,R5,#+1
   \       0x58   0xE7D9             B.N      ??emberAfFindClusterInTypeWithMfgCode_0
    652                return cluster;
    653              }
    654            }
    655            return NULL;
   \                     ??emberAfFindClusterInTypeWithMfgCode_1: (+1)
   \       0x5A   0x2000             MOVS     R0,#+0
   \                     ??emberAfFindClusterInTypeWithMfgCode_6: (+1)
   \       0x5C   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   \                     ??emberAfFindClusterInTypeWithMfgCode_5: (+1)
   \       0x60   0x4638             MOV      R0,R7
   \       0x62   0xE7FB             B.N      ??emberAfFindClusterInTypeWithMfgCode_6
    656          }
    657          
    658          // This functions wraps emberAfFindClusterInTypeWithMfgCode with
    659          // a manufacturerCode of EMBER_AF_NULL_MANUFACTURER_CODE.

   \                                 In section .text, align 2, keep-with-next
    660          EmberAfCluster *emberAfFindClusterInType(EmberAfEndpointType *endpointType,
    661                                                   EmberAfClusterId clusterId,
    662                                                   EmberAfClusterMask mask)
    663          {
    664            return emberAfFindClusterInTypeWithMfgCode(endpointType,
    665                                                       clusterId,
    666                                                       mask,
    667                                                       EMBER_AF_NULL_MANUFACTURER_CODE);
   \                     emberAfFindClusterInType: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x....             B.N      emberAfFindClusterInTypeWithMfgCode
    668          }
    669          
    670          // This code is used during unit tests for clusters that do not involve manufacturer code.
    671          // Should this code be used in other locations, manufacturerCode should be added.

   \                                 In section .text, align 2, keep-with-next
    672          uint8_t emberAfClusterIndex(uint8_t endpoint,
    673                                      EmberAfClusterId clusterId,
    674                                      EmberAfClusterMask mask)
    675          {
   \                     emberAfClusterIndex: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x468B             MOV      R11,R1
   \        0x8   0x4690             MOV      R8,R2
    676            uint8_t ep;
    677            uint8_t index = 0xFF;
   \        0xA   0x25FF             MOVS     R5,#+255
    678            for ( ep = 0; ep < emberAfEndpointCount(); ep++ ) {
   \        0xC   0x2600             MOVS     R6,#+0
   \        0xE   0x....'....        LDR.W    R4,??DataTable17_6
   \       0x12   0x....'....        LDR.W    R9,??DataTable17_4
   \       0x16   0xE000             B.N      ??emberAfClusterIndex_0
   \                     ??emberAfClusterIndex_1: (+1)
   \       0x18   0x1C76             ADDS     R6,R6,#+1
   \                     ??emberAfClusterIndex_0: (+1)
   \       0x1A   0xF899 0x1000      LDRB     R1,[R9, #+0]
   \       0x1E   0xB2F0             UXTB     R0,R6
   \       0x20   0x4288             CMP      R0,R1
   \       0x22   0xD212             BCS.N    ??emberAfClusterIndex_2
    679              EmberAfEndpointType *endpointType = emAfEndpoints[ep].endpointType;
    680              if ( emberAfFindClusterInTypeWithMfgCode(endpointType, clusterId, mask, EMBER_AF_NULL_MANUFACTURER_CODE) != NULL ) {
   \       0x24   0x0637             LSLS     R7,R6,#+24
   \       0x26   0x0D3F             LSRS     R7,R7,#+20
   \       0x28   0xEB04 0x0E07      ADD      LR,R4,R7
   \       0x2C   0xF8DE 0x0008      LDR      R0,[LR, #+8]
   \       0x30   0x2300             MOVS     R3,#+0
   \       0x32   0x4642             MOV      R2,R8
   \       0x34   0x4659             MOV      R1,R11
   \       0x36   0x....'....        BL       emberAfFindClusterInTypeWithMfgCode
   \       0x3A   0x2800             CMP      R0,#+0
   \       0x3C   0xD0EC             BEQ.N    ??emberAfClusterIndex_1
    681                index++;
    682                if ( emAfEndpoints[ep].endpoint == endpoint ) {
   \       0x3E   0x5DE0             LDRB     R0,[R4, R7]
   \       0x40   0x1C6D             ADDS     R5,R5,#+1
   \       0x42   0x4550             CMP      R0,R10
   \       0x44   0xD1E8             BNE.N    ??emberAfClusterIndex_1
    683                  return index;
   \       0x46   0xB2E8             UXTB     R0,R5
   \       0x48   0xE000             B.N      ??emberAfClusterIndex_3
    684                }
    685              }
    686            }
    687            return 0xFF;
   \                     ??emberAfClusterIndex_2: (+1)
   \       0x4A   0x20FF             MOVS     R0,#+255
   \                     ??emberAfClusterIndex_3: (+1)
   \       0x4C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    688          }
    689          
    690          // Returns true uf endpoint contains passed cluster

   \                                 In section .text, align 2, keep-with-next
    691          bool emberAfContainsClusterWithMfgCode(uint8_t endpoint, EmberAfClusterId clusterId, uint16_t manufacturerCode)
    692          {
   \                     emberAfContainsClusterWithMfgCode: (+1)
   \        0x0   0x4613             MOV      R3,R2
   \        0x2   0xB580             PUSH     {R7,LR}
    693            return (emberAfFindClusterWithMfgCode(endpoint, clusterId, 0, manufacturerCode) != NULL);
   \        0x4   0x....             B.N      ?Subroutine3
    694          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \                     ??Subroutine3_0: (+1)
   \        0x2   0x....'....        BL       emberAfFindClusterWithMfgCode
   \        0x6   0xB100             CBZ.N    R0,??Subroutine3_1
   \        0x8   0x2001             MOVS     R0,#+1
   \                     ??Subroutine3_1: (+1)
   \        0xA   0xBD02             POP      {R1,PC}          ;; return
    695          
    696          // Returns true if endpoint contains passed cluster as a server

   \                                 In section .text, align 2, keep-with-next
    697          bool emberAfContainsServerWithMfgCode(uint8_t endpoint, EmberAfClusterId clusterId, uint16_t manufacturerCode)
    698          {
   \                     emberAfContainsServerWithMfgCode: (+1)
   \        0x0   0x4613             MOV      R3,R2
   \        0x2   0xB580             PUSH     {R7,LR}
    699            return (emberAfFindClusterWithMfgCode(endpoint, clusterId, CLUSTER_MASK_SERVER, manufacturerCode) != NULL);
   \        0x4   0x2240             MOVS     R2,#+64
   \        0x6   0x....             B.N      ??Subroutine3_0
    700          }
    701          
    702          // Returns true if endpoint contains passed cluster as a client

   \                                 In section .text, align 2, keep-with-next
    703          bool emberAfContainsClientWithMfgCode(uint8_t endpoint, EmberAfClusterId clusterId, uint16_t manufacturerCode)
    704          {
   \                     emberAfContainsClientWithMfgCode: (+1)
   \        0x0   0x4613             MOV      R3,R2
   \        0x2   0xB580             PUSH     {R7,LR}
    705            return (emberAfFindClusterWithMfgCode(endpoint, clusterId, CLUSTER_MASK_CLIENT, manufacturerCode) != NULL);
   \        0x4   0x2280             MOVS     R2,#+128
   \        0x6   0x....             B.N      ??Subroutine3_0
    706          }
    707          
    708          // Wraps emberAfContainsClusterWithMfgCode with EMBER_AF_NULL_MANUFACTURER_CODE
    709          // This will find the first cluster that has the clusterId given, regardless of mfgCode.

   \                                 In section .text, align 2, keep-with-next
    710          bool emberAfContainsCluster(uint8_t endpoint, EmberAfClusterId clusterId)
    711          {
   \                     emberAfContainsCluster: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    712            return (emberAfFindClusterWithMfgCode(endpoint, clusterId, 0, EMBER_AF_NULL_MANUFACTURER_CODE) != NULL);
   \        0x2   0x2300             MOVS     R3,#+0
   \        0x4                      REQUIRE ?Subroutine3
   \        0x4                      ;; // Fall through to label ?Subroutine3
    713          }
    714          
    715          // Wraps emberAfContainsServerWithMfgCode with EMBER_AF_NULL_MANUFACTURER_CODE
    716          // This will find the first server that has the clusterId given, regardless of mfgCode.

   \                                 In section .text, align 2, keep-with-next
    717          bool emberAfContainsServer(uint8_t endpoint, EmberAfClusterId clusterId)
    718          {
   \                     emberAfContainsServer: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    719            return (emberAfFindClusterWithMfgCode(endpoint, clusterId, CLUSTER_MASK_SERVER, EMBER_AF_NULL_MANUFACTURER_CODE) != NULL);
   \        0x2   0x2300             MOVS     R3,#+0
   \        0x4   0x2240             MOVS     R2,#+64
   \        0x6   0x....             B.N      ??Subroutine3_0
    720          }
    721          
    722          // Wraps emberAfContainsClientWithMfgCode with EMBER_AF_NULL_MANUFACTURER_CODE
    723          // This will find the first client that has the clusterId given, regardless of mfgCode.

   \                                 In section .text, align 2, keep-with-next
    724          bool emberAfContainsClient(uint8_t endpoint, EmberAfClusterId clusterId)
    725          {
   \                     emberAfContainsClient: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    726            return (emberAfFindClusterWithMfgCode(endpoint, clusterId, CLUSTER_MASK_CLIENT, EMBER_AF_NULL_MANUFACTURER_CODE) != NULL);
   \        0x2   0x2300             MOVS     R3,#+0
   \        0x4   0x2280             MOVS     R2,#+128
   \        0x6   0x....             B.N      ??Subroutine3_0
    727          }
    728          
    729          // Finds the cluster that matches endpoint, clusterId, direction, and manufacturerCode.

   \                                 In section .text, align 2, keep-with-next
    730          EmberAfCluster *emberAfFindClusterWithMfgCode(uint8_t endpoint,
    731                                                        EmberAfClusterId clusterId,
    732                                                        EmberAfClusterMask mask,
    733                                                        uint16_t manufacturerCode)
    734          {
   \                     emberAfFindClusterWithMfgCode: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4615             MOV      R5,R2
   \        0x6   0x461E             MOV      R6,R3
    735            uint8_t ep = emberAfIndexFromEndpoint(endpoint);
   \        0x8   0x....'....        BL       emberAfIndexFromEndpoint
    736            if ( ep == 0xFF ) {
   \        0xC   0x28FF             CMP      R0,#+255
   \        0xE   0xD101             BNE.N    ??emberAfFindClusterWithMfgCode_0
    737              return NULL;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xBD70             POP      {R4-R6,PC}
    738            } else {
    739              return emberAfFindClusterInTypeWithMfgCode(emAfEndpoints[ep].endpointType, clusterId, mask, manufacturerCode);
   \                     ??emberAfFindClusterWithMfgCode_0: (+1)
   \       0x14   0x....             B.N      ?Subroutine2
    740            }
    741          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x4621             MOV      R1,R4
   \        0x2   0x....'....        LDR.W    R4,??DataTable19
   \        0x6   0xEB04 0x1000      ADD      R0,R4,R0, LSL #+4
   \        0xA   0x4633             MOV      R3,R6
   \        0xC   0x462A             MOV      R2,R5
   \        0xE   0x6880             LDR      R0,[R0, #+8]
   \       0x10   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x14   0x....             B.N      emberAfFindClusterInTypeWithMfgCode
    742          
    743          // This function wraps emberAfFindClusterWithMfgCode with EMBER_AF_NULL_MANUFACTURER_CODE
    744          // and will ignore the manufacturerCode when trying to find clusters.
    745          // This will return the first cluster in the cluster table that matches the parameters given.

   \                                 In section .text, align 2, keep-with-next
    746          EmberAfCluster *emberAfFindCluster(uint8_t endpoint,
    747                                             EmberAfClusterId clusterId,
    748                                             EmberAfClusterMask mask)
    749          {
    750            return emberAfFindClusterWithMfgCode(endpoint, clusterId, mask, EMBER_AF_NULL_MANUFACTURER_CODE);
   \                     emberAfFindCluster: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x....             B.N      emberAfFindClusterWithMfgCode
    751          }
    752          
    753          // Returns cluster within the endpoint; Does not ignore disabled endpoints

   \                                 In section .text, align 2, keep-with-next
    754          EmberAfCluster *emberAfFindClusterIncludingDisabledEndpointsWithMfgCode(uint8_t endpoint,
    755                                                                                  EmberAfClusterId clusterId,
    756                                                                                  EmberAfClusterMask mask,
    757                                                                                  uint16_t manufacturerCode)
    758          {
   \                     emberAfFindClusterIncludingDisabledEndpointsWithMfgCode: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4615             MOV      R5,R2
   \        0x6   0x461E             MOV      R6,R3
    759            uint8_t ep = emberAfIndexFromEndpointIncludingDisabledEndpoints(endpoint);
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x....'....        BL       findIndexFromEndpoint
    760            return emberAfFindClusterInTypeWithMfgCode(emAfEndpoints[ep].endpointType, clusterId, mask, manufacturerCode);
   \        0xE                      REQUIRE ?Subroutine2
   \        0xE                      ;; // Fall through to label ?Subroutine2
    761          }
    762          
    763          // Returns cluster within the endpoint; Does not ignore disabled endpoints
    764          // This will ignore manufacturerCode.

   \                                 In section .text, align 2, keep-with-next
    765          EmberAfCluster *emberAfFindClusterIncludingDisabledEndpoints(uint8_t endpoint,
    766                                                                       EmberAfClusterId clusterId,
    767                                                                       EmberAfClusterMask mask)
    768          {
    769            return emberAfFindClusterIncludingDisabledEndpointsWithMfgCode(endpoint, clusterId, mask, EMBER_AF_NULL_MANUFACTURER_CODE);
   \                     emberAfFindClusterIncludingDisabledEndpoints: (+1)
   \        0x0   0x2300             MOVS     R3,#+0
   \        0x2   0x....             B.N      emberAfFindClusterIncludingDisabledEndpointsWithMfgCode
    770          }
    771          
    772          // Server wrapper for findClusterEndpointIndex.

   \                                 In section .text, align 2, keep-with-next
    773          uint8_t emberAfFindClusterServerEndpointIndexWithMfgCode(uint8_t endpoint, EmberAfClusterId clusterId, uint16_t manufacturerCode)
    774          {
   \                     emberAfFindClusterServerEndpointIndexWithMfgCode: (+1)
   \        0x0   0x4613             MOV      R3,R2
    775            return findClusterEndpointIndex(endpoint, clusterId, CLUSTER_MASK_SERVER, manufacturerCode);
   \        0x2   0x2240             MOVS     R2,#+64
   \        0x4   0x....             B.N      findClusterEndpointIndex
    776          }
    777          
    778          // Client wrapper for findClusterEndpointIndex.

   \                                 In section .text, align 2, keep-with-next
    779          uint8_t emberAfFindClusterClientEndpointIndexWithMfgCode(uint8_t endpoint, EmberAfClusterId clusterId, uint16_t manufacturerCode)
    780          {
   \                     emberAfFindClusterClientEndpointIndexWithMfgCode: (+1)
   \        0x0   0x4613             MOV      R3,R2
    781            return findClusterEndpointIndex(endpoint, clusterId, CLUSTER_MASK_CLIENT, manufacturerCode);
   \        0x2   0x2280             MOVS     R2,#+128
   \        0x4   0x....             B.N      findClusterEndpointIndex
    782          }
    783          
    784          // Server wrapper for findClusterEndpointIndex
    785          // This will ignore manufacturerCode, and return the index for the first server that matches on clusterId

   \                                 In section .text, align 2, keep-with-next
    786          uint8_t emberAfFindClusterServerEndpointIndex(uint8_t endpoint, EmberAfClusterId clusterId)
    787          {
    788            return emberAfFindClusterServerEndpointIndexWithMfgCode(endpoint, clusterId, EMBER_AF_NULL_MANUFACTURER_CODE);
   \                     emberAfFindClusterServerEndpointIndex: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \        0x2   0x....             B.N      emberAfFindClusterServerEndpointIndexWithMfgCode
    789          }
    790          
    791          // Client wrapper for findClusterEndpointIndex
    792          // This will ignore manufacturerCode, and return the index for the first client that matches on clusterId

   \                                 In section .text, align 2, keep-with-next
    793          uint8_t emberAfFindClusterClientEndpointIndex(uint8_t endpoint, EmberAfClusterId clusterId)
    794          {
    795            return emberAfFindClusterClientEndpointIndexWithMfgCode(endpoint, clusterId, EMBER_AF_NULL_MANUFACTURER_CODE);
   \                     emberAfFindClusterClientEndpointIndex: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \        0x2   0x....             B.N      emberAfFindClusterClientEndpointIndexWithMfgCode
    796          }
    797          
    798          // Returns the endpoint index within a given cluster

   \                                 In section .text, align 2, keep-with-next
    799          static uint8_t findClusterEndpointIndex(uint8_t endpoint, EmberAfClusterId clusterId, uint8_t mask, uint16_t manufacturerCode)
    800          {
   \                     findClusterEndpointIndex: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4682             MOV      R10,R0
   \        0x6   0x468B             MOV      R11,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x4699             MOV      R9,R3
    801            uint8_t i, epi = 0;
   \        0xC   0x2600             MOVS     R6,#+0
    802          
    803            if (emberAfFindClusterWithMfgCode(endpoint, clusterId, mask, manufacturerCode) == NULL) {
   \        0xE   0x....'....        BL       emberAfFindClusterWithMfgCode
   \       0x12   0xB908             CBNZ.N   R0,??findClusterEndpointIndex_0
    804              return 0xFF;
   \       0x14   0x20FF             MOVS     R0,#+255
   \       0x16   0xE016             B.N      ??findClusterEndpointIndex_1
    805            }
    806          
    807            for (i = 0; i < emberAfEndpointCount(); i++) {
   \                     ??findClusterEndpointIndex_0: (+1)
   \       0x18   0x2700             MOVS     R7,#+0
   \       0x1A   0x....'....        LDR.W    R4,??DataTable17_6
   \       0x1E   0x....'....        LDR.W    R5,??DataTable17_4
   \                     ??findClusterEndpointIndex_2: (+1)
   \       0x22   0x7829             LDRB     R1,[R5, #+0]
   \       0x24   0xB2F8             UXTB     R0,R7
   \       0x26   0x4288             CMP      R0,R1
   \       0x28   0xD20C             BCS.N    ??findClusterEndpointIndex_3
    808              if (emAfEndpoints[i].endpoint == endpoint) {
   \       0x2A   0x0100             LSLS     R0,R0,#+4
   \       0x2C   0x5C20             LDRB     R0,[R4, R0]
   \       0x2E   0x4550             CMP      R0,R10
   \       0x30   0xD008             BEQ.N    ??findClusterEndpointIndex_3
    809                break;
    810              }
    811              epi += (emberAfFindClusterIncludingDisabledEndpointsWithMfgCode(emAfEndpoints[i].endpoint, clusterId, mask, manufacturerCode) != NULL) ? 1 : 0;
   \       0x32   0x464B             MOV      R3,R9
   \       0x34   0x4642             MOV      R2,R8
   \       0x36   0x4659             MOV      R1,R11
   \       0x38   0x....'....        BL       emberAfFindClusterIncludingDisabledEndpointsWithMfgCode
   \       0x3C   0xB100             CBZ.N    R0,??findClusterEndpointIndex_4
   \       0x3E   0x1C76             ADDS     R6,R6,#+1
    812            }
   \                     ??findClusterEndpointIndex_4: (+1)
   \       0x40   0x1C7F             ADDS     R7,R7,#+1
   \       0x42   0xE7EE             B.N      ??findClusterEndpointIndex_2
    813          
    814            return epi;
   \                     ??findClusterEndpointIndex_3: (+1)
   \       0x44   0xB2F0             UXTB     R0,R6
   \                     ??findClusterEndpointIndex_1: (+1)
   \       0x46   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    815          }
    816          

   \                                 In section .text, align 2, keep-with-next
    817          static uint8_t findIndexFromEndpoint(uint8_t endpoint, bool ignoreDisabledEndpoints)
    818          {
   \                     findIndexFromEndpoint: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    819            uint8_t epi;
    820            for (epi = 0; epi < emberAfEndpointCount(); epi++) {
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x....'....        LDR.W    R3,??DataTable17_6
   \                     ??findIndexFromEndpoint_0: (+1)
   \        0x8   0x....'....        LDR.W    R5,??DataTable17_4
   \        0xC   0x782E             LDRB     R6,[R5, #+0]
   \        0xE   0xB2D4             UXTB     R4,R2
   \       0x10   0x42B4             CMP      R4,R6
   \       0x12   0xD20B             BCS.N    ??findIndexFromEndpoint_1
    821              if (emAfEndpoints[epi].endpoint == endpoint
    822                  && (!ignoreDisabledEndpoints
    823                      || emAfEndpoints[epi].bitmask & EMBER_AF_ENDPOINT_ENABLED)) {
   \       0x14   0x0124             LSLS     R4,R4,#+4
   \       0x16   0x5D1D             LDRB     R5,[R3, R4]
   \       0x18   0x4285             CMP      R5,R0
   \       0x1A   0xD105             BNE.N    ??findIndexFromEndpoint_2
   \       0x1C   0x000D             MOVS     R5,R1
   \       0x1E   0xD007             BEQ.N    ??findIndexFromEndpoint_3
   \       0x20   0x441C             ADD      R4,R3,R4
   \       0x22   0x7B64             LDRB     R4,[R4, #+13]
   \       0x24   0x07E5             LSLS     R5,R4,#+31
   \       0x26   0xD403             BMI.N    ??findIndexFromEndpoint_3
   \                     ??findIndexFromEndpoint_2: (+1)
   \       0x28   0x1C52             ADDS     R2,R2,#+1
   \       0x2A   0xE7ED             B.N      ??findIndexFromEndpoint_0
    824                return epi;
    825              }
    826            }
    827            return 0xFF;
   \                     ??findIndexFromEndpoint_1: (+1)
   \       0x2C   0x20FF             MOVS     R0,#+255
   \       0x2E   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??findIndexFromEndpoint_3: (+1)
   \       0x30   0xB2D0             UXTB     R0,R2
   \       0x32   0xBD70             POP      {R4-R6,PC}
    828          }
    829          

   \                                 In section .text, align 2, keep-with-next
    830          bool emberAfEndpointIsEnabled(uint8_t endpoint)
    831          {
   \                     emberAfEndpointIsEnabled: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    832            uint8_t index = findIndexFromEndpoint(endpoint,
    833                                                  false);  // ignore disabled endpoints?
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x....'....        BL       findIndexFromEndpoint
    834          
    835            EMBER_TEST_ASSERT(0xFF != index);
    836          
    837            if (0xFF == index) {
   \        0x8   0x28FF             CMP      R0,#+255
   \        0xA   0xD101             BNE.N    ??emberAfEndpointIsEnabled_0
    838              return false;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xBD02             POP      {R1,PC}
    839            }
    840          
    841            return emberAfEndpointIndexIsEnabled(index);
   \                     ??emberAfEndpointIsEnabled_0: (+1)
   \       0x10   0x....'....        BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0x14   0x7B40             LDRB     R0,[R0, #+13]
   \       0x16   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x1A   0xBD02             POP      {R1,PC}          ;; return
    842          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable19
   \        0x4   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \        0x8   0x4770             BX       LR
    843          

   \                                 In section .text, align 2, keep-with-next
    844          bool emberAfEndpointEnableDisable(uint8_t endpoint, bool enable)
    845          {
   \                     emberAfEndpointEnableDisable: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x460E             MOV      R6,R1
   \        0x4   0x4604             MOV      R4,R0
    846            uint8_t index = findIndexFromEndpoint(endpoint,
    847                                                  false);  // ignore disabled endpoints?
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x....'....        BL       findIndexFromEndpoint
    848            bool currentlyEnabled;
    849          
    850            if (0xFF == index) {
   \        0xC   0x28FF             CMP      R0,#+255
   \        0xE   0xD101             BNE.N    ??emberAfEndpointEnableDisable_0
    851              return false;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xBD70             POP      {R4-R6,PC}
    852            }
    853          
    854            currentlyEnabled = emAfEndpoints[index].bitmask & EMBER_AF_ENDPOINT_ENABLED;
   \                     ??emberAfEndpointEnableDisable_0: (+1)
   \       0x14   0x....'....        LDR.W    R1,??DataTable19
   \       0x18   0xEB01 0x1500      ADD      R5,R1,R0, LSL #+4
    855          
    856            if (enable) {
   \       0x1C   0x0032             MOVS     R2,R6
   \       0x1E   0x7B68             LDRB     R0,[R5, #+13]
   \       0x20   0xF000 0x0101      AND      R1,R0,#0x1
   \       0x24   0xBF14             ITE      NE 
   \       0x26   0xF040 0x0001      ORRNE    R0,R0,#0x1
   \       0x2A   0x2000             MOVEQ    R0,#+0
    857              emAfEndpoints[index].bitmask |= EMBER_AF_ENDPOINT_ENABLED;
    858            } else {
    859              emAfEndpoints[index].bitmask &= EMBER_AF_ENDPOINT_DISABLED;
   \       0x2C   0x7368             STRB     R0,[R5, #+13]
    860            }
    861          
    862          #if defined(EZSP_HOST)
    863            ezspSetEndpointFlags(endpoint,
    864                                 (enable
    865                                  ? EZSP_ENDPOINT_ENABLED
    866                                  : EZSP_ENDPOINT_DISABLED));
    867          #endif
    868          
    869            if (currentlyEnabled != enable) {
   \       0x2E   0x42B1             CMP      R1,R6
   \       0x30   0xD014             BEQ.N    ??emberAfEndpointEnableDisable_1
    870              if (enable) {
   \       0x32   0xB176             CBZ.N    R6,??emberAfEndpointEnableDisable_2
    871                initializeEndpoint(&(emAfEndpoints[index]));
   \       0x34   0x4628             MOV      R0,R5
   \       0x36   0x....'....        BL       initializeEndpoint
   \       0x3A   0xE00F             B.N      ??emberAfEndpointEnableDisable_1
    872              } else {
    873                uint8_t i;
    874                for (i = 0; i < emAfEndpoints[index].endpointType->clusterCount; i++) {
    875                  EmberAfCluster* cluster = &((emAfEndpoints[index].endpointType->cluster)[i]);
   \                     ??emberAfEndpointEnableDisable_3: (+1)
   \       0x3C   0x2214             MOVS     R2,#+20
   \       0x3E   0x6800             LDR      R0,[R0, #+0]
   \       0x40   0x4351             MULS     R1,R2,R1
    876          //        emberAfCorePrintln("Disabling cluster tick for ep:%d, cluster:0x%2X, %p",
    877          //                           endpoint,
    878          //                           cluster->clusterId,
    879          //                           ((cluster->mask & CLUSTER_MASK_CLIENT)
    880          //                            ? "client"
    881          //                            : "server"));
    882          //        emberAfCoreFlush();
    883                  emberAfDeactivateClusterTick(endpoint,
    884                                               cluster->clusterId,
    885                                               (cluster->mask & CLUSTER_MASK_CLIENT
    886                                                ? EMBER_AF_CLIENT_CLUSTER_TICK
    887                                                : EMBER_AF_SERVER_CLUSTER_TICK));
   \       0x42   0x1C76             ADDS     R6,R6,#+1
   \       0x44   0x4408             ADD      R0,R0,R1
   \       0x46   0x7B02             LDRB     R2,[R0, #+12]
   \       0x48   0x8801             LDRH     R1,[R0, #+0]
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0x09D2             LSRS     R2,R2,#+7
   \       0x4E   0x....'....        BL       emberAfDeactivateClusterTick
    888                }
   \                     ??emberAfEndpointEnableDisable_2: (+1)
   \       0x52   0x68A8             LDR      R0,[R5, #+8]
   \       0x54   0xB2F1             UXTB     R1,R6
   \       0x56   0x7902             LDRB     R2,[R0, #+4]
   \       0x58   0x4291             CMP      R1,R2
   \       0x5A   0xD3EF             BCC.N    ??emberAfEndpointEnableDisable_3
    889              }
    890            }
    891          
    892            return true;
   \                     ??emberAfEndpointEnableDisable_1: (+1)
   \       0x5C   0x2001             MOVS     R0,#+1
   \       0x5E   0xBD70             POP      {R4-R6,PC}       ;; return
    893          }
    894          
    895          // Returns the index of a given endpoint.  Does not consider disabled endpoints.

   \                                 In section .text, align 2, keep-with-next
    896          uint8_t emberAfIndexFromEndpoint(uint8_t endpoint)
    897          {
    898            return findIndexFromEndpoint(endpoint,
    899                                         true);    // ignore disabled endpoints?
   \                     emberAfIndexFromEndpoint: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
   \        0x2   0x....             B.N      findIndexFromEndpoint
    900          }
    901          
    902          // Returns the index of a given endpoint.  Considers disabled endpoints.

   \                                 In section .text, align 2, keep-with-next
    903          uint8_t emberAfIndexFromEndpointIncludingDisabledEndpoints(uint8_t endpoint)
    904          {
    905            return findIndexFromEndpoint(endpoint,
    906                                         false);    // ignore disabled endpoints?
   \                     emberAfIndexFromEndpointIncludingDisabledEndpoints: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x....             B.N      findIndexFromEndpoint
    907          }
    908          

   \                                 In section .text, align 2, keep-with-next
    909          uint8_t emberAfEndpointFromIndex(uint8_t index)
    910          {
    911            return emAfEndpoints[index].endpoint;
   \                     emberAfEndpointFromIndex: (+1)
   \        0x0   0x....'....        LDR.W    R1,??DataTable19
   \        0x4   0x0100             LSLS     R0,R0,#+4
   \        0x6   0x5C08             LDRB     R0,[R1, R0]
   \        0x8   0x4770             BX       LR               ;; return
    912          }
    913          
    914          // If server == true, returns the number of server clusters,
    915          // otherwise number of client clusters on this endpoint

   \                                 In section .text, align 2, keep-with-next
    916          uint8_t emberAfClusterCount(uint8_t endpoint, bool server)
    917          {
   \                     emberAfClusterCount: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x460C             MOV      R4,R1
    918            uint8_t index = emberAfIndexFromEndpoint(endpoint);
   \        0x4   0x....'....        BL       emberAfIndexFromEndpoint
   \        0x8   0x4601             MOV      R1,R0
    919            uint8_t i, c = 0;
   \        0xA   0x2000             MOVS     R0,#+0
    920            EmberAfDefinedEndpoint *de;
    921            EmberAfCluster *cluster;
    922          
    923            if ( index == 0xFF ) {
   \        0xC   0x29FF             CMP      R1,#+255
   \        0xE   0xBF1F             ITTTT    NE 
   \       0x10   0x....'....        LDRNE.W  R2,??DataTable19
   \       0x14   0xEB02 0x1101      ADDNE    R1,R2,R1, LSL #+4
   \       0x18   0x6889             LDRNE    R1,[R1, #+8]
   \       0x1A   0x2900             CMPNE    R1,#+0
    924              return 0;
    925            }
    926            de = &(emAfEndpoints[index]);
    927            if ( de->endpointType == NULL) {
   \       0x1C   0xD015             BEQ.N    ??emberAfClusterCount_0
    928              return 0;
    929            }
    930            for ( i = 0; i < de->endpointType->clusterCount; i++ ) {
   \       0x1E   0x2200             MOVS     R2,#+0
   \       0x20   0x2714             MOVS     R7,#+20
   \                     ??emberAfClusterCount_1: (+1)
   \       0x22   0x790D             LDRB     R5,[R1, #+4]
   \       0x24   0xB2D3             UXTB     R3,R2
   \       0x26   0x42AB             CMP      R3,R5
   \       0x28   0xD20E             BCS.N    ??emberAfClusterCount_2
    931              cluster = &(de->endpointType->cluster[i]);
   \       0x2A   0xB2D6             UXTB     R6,R2
   \       0x2C   0x680B             LDR      R3,[R1, #+0]
   \       0x2E   0x437E             MULS     R6,R7,R6
    932              if ( server && emberAfClusterIsServer(cluster) ) {
   \       0x30   0x1C45             ADDS     R5,R0,#+1
   \       0x32   0x4433             ADD      R3,R3,R6
   \       0x34   0x7B1B             LDRB     R3,[R3, #+12]
   \       0x36   0x0026             MOVS     R6,R4
   \       0x38   0xD101             BNE.N    ??emberAfClusterCount_3
   \       0x3A   0x061B             LSLS     R3,R3,#+24
   \       0x3C   0xE000             B.N      ??emberAfClusterCount_4
   \                     ??emberAfClusterCount_3: (+1)
   \       0x3E   0x065E             LSLS     R6,R3,#+25
   \                     ??emberAfClusterCount_4: (+1)
   \       0x40   0xBF48             IT       MI 
   \       0x42   0x4628             MOVMI    R0,R5
    933                c++;
    934              }
    935              if ( (!server) && emberAfClusterIsClient(cluster) ) {
    936                c++;
    937              }
    938            }
   \       0x44   0x1C52             ADDS     R2,R2,#+1
   \       0x46   0xE7EC             B.N      ??emberAfClusterCount_1
    939            return c;
   \                     ??emberAfClusterCount_2: (+1)
   \       0x48   0xB2C0             UXTB     R0,R0
   \                     ??emberAfClusterCount_0: (+1)
   \       0x4A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    940          }
    941          

   \                                 In section .text, align 2, keep-with-next
    942          uint8_t emberAfGetClusterCountForEndpoint(uint8_t endpoint)
    943          {
   \                     emberAfGetClusterCountForEndpoint: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    944            uint8_t index = emberAfIndexFromEndpoint(endpoint);
   \        0x2   0x....'....        BL       emberAfIndexFromEndpoint
    945            if ( index == 0xFF) {
   \        0x6   0x28FF             CMP      R0,#+255
   \        0x8   0xD101             BNE.N    ??emberAfGetClusterCountForEndpoint_0
    946              return 0;
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xBD02             POP      {R1,PC}
    947            }
    948            return emAfEndpoints[index].endpointType->clusterCount;
   \                     ??emberAfGetClusterCountForEndpoint_0: (+1)
   \        0xE   0x....'....        BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0x12   0x6882             LDR      R2,[R0, #+8]
   \       0x14   0x7910             LDRB     R0,[R2, #+4]
   \       0x16   0xBD02             POP      {R1,PC}          ;; return
    949          }
    950          
    951          // Note the difference in implementation from emberAfGetNthCluster().
    952          // emberAfGetClusterByIndex() retrieves the cluster by index regardless of server/client
    953          // and those indexes may be DIFFERENT than the indexes returned from
    954          // emberAfGetNthCluster().  In other words:
    955          //
    956          //  - Use emberAfGetClustersFromEndpoint()  with emberAfGetNthCluster()
    957          //  - Use emberAfGetClusterCountForEndpoint() with emberAfGetClusterByIndex()
    958          //
    959          // Don't mix them.

   \                                 In section .text, align 2, keep-with-next
    960          EmberAfCluster* emberAfGetClusterByIndex(uint8_t endpoint, uint8_t clusterIndex)
    961          {
   \                     emberAfGetClusterByIndex: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x460C             MOV      R4,R1
    962            uint8_t endpointIndex = emberAfIndexFromEndpoint(endpoint);
   \        0x4   0x....'....        BL       emberAfIndexFromEndpoint
    963            EmberAfDefinedEndpoint* definedEndpoint;
    964          
    965            if (endpointIndex == 0xFF) {
   \        0x8   0x28FF             CMP      R0,#+255
   \        0xA   0xD005             BEQ.N    ??emberAfGetClusterByIndex_0
    966              return NULL;
    967            }
    968            definedEndpoint = &(emAfEndpoints[endpointIndex]);
    969          
    970            if (clusterIndex >= definedEndpoint->endpointType->clusterCount) {
   \        0xC   0x....'....        BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x10   0x6880             LDR      R0,[R0, #+8]
   \       0x12   0x7901             LDRB     R1,[R0, #+4]
   \       0x14   0x428C             CMP      R4,R1
   \       0x16   0xD301             BCC.N    ??emberAfGetClusterByIndex_1
    971              return NULL;
   \                     ??emberAfGetClusterByIndex_0: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0xBD10             POP      {R4,PC}
    972            }
    973            return &(definedEndpoint->endpointType->cluster[clusterIndex]);
   \                     ??emberAfGetClusterByIndex_1: (+1)
   \       0x1C   0x6801             LDR      R1,[R0, #+0]
   \       0x1E   0x2014             MOVS     R0,#+20
   \       0x20   0x4344             MULS     R4,R0,R4
   \       0x22   0x1908             ADDS     R0,R1,R4
   \       0x24   0xBD10             POP      {R4,PC}          ;; return
    974          }
    975          

   \                                 In section .text, align 2, keep-with-next
    976          EmberAfProfileId emberAfGetProfileIdForEndpoint(uint8_t endpoint)
    977          {
   \                     emberAfGetProfileIdForEndpoint: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    978            uint8_t endpointIndex = emberAfIndexFromEndpoint(endpoint);
   \        0x2   0x....'....        BL       emberAfIndexFromEndpoint
    979            if (endpointIndex == 0xFF) {
   \        0x6   0x28FF             CMP      R0,#+255
   \        0x8   0xD100             BNE.N    ??emberAfGetProfileIdForEndpoint_0
    980              return EMBER_AF_INVALID_PROFILE_ID;
   \        0xA   0x....             B.N      ?Subroutine4
    981            }
    982            return emAfEndpoints[endpointIndex].profileId;
   \                     ??emberAfGetProfileIdForEndpoint_0: (+1)
   \        0xC   0x....'....        BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x10   0x8840             LDRH     R0,[R0, #+2]
   \       0x12   0xBD02             POP      {R1,PC}          ;; return
    983          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0xF64F 0x70FF      MOVW     R0,#+65535
   \        0x4   0xBD02             POP      {R1,PC}
    984          

   \                                 In section .text, align 2, keep-with-next
    985          uint16_t emberAfGetDeviceIdForEndpoint(uint8_t endpoint)
    986          {
   \                     emberAfGetDeviceIdForEndpoint: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    987            uint8_t endpointIndex = emberAfIndexFromEndpoint(endpoint);
   \        0x2   0x....'....        BL       emberAfIndexFromEndpoint
    988            if (endpointIndex == 0xFF) {
   \        0x6   0x28FF             CMP      R0,#+255
   \        0x8   0xD100             BNE.N    ??emberAfGetDeviceIdForEndpoint_0
    989              return EMBER_AF_INVALID_PROFILE_ID;
   \        0xA   0x....             B.N      ?Subroutine4
    990            }
    991            return emAfEndpoints[endpointIndex].deviceId;
   \                     ??emberAfGetDeviceIdForEndpoint_0: (+1)
   \        0xC   0x....'....        BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x10   0x8880             LDRH     R0,[R0, #+4]
   \       0x12   0xBD02             POP      {R1,PC}          ;; return
    992          }
    993          
    994          // Returns the cluster of Nth server or client cluster,
    995          // depending on server toggle.

   \                                 In section .text, align 2, keep-with-next
    996          EmberAfCluster *emberAfGetNthCluster(uint8_t endpoint, uint8_t n, bool server)
    997          {
   \                     emberAfGetNthCluster: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4615             MOV      R5,R2
    998            uint8_t index = emberAfIndexFromEndpoint(endpoint);
   \        0x6   0x....'....        BL       emberAfIndexFromEndpoint
   \        0xA   0x4601             MOV      R1,R0
    999            EmberAfDefinedEndpoint *de;
   1000            uint8_t i, c = 0;
   \        0xC   0x2200             MOVS     R2,#+0
   1001            EmberAfCluster *cluster;
   1002          
   1003            if ( index == 0xFF ) {
   \        0xE   0x29FF             CMP      R1,#+255
   \       0x10   0xD01D             BEQ.N    ??emberAfGetNthCluster_0
   1004              return NULL;
   1005            }
   1006            de = &(emAfEndpoints[index]);
   1007          
   1008            for ( i = 0; i < de->endpointType->clusterCount; i++ ) {
   \       0x12   0x2300             MOVS     R3,#+0
   \       0x14   0xF04F 0x0C14      MOV      R12,#+20
   \       0x18   0xE001             B.N      ??emberAfGetNthCluster_1
   1009              cluster = &(de->endpointType->cluster[i]);
   1010          
   1011              if ( (server && emberAfClusterIsServer(cluster) )
   1012                   || ( (!server) &&  emberAfClusterIsClient(cluster) ) ) {
   1013                if ( c == n ) {
   1014                  return cluster;
   1015                }
   1016                c++;
   \                     ??emberAfGetNthCluster_2: (+1)
   \       0x1A   0x1C52             ADDS     R2,R2,#+1
   \                     ??emberAfGetNthCluster_3: (+1)
   \       0x1C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??emberAfGetNthCluster_1: (+1)
   \       0x1E   0x....'....        LDR.W    R0,??DataTable19
   \       0x22   0xEB00 0x1601      ADD      R6,R0,R1, LSL #+4
   \       0x26   0xB2DF             UXTB     R7,R3
   \       0x28   0x68B0             LDR      R0,[R6, #+8]
   \       0x2A   0x7906             LDRB     R6,[R0, #+4]
   \       0x2C   0x42B7             CMP      R7,R6
   \       0x2E   0xD20E             BCS.N    ??emberAfGetNthCluster_0
   \       0x30   0x6800             LDR      R0,[R0, #+0]
   \       0x32   0xFB0C 0xF707      MUL      R7,R12,R7
   \       0x36   0x4438             ADD      R0,R0,R7
   \       0x38   0x7B06             LDRB     R6,[R0, #+12]
   \       0x3A   0xB115             CBZ.N    R5,??emberAfGetNthCluster_4
   \       0x3C   0x0676             LSLS     R6,R6,#+25
   \       0x3E   0xD402             BMI.N    ??emberAfGetNthCluster_5
   \       0x40   0xE7EC             B.N      ??emberAfGetNthCluster_3
   \                     ??emberAfGetNthCluster_4: (+1)
   \       0x42   0x0637             LSLS     R7,R6,#+24
   \       0x44   0xD5EA             BPL.N    ??emberAfGetNthCluster_3
   \                     ??emberAfGetNthCluster_5: (+1)
   \       0x46   0xB2D6             UXTB     R6,R2
   \       0x48   0x42A6             CMP      R6,R4
   \       0x4A   0xD1E6             BNE.N    ??emberAfGetNthCluster_2
   \       0x4C   0xBDF2             POP      {R1,R4-R7,PC}
   1017              }
   1018            }
   1019            return NULL;
   \                     ??emberAfGetNthCluster_0: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1020          }
   1021          
   1022          // Returns number of clusters put into the passed cluster list
   1023          // for the given endpoint and client/server polarity

   \                                 In section .text, align 2, keep-with-next
   1024          uint8_t emberAfGetClustersFromEndpoint(uint8_t endpoint, EmberAfClusterId *clusterList, uint8_t listLen, bool server)
   1025          {
   \                     emberAfGetClustersFromEndpoint: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4698             MOV      R8,R3
   \        0x8   0x4604             MOV      R4,R0
   \        0xA   0x4616             MOV      R6,R2
   1026            uint8_t clusterCount = emberAfClusterCount(endpoint, server);
   \        0xC   0x4641             MOV      R1,R8
   \        0xE   0x....'....        BL       emberAfClusterCount
   \       0x12   0x4681             MOV      R9,R0
   1027            uint8_t i;
   1028            EmberAfCluster *cluster;
   1029            if (clusterCount > listLen) {
   \       0x14   0x454E             CMP      R6,R9
   \       0x16   0xBFB8             IT       LT 
   \       0x18   0x46B1             MOVLT    R9,R6
   1030              clusterCount = listLen;
   1031            }
   1032            for (i = 0; i < clusterCount; i++) {
   \       0x1A   0x2600             MOVS     R6,#+0
   \                     ??emberAfGetClustersFromEndpoint_0: (+1)
   \       0x1C   0xB2F7             UXTB     R7,R6
   \       0x1E   0x454F             CMP      R7,R9
   \       0x20   0xDA0D             BGE.N    ??emberAfGetClustersFromEndpoint_1
   1033              cluster = emberAfGetNthCluster(endpoint, i, server);
   \       0x22   0x4642             MOV      R2,R8
   \       0x24   0xB2F1             UXTB     R1,R6
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x....'....        BL       emberAfGetNthCluster
   1034              clusterList[i] = (cluster == NULL ? 0xFFFF : cluster->clusterId);
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xBF14             ITE      NE 
   \       0x30   0x8800             LDRHNE   R0,[R0, #+0]
   \       0x32   0xF64F 0x70FF      MOVWEQ   R0,#+65535
   \       0x36   0xF825 0x0017      STRH     R0,[R5, R7, LSL #+1]
   1035            }
   \       0x3A   0x1C76             ADDS     R6,R6,#+1
   \       0x3C   0xE7EE             B.N      ??emberAfGetClustersFromEndpoint_0
   1036            return clusterCount;
   \                     ??emberAfGetClustersFromEndpoint_1: (+1)
   \       0x3E   0x4648             MOV      R0,R9
   \       0x40   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1037          }
   1038          

   \                                 In section .text, align 2, keep-with-next
   1039          void emberAfInitializeAttributes(uint8_t endpoint)
   1040          {
   1041            emAfLoadAttributeDefaults(endpoint, false);
   \                     emberAfInitializeAttributes: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x....             B.N      emAfLoadAttributeDefaults
   1042          }
   1043          

   \                                 In section .text, align 2, keep-with-next
   1044          void emberAfResetAttributes(uint8_t endpoint)
   1045          {
   \                     emberAfResetAttributes: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1046            emAfLoadAttributeDefaults(endpoint, true);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x....'....        BL       emAfLoadAttributeDefaults
   1047            emAfResetAttributes(endpoint);
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0xE8BD 0x4010      POP      {R4,LR}
   \       0x10   0x....'....        B.W      emAfResetAttributes
   1048          }
   1049          

   \                                 In section .text, align 2, keep-with-next
   1050          void emAfLoadAttributeDefaults(uint8_t endpoint, bool writeTokens)
   1051          {
   \                     emAfLoadAttributeDefaults: (+1)
   \        0x0   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \        0x4   0xB088             SUB      SP,SP,#+32
   \        0x6   0x4689             MOV      R9,R1
   1052            uint8_t ep, clusterI, curNetwork = emberGetCurrentNetwork();
   \        0x8   0x....'....        BL       emberGetCurrentNetwork
   1053            uint16_t attr;
   1054            uint8_t *ptr;
   1055            uint8_t epCount = emberAfEndpointCount();
   \        0xC   0x....             LDR.N    R1,??DataTable17_4
   \        0xE   0x780A             LDRB     R2,[R1, #+0]
   1056          
   1057            for ( ep = 0; ep < epCount; ep++ ) {
   \       0x10   0x2300             MOVS     R3,#+0
   \       0x12   0x9006             STR      R0,[SP, #+24]
   \       0x14   0x9205             STR      R2,[SP, #+20]
   \       0x16   0xF88D 0x3004      STRB     R3,[SP, #+4]
   \       0x1A   0x....'....        LDR.W    R10,??DataTable19
   \       0x1E   0xE00A             B.N      ??emAfLoadAttributeDefaults_0
   1058              EmberAfDefinedEndpoint *de;
   1059              if (endpoint != EMBER_BROADCAST_ENDPOINT) {
   \                     ??emAfLoadAttributeDefaults_1: (+1)
   \       0x20   0xEB0A 0x1000      ADD      R0,R10,R0, LSL #+4
   \       0x24   0x7B01             LDRB     R1,[R0, #+12]
   \       0x26   0x9806             LDR      R0,[SP, #+24]
   \       0x28   0x4281             CMP      R1,R0
   \       0x2A   0xD014             BEQ.N    ??emAfLoadAttributeDefaults_2
   \                     ??emAfLoadAttributeDefaults_3: (+1)
   \       0x2C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x30   0x1C40             ADDS     R0,R0,#+1
   \       0x32   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \                     ??emAfLoadAttributeDefaults_0: (+1)
   \       0x36   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x3A   0x9905             LDR      R1,[SP, #+20]
   \       0x3C   0x4288             CMP      R0,R1
   \       0x3E   0xDA58             BGE.N    ??emAfLoadAttributeDefaults_4
   \       0x40   0xF89D 0x2020      LDRB     R2,[SP, #+32]
   \       0x44   0x2AFF             CMP      R2,#+255
   \       0x46   0xD0EB             BEQ.N    ??emAfLoadAttributeDefaults_1
   1060                ep = emberAfIndexFromEndpoint(endpoint);
   \       0x48   0x4610             MOV      R0,R2
   \       0x4A   0x....'....        BL       emberAfIndexFromEndpoint
   \       0x4E   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1061                if (ep == 0xFF) {
   \       0x52   0x28FF             CMP      R0,#+255
   \       0x54   0xD054             BEQ.N    ??emAfLoadAttributeDefaults_5
   1062                  return;
   1063                }
   1064              }
   1065              de = &(emAfEndpoints[ep]);
   1066          
   1067              // Ensure that the endpoint is on the current network
   1068              if (endpoint == EMBER_BROADCAST_ENDPOINT
   1069                  && de->networkIndex != curNetwork) {
   1070                continue;
   1071              }
   1072              for ( clusterI = 0; clusterI < de->endpointType->clusterCount; clusterI++) {
   \                     ??emAfLoadAttributeDefaults_2: (+1)
   \       0x56   0x2700             MOVS     R7,#+0
   \       0x58   0xE056             B.N      ??emAfLoadAttributeDefaults_6
   1073                EmberAfCluster *cluster = &(de->endpointType->cluster[clusterI]);
   1074          
   1075                // when the attributeCount is high, the loop takes too long to run and a
   1076                // watchdog kicks in causing a reset. As a workaround, we'll
   1077                // conditionally manually reset the watchdog. 300 sounds like a good
   1078                // magic number for now.
   1079                if (cluster->attributeCount > 300) {
   1080                  halResetWatchdog();
   1081                }
   1082                for ( attr = 0; attr < cluster->attributeCount; attr++) {
   1083                  EmberAfAttributeMetadata *am = &(cluster->attributes[attr]);
   1084                  if (!(am->mask & ATTRIBUTE_MASK_EXTERNAL_STORAGE)) {
   1085                    EmberAfAttributeSearchRecord record;
   1086                    record.endpoint = de->endpoint;
   1087                    record.clusterId = cluster->clusterId;
   1088                    record.clusterMask = (emberAfAttributeIsClient(am)
   1089                                          ? CLUSTER_MASK_CLIENT
   1090                                          : CLUSTER_MASK_SERVER);
   1091                    record.attributeId = am->attributeId;
   1092                    record.manufacturerCode = emAfGetManufacturerCodeForAttribute(cluster,
   1093                                                                                  am);
   1094                    if ((am->mask & ATTRIBUTE_MASK_MIN_MAX) != 0U) {
   1095                      if ( emberAfAttributeSize(am) <= 2 ) {
   1096                        ptr = (uint8_t*)&(am->defaultValue.ptrToMinMaxValue->defaultValue.defaultValue);
   1097                      } else {
   1098                        ptr = (uint8_t*)am->defaultValue.ptrToMinMaxValue->defaultValue.ptrToDefaultValue;
   1099                      }
   1100                    } else {
   1101                      if ( emberAfAttributeSize(am) <= 2 ) {
   \                     ??emAfLoadAttributeDefaults_7: (+1)
   \       0x5A   0x2803             CMP      R0,#+3
   \       0x5C   0xBFAC             ITE      GE 
   \       0x5E   0xF8D6 0xB008      LDRGE    R11,[R6, #+8]
   \       0x62   0xF106 0x0B08      ADDLT    R11,R6,#+8
   1102                        ptr = (uint8_t*)&(am->defaultValue.defaultValue);
   1103                      } else {
   1104                        ptr = (uint8_t*)am->defaultValue.ptrToDefaultValue;
   1105                      }
   1106                    }
   1107                    // At this point, ptr either points to a default value, or is NULL, in which case
   1108                    // it should be treated as if it is pointing to an array of all zeroes.
   1109          
   1110          #if (BIGENDIAN_CPU)
   1111                    // The default value for one- and two-byte attributes is stored in an
   1112                    // uint16_t.  On big-endian platforms, a pointer to the default value of
   1113                    // a one-byte attribute will point to the wrong byte.  So, for those
   1114                    // cases, nudge the pointer forward so it points to the correct byte.
   1115                    if (emberAfAttributeSize(am) == 1 && ptr != NULL) {
   1116                      *ptr++;
   1117                    }
   1118          #endif //BIGENDIAN
   1119                    emAfReadOrWriteAttribute(&record,
   1120                                             NULL,  // metadata - unused
   1121                                             ptr,
   1122                                             0,     // buffer size - unused
   1123                                             true); // write?
   \                     ??emAfLoadAttributeDefaults_8: (+1)
   \       0x66   0x2001             MOVS     R0,#+1
   \       0x68   0x9000             STR      R0,[SP, #+0]
   \       0x6A   0x2300             MOVS     R3,#+0
   \       0x6C   0x465A             MOV      R2,R11
   \       0x6E   0x2100             MOVS     R1,#+0
   \       0x70   0xA802             ADD      R0,SP,#+8
   \       0x72   0x....'....        BL       emAfReadOrWriteAttribute
   1124                    if (writeTokens) {
   \       0x76   0xEA5F 0x0009      MOVS     R0,R9
   \       0x7A   0xD007             BEQ.N    ??emAfLoadAttributeDefaults_9
   1125                      emAfSaveAttributeToToken(ptr, de->endpoint, record.clusterId, am);
   \       0x7C   0xF8BD 0x200A      LDRH     R2,[SP, #+10]
   \       0x80   0xF81A 0x1008      LDRB     R1,[R10, R8]
   \       0x84   0x4633             MOV      R3,R6
   \       0x86   0x4658             MOV      R0,R11
   \       0x88   0x....'....        BL       emAfSaveAttributeToToken
   1126                    }
   \                     ??emAfLoadAttributeDefaults_9: (+1)
   \       0x8C   0x1C64             ADDS     R4,R4,#+1
   \                     ??emAfLoadAttributeDefaults_10: (+1)
   \       0x8E   0x8929             LDRH     R1,[R5, #+8]
   \       0x90   0xB2A0             UXTH     R0,R4
   \       0x92   0x4288             CMP      R0,R1
   \       0x94   0xD237             BCS.N    ??emAfLoadAttributeDefaults_11
   \       0x96   0xB2A2             UXTH     R2,R4
   \       0x98   0x210C             MOVS     R1,#+12
   \       0x9A   0x6868             LDR      R0,[R5, #+4]
   \       0x9C   0x434A             MULS     R2,R1,R2
   \       0x9E   0x1886             ADDS     R6,R0,R2
   \       0xA0   0x7933             LDRB     R3,[R6, #+4]
   \       0xA2   0x06D9             LSLS     R1,R3,#+27
   \       0xA4   0xD4F2             BMI.N    ??emAfLoadAttributeDefaults_9
   \       0xA6   0xF81A 0x2008      LDRB     R2,[R10, R8]
   \       0xAA   0xF88D 0x2008      STRB     R2,[SP, #+8]
   \       0xAE   0x8829             LDRH     R1,[R5, #+0]
   \       0xB0   0xF8AD 0x100A      STRH     R1,[SP, #+10]
   \       0xB4   0x7930             LDRB     R0,[R6, #+4]
   \       0xB6   0x0641             LSLS     R1,R0,#+25
   \       0xB8   0x4628             MOV      R0,R5
   \       0xBA   0xBF4C             ITE      MI 
   \       0xBC   0x2180             MOVMI    R1,#+128
   \       0xBE   0x2140             MOVPL    R1,#+64
   \       0xC0   0xF88D 0x100C      STRB     R1,[SP, #+12]
   \       0xC4   0x8831             LDRH     R1,[R6, #+0]
   \       0xC6   0xF8AD 0x100E      STRH     R1,[SP, #+14]
   \       0xCA   0x4631             MOV      R1,R6
   \       0xCC   0x....'....        BL       emAfGetManufacturerCodeForAttribute
   \       0xD0   0xF8AD 0x0010      STRH     R0,[SP, #+16]
   \       0xD4   0x7931             LDRB     R1,[R6, #+4]
   \       0xD6   0x78F0             LDRB     R0,[R6, #+3]
   \       0xD8   0x074A             LSLS     R2,R1,#+29
   \       0xDA   0xD5BE             BPL.N    ??emAfLoadAttributeDefaults_7
   \       0xDC   0xF8D6 0xB008      LDR      R11,[R6, #+8]
   \       0xE0   0x2803             CMP      R0,#+3
   \       0xE2   0xDBC0             BLT.N    ??emAfLoadAttributeDefaults_8
   \       0xE4   0xF8DB 0xB000      LDR      R11,[R11, #+0]
   \       0xE8   0xE7BD             B.N      ??emAfLoadAttributeDefaults_8
   1127                  }
   1128                }
   1129              }
   1130              if (endpoint != EMBER_BROADCAST_ENDPOINT) {
   \                     ??emAfLoadAttributeDefaults_12: (+1)
   \       0xEA   0xF89D 0x0020      LDRB     R0,[SP, #+32]
   \       0xEE   0x28FF             CMP      R0,#+255
   \       0xF0   0xD09C             BEQ.N    ??emAfLoadAttributeDefaults_3
   1131                break;
   1132              }
   1133            }
   1134          
   1135            if (!writeTokens) {
   \                     ??emAfLoadAttributeDefaults_4: (+1)
   \       0xF2   0xF1B9 0x0F00      CMP      R9,#+0
   \       0xF6   0xBF04             ITT      EQ 
   1136              emAfLoadAttributesFromTokens(endpoint);
   \       0xF8   0xF89D 0x0020      LDRBEQ   R0,[SP, #+32]
   \       0xFC   0x....'....        BLEQ     emAfLoadAttributesFromTokens
   1137            }
   1138          }
   \                     ??emAfLoadAttributeDefaults_5: (+1)
   \      0x100   0xB009             ADD      SP,SP,#+36
   \      0x102   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??emAfLoadAttributeDefaults_11: (+1)
   \      0x106   0x1C7F             ADDS     R7,R7,#+1
   \                     ??emAfLoadAttributeDefaults_6: (+1)
   \      0x108   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \      0x10C   0xB2F9             UXTB     R1,R7
   \      0x10E   0xEA4F 0x1800      LSL      R8,R0,#+4
   \      0x112   0xF10A 0x0008      ADD      R0,R10,#+8
   \      0x116   0xF850 0x0008      LDR      R0,[R0, R8]
   \      0x11A   0x7902             LDRB     R2,[R0, #+4]
   \      0x11C   0x4291             CMP      R1,R2
   \      0x11E   0xD2E4             BCS.N    ??emAfLoadAttributeDefaults_12
   \      0x120   0x6801             LDR      R1,[R0, #+0]
   \      0x122   0xB2FB             UXTB     R3,R7
   \      0x124   0x2014             MOVS     R0,#+20
   \      0x126   0x4343             MULS     R3,R0,R3
   \      0x128   0x18CD             ADDS     R5,R1,R3
   \      0x12A   0x892A             LDRH     R2,[R5, #+8]
   \      0x12C   0xF240 0x112D      MOVW     R1,#+301
   \      0x130   0x428A             CMP      R2,R1
   \      0x132   0xBFA8             IT       GE 
   \      0x134   0x....'....        BLGE     halInternalResetWatchDog
   \      0x138   0x2400             MOVS     R4,#+0
   \      0x13A   0xE7A8             B.N      ??emAfLoadAttributeDefaults_10
   1139          

   \                                 In section .text, align 2, keep-with-next
   1140          void emAfLoadAttributesFromTokens(uint8_t endpoint)
   1141          {
   \                     emAfLoadAttributesFromTokens: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   1142            // On EZSP host we currently do not support this. We need to come up with some
   1143            // callbacks.
   1144          #ifndef EZSP_HOST
   1145            GENERATED_TOKEN_LOADER(endpoint);
   \        0x4   0x....'....        BL       emberGetCurrentNetwork
   \        0x8   0x4605             MOV      R5,R0
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x....'....        BL       emberAfNetworkIndexFromEndpoint
   \       0x10   0xF244 0x0603      MOVW     R6,#+16387
   \       0x14   0x2C01             CMP      R4,#+1
   \       0x16   0xD003             BEQ.N    ??emAfLoadAttributesFromTokens_0
   \       0x18   0x2CFF             CMP      R4,#+255
   \       0x1A   0xBF08             IT       EQ 
   \       0x1C   0x42A8             CMPEQ    R0,R5
   \       0x1E   0xD127             BNE.N    ??CrossCallReturnLabel_20
   \                     ??emAfLoadAttributesFromTokens_0: (+1)
   \       0x20   0x2301             MOVS     R3,#+1
   \       0x22   0x227F             MOVS     R2,#+127
   \       0x24   0x2121             MOVS     R1,#+33
   \       0x26   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x2A   0x....'....        BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0x2E   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0x32   0x2301             MOVS     R3,#+1
   \       0x34   0x227F             MOVS     R2,#+127
   \       0x36   0x2122             MOVS     R1,#+34
   \       0x38   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x3C   0x2030             MOVS     R0,#+48
   \       0x3E   0x9000             STR      R0,[SP, #+0]
   \       0x40   0xAB01             ADD      R3,SP,#+4
   \       0x42   0x4632             MOV      R2,R6
   \       0x44   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0x48   0x2301             MOVS     R3,#+1
   \       0x4A   0x227F             MOVS     R2,#+127
   \       0x4C   0x2123             MOVS     R1,#+35
   \       0x4E   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x52   0x2020             MOVS     R0,#+32
   \       0x54   0x....'....        BL       ??Subroutine9_0
   \                     ??CrossCallReturnLabel_30: (+1)
   \       0x58   0x2108             MOVS     R1,#+8
   \       0x5A   0x....'....        BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x5E   0x2301             MOVS     R3,#+1
   \       0x60   0x227F             MOVS     R2,#+127
   \       0x62   0x2124             MOVS     R1,#+36
   \       0x64   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x68   0x....'....        BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_33: (+1)
   \       0x6C   0x....'....        BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0x70   0x2002             MOVS     R0,#+2
   \       0x72   0x....'....        BL       emberAfNetworkIndexFromEndpoint
   \       0x76   0x2C02             CMP      R4,#+2
   \       0x78   0xD003             BEQ.N    ??emAfLoadAttributesFromTokens_1
   \       0x7A   0x2CFF             CMP      R4,#+255
   \       0x7C   0xBF08             IT       EQ 
   \       0x7E   0x42A8             CMPEQ    R0,R5
   \       0x80   0xD140             BNE.N    ??CrossCallReturnLabel_47
   \                     ??emAfLoadAttributesFromTokens_1: (+1)
   \       0x82   0x2301             MOVS     R3,#+1
   \       0x84   0x227F             MOVS     R2,#+127
   \       0x86   0x2125             MOVS     R1,#+37
   \       0x88   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x8C   0x....'....        BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_31: (+1)
   \       0x90   0x2106             MOVS     R1,#+6
   \       0x92   0x....'....        BL       ??Subroutine12_0
   \                     ??CrossCallReturnLabel_46: (+1)
   \       0x96   0x2301             MOVS     R3,#+1
   \       0x98   0x227F             MOVS     R2,#+127
   \       0x9A   0x2126             MOVS     R1,#+38
   \       0x9C   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0xA0   0x2030             MOVS     R0,#+48
   \       0xA2   0x9000             STR      R0,[SP, #+0]
   \       0xA4   0xAB01             ADD      R3,SP,#+4
   \       0xA6   0x4632             MOV      R2,R6
   \       0xA8   0x2106             MOVS     R1,#+6
   \       0xAA   0x....'....        BL       ??Subroutine12_0
   \                     ??CrossCallReturnLabel_45: (+1)
   \       0xAE   0x2301             MOVS     R3,#+1
   \       0xB0   0x227F             MOVS     R2,#+127
   \       0xB2   0x2127             MOVS     R1,#+39
   \       0xB4   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0xB8   0x2020             MOVS     R0,#+32
   \       0xBA   0x....'....        BL       ??Subroutine9_0
   \                     ??CrossCallReturnLabel_32: (+1)
   \       0xBE   0x2108             MOVS     R1,#+8
   \       0xC0   0x....'....        BL       ??Subroutine12_0
   \                     ??CrossCallReturnLabel_44: (+1)
   \       0xC4   0x2301             MOVS     R3,#+1
   \       0xC6   0x227F             MOVS     R2,#+127
   \       0xC8   0x2128             MOVS     R1,#+40
   \       0xCA   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0xCE   0x....'....        BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_34: (+1)
   \       0xD2   0x....'....        BL       ??Subroutine12_0
   \                     ??CrossCallReturnLabel_43: (+1)
   \       0xD6   0x2302             MOVS     R3,#+2
   \       0xD8   0x227F             MOVS     R2,#+127
   \       0xDA   0x2129             MOVS     R1,#+41
   \       0xDC   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0xE0   0x2021             MOVS     R0,#+33
   \       0xE2   0x9000             STR      R0,[SP, #+0]
   \       0xE4   0xAB01             ADD      R3,SP,#+4
   \       0xE6   0x2207             MOVS     R2,#+7
   \       0xE8   0x....'....        BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_48: (+1)
   \       0xEC   0x2302             MOVS     R3,#+2
   \       0xEE   0x227F             MOVS     R2,#+127
   \       0xF0   0x212A             MOVS     R1,#+42
   \       0xF2   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0xF6   0x2021             MOVS     R0,#+33
   \       0xF8   0x9000             STR      R0,[SP, #+0]
   \       0xFA   0xAB01             ADD      R3,SP,#+4
   \       0xFC   0xF244 0x0210      MOVW     R2,#+16400
   \      0x100   0x....'....        BL       ?Subroutine12
   1146          #endif // EZSP_HOST
   1147          }
   \                     ??CrossCallReturnLabel_47: (+1)
   \      0x104   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0xF44F 0x7140      MOV      R1,#+768
   \                     ??Subroutine12_0: (+1)
   \        0x4   0x2002             MOVS     R0,#+2
   \        0x6   0x....'....        B.W      emberAfWriteServerAttribute

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x2020             MOVS     R0,#+32
   \        0x2   0x9000             STR      R0,[SP, #+0]
   \        0x4   0xAB01             ADD      R3,SP,#+4
   \        0x6   0xF44F 0x4280      MOV      R2,#+16384
   \        0xA   0x2108             MOVS     R1,#+8
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x2010             MOVS     R0,#+16
   \                     ??Subroutine9_0: (+1)
   \        0x2   0x9000             STR      R0,[SP, #+0]
   \        0x4   0xAB01             ADD      R3,SP,#+4
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x2106             MOVS     R1,#+6
   \                     ??Subroutine7_0: (+1)
   \        0x2   0x2001             MOVS     R0,#+1
   \        0x4   0x....'....        B.W      emberAfWriteServerAttribute

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0xA801             ADD      R0,SP,#+4
   \        0x2   0x....'....        B.W      halInternalGetTokenData
   1148          
   1149          // 'data' argument may be null, since we changed the ptrToDefaultValue
   1150          // to be null instead of pointing to all zeroes.
   1151          // This function has to be able to deal with that.

   \                                 In section .text, align 2, keep-with-next
   1152          void emAfSaveAttributeToToken(uint8_t *data,
   1153                                        uint8_t endpoint,
   1154                                        EmberAfClusterId clusterId,
   1155                                        EmberAfAttributeMetadata *metadata)
   1156          {
   \                     emAfSaveAttributeToToken: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x461D             MOV      R5,R3
   1157            // Get out of here if this attribute doesn't have a token.
   1158            if ( !emberAfAttributeIsTokenized(metadata)) {
   \        0x8   0x7928             LDRB     R0,[R5, #+4]
   \        0xA   0x460E             MOV      R6,R1
   \        0xC   0x4617             MOV      R7,R2
   \        0xE   0x0783             LSLS     R3,R0,#+30
   \       0x10   0xF140 0x80A5      BPL.W    ??emAfSaveAttributeToToken_0
   1159              return;
   1160            }
   1161          
   1162          // On EZSP host we currently do not support this. We need to come up with some
   1163          // callbacks.
   1164          #ifndef EZSP_HOST
   1165            GENERATED_TOKEN_SAVER;
   \       0x14   0x2202             MOVS     R2,#+2
   \       0x16   0x2100             MOVS     R1,#+0
   \       0x18   0x4668             MOV      R0,SP
   \       0x1A   0x....'....        BL       halCommonMemSet
   \       0x1E   0xB904             CBNZ.N   R4,??emAfSaveAttributeToToken_1
   \       0x20   0x466C             MOV      R4,SP
   \                     ??emAfSaveAttributeToToken_1: (+1)
   \       0x22   0xF244 0x0803      MOVW     R8,#+16387
   \       0x26   0x2E01             CMP      R6,#+1
   \       0x28   0xD13A             BNE.N    ??emAfSaveAttributeToToken_2
   \       0x2A   0x2F06             CMP      R7,#+6
   \       0x2C   0xD11A             BNE.N    ??emAfSaveAttributeToToken_3
   \       0x2E   0x8828             LDRH     R0,[R5, #+0]
   \       0x30   0xB950             CBNZ.N   R0,??emAfSaveAttributeToToken_4
   \       0x32   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x36   0xB938             CBNZ.N   R0,??emAfSaveAttributeToToken_4
   \       0x38   0x7928             LDRB     R0,[R5, #+4]
   \       0x3A   0x0641             LSLS     R1,R0,#+25
   \       0x3C   0xD404             BMI.N    ??emAfSaveAttributeToToken_4
   \       0x3E   0x....'....        BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_35: (+1)
   \       0x42   0x2021             MOVS     R0,#+33
   \       0x44   0x....'....        BL       halInternalSetTokenData
   \                     ??emAfSaveAttributeToToken_4: (+1)
   \       0x48   0x8828             LDRH     R0,[R5, #+0]
   \       0x4A   0x4540             CMP      R0,R8
   \       0x4C   0xD10B             BNE.N    ??emAfSaveAttributeToToken_5
   \       0x4E   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x52   0x2800             CMP      R0,#+0
   \       0x54   0xD107             BNE.N    ??emAfSaveAttributeToToken_5
   \       0x56   0x7928             LDRB     R0,[R5, #+4]
   \       0x58   0x0641             LSLS     R1,R0,#+25
   \       0x5A   0xD41C             BMI.N    ??emAfSaveAttributeToToken_6
   \       0x5C   0x....'....        BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_36: (+1)
   \       0x60   0x2022             MOVS     R0,#+34
   \       0x62   0xE07A             B.N      ??emAfSaveAttributeToToken_7
   \                     ??emAfSaveAttributeToToken_3: (+1)
   \       0x64   0x2F08             CMP      R7,#+8
   \                     ??emAfSaveAttributeToToken_5: (+1)
   \       0x66   0xD17A             BNE.N    ??emAfSaveAttributeToToken_0
   \       0x68   0x8828             LDRH     R0,[R5, #+0]
   \       0x6A   0xB950             CBNZ.N   R0,??emAfSaveAttributeToToken_8
   \       0x6C   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x70   0xB938             CBNZ.N   R0,??emAfSaveAttributeToToken_8
   \       0x72   0x7928             LDRB     R0,[R5, #+4]
   \       0x74   0x0641             LSLS     R1,R0,#+25
   \       0x76   0xD404             BMI.N    ??emAfSaveAttributeToToken_8
   \       0x78   0x....'....        BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_37: (+1)
   \       0x7C   0x2023             MOVS     R0,#+35
   \       0x7E   0x....'....        BL       halInternalSetTokenData
   \                     ??emAfSaveAttributeToToken_8: (+1)
   \       0x82   0x8828             LDRH     R0,[R5, #+0]
   \       0x84   0xF5B0 0x4F80      CMP      R0,#+16384
   \       0x88   0xD169             BNE.N    ??emAfSaveAttributeToToken_0
   \       0x8A   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x8E   0x2800             CMP      R0,#+0
   \       0x90   0xD165             BNE.N    ??emAfSaveAttributeToToken_0
   \       0x92   0x7928             LDRB     R0,[R5, #+4]
   \       0x94   0x0641             LSLS     R1,R0,#+25
   \                     ??emAfSaveAttributeToToken_6: (+1)
   \       0x96   0xD462             BMI.N    ??emAfSaveAttributeToToken_0
   \       0x98   0x....'....        BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_38: (+1)
   \       0x9C   0x2024             MOVS     R0,#+36
   \       0x9E   0xE05C             B.N      ??emAfSaveAttributeToToken_7
   \                     ??emAfSaveAttributeToToken_2: (+1)
   \       0xA0   0x2E02             CMP      R6,#+2
   \       0xA2   0xD15C             BNE.N    ??emAfSaveAttributeToToken_0
   \       0xA4   0x2F06             CMP      R7,#+6
   \       0xA6   0xD11A             BNE.N    ??emAfSaveAttributeToToken_9
   \       0xA8   0x8828             LDRH     R0,[R5, #+0]
   \       0xAA   0xB950             CBNZ.N   R0,??emAfSaveAttributeToToken_10
   \       0xAC   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0xB0   0xB938             CBNZ.N   R0,??emAfSaveAttributeToToken_10
   \       0xB2   0x7928             LDRB     R0,[R5, #+4]
   \       0xB4   0x0641             LSLS     R1,R0,#+25
   \       0xB6   0xD404             BMI.N    ??emAfSaveAttributeToToken_10
   \       0xB8   0x....'....        BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_39: (+1)
   \       0xBC   0x2025             MOVS     R0,#+37
   \       0xBE   0x....'....        BL       halInternalSetTokenData
   \                     ??emAfSaveAttributeToToken_10: (+1)
   \       0xC2   0x8828             LDRH     R0,[R5, #+0]
   \       0xC4   0x4540             CMP      R0,R8
   \       0xC6   0xD14A             BNE.N    ??emAfSaveAttributeToToken_0
   \       0xC8   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD146             BNE.N    ??emAfSaveAttributeToToken_0
   \       0xD0   0x7928             LDRB     R0,[R5, #+4]
   \       0xD2   0x0641             LSLS     R1,R0,#+25
   \       0xD4   0xD443             BMI.N    ??emAfSaveAttributeToToken_0
   \       0xD6   0x....'....        BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_40: (+1)
   \       0xDA   0x2026             MOVS     R0,#+38
   \       0xDC   0xE03D             B.N      ??emAfSaveAttributeToToken_7
   \                     ??emAfSaveAttributeToToken_9: (+1)
   \       0xDE   0x2F08             CMP      R7,#+8
   \       0xE0   0xD11A             BNE.N    ??emAfSaveAttributeToToken_11
   \       0xE2   0x8828             LDRH     R0,[R5, #+0]
   \       0xE4   0xB950             CBNZ.N   R0,??emAfSaveAttributeToToken_12
   \       0xE6   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0xEA   0xB938             CBNZ.N   R0,??emAfSaveAttributeToToken_12
   \       0xEC   0x7928             LDRB     R0,[R5, #+4]
   \       0xEE   0x0641             LSLS     R1,R0,#+25
   \       0xF0   0xD404             BMI.N    ??emAfSaveAttributeToToken_12
   \       0xF2   0x....'....        BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_41: (+1)
   \       0xF6   0x2027             MOVS     R0,#+39
   \       0xF8   0x....'....        BL       halInternalSetTokenData
   \                     ??emAfSaveAttributeToToken_12: (+1)
   \       0xFC   0x8828             LDRH     R0,[R5, #+0]
   \       0xFE   0xF5B0 0x4F80      CMP      R0,#+16384
   \      0x102   0xD12C             BNE.N    ??emAfSaveAttributeToToken_0
   \      0x104   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_12: (+1)
   \      0x108   0xBB48             CBNZ.N   R0,??emAfSaveAttributeToToken_0
   \      0x10A   0x7928             LDRB     R0,[R5, #+4]
   \      0x10C   0x0641             LSLS     R1,R0,#+25
   \      0x10E   0xD426             BMI.N    ??emAfSaveAttributeToToken_0
   \      0x110   0x....'....        BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_42: (+1)
   \      0x114   0x2028             MOVS     R0,#+40
   \      0x116   0xE020             B.N      ??emAfSaveAttributeToToken_7
   \                     ??emAfSaveAttributeToToken_11: (+1)
   \      0x118   0xF5B7 0x7F40      CMP      R7,#+768
   \      0x11C   0xD11F             BNE.N    ??emAfSaveAttributeToToken_0
   \      0x11E   0x8828             LDRH     R0,[R5, #+0]
   \      0x120   0x2807             CMP      R0,#+7
   \      0x122   0xD10B             BNE.N    ??emAfSaveAttributeToToken_13
   \      0x124   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_11: (+1)
   \      0x128   0xB940             CBNZ.N   R0,??emAfSaveAttributeToToken_13
   \      0x12A   0x7928             LDRB     R0,[R5, #+4]
   \      0x12C   0x0641             LSLS     R1,R0,#+25
   \      0x12E   0xD405             BMI.N    ??emAfSaveAttributeToToken_13
   \      0x130   0x2302             MOVS     R3,#+2
   \      0x132   0x4622             MOV      R2,R4
   \      0x134   0x217F             MOVS     R1,#+127
   \      0x136   0x2029             MOVS     R0,#+41
   \      0x138   0x....'....        BL       halInternalSetTokenData
   \                     ??emAfSaveAttributeToToken_13: (+1)
   \      0x13C   0x8828             LDRH     R0,[R5, #+0]
   \      0x13E   0xF244 0x0110      MOVW     R1,#+16400
   \      0x142   0x4288             CMP      R0,R1
   \      0x144   0xD10B             BNE.N    ??emAfSaveAttributeToToken_0
   \      0x146   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_10: (+1)
   \      0x14A   0xB940             CBNZ.N   R0,??emAfSaveAttributeToToken_0
   \      0x14C   0x7928             LDRB     R0,[R5, #+4]
   \      0x14E   0x0641             LSLS     R1,R0,#+25
   \      0x150   0xD405             BMI.N    ??emAfSaveAttributeToToken_0
   \      0x152   0x2302             MOVS     R3,#+2
   \      0x154   0x4622             MOV      R2,R4
   \      0x156   0x217F             MOVS     R1,#+127
   \      0x158   0x202A             MOVS     R0,#+42
   \                     ??emAfSaveAttributeToToken_7: (+1)
   \      0x15A   0x....'....        BL       halInternalSetTokenData
   1166          #endif // EZSP_HOST
   1167          }
   \                     ??emAfSaveAttributeToToken_0: (+1)
   \      0x15E   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x2301             MOVS     R3,#+1
   \        0x2   0x4622             MOV      R2,R4
   \        0x4   0x217F             MOVS     R1,#+127
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x4628             MOV      R0,R5
   \        0x2   0x....'....        B.W      emberAfGetMfgCode
   1168          
   1169          // This function returns the actual function point from the array,
   1170          // iterating over the function bits.

   \                                 In section .text, align 2, keep-with-next
   1171          EmberAfGenericClusterFunction
   1172          emberAfFindClusterFunction(EmberAfCluster *cluster,
   1173                                     EmberAfClusterMask functionMask)
   1174          {
   \                     emberAfFindClusterFunction: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   1175            EmberAfClusterMask mask = 0x01;
   1176            uint8_t functionIndex = 0;
   1177          
   1178            if ( (cluster->mask & functionMask) == 0 ) {
   \        0x2   0x7B04             LDRB     R4,[R0, #+12]
   \        0x4   0x2201             MOVS     R2,#+1
   \        0x6   0x2300             MOVS     R3,#+0
   \        0x8   0x420C             TST      R4,R1
   \        0xA   0xD105             BNE.N    ??emberAfFindClusterFunction_0
   1179              return NULL;
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xBD30             POP      {R4,R5,PC}
   1180            }
   1181          
   1182            while ( mask < functionMask ) {
   1183              if ( (cluster->mask & mask) != 0 ) {
   \                     ??emberAfFindClusterFunction_1: (+1)
   \       0x10   0x4214             TST      R4,R2
   \       0x12   0xBF18             IT       NE 
   \       0x14   0x1C5B             ADDNE    R3,R3,#+1
   1184                functionIndex++;
   1185              }
   1186              mask <<= 1;
   \       0x16   0x0052             LSLS     R2,R2,#+1
   1187            }
   \                     ??emberAfFindClusterFunction_0: (+1)
   \       0x18   0xB2D5             UXTB     R5,R2
   \       0x1A   0x428D             CMP      R5,R1
   \       0x1C   0xD3F8             BCC.N    ??emberAfFindClusterFunction_1
   1188            return cluster->functions[functionIndex];
   \       0x1E   0x6900             LDR      R0,[R0, #+16]
   \       0x20   0xB2DB             UXTB     R3,R3
   \       0x22   0xF850 0x0023      LDR      R0,[R0, R3, LSL #+2]
   \       0x26   0xBD30             POP      {R4,R5,PC}       ;; return
   1189          }
   1190          
   1191          #ifdef EMBER_AF_SUPPORT_COMMAND_DISCOVERY
   1192          

   \                                 In section .text, align 2, keep-with-next
   1193          uint16_t emAfGetManufacturerCodeForCommand(EmberAfCommandMetadata *command)
   1194          {
   1195            return getManufacturerCode((EmberAfManufacturerCodeEntry *)commandManufacturerCodes,
   1196                                       commandManufacturerCodeCount,
   1197                                       (command - generatedCommands));
   \                     emAfGetManufacturerCodeForCommand: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable19_9
   \        0x2   0x1A40             SUBS     R0,R0,R1
   \        0x4   0x0380             LSLS     R0,R0,#+14
   \        0x6   0x0C02             LSRS     R2,R0,#+16
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x....             LDR.N    R0,??DataTable19_10
   \        0xC   0x....'....        B.W      getManufacturerCode
   1198          }
   1199          
   1200          /**
   1201           * This function populates command IDs into a given buffer.
   1202           *
   1203           * It returns true if commands are complete, meaning there are NO MORE
   1204           * commands that would be returned after the last command.
   1205           * It returns false, if there were more commands, but were not populated
   1206           * because of maxIdCount limitation.
   1207           */

   \                                 In section .text, align 2, keep-with-next
   1208          bool emberAfExtractCommandIds(bool outgoing,
   1209                                        EmberAfClusterCommand *cmd,
   1210                                        uint16_t clusterId,
   1211                                        uint8_t *buffer,
   1212                                        uint16_t bufferLength,
   1213                                        uint16_t *bufferIndex,
   1214                                        uint8_t startId,
   1215                                        uint8_t maxIdCount)
   1216          {
   \                     emberAfExtractCommandIds: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   1217            uint16_t i, count = 0;
   \        0x4   0x2700             MOVS     R7,#+0
   1218            bool returnValue = true;
   1219            uint8_t cmdDirMask = 0;
   1220          
   1221            // determine the appropriate mask to match the request
   1222            // discover commands generated, client is asking server what commands do you generate?
   1223            if (outgoing && (cmd->direction == ZCL_DIRECTION_CLIENT_TO_SERVER)) {
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xF04F 0x0801      MOV      R8,#+1
   \        0xC   0x7D48             LDRB     R0,[R1, #+21]
   \        0xE   0xD006             BEQ.N    ??emberAfExtractCommandIds_0
   \       0x10   0xB908             CBNZ.N   R0,??emberAfExtractCommandIds_1
   1224              cmdDirMask = COMMAND_MASK_OUTGOING_SERVER;
   \       0x12   0x2402             MOVS     R4,#+2
   \       0x14   0xE007             B.N      ??emberAfExtractCommandIds_2
   1225              // discover commands generated server is asking client what commands do you generate?
   1226            } else if (outgoing && (cmd->direction == ZCL_DIRECTION_SERVER_TO_CLIENT)) {
   \                     ??emberAfExtractCommandIds_1: (+1)
   \       0x16   0x2801             CMP      R0,#+1
   \       0x18   0xD104             BNE.N    ??emberAfExtractCommandIds_3
   1227              cmdDirMask = COMMAND_MASK_OUTGOING_CLIENT;
   \       0x1A   0x2401             MOVS     R4,#+1
   \       0x1C   0xE003             B.N      ??emberAfExtractCommandIds_2
   1228              // discover commands received client is asking server what commands do you receive?
   1229            } else if (!outgoing && (cmd->direction == ZCL_DIRECTION_CLIENT_TO_SERVER)) {
   \                     ??emberAfExtractCommandIds_0: (+1)
   \       0x1E   0xB908             CBNZ.N   R0,??emberAfExtractCommandIds_3
   1230              cmdDirMask = COMMAND_MASK_INCOMING_SERVER;
   \       0x20   0x2408             MOVS     R4,#+8
   \       0x22   0xE000             B.N      ??emberAfExtractCommandIds_2
   1231              // discover commands received server is asking client what commands do you receive?
   1232            } else {
   1233              cmdDirMask = COMMAND_MASK_INCOMING_CLIENT;
   \                     ??emberAfExtractCommandIds_3: (+1)
   \       0x24   0x2404             MOVS     R4,#+4
   1234            }
   1235          
   1236            for ( i = 0; i < EMBER_AF_GENERATED_COMMAND_COUNT; i++ ) {
   \                     ??emberAfExtractCommandIds_2: (+1)
   \       0x26   0x980E             LDR      R0,[SP, #+56]
   \       0x28   0x9D0C             LDR      R5,[SP, #+48]
   \       0x2A   0x46B9             MOV      R9,R7
   \       0x2C   0x9E0D             LDR      R6,[SP, #+52]
   \       0x2E   0xF8DD 0xB03C      LDR      R11,[SP, #+60]
   \       0x32   0x468A             MOV      R10,R1
   \       0x34   0xF8AD 0x2000      STRH     R2,[SP, #+0]
   \       0x38   0x9301             STR      R3,[SP, #+4]
   \       0x3A   0xF8AD 0x5030      STRH     R5,[SP, #+48]
   \       0x3E   0xF88D 0x0038      STRB     R0,[SP, #+56]
   1237              if ( generatedCommands[i].clusterId != clusterId ) {
   \                     ??emberAfExtractCommandIds_4: (+1)
   \       0x42   0x....             LDR.N    R0,??DataTable19_9
   \       0x44   0xEB00 0x0589      ADD      R5,R0,R9, LSL #+2
   \       0x48   0x8829             LDRH     R1,[R5, #+0]
   \       0x4A   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \       0x4E   0x4281             CMP      R1,R0
   \       0x50   0xD124             BNE.N    ??emberAfExtractCommandIds_5
   1238                continue;
   1239              }
   1240          
   1241              if ((generatedCommands[i].mask & cmdDirMask) == 0 ) {
   \       0x52   0x78E9             LDRB     R1,[R5, #+3]
   \       0x54   0x4221             TST      R1,R4
   \       0x56   0xD021             BEQ.N    ??emberAfExtractCommandIds_5
   1242                continue;
   1243              }
   1244          
   1245              //Only start from the passed command id
   1246              if (generatedCommands[i].commandId < startId) {
   \       0x58   0x78A9             LDRB     R1,[R5, #+2]
   \       0x5A   0xF89D 0x0038      LDRB     R0,[SP, #+56]
   \       0x5E   0x4281             CMP      R1,R0
   \       0x60   0xD31C             BCC.N    ??emberAfExtractCommandIds_5
   1247                continue;
   1248              }
   1249          
   1250              // According to spec: if cmd->mfgSpecific is set, then we ONLY return the
   1251              // mfg specific commands. If it's not, then we ONLY return non-mfg specific.
   1252              if ( generatedCommands[i].mask & COMMAND_MASK_MANUFACTURER_SPECIFIC ) {
   \       0x62   0x78E9             LDRB     R1,[R5, #+3]
   \       0x64   0xF89A 0x000F      LDRB     R0,[R10, #+15]
   \       0x68   0x06CA             LSLS     R2,R1,#+27
   \       0x6A   0xD508             BPL.N    ??emberAfExtractCommandIds_6
   1253                // Command is Mfg specific
   1254                if ( !cmd->mfgSpecific ) {
   \       0x6C   0xB1B0             CBZ.N    R0,??emberAfExtractCommandIds_5
   1255                  continue;                        // ignore if asking for not mfg specific
   1256                }
   1257                if ( cmd->mfgCode != emAfGetManufacturerCodeForCommand( (EmberAfCommandMetadata*) &(generatedCommands[i]))) {
   \       0x6E   0x4628             MOV      R0,R5
   \       0x70   0x....'....        BL       emAfGetManufacturerCodeForCommand
   \       0x74   0xF8BA 0x1010      LDRH     R1,[R10, #+16]
   \       0x78   0x4281             CMP      R1,R0
   \       0x7A   0xD001             BEQ.N    ??emberAfExtractCommandIds_7
   \       0x7C   0xE00E             B.N      ??emberAfExtractCommandIds_5
   1258                  continue;                        // Ignore if mfg code doesn't match the commands
   1259                }
   1260              } else {
   1261                // Command is not mfg specific.
   1262                if ( cmd->mfgSpecific ) {
   \                     ??emberAfExtractCommandIds_6: (+1)
   \       0x7E   0xB968             CBNZ.N   R0,??emberAfExtractCommandIds_5
   1263                  continue;                       // Ignore if asking for mfg specific
   1264                }
   1265              }
   1266          
   1267              // The one we are about to put in, is beyond the maxIdCount,
   1268              // so instead of populating it in, we set the return flag to
   1269              // false and get out of here.
   1270              if ( maxIdCount == count || count >= bufferLength ) {
   \                     ??emberAfExtractCommandIds_7: (+1)
   \       0x80   0x45BB             CMP      R11,R7
   \       0x82   0xD013             BEQ.N    ??emberAfExtractCommandIds_8
   \       0x84   0xF8BD 0x0030      LDRH     R0,[SP, #+48]
   \       0x88   0x4287             CMP      R7,R0
   \       0x8A   0xDA0F             BGE.N    ??emberAfExtractCommandIds_8
   1271                returnValue = false;
   1272                break;
   1273              }
   1274              buffer[count] = generatedCommands[i].commandId;
   \       0x8C   0x78A9             LDRB     R1,[R5, #+2]
   \       0x8E   0x9801             LDR      R0,[SP, #+4]
   \       0x90   0x55C1             STRB     R1,[R0, R7]
   1275              (*bufferIndex)++;
   \       0x92   0x8832             LDRH     R2,[R6, #+0]
   1276              count++;
   \       0x94   0x1C7F             ADDS     R7,R7,#+1
   \       0x96   0xB2BF             UXTH     R7,R7
   \       0x98   0x1C52             ADDS     R2,R2,#+1
   \       0x9A   0x8032             STRH     R2,[R6, #+0]
   \                     ??emberAfExtractCommandIds_5: (+1)
   \       0x9C   0xF109 0x0901      ADD      R9,R9,#+1
   \       0xA0   0xF1B9 0x0F4B      CMP      R9,#+75
   \       0xA4   0xDBCD             BLT.N    ??emberAfExtractCommandIds_4
   1277            }
   1278            return returnValue;
   \                     ??emberAfExtractCommandIds_9: (+1)
   \       0xA6   0x4640             MOV      R0,R8
   \       0xA8   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   \                     ??emberAfExtractCommandIds_8: (+1)
   \       0xAC   0xF04F 0x0800      MOV      R8,#+0
   \       0xB0   0xE7F9             B.N      ??emberAfExtractCommandIds_9
   1279          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \        0x0   0x....'....        DC32     emberEndpointCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \        0x0   0x....'....        DC32     generatedEmberAfEndpointTypes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \        0x0   0x....'....        DC32     emAfEndpoints

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \        0x0   0x....'....        DC32     emAfEndpoints

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \        0x0   0x....'....        DC32     generatedAttributes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \        0x0   0x....'....        DC32     attributeManufacturerCodes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \        0x0   0x....'....        DC32     generatedClusters

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \        0x0   0x....'....        DC32     clusterManufacturerCodes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \        0x0   0x....'....        DC32     singletonAttributeData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_6:
   \        0x0   0x....'....        DC32     attributeData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_7:
   \        0x0   0x....'....        DC32     emberAfExternalAttributeWriteCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_8:
   \        0x0   0x....'....        DC32     emberAfExternalAttributeReadCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_9:
   \        0x0   0x....'....        DC32     generatedCommands

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_10:
   \        0x0   0x....'....        DC32     commandManufacturerCodes

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x01 0x02          DC8 1, 2, 242, 0
   \              0xF2 0x00    

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x0104 0x0104      DC16 260, 260, 41440
   \               0xA1E0      
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x0101 0x010D      DC16 257, 269, 97
   \               0x0061      
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x00 0x01          DC8 0, 1, 2, 0
   \              0x02 0x00    

   \                                 In section .rodata, align 4
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   1280          #else
   1281          // We just need an empty stub if we don't support it
   1282          bool emberAfExtractCommandIds(bool outgoing,
   1283                                        EmberAfClusterCommand *cmd,
   1284                                        uint16_t clusterId,
   1285                                        uint8_t *buffer,
   1286                                        uint16_t bufferLength,
   1287                                        uint16_t *bufferIndex,
   1288                                        uint8_t startId,
   1289                                        uint8_t maxIdCount)
   1290          {
   1291            return true;
   1292          }
   1293          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   emAfCallInits
        16   -> initializeEndpoint
      24   emAfClusterAttributeChangedCallback
        24   -- Indirect call
        24   -> emberAfFindClusterFunction
        24   -> emberAfFindClusterWithMfgCode
         0   -> emberAfPopNetworkIndex
        24   -> emberAfPushEndpointNetworkIndex
      32   emAfClusterPreAttributeChangedCallback
        32   -- Indirect call
        32   -> emberAfFindClusterFunction
        32   -> emberAfFindClusterWithMfgCode
        32   -> emberAfPopNetworkIndex
        32   -> emberAfPushEndpointNetworkIndex
       0   emAfGetManufacturerCodeForAttribute
         0   -> emAfGetManufacturerCodeForCluster
         0   -> emberAfGetMfgCode
       0   emAfGetManufacturerCodeForCluster
         0   -> getManufacturerCode
       0   emAfGetManufacturerCodeForCommand
         0   -> getManufacturerCode
      72   emAfLoadAttributeDefaults
        72   -> emAfGetManufacturerCodeForAttribute
        72   -> emAfLoadAttributesFromTokens
        72   -> emAfReadOrWriteAttribute
        72   -> emAfSaveAttributeToToken
        72   -> emberAfIndexFromEndpoint
        72   -> emberGetCurrentNetwork
        72   -> halInternalResetWatchDog
      24   emAfLoadAttributesFromTokens
        24   -> emberAfNetworkIndexFromEndpoint
        24   -> emberAfWriteServerAttribute
        24   -> emberGetCurrentNetwork
        24   -> halInternalGetTokenData
       8   emAfMatchAttribute
         8   -> emAfGetManufacturerCodeForAttribute
       8   emAfMatchCluster
         8   -> emAfGetManufacturerCodeForCluster
      56   emAfReadOrWriteAttribute
        56   -- Indirect call
        56   -> emAfGetManufacturerCodeForAttribute
        56   -> emAfMatchAttribute
        56   -> emAfMatchCluster
        56   -> emberAfAttributeReadAccessCallback
        56   -> emberAfAttributeWriteAccessCallback
        56   -> typeSensitiveMemCopy
      32   emAfSaveAttributeToToken
        32   -> emberAfGetMfgCode
        32   -> halCommonMemSet
        32   -> halInternalSetTokenData
      24   emberAfClusterCount
        24   -> emberAfIndexFromEndpoint
      24   emberAfClusterDefaultResponseCallback
        24   -> emberAfClusterDefaultResponseWithMfgCodeCallback
      24   emberAfClusterDefaultResponseWithMfgCodeCallback
        24   -- Indirect call
        24   -> emberAfFindClusterFunction
        24   -> emberAfFindClusterWithMfgCode
         0   -> emberAfPopNetworkIndex
        24   -> emberAfPushEndpointNetworkIndex
      40   emberAfClusterIndex
        40   -> emberAfFindClusterInTypeWithMfgCode
      32   emberAfClusterMessageSentCallback
        32   -> emberAfClusterMessageSentWithMfgCodeCallback
      40   emberAfClusterMessageSentWithMfgCodeCallback
        40   -- Indirect call
        40   -> emberAfFindClusterFunction
        40   -> emberAfFindClusterWithMfgCode
         0   -> emberAfPopNetworkIndex
        40   -> emberAfPushEndpointNetworkIndex
       8   emberAfContainsClient
         8   -> emberAfFindClusterWithMfgCode
       8   emberAfContainsClientWithMfgCode
         8   -> emberAfFindClusterWithMfgCode
       8   emberAfContainsCluster
         8   -> emberAfFindClusterWithMfgCode
       8   emberAfContainsClusterWithMfgCode
         8   -> emberAfFindClusterWithMfgCode
       8   emberAfContainsServer
         8   -> emberAfFindClusterWithMfgCode
       8   emberAfContainsServerWithMfgCode
         8   -> emberAfFindClusterWithMfgCode
      52   emberAfEndpointConfigure
       0   emberAfEndpointCount
      16   emberAfEndpointEnableDisable
        16   -> emberAfDeactivateClusterTick
        16   -> findIndexFromEndpoint
        16   -> initializeEndpoint
       0   emberAfEndpointFromIndex
       0   emberAfEndpointIndexIsEnabled
       8   emberAfEndpointIsEnabled
         8   -> findIndexFromEndpoint
      48   emberAfExtractCommandIds
        48   -> emAfGetManufacturerCodeForCommand
       0   emberAfFindCluster
         0   -> emberAfFindClusterWithMfgCode
       0   emberAfFindClusterClientEndpointIndex
         0   -> emberAfFindClusterClientEndpointIndexWithMfgCode
       0   emberAfFindClusterClientEndpointIndexWithMfgCode
         0   -> findClusterEndpointIndex
      12   emberAfFindClusterFunction
       0   emberAfFindClusterInType
         0   -> emberAfFindClusterInTypeWithMfgCode
      32   emberAfFindClusterInTypeWithMfgCode
        32   -> emAfGetManufacturerCodeForCluster
       0   emberAfFindClusterIncludingDisabledEndpoints
         0   -> emberAfFindClusterIncludingDisabledEndpointsWithMfgCode
      16   emberAfFindClusterIncludingDisabledEndpointsWithMfgCode
         0   -> emberAfFindClusterInTypeWithMfgCode
        16   -> findIndexFromEndpoint
       0   emberAfFindClusterServerEndpointIndex
         0   -> emberAfFindClusterServerEndpointIndexWithMfgCode
       0   emberAfFindClusterServerEndpointIndexWithMfgCode
         0   -> findClusterEndpointIndex
      16   emberAfFindClusterWithMfgCode
         0   -> emberAfFindClusterInTypeWithMfgCode
        16   -> emberAfIndexFromEndpoint
       0   emberAfFixedEndpointCount
       8   emberAfGetClusterByIndex
         8   -> emberAfIndexFromEndpoint
       8   emberAfGetClusterCountForEndpoint
         8   -> emberAfIndexFromEndpoint
      32   emberAfGetClustersFromEndpoint
        32   -> emberAfClusterCount
        32   -> emberAfGetNthCluster
       8   emberAfGetDeviceIdForEndpoint
         8   -> emberAfIndexFromEndpoint
       0   emberAfGetMfgCode
         0   -> getManufacturerCode
      24   emberAfGetNthCluster
        24   -> emberAfIndexFromEndpoint
       8   emberAfGetProfileIdForEndpoint
         8   -> emberAfIndexFromEndpoint
       0   emberAfIndexFromEndpoint
         0   -> findIndexFromEndpoint
       0   emberAfIndexFromEndpointIncludingDisabledEndpoints
         0   -> findIndexFromEndpoint
       0   emberAfInitializeAttributes
         0   -> emAfLoadAttributeDefaults
       0   emberAfIsLongStringAttributeType
       0   emberAfIsStringAttributeType
       0   emberAfIsThisDataTypeAStringType
      40   emberAfLocateAttributeMetadata
        40   -> emAfReadOrWriteAttribute
       8   emberAfResetAttributes
         8   -> emAfLoadAttributeDefaults
         0   -> emAfResetAttributes
       0   emberAfSetEndpointCount
      40   findClusterEndpointIndex
        40   -> emberAfFindClusterIncludingDisabledEndpointsWithMfgCode
        40   -> emberAfFindClusterWithMfgCode
      16   findIndexFromEndpoint
       8   getManufacturerCode
      24   initializeEndpoint
        24   -- Indirect call
        24   -> emberAfClusterInitCallback
        24   -> emberAfFindClusterFunction
         0   -> emberAfPopNetworkIndex
        24   -> emberAfPushEndpointNetworkIndex
      24   typeSensitiveMemCopy
        24   -> emberAfCopyLongString
        24   -> emberAfCopyString
        24   -> halCommonMemMove
        24   -> halCommonMemSet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_10
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable19_9
       8  ?Subroutine0
       4  ?Subroutine1
      14  ?Subroutine10
       8  ?Subroutine11
      10  ?Subroutine12
      22  ?Subroutine2
      12  ?Subroutine3
       6  ?Subroutine4
       6  ?Subroutine5
       6  ?Subroutine6
       8  ?Subroutine7
      10  ?Subroutine8
      10  ?Subroutine9
       4  ?_0
       8  ?_1
       8  ?_2
       4  ?_3
       4  ?_4
       4  ?_5
     160  attributeData
       2  attributeManufacturerCodeCount
       4  attributeManufacturerCodes
       2  clusterManufacturerCodeCount
       4  clusterManufacturerCodes
       2  commandManufacturerCodeCount
       4  commandManufacturerCodes
      42  emAfCallInits
      74  emAfClusterAttributeChangedCallback
      74  emAfClusterPreAttributeChangedCallback
      48  emAfEndpoints
      16  emAfGetManufacturerCodeForAttribute
      18  emAfGetManufacturerCodeForCluster
      16  emAfGetManufacturerCodeForCommand
     316  emAfLoadAttributeDefaults
     262  emAfLoadAttributesFromTokens
      38  emAfMatchAttribute
      44  emAfMatchCluster
     370  emAfReadOrWriteAttribute
     354  emAfSaveAttributeToToken
       2  emAfZigbeeProNetworks
      76  emberAfClusterCount
      16  emberAfClusterDefaultResponseCallback
      46  emberAfClusterDefaultResponseWithMfgCodeCallback
      80  emberAfClusterIndex
      20  emberAfClusterMessageSentCallback
      88  emberAfClusterMessageSentWithMfgCodeCallback
       8  emberAfContainsClient
       8  emberAfContainsClientWithMfgCode
       4  emberAfContainsCluster
       6  emberAfContainsClusterWithMfgCode
       8  emberAfContainsServer
       8  emberAfContainsServerWithMfgCode
     140  emberAfEndpointConfigure
       8  emberAfEndpointCount
      96  emberAfEndpointEnableDisable
      10  emberAfEndpointFromIndex
      16  emberAfEndpointIndexIsEnabled
      28  emberAfEndpointIsEnabled
     178  emberAfExtractCommandIds
       4  emberAfFindCluster
       4  emberAfFindClusterClientEndpointIndex
       6  emberAfFindClusterClientEndpointIndexWithMfgCode
      40  emberAfFindClusterFunction
       4  emberAfFindClusterInType
     100  emberAfFindClusterInTypeWithMfgCode
       4  emberAfFindClusterIncludingDisabledEndpoints
      14  emberAfFindClusterIncludingDisabledEndpointsWithMfgCode
       4  emberAfFindClusterServerEndpointIndex
       6  emberAfFindClusterServerEndpointIndexWithMfgCode
      22  emberAfFindClusterWithMfgCode
       4  emberAfFixedEndpointCount
       4  emberAfFuncArrayColorControlClusterServer
       4  emberAfFuncArrayGroupsClusterServer
       8  emberAfFuncArrayIdentifyClusterServer
       4  emberAfFuncArrayLevelControlClusterServer
       4  emberAfFuncArrayOnOffClusterServer
       4  emberAfFuncArrayScenesClusterServer
      38  emberAfGetClusterByIndex
      24  emberAfGetClusterCountForEndpoint
      68  emberAfGetClustersFromEndpoint
      20  emberAfGetDeviceIdForEndpoint
      20  emberAfGetMfgCode
      82  emberAfGetNthCluster
      20  emberAfGetProfileIdForEndpoint
       4  emberAfIndexFromEndpoint
       4  emberAfIndexFromEndpointIncludingDisabledEndpoints
       4  emberAfInitializeAttributes
      16  emberAfIsLongStringAttributeType
      16  emberAfIsStringAttributeType
      24  emberAfIsThisDataTypeAStringType
      50  emberAfLocateAttributeMetadata
      20  emberAfResetAttributes
      10  emberAfSetEndpointCount
       1  emberEndpointCount
      74  findClusterEndpointIndex
      52  findIndexFromEndpoint
     984  generatedAttributes
     300  generatedClusters
     300  generatedCommands
      24  generatedDefaults
      24  generatedEmberAfEndpointTypes
      30  getManufacturerCode
      60  initializeEndpoint
     192  singletonAttributeData
      86  typeSensitiveMemCopy

 
   401 bytes in section .bss
 1 712 bytes in section .rodata
 3 598 bytes in section .text
 
 3 598 bytes of CODE  memory
 1 712 bytes of CONST memory
   401 bytes of DATA  memory

Errors: none
Warnings: none
