###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:54
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\em_timer.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW5DA2.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\em_timer.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"em_timer.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0
#        -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\em_timer.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\em_timer.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\em_timer.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Timer/counter (TIMER) Peripheral API
      4           * @version 5.8.0
      5           *******************************************************************************
      6           * # License
      7           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      8           *******************************************************************************
      9           *
     10           * SPDX-License-Identifier: Zlib
     11           *
     12           * The licensor of this software is Silicon Laboratories Inc.
     13           *
     14           * This software is provided 'as-is', without any express or implied
     15           * warranty. In no event will the authors be held liable for any damages
     16           * arising from the use of this software.
     17           *
     18           * Permission is granted to anyone to use this software for any purpose,
     19           * including commercial applications, and to alter it and redistribute it
     20           * freely, subject to the following restrictions:
     21           *
     22           * 1. The origin of this software must not be misrepresented; you must not
     23           *    claim that you wrote the original software. If you use this software
     24           *    in a product, an acknowledgment in the product documentation would be
     25           *    appreciated but is not required.
     26           * 2. Altered source versions must be plainly marked as such, and must not be
     27           *    misrepresented as being the original software.
     28           * 3. This notice may not be removed or altered from any source distribution.
     29           *
     30           ******************************************************************************/
     31          
     32          #include "em_timer.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp bool TIMER_Valid(TIMER_TypeDef const *)
   \                     TIMER_Valid: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable2  ;; 0x40048000
   \        0x2   0x4288             CMP      R0,R1
   \        0x4   0xBF1C             ITT      NE 
   \        0x6   0x....             LDRNE.N  R2,??DataTable2_1  ;; 0x4004c000
   \        0x8   0x4290             CMPNE    R0,R2
   \        0xA   0xD005             BEQ.N    ??TIMER_Valid_0
   \        0xC   0x....             LDR.N    R1,??DataTable2_2  ;; 0x40050000
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xBF1C             ITT      NE 
   \       0x12   0x....             LDRNE.N  R2,??DataTable2_3  ;; 0x40054000
   \       0x14   0x4290             CMPNE    R0,R2
   \       0x16   0xD101             BNE.N    ??TIMER_Valid_1
   \                     ??TIMER_Valid_0: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0x4770             BX       LR
   \                     ??TIMER_Valid_1: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void TIMER_EnableDTI(TIMER_TypeDef *, bool)
   \                     TIMER_EnableDTI: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x6B25             LDR      R5,[R4, #+48]
   \        0x8   0x....'....        BL       TIMER_SyncWait
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0xF242 0x0030      MOVW     R0,#+8240
   \       0x12   0xF005 0x0501      AND      R5,R5,#0x1
   \       0x16   0x5021             STR      R1,[R4, R0]
   \       0x18   0xB11E             CBZ.N    R6,??TIMER_EnableDTI_0
   \       0x1A   0xF504 0x5087      ADD      R0,R4,#+4320
   \       0x1E   0x6001             STR      R1,[R0, #+0]
   \       0x20   0xE003             B.N      ??TIMER_EnableDTI_1
   \                     ??TIMER_EnableDTI_0: (+1)
   \       0x22   0x2201             MOVS     R2,#+1
   \       0x24   0xF242 0x01E0      MOVW     R1,#+8416
   \       0x28   0x5062             STR      R2,[R4, R1]
   \                     ??TIMER_EnableDTI_1: (+1)
   \       0x2A   0xF241 0x0030      MOVW     R0,#+4144
   \       0x2E   0x5025             STR      R5,[R4, R0]
   \       0x30   0xBD70             POP      {R4-R6,PC}       ;; return
     33          #if defined(TIMER_COUNT) && (TIMER_COUNT > 0)
     34          
     35          #include "em_assert.h"
     36          
     37          /***************************************************************************//**
     38           * @addtogroup emlib
     39           * @{
     40           ******************************************************************************/
     41          
     42          /***************************************************************************//**
     43           * @addtogroup TIMER
     44           * @brief Timer/Counter (TIMER) Peripheral API
     45           * @details
     46           *   The timer module consists of three main parts:
     47           *   @li General timer configuration and enable control.
     48           *   @li Compare/capture control.
     49           *   @li Dead time insertion control (may not be available for all timers).
     50           * @{
     51           ******************************************************************************/
     52          
     53          /*******************************************************************************
     54           **************************   LOCAL FUNCTIONS   ********************************
     55           ******************************************************************************/
     56          
     57          /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
     58          #if defined(_PRS_CONSUMER_TIMER0_CC0_MASK)
     59          
     60          /** Map TIMER reference to index of device. */
     61          #if defined(TIMER4)
     62          #define TIMER_DEVICE_ID(timer) ( \
     63              (timer) == TIMER0   ? 0      \
     64              : (timer) == TIMER1 ? 1      \
     65              : (timer) == TIMER2 ? 2      \
     66              : (timer) == TIMER3 ? 3      \
     67              : (timer) == TIMER4 ? 4      \
     68              : -1)
     69          #else
     70          #define TIMER_DEVICE_ID(timer) ( \
     71              (timer) == TIMER0   ? 0      \
     72              : (timer) == TIMER1 ? 1      \
     73              : (timer) == TIMER2 ? 2      \
     74              : (timer) == TIMER3 ? 3      \
     75              : -1)
     76          #endif
     77          
     78          #define TIMER_INPUT_CHANNEL_DTI     3UL
     79          #define TIMER_INPUT_CHANNEL_DTIFS1  4UL
     80          #define TIMER_INPUT_CHANNEL_DTIFS2  5UL
     81          
     82          /**
     83           * TIMER PRS registers are moved into the PRS register space on series 2 devices.
     84           * The PRS Consumer registers for a timer consist of 6 registers.
     85           *
     86           * [0] - CC0 PRS Consumer
     87           * [1] - CC1 PRS Consumer
     88           * [2] - CC2 PRS Consumer
     89           * [3] - DTI PRS Consumer
     90           * [4] - DTIFS1 PRS Consumer
     91           * [5] - DTIFS2 PRS Consumer
     92           */
     93          typedef struct {
     94            __IOM uint32_t CONSUMER_CH[6];         /**< TIMER PRS consumers. */
     95          } PRS_TIMERn_Consumer_TypeDef;
     96          
     97          typedef struct {
     98            PRS_TIMERn_Consumer_TypeDef TIMER_CONSUMER[TIMER_COUNT];
     99          } PRS_TIMERn_TypeDef;
    100          
    101          /**
    102           * @brief Configure a timer capture/compare channel to use a PRS channel as input.
    103           *
    104           * @param[in] timer
    105           *
    106           * @param[in] cc
    107           *   Timer input channel. Valid input is 0-5.
    108           *   0 - CC0
    109           *   1 - CC1
    110           *   2 - CC2
    111           *   3 - DTI
    112           *   4 - DTIFS1
    113           *   5 - DTIFS2
    114           *
    115           * @param[in] prsCh
    116           *   PRS channel number.
    117           *
    118           * @param[in] async
    119           *   true for asynchronous PRS channel, false for synchronous PRS channel.
    120           */

   \                                 In section .text, align 2, keep-with-next
    121          static void timerPrsConfig(TIMER_TypeDef * timer, unsigned int cc, unsigned int prsCh, bool async)
    122          {
   \                     timerPrsConfig: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
    123            int i = TIMER_DEVICE_ID(timer);
   \        0x2   0x....             LDR.N    R5,??DataTable2  ;; 0x40048000
   \        0x4   0x....             LDR.N    R4,??DataTable2_4  ;; 0x40038104
   \        0x6   0x42A8             CMP      R0,R5
   \        0x8   0xBF08             IT       EQ 
   \        0xA   0x3418             ADDEQ    R4,R4,#+24
   \        0xC   0xD00D             BEQ.N    ??timerPrsConfig_0
   \        0xE   0x....             LDR.N    R5,??DataTable2_1  ;; 0x4004c000
   \       0x10   0x42A8             CMP      R0,R5
   \       0x12   0xBF08             IT       EQ 
   \       0x14   0x3430             ADDEQ    R4,R4,#+48
   \       0x16   0xD008             BEQ.N    ??timerPrsConfig_0
   \       0x18   0x....             LDR.N    R5,??DataTable2_2  ;; 0x40050000
   \       0x1A   0x42A8             CMP      R0,R5
   \       0x1C   0xBF08             IT       EQ 
   \       0x1E   0x3448             ADDEQ    R4,R4,#+72
   \       0x20   0xD003             BEQ.N    ??timerPrsConfig_0
   \       0x22   0x....             LDR.N    R5,??DataTable2_3  ;; 0x40054000
   \       0x24   0x42A8             CMP      R0,R5
   \       0x26   0xBF08             IT       EQ 
   \       0x28   0x3460             ADDEQ    R4,R4,#+96
    124            PRS_TIMERn_TypeDef * base = (PRS_TIMERn_TypeDef *) &PRS->CONSUMER_TIMER0_CC0;
    125            EFM_ASSERT(i != -1);
    126          
    127            if (async) {
   \                     ??timerPrsConfig_0: (+1)
   \       0x2A   0xB903             CBNZ.N   R3,??timerPrsConfig_1
    128              base->TIMER_CONSUMER[i].CONSUMER_CH[cc] = prsCh << _PRS_CONSUMER_TIMER0_CC0_PRSSEL_SHIFT;
    129            } else {
    130              base->TIMER_CONSUMER[i].CONSUMER_CH[cc] = prsCh << _PRS_CONSUMER_TIMER0_CC0_SPRSSEL_SHIFT;
   \       0x2C   0x0212             LSLS     R2,R2,#+8
   \                     ??timerPrsConfig_1: (+1)
   \       0x2E   0xF844 0x2021      STR      R2,[R4, R1, LSL #+2]
    131            }
    132          }
   \       0x32   0xBD30             POP      {R4,R5,PC}       ;; return
    133          #endif
    134          
    135          /** @endcond */
    136          
    137          /*******************************************************************************
    138           **************************   GLOBAL FUNCTIONS   *******************************
    139           ******************************************************************************/
    140          
    141          /***************************************************************************//**
    142           * @brief
    143           *   Initialize TIMER.
    144           *
    145           * @details
    146           *   Notice that the counter top must be configured separately with, for instance
    147           *   TIMER_TopSet(). In addition, compare/capture and dead-time insertion
    148           *   initialization must be initialized separately if used, which should probably
    149           *   be done prior to using this function if configuring the TIMER to
    150           *   start when initialization is completed.
    151           *
    152           * @param[in] timer
    153           *   A pointer to the TIMER peripheral register block.
    154           *
    155           * @param[in] init
    156           *   A pointer to the TIMER initialization structure.
    157           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    158          void TIMER_Init(TIMER_TypeDef *timer, const TIMER_Init_TypeDef *init)
    159          {
   \                     TIMER_Init: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    160            EFM_ASSERT(TIMER_REF_VALID(timer));
   \        0x6   0x....'....        BL       TIMER_Valid
    161            uint32_t ctrlRegVal = 0;
    162          
    163          #if defined (_TIMER_CFG_PRESC_SHIFT)
    164            TIMER_SyncWait(timer);
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0x....'....        BL       TIMER_SyncWait
    165            timer->EN_CLR = TIMER_EN_EN;
   \       0x10   0x2101             MOVS     R1,#+1
   \       0x12   0xF242 0x0230      MOVW     R2,#+8240
   \       0x16   0x50A1             STR      R1,[R4, R2]
    166            timer->CFG = ((uint32_t)init->prescale << _TIMER_CFG_PRESC_SHIFT)
    167                         | ((uint32_t)init->clkSel << _TIMER_CFG_CLKSEL_SHIFT)
    168                         | ((uint32_t)init->mode   << _TIMER_CFG_MODE_SHIFT)
    169                         | (init->debugRun         ?   TIMER_CFG_DEBUGRUN  : 0)
    170                         | (init->dmaClrAct        ?   TIMER_CFG_DMACLRACT : 0)
    171                         | (init->quadModeX4       ?   TIMER_CFG_QDM_X4    : 0)
    172                         | (init->oneShot          ?   TIMER_CFG_OSMEN     : 0)
    173                         | (init->sync             ?   TIMER_CFG_SYNC      : 0)
    174                         | (init->ati              ?   TIMER_CFG_ATI       : 0);
   \       0x18   0x7868             LDRB     R0,[R5, #+1]
   \       0x1A   0xF895 0xE004      LDRB     LR,[R5, #+4]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0x7AA8             LDRB     R0,[R5, #+10]
   \       0x22   0xEA4F 0x2E0E      LSL      LR,LR,#+8
   \       0x26   0xBF14             ITE      NE 
   \       0x28   0x2140             MOVNE    R1,#+64
   \       0x2A   0x2100             MOVEQ    R1,#+0
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0x7AE8             LDRB     R0,[R5, #+11]
   \       0x30   0xBF14             ITE      NE 
   \       0x32   0x2280             MOVNE    R2,#+128
   \       0x34   0x2200             MOVEQ    R2,#+0
   \       0x36   0x2800             CMP      R0,#+0
   \       0x38   0x7B28             LDRB     R0,[R5, #+12]
   \       0x3A   0xBF14             ITE      NE 
   \       0x3C   0x2320             MOVNE    R3,#+32
   \       0x3E   0x2300             MOVEQ    R3,#+0
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0x7B68             LDRB     R0,[R5, #+13]
   \       0x44   0xBF14             ITE      NE 
   \       0x46   0x2610             MOVNE    R6,#+16
   \       0x48   0x2600             MOVEQ    R6,#+0
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0x79A8             LDRB     R0,[R5, #+6]
   \       0x4E   0xBF14             ITE      NE 
   \       0x50   0x2708             MOVNE    R7,#+8
   \       0x52   0x2700             MOVEQ    R7,#+0
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xF9B5 0x0002      LDRSH    R0,[R5, #+2]
   \       0x5A   0xEA4E 0x4E80      ORR      LR,LR,R0, LSL #+18
   \       0x5E   0x7A68             LDRB     R0,[R5, #+9]
   \       0x60   0xBF14             ITE      NE 
   \       0x62   0xF44F 0x3C80      MOVNE    R12,#+65536
   \       0x66   0xF04F 0x0C00      MOVEQ    R12,#+0
   \       0x6A   0xEA40 0x000E      ORR      R0,R0,LR
   \       0x6E   0x4301             ORRS     R1,R1,R0
   \       0x70   0x4311             ORRS     R1,R2,R1
   \       0x72   0x4319             ORRS     R1,R3,R1
   \       0x74   0x4331             ORRS     R1,R6,R1
   \       0x76   0x4339             ORRS     R1,R7,R1
   \       0x78   0xEA4C 0x0101      ORR      R1,R12,R1
   \       0x7C   0x6061             STR      R1,[R4, #+4]
    175            timer->EN_SET = TIMER_EN_EN;
   \       0x7E   0x2101             MOVS     R1,#+1
   \       0x80   0xF241 0x0230      MOVW     R2,#+4144
   \       0x84   0x50A1             STR      R1,[R4, R2]
    176          #endif
    177          
    178            /* Stop the timer if specified to be disabled (doesn't hurt if already stopped). */
    179            if (!(init->enable)) {
   \       0x86   0x7828             LDRB     R0,[R5, #+0]
   \       0x88   0xB908             CBNZ.N   R0,??TIMER_Init_0
    180              timer->CMD = TIMER_CMD_STOP;
   \       0x8A   0x2102             MOVS     R1,#+2
   \       0x8C   0x60E1             STR      R1,[R4, #+12]
    181            }
    182          
    183            /* Reset the counter. */
    184            timer->CNT = _TIMER_CNT_RESETVALUE;
   \                     ??TIMER_Init_0: (+1)
   \       0x8E   0x2200             MOVS     R2,#+0
   \       0x90   0x6262             STR      R2,[R4, #+36]
    185          
    186          #if defined(_SILICON_LABS_32B_SERIES_2)
    187            ctrlRegVal = ((uint32_t)init->fallAction   << _TIMER_CTRL_FALLA_SHIFT)
    188                         | ((uint32_t)init->riseAction << _TIMER_CTRL_RISEA_SHIFT)
    189                         | (init->count2x              ?   TIMER_CTRL_X2CNT     : 0);
   \       0x92   0x7969             LDRB     R1,[R5, #+5]
   \       0x94   0xB101             CBZ.N    R1,??TIMER_Init_1
   \       0x96   0x2110             MOVS     R1,#+16
    190          #else
    191            ctrlRegVal = ((uint32_t)init->prescale     << _TIMER_CTRL_PRESC_SHIFT)
    192                         | ((uint32_t)init->clkSel     << _TIMER_CTRL_CLKSEL_SHIFT)
    193                         | ((uint32_t)init->fallAction << _TIMER_CTRL_FALLA_SHIFT)
    194                         | ((uint32_t)init->riseAction << _TIMER_CTRL_RISEA_SHIFT)
    195                         | ((uint32_t)init->mode       << _TIMER_CTRL_MODE_SHIFT)
    196                         | (init->debugRun             ?   TIMER_CTRL_DEBUGRUN  : 0)
    197                         | (init->dmaClrAct            ?   TIMER_CTRL_DMACLRACT : 0)
    198                         | (init->quadModeX4           ?   TIMER_CTRL_QDM_X4    : 0)
    199                         | (init->oneShot              ?   TIMER_CTRL_OSMEN     : 0)
    200                         | (init->sync                 ?   TIMER_CTRL_SYNC      : 0);
    201          #if defined(TIMER_CTRL_X2CNT) && defined(TIMER_CTRL_ATI)
    202            ctrlRegVal |= (init->count2x              ?   TIMER_CTRL_X2CNT     : 0)
    203                          | (init->ati                ?   TIMER_CTRL_ATI       : 0);
    204          #endif
    205          #endif
    206          
    207            timer->CTRL = ctrlRegVal;
   \                     ??TIMER_Init_1: (+1)
   \       0x98   0x79EA             LDRB     R2,[R5, #+7]
   \       0x9A   0x7A2B             LDRB     R3,[R5, #+8]
   \       0x9C   0xEA43 0x0382      ORR      R3,R3,R2, LSL #+2
   \       0xA0   0x4319             ORRS     R1,R1,R3
   \       0xA2   0x60A1             STR      R1,[R4, #+8]
    208          
    209            /* Start the timer if specified to be enabled (doesn't hurt if already started). */
    210            if (init->enable) {
   \       0xA4   0xB108             CBZ.N    R0,??TIMER_Init_2
    211              timer->CMD = TIMER_CMD_START;
   \       0xA6   0x2001             MOVS     R0,#+1
   \       0xA8   0x60E0             STR      R0,[R4, #+12]
    212            }
    213          }
   \                     ??TIMER_Init_2: (+1)
   \       0xAA   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    214          
    215          /***************************************************************************//**
    216           * @brief
    217           *   Initialize the TIMER compare/capture channel.
    218           *
    219           * @details
    220           *   Notice that if operating the channel in compare mode, the CCV and CCVB register
    221           *   must be set separately, as required.
    222           *
    223           * @param[in] timer
    224           *   A pointer to the TIMER peripheral register block.
    225           *
    226           * @param[in] ch
    227           *   A compare/capture channel to initialize for.
    228           *
    229           * @param[in] init
    230           *   A pointer to the TIMER initialization structure.
    231           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    232          void TIMER_InitCC(TIMER_TypeDef *timer,
    233                            unsigned int ch,
    234                            const TIMER_InitCC_TypeDef *init)
    235          {
   \                     TIMER_InitCC: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4614             MOV      R4,R2
    236            EFM_ASSERT(TIMER_REF_VALID(timer));
   \        0x8   0x....'....        BL       TIMER_Valid
    237            EFM_ASSERT(TIMER_CH_VALID(ch));
    238          
    239          #if defined (_TIMER_CC_CFG_MASK)
    240            TIMER_SyncWait(timer);
   \        0xC   0x4628             MOV      R0,R5
   \        0xE   0x....'....        BL       TIMER_SyncWait
    241            timer->EN_CLR = TIMER_EN_EN;
   \       0x12   0x2101             MOVS     R1,#+1
   \       0x14   0xF242 0x0230      MOVW     R2,#+8240
   \       0x18   0x50A9             STR      R1,[R5, R2]
    242            timer->CC[ch].CFG =
    243              ((uint32_t)init->mode        << _TIMER_CC_CFG_MODE_SHIFT)
    244              | (init->filter              ?   TIMER_CC_CFG_FILT_ENABLE : 0)
    245              | (init->coist               ?   TIMER_CC_CFG_COIST       : 0)
    246              | ((uint32_t)init->prsOutput << _TIMER_CC_CFG_PRSCONF_SHIFT);
   \       0x1A   0x79E0             LDRB     R0,[R4, #+7]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0x7A60             LDRB     R0,[R4, #+9]
   \       0x20   0xBF14             ITE      NE 
   \       0x22   0xF44F 0x1180      MOVNE    R1,#+1048576
   \       0x26   0x2100             MOVEQ    R1,#+0
   \       0x28   0xB100             CBZ.N    R0,??TIMER_InitCC_0
   \       0x2A   0x2010             MOVS     R0,#+16
   \                     ??TIMER_InitCC_0: (+1)
   \       0x2C   0x79A3             LDRB     R3,[R4, #+6]
   \       0x2E   0xEB05 0x1746      ADD      R7,R5,R6, LSL #+5
   \       0x32   0x4319             ORRS     R1,R1,R3
   \       0x34   0x4301             ORRS     R1,R0,R1
   \       0x36   0x7AE0             LDRB     R0,[R4, #+11]
   \       0x38   0xEA41 0x41C0      ORR      R1,R1,R0, LSL #+19
   \       0x3C   0x6639             STR      R1,[R7, #+96]
    247          
    248            if (init->prsInput) {
   \       0x3E   0x7A20             LDRB     R0,[R4, #+8]
   \       0x40   0x2800             CMP      R0,#+0
   \       0x42   0x6E38             LDR      R0,[R7, #+96]
   \       0x44   0xD00E             BEQ.N    ??TIMER_InitCC_1
    249              timer->CC[ch].CFG |= (uint32_t)init->prsInputType << _TIMER_CC_CFG_INSEL_SHIFT;
   \       0x46   0x7B21             LDRB     R1,[R4, #+12]
   \       0x48   0xEA40 0x4041      ORR      R0,R0,R1, LSL #+17
    250              bool async = (init->prsInputType != timerPrsInputSync);
    251              timerPrsConfig(timer, ch, init->prsSel, async);
   \       0x4C   0x4631             MOV      R1,R6
   \       0x4E   0x6638             STR      R0,[R7, #+96]
   \       0x50   0x7B20             LDRB     R0,[R4, #+12]
   \       0x52   0x78A2             LDRB     R2,[R4, #+2]
   \       0x54   0x2801             CMP      R0,#+1
   \       0x56   0x4628             MOV      R0,R5
   \       0x58   0xBF14             ITE      NE 
   \       0x5A   0x2301             MOVNE    R3,#+1
   \       0x5C   0x2300             MOVEQ    R3,#+0
   \       0x5E   0x....'....        BL       timerPrsConfig
   \       0x62   0xE000             B.N      ??TIMER_InitCC_2
    252            } else {
    253              timer->CC[ch].CFG |= TIMER_CC_CFG_INSEL_PIN;
   \                     ??TIMER_InitCC_1: (+1)
   \       0x64   0x6638             STR      R0,[R7, #+96]
    254            }
    255            timer->EN_SET = TIMER_EN_EN;
   \                     ??TIMER_InitCC_2: (+1)
   \       0x66   0x2101             MOVS     R1,#+1
   \       0x68   0xF241 0x0230      MOVW     R2,#+4144
   \       0x6C   0x50A9             STR      R1,[R5, R2]
    256          
    257            timer->CC[ch].CTRL =
    258              ((uint32_t)init->eventCtrl << _TIMER_CC_CTRL_ICEVCTRL_SHIFT)
    259              | ((uint32_t)init->edge    << _TIMER_CC_CTRL_ICEDGE_SHIFT)
    260              | ((uint32_t)init->cufoa   << _TIMER_CC_CTRL_CUFOA_SHIFT)
    261              | ((uint32_t)init->cofoa   << _TIMER_CC_CTRL_COFOA_SHIFT)
    262              | ((uint32_t)init->cmoa    << _TIMER_CC_CTRL_CMOA_SHIFT)
    263              | (init->outInvert         ?   TIMER_CC_CTRL_OUTINV : 0);
   \       0x6E   0x7AA0             LDRB     R0,[R4, #+10]
   \       0x70   0xB100             CBZ.N    R0,??TIMER_InitCC_3
   \       0x72   0x2004             MOVS     R0,#+4
   \                     ??TIMER_InitCC_3: (+1)
   \       0x74   0x7862             LDRB     R2,[R4, #+1]
   \       0x76   0x7821             LDRB     R1,[R4, #+0]
   \       0x78   0x7923             LDRB     R3,[R4, #+4]
   \       0x7A   0x0612             LSLS     R2,R2,#+24
   \       0x7C   0xEA42 0x6281      ORR      R2,R2,R1, LSL #+26
   \       0x80   0x78E1             LDRB     R1,[R4, #+3]
   \       0x82   0xEA42 0x3201      ORR      R2,R2,R1, LSL #+12
   \       0x86   0x7961             LDRB     R1,[R4, #+5]
   \       0x88   0xEA42 0x2283      ORR      R2,R2,R3, LSL #+10
   \       0x8C   0xEA42 0x2201      ORR      R2,R2,R1, LSL #+8
   \       0x90   0x4310             ORRS     R0,R0,R2
   \       0x92   0x6678             STR      R0,[R7, #+100]
    264          #else
    265            timer->CC[ch].CTRL =
    266              ((uint32_t)init->eventCtrl   << _TIMER_CC_CTRL_ICEVCTRL_SHIFT)
    267              | ((uint32_t)init->edge      << _TIMER_CC_CTRL_ICEDGE_SHIFT)
    268              | ((uint32_t)init->prsSel    << _TIMER_CC_CTRL_PRSSEL_SHIFT)
    269              | ((uint32_t)init->cufoa     << _TIMER_CC_CTRL_CUFOA_SHIFT)
    270              | ((uint32_t)init->cofoa     << _TIMER_CC_CTRL_COFOA_SHIFT)
    271              | ((uint32_t)init->cmoa      << _TIMER_CC_CTRL_CMOA_SHIFT)
    272              | ((uint32_t)init->mode      << _TIMER_CC_CTRL_MODE_SHIFT)
    273              | (init->filter              ?   TIMER_CC_CTRL_FILT_ENABLE : 0)
    274              | (init->prsInput            ?   TIMER_CC_CTRL_INSEL_PRS   : 0)
    275              | (init->coist               ?   TIMER_CC_CTRL_COIST       : 0)
    276              | (init->outInvert           ?   TIMER_CC_CTRL_OUTINV      : 0)
    277          #if defined(_TIMER_CC_CTRL_PRSCONF_MASK)
    278              | ((uint32_t)init->prsOutput << _TIMER_CC_CTRL_PRSCONF_SHIFT)
    279          #endif
    280            ;
    281          #endif
    282          }
   \       0x94   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    283          
    284          #if defined(_TIMER_DTCTRL_MASK)
    285          /***************************************************************************//**
    286           * @brief
    287           *   Initialize the TIMER DTI unit.
    288           *
    289           * @param[in] timer
    290           *   A pointer to the TIMER peripheral register block.
    291           *
    292           * @param[in] init
    293           *   A pointer to the TIMER DTI initialization structure.
    294           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    295          void TIMER_InitDTI(TIMER_TypeDef *timer, const TIMER_InitDTI_TypeDef *init)
    296          {
   \                     TIMER_InitDTI: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4604             MOV      R4,R0
    297            EFM_ASSERT(TIMER0 == timer);
    298          
    299            /* Make sure the DTI unit is disabled while initializing. */
    300            TIMER_EnableDTI(timer, false);
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x....'....        BL       TIMER_EnableDTI
    301          
    302          #if defined (_TIMER_DTCFG_MASK)
    303            TIMER_SyncWait(timer);
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x....'....        BL       TIMER_SyncWait
    304            timer->EN_CLR = TIMER_EN_EN;
   \       0x12   0x2101             MOVS     R1,#+1
   \       0x14   0xF242 0x0230      MOVW     R2,#+8240
   \       0x18   0x50A1             STR      R1,[R4, R2]
    305            timer->DTCFG = (init->autoRestart       ?   TIMER_DTCFG_DTDAS   : 0)
    306                           | (init->enablePrsSource ?   TIMER_DTCFG_DTPRSEN : 0);
   \       0x1A   0x78E8             LDRB     R0,[R5, #+3]
   \       0x1C   0xF104 0x06E0      ADD      R6,R4,#+224
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0x7928             LDRB     R0,[R5, #+4]
   \       0x24   0xBF14             ITE      NE 
   \       0x26   0x2102             MOVNE    R1,#+2
   \       0x28   0x2100             MOVEQ    R1,#+0
   \       0x2A   0x2800             CMP      R0,#+0
   \       0x2C   0xBF18             IT       NE 
   \       0x2E   0xF441 0x6100      ORRNE    R1,R1,#0x800
   \       0x32   0x6031             STR      R1,[R6, #+0]
    307            if (init->enablePrsSource) {
   \       0x34   0xD005             BEQ.N    ??TIMER_InitDTI_0
    308              timerPrsConfig(timer, TIMER_INPUT_CHANNEL_DTI, init->prsSel, true);
   \       0x36   0x796A             LDRB     R2,[R5, #+5]
   \       0x38   0x2301             MOVS     R3,#+1
   \       0x3A   0x2103             MOVS     R1,#+3
   \       0x3C   0x4620             MOV      R0,R4
   \       0x3E   0x....'....        BL       timerPrsConfig
    309            }
    310          
    311            timer->DTTIMECFG =
    312              ((uint32_t)init->prescale   << _TIMER_DTTIMECFG_DTPRESC_SHIFT)
    313              | ((uint32_t)init->riseTime << _TIMER_DTTIMECFG_DTRISET_SHIFT)
    314              | ((uint32_t)init->fallTime << _TIMER_DTTIMECFG_DTFALLT_SHIFT);
   \                     ??TIMER_InitDTI_0: (+1)
   \       0x42   0xF9B5 0x0006      LDRSH    R0,[R5, #+6]
   \       0x46   0x68A9             LDR      R1,[R5, #+8]
   \       0x48   0x68EA             LDR      R2,[R5, #+12]
   \       0x4A   0xEA40 0x2081      ORR      R0,R0,R1, LSL #+10
   \       0x4E   0xEA40 0x4002      ORR      R0,R0,R2, LSL #+16
   \       0x52   0x6070             STR      R0,[R6, #+4]
    315          
    316            timer->DTFCFG =
    317              (init->enableFaultSourceCoreLockup ?   TIMER_DTFCFG_DTLOCKUPFEN : 0)
    318              | (init->enableFaultSourceDebugger ?   TIMER_DTFCFG_DTDBGFEN    : 0)
    319              | (init->enableFaultSourcePrsSel0  ?   TIMER_DTFCFG_DTPRS0FEN   : 0)
    320              | (init->enableFaultSourcePrsSel1  ?   TIMER_DTFCFG_DTPRS1FEN   : 0)
    321              | ((uint32_t)(init->faultAction)   << _TIMER_DTFCFG_DTFA_SHIFT);
   \       0x54   0x7D28             LDRB     R0,[R5, #+20]
   \       0x56   0x7E29             LDRB     R1,[R5, #+24]
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0x7D68             LDRB     R0,[R5, #+21]
   \       0x5C   0xBF14             ITE      NE 
   \       0x5E   0xF04F 0x6200      MOVNE    R2,#+134217728
   \       0x62   0x2200             MOVEQ    R2,#+0
   \       0x64   0x2800             CMP      R0,#+0
   \       0x66   0x7DA8             LDRB     R0,[R5, #+22]
   \       0x68   0xBF14             ITE      NE 
   \       0x6A   0xF04F 0x6380      MOVNE    R3,#+67108864
   \       0x6E   0x2300             MOVEQ    R3,#+0
   \       0x70   0x2800             CMP      R0,#+0
   \       0x72   0xBF14             ITE      NE 
   \       0x74   0xF04F 0x7780      MOVNE    R7,#+16777216
   \       0x78   0x2700             MOVEQ    R7,#+0
   \       0x7A   0xB109             CBZ.N    R1,??TIMER_InitDTI_1
   \       0x7C   0xF04F 0x7100      MOV      R1,#+33554432
   \                     ??TIMER_InitDTI_1: (+1)
   \       0x80   0x431A             ORRS     R2,R3,R2
   \       0x82   0x433A             ORRS     R2,R7,R2
   \       0x84   0x430A             ORRS     R2,R1,R2
   \       0x86   0x7EA9             LDRB     R1,[R5, #+26]
   \       0x88   0xEA42 0x4201      ORR      R2,R2,R1, LSL #+16
   \       0x8C   0x60B2             STR      R2,[R6, #+8]
    322          
    323            if (init->enableFaultSourcePrsSel0) {
   \       0x8E   0xB128             CBZ.N    R0,??TIMER_InitDTI_2
    324              timerPrsConfig(timer, TIMER_INPUT_CHANNEL_DTIFS1, init->faultSourcePrsSel0, true);
   \       0x90   0x7DEA             LDRB     R2,[R5, #+23]
   \       0x92   0x2301             MOVS     R3,#+1
   \       0x94   0x2104             MOVS     R1,#+4
   \       0x96   0x4620             MOV      R0,R4
   \       0x98   0x....'....        BL       timerPrsConfig
    325            }
    326            if (init->enableFaultSourcePrsSel1) {
   \                     ??TIMER_InitDTI_2: (+1)
   \       0x9C   0x7E28             LDRB     R0,[R5, #+24]
   \       0x9E   0xB128             CBZ.N    R0,??TIMER_InitDTI_3
    327              timerPrsConfig(timer, TIMER_INPUT_CHANNEL_DTIFS2, init->faultSourcePrsSel1, true);
   \       0xA0   0x7E6A             LDRB     R2,[R5, #+25]
   \       0xA2   0x2301             MOVS     R3,#+1
   \       0xA4   0x2105             MOVS     R1,#+5
   \       0xA6   0x4620             MOV      R0,R4
   \       0xA8   0x....'....        BL       timerPrsConfig
    328            }
    329          
    330            timer->EN_SET = TIMER_EN_EN;
   \                     ??TIMER_InitDTI_3: (+1)
   \       0xAC   0x2101             MOVS     R1,#+1
   \       0xAE   0xF241 0x0230      MOVW     R2,#+4144
   \       0xB2   0x50A1             STR      R1,[R4, R2]
    331          #endif
    332          
    333          #if defined(TIMER_DTCTRL_DTDAS)
    334            /* Set up the DTCTRL register.
    335               The enable bit will be set at the end of the function if specified. */
    336            timer->DTCTRL =
    337              (init->autoRestart              ?   TIMER_DTCTRL_DTDAS   : 0)
    338              | (init->activeLowOut           ?   TIMER_DTCTRL_DTIPOL  : 0)
    339              | (init->invertComplementaryOut ?   TIMER_DTCTRL_DTCINV  : 0)
    340              | (init->enablePrsSource        ?   TIMER_DTCTRL_DTPRSEN : 0)
    341              | ((uint32_t)(init->prsSel)     << _TIMER_DTCTRL_DTPRSSEL_SHIFT);
    342          #endif
    343          
    344          #if defined (TIMER_DTCFG_DTDAS)
    345            timer->DTCTRL = (init->activeLowOut             ? TIMER_DTCTRL_DTIPOL  : 0)
    346                            | (init->invertComplementaryOut ? TIMER_DTCTRL_DTCINV  : 0);
   \       0xB4   0x7868             LDRB     R0,[R5, #+1]
   \       0xB6   0xB100             CBZ.N    R0,??TIMER_InitDTI_4
   \       0xB8   0x2002             MOVS     R0,#+2
   \                     ??TIMER_InitDTI_4: (+1)
   \       0xBA   0x78A9             LDRB     R1,[R5, #+2]
   \       0xBC   0xB101             CBZ.N    R1,??TIMER_InitDTI_5
   \       0xBE   0x2101             MOVS     R1,#+1
   \                     ??TIMER_InitDTI_5: (+1)
   \       0xC0   0x4308             ORRS     R0,R1,R0
   \       0xC2   0x60F0             STR      R0,[R6, #+12]
    347          #endif
    348          
    349          #if defined (_TIMER_DTTIME_DTPRESC_SHIFT)
    350            /* Set up the DTTIME register. */
    351            timer->DTTIME = ((uint32_t)init->prescale   << _TIMER_DTTIME_DTPRESC_SHIFT)
    352                            | ((uint32_t)init->riseTime << _TIMER_DTTIME_DTRISET_SHIFT)
    353                            | ((uint32_t)init->fallTime << _TIMER_DTTIME_DTFALLT_SHIFT);
    354          #endif
    355          
    356          #if defined (TIMER_DTFC_DTLOCKUPFEN)
    357            /* Set up the DTFC register. */
    358            timer->DTFC =
    359              (init->enableFaultSourceCoreLockup    ?   TIMER_DTFC_DTLOCKUPFEN : 0)
    360              | (init->enableFaultSourceDebugger    ?   TIMER_DTFC_DTDBGFEN    : 0)
    361              | (init->enableFaultSourcePrsSel0     ?   TIMER_DTFC_DTPRS0FEN   : 0)
    362              | (init->enableFaultSourcePrsSel1     ?   TIMER_DTFC_DTPRS1FEN   : 0)
    363              | ((uint32_t)init->faultAction        << _TIMER_DTFC_DTFA_SHIFT)
    364              | ((uint32_t)init->faultSourcePrsSel0 << _TIMER_DTFC_DTPRS0FSEL_SHIFT)
    365              | ((uint32_t)init->faultSourcePrsSel1 << _TIMER_DTFC_DTPRS1FSEL_SHIFT);
    366          #endif
    367          
    368            /* Set up the DTOGEN register. */
    369            timer->DTOGEN = init->outputsEnableMask;
   \       0xC4   0x6928             LDR      R0,[R5, #+16]
   \       0xC6   0x6130             STR      R0,[R6, #+16]
    370          
    371            /* Clear any previous DTI faults.  */
    372            TIMER_ClearDTIFault(timer, TIMER_GetDTIFault(timer));
   \       0xC8   0x6970             LDR      R0,[R6, #+20]
   \       0xCA   0x6B21             LDR      R1,[R4, #+48]
   \       0xCC   0x61B0             STR      R0,[R6, #+24]
    373          
    374            /* Enable/disable before returning. */
    375            TIMER_EnableDTI(timer, init->enable);
   \       0xCE   0x7829             LDRB     R1,[R5, #+0]
   \       0xD0   0x4620             MOV      R0,R4
   \       0xD2   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \       0xD6   0x....             B.N      TIMER_EnableDTI
    376          }
    377          #endif
    378          
    379          /***************************************************************************//**
    380           * @brief
    381           *   Reset the TIMER to the same state that it was in after a hardware reset.
    382           *
    383           * @note
    384           *   The ROUTE register is NOT reset by this function to allow for
    385           *   a centralized setup of this feature.
    386           *
    387           * @param[in] timer
    388           *   A pointer to the TIMER peripheral register block.
    389           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    390          void TIMER_Reset(TIMER_TypeDef *timer)
    391          {
   \                     TIMER_Reset: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
    392            int i;
    393          
    394            EFM_ASSERT(TIMER_REF_VALID(timer));
   \        0x4   0x....'....        BL       TIMER_Valid
    395          
    396            /* Make sure disabled first, before resetting other registers. */
    397            timer->CMD = TIMER_CMD_STOP;
   \        0x8   0x2002             MOVS     R0,#+2
   \        0xA   0x60E0             STR      R0,[R4, #+12]
    398          
    399            timer->CTRL = _TIMER_CTRL_RESETVALUE;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x60A1             STR      R1,[R4, #+8]
    400            timer->IEN  = _TIMER_IEN_RESETVALUE;
   \       0x10   0x2000             MOVS     R0,#+0
    401          #if defined (TIMER_HAS_SET_CLEAR)
    402            timer->IF_CLR = _TIMER_IF_MASK;
   \       0x12   0xF242 0x0114      MOVW     R1,#+8212
   \       0x16   0x61A0             STR      R0,[R4, #+24]
   \       0x18   0x1865             ADDS     R5,R4,R1
   \       0x1A   0x....             LDR.N    R2,??DataTable2_5  ;; 0x7770077
   \       0x1C   0x602A             STR      R2,[R5, #+0]
    403          #else
    404            timer->IFC  = _TIMER_IFC_MASK;
    405          #endif
    406            timer->TOPB = _TIMER_TOPB_RESETVALUE;
   \       0x1E   0x6220             STR      R0,[R4, #+32]
    407            /* Write TOP after TOPB to invalidate TOPB (clear TIMER_STATUS_TOPBV). */
    408            timer->TOP  = _TIMER_TOP_RESETVALUE;
   \       0x20   0xF64F 0x71FF      MOVW     R1,#+65535
   \       0x24   0x61E1             STR      R1,[R4, #+28]
    409            timer->CNT  = _TIMER_CNT_RESETVALUE;
   \       0x26   0x6260             STR      R0,[R4, #+36]
    410            /* Do not reset the route register, setting should be done independently. */
    411            /* Note: The ROUTE register may be locked by the DTLOCK register. */
    412          
    413            for (i = 0; TIMER_CH_VALID(i); i++) {
   \       0x28   0x2300             MOVS     R3,#+0
   \       0x2A   0x2200             MOVS     R2,#+0
    414              timer->CC[i].CTRL = _TIMER_CC_CTRL_RESETVALUE;
   \                     ??TIMER_Reset_0: (+1)
   \       0x2C   0xEB04 0x1140      ADD      R1,R4,R0, LSL #+5
    415          #if defined (_TIMER_CC_CCV_RESETVALUE) && defined (_TIMER_CC_CCVB_RESETVALUE)
    416              timer->CC[i].CCV  = _TIMER_CC_CCV_RESETVALUE;
    417              timer->CC[i].CCVB = _TIMER_CC_CCVB_RESETVALUE;
    418          #endif
    419          #if defined (_TIMER_CC_OC_RESETVALUE) && defined (_TIMER_CC_OCB_RESETVALUE) \
    420              && defined (_TIMER_CC_ICF_RESETVALUE) && defined (_TIMER_CC_ICOF_RESETVALUE)
    421              timer->CC[i].OC     = _TIMER_CC_OC_RESETVALUE;
    422              timer->CC[i].OCB    = _TIMER_CC_OCB_RESETVALUE;
    423          #endif
    424            }
   \       0x30   0x1C40             ADDS     R0,R0,#+1
   \       0x32   0x2803             CMP      R0,#+3
   \       0x34   0x664A             STR      R2,[R1, #+100]
   \       0x36   0x668B             STR      R3,[R1, #+104]
   \       0x38   0x670A             STR      R2,[R1, #+112]
   \       0x3A   0xDBF7             BLT.N    ??TIMER_Reset_0
    425          
    426            /* Reset dead time insertion module, which has no effect on timers without DTI. */
    427          #if defined(_TIMER_DTCFG_MASK)
    428            timer->DTLOCK   = TIMER_DTLOCK_DTILOCKKEY_UNLOCK;
   \       0x3C   0xF104 0x06E0      ADD      R6,R4,#+224
   \       0x40   0xF64C 0x6080      MOVW     R0,#+52864
   \       0x44   0x61F0             STR      R0,[R6, #+28]
    429            timer->DTCTRL   = _TIMER_DTCTRL_RESETVALUE;
   \       0x46   0x60F2             STR      R2,[R6, #+12]
    430            timer->DTOGEN   = _TIMER_DTOGEN_RESETVALUE;
   \       0x48   0x6132             STR      R2,[R6, #+16]
    431            timer->DTFAULTC = _TIMER_DTFAULTC_MASK;
   \       0x4A   0x211F             MOVS     R1,#+31
   \       0x4C   0x61B1             STR      R1,[R6, #+24]
    432          #elif defined(TIMER_DTLOCK_LOCKKEY_UNLOCK)
    433            /* Unlock DTI registers first if locked. */
    434            timer->DTLOCK   = TIMER_DTLOCK_LOCKKEY_UNLOCK;
    435            timer->DTCTRL   = _TIMER_DTCTRL_RESETVALUE;
    436            timer->DTTIME   = _TIMER_DTTIME_RESETVALUE;
    437            timer->DTFC     = _TIMER_DTFC_RESETVALUE;
    438            timer->DTOGEN   = _TIMER_DTOGEN_RESETVALUE;
    439            timer->DTFAULTC = _TIMER_DTFAULTC_MASK;
    440          #endif
    441          
    442          #if defined(_TIMER_CFG_MASK)
    443            TIMER_SyncWait(timer);
   \       0x4E   0x4620             MOV      R0,R4
   \       0x50   0x....'....        BL       TIMER_SyncWait
    444            /* CFG registers must be reset after the timer is disabled */
    445            timer->EN_CLR = TIMER_EN_EN;
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0x61E8             STR      R0,[R5, #+28]
    446            timer->CFG = _TIMER_CFG_RESETVALUE;
   \       0x58   0x2100             MOVS     R1,#+0
   \       0x5A   0x6061             STR      R1,[R4, #+4]
    447            for (i = 0; TIMER_CH_VALID(i); i++) {
   \       0x5C   0x2000             MOVS     R0,#+0
    448              timer->CC[i].CFG = _TIMER_CC_CFG_RESETVALUE;
   \                     ??TIMER_Reset_1: (+1)
   \       0x5E   0xEB04 0x1240      ADD      R2,R4,R0, LSL #+5
    449            }
   \       0x62   0x1C40             ADDS     R0,R0,#+1
   \       0x64   0x2803             CMP      R0,#+3
   \       0x66   0x6611             STR      R1,[R2, #+96]
   \       0x68   0xDBF9             BLT.N    ??TIMER_Reset_1
    450            timer->DTCFG = _TIMER_DTCFG_RESETVALUE;
   \       0x6A   0x6031             STR      R1,[R6, #+0]
    451            timer->DTFCFG = _TIMER_DTFCFG_RESETVALUE;
   \       0x6C   0x60B1             STR      R1,[R6, #+8]
    452            timer->DTTIMECFG = _TIMER_DTTIMECFG_RESETVALUE;
   \       0x6E   0x6071             STR      R1,[R6, #+4]
    453          #endif
    454          }
   \       0x70   0xBD70             POP      {R4-R6,PC}       ;; return
    455          
    456          #if defined(TIMER_STATUS_SYNCBUSY)
    457          /**
    458           * @brief Wait for pending synchronization to finish
    459           *
    460           * @param[in] timer
    461           */

   \                                 In section .text, align 2, keep-with-next
    462          void TIMER_SyncWait(TIMER_TypeDef * timer)
    463          {
    464            while (((timer->EN & TIMER_EN_EN) != 0U)
    465                   && ((timer->STATUS & TIMER_STATUS_SYNCBUSY) != 0U)) {
   \                     TIMER_SyncWait: (+1)
   \                     ??TIMER_SyncWait_0: (+1)
   \        0x0   0x6B01             LDR      R1,[R0, #+48]
   \        0x2   0x07CA             LSLS     R2,R1,#+31
   \        0x4   0xD502             BPL.N    ??TIMER_SyncWait_1
   \        0x6   0x6901             LDR      R1,[R0, #+16]
   \        0x8   0x064A             LSLS     R2,R1,#+25
   \        0xA   0xD4F9             BMI.N    ??TIMER_SyncWait_0
    466              /* Wait for synchronization to complete */
    467            }
    468          }
   \                     ??TIMER_SyncWait_1: (+1)
   \        0xC   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x4004'8000        DC32     0x40048000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x4004'C000        DC32     0x4004c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x4005'0000        DC32     0x40050000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x4005'4000        DC32     0x40054000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0x4003'8104        DC32     0x40038104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \        0x0   0x0777'0077        DC32     0x7770077
    469          #endif
    470          
    471          /** @} (end addtogroup TIMER) */
    472          /** @} (end addtogroup emlib) */
    473          #endif /* defined(TIMER_COUNT) && (TIMER_COUNT > 0) */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   TIMER_EnableDTI
        16   -> TIMER_SyncWait
      24   TIMER_Init
        24   -> TIMER_SyncWait
        24   -> TIMER_Valid
      24   TIMER_InitCC
        24   -> TIMER_SyncWait
        24   -> TIMER_Valid
        24   -> timerPrsConfig
      24   TIMER_InitDTI
         0   -> TIMER_EnableDTI
        24   -> TIMER_EnableDTI
        24   -> TIMER_SyncWait
        24   -> timerPrsConfig
      16   TIMER_Reset
        16   -> TIMER_SyncWait
        16   -> TIMER_Valid
       0   TIMER_SyncWait
       0   TIMER_Valid
      12   timerPrsConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
      50  TIMER_EnableDTI
     172  TIMER_Init
     150  TIMER_InitCC
     216  TIMER_InitDTI
     114  TIMER_Reset
      14  TIMER_SyncWait
      32  TIMER_Valid
      52  timerPrsConfig

 
 824 bytes in section .text
 
 824 bytes of CODE memory

Errors: none
Warnings: none
