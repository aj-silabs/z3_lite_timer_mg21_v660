###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:20
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\micro\cortexm3\efm32\button.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EWD769.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\micro\cortexm3\efm32\button.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"button.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0 -D
#        LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D EMBER_AF_USE_HWCONF
#        -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\button.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\button.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\micro\cortexm3\efm32\button.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief  Sample API functions for operating buttons (external interrupts).
      4           *  Please see the board header file for the definition of the BUTTON*
      5           *  instances used below.  The BUTTON* defines used here are designed to make
      6           *  this library generic such that only the board header needs to be modified
      7           *  to change which GPIO the buttons are on.
      8           *******************************************************************************
      9           * # License
     10           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
     11           *******************************************************************************
     12           *
     13           * The licensor of this software is Silicon Laboratories Inc. Your use of this
     14           * software is governed by the terms of Silicon Labs Master Software License
     15           * Agreement (MSLA) available at
     16           * www.silabs.com/about-us/legal/master-software-license-agreement. This
     17           * software is distributed to you in Source Code format and is governed by the
     18           * sections of the MSLA applicable to Source Code.
     19           *
     20           ******************************************************************************/
     21          #include PLATFORM_HEADER
     22          #include "stack/include/ember.h"
     23          #include "hal/hal.h"
     24          #include "serial/serial.h"
     25          
     26          #include "em_cmu.h"
     27          #include "em_gpio.h"
     28          #include "gpiointerrupt.h"
     29          
     30          // This state is kept track of so the IRQ ISRs knows when to notify buttonIsrs.
     31          #if (HAL_BUTTON_COUNT > 0)

   \                                 In section .bss, align 2
     32          static uint8_t buttonState[BSP_BUTTON_COUNT];
   \                     buttonState:
   \        0x0                      DS8 2
     33          void halInternalButtonIsr(uint8_t pin);
     34          typedef struct {
     35            GPIO_Port_TypeDef   port;
     36            unsigned int        pin;
     37          } tButtonArray;

   \                                 In section .rodata, align 4
     38          static const tButtonArray buttonArray[BSP_BUTTON_COUNT] = BSP_BUTTON_INIT;
   \                     buttonArray:
   \        0x0   0x03 0x00          DC8 3, 0, 0, 0
   \              0x00 0x00    
   \        0x4   0x0000'0002        DC32 2
   \        0x8   0x03 0x00          DC8 3, 0, 0, 0
   \              0x00 0x00    
   \        0xC   0x0000'0003        DC32 3
     39          #endif
     40          
     41          #define HAL_BUTTON_INVALID_INDEX BSP_BUTTON_COUNT
     42          #if (HAL_BUTTON_COUNT > 0)

   \                                 In section .text, align 2, keep-with-next
     43          static uint8_t halInternalButtonIndex(uint8_t pin)
     44          {
   \                     halInternalButtonIndex: (+1)
   \        0x0   0x4601             MOV      R1,R0
   \        0x2   0xB510             PUSH     {R4,LR}
     45            uint8_t i;
     46            for ( i = 0; i < BSP_BUTTON_COUNT; i++ ) {
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x....             LDR.N    R2,??DataTable5
     47              if (buttonArray[i].pin == pin) {
   \                     ??halInternalButtonIndex_0: (+1)
   \        0x8   0xB2C3             UXTB     R3,R0
   \        0xA   0xEB02 0x03C3      ADD      R3,R2,R3, LSL #+3
   \        0xE   0x685C             LDR      R4,[R3, #+4]
   \       0x10   0x428C             CMP      R4,R1
   \       0x12   0xD003             BEQ.N    ??halInternalButtonIndex_1
     48                break;
     49              }
     50            }
   \       0x14   0x1C40             ADDS     R0,R0,#+1
   \       0x16   0xB2C3             UXTB     R3,R0
   \       0x18   0x2B02             CMP      R3,#+2
   \       0x1A   0xD3F5             BCC.N    ??halInternalButtonIndex_0
     51            return i;
   \                     ??halInternalButtonIndex_1: (+1)
   \       0x1C   0xB2C0             UXTB     R0,R0
   \       0x1E   0xBD10             POP      {R4,PC}          ;; return
     52          }
     53          #endif
     54          

   \                                 In section .text, align 2, keep-with-next
     55          void halInternalInitButton(void)
     56          {
   \                     halInternalInitButton: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
     57          #if (HAL_BUTTON_COUNT > 0)
     58            uint8_t enableButtons[HAL_BUTTON_COUNT] = HAL_BUTTON_ENABLE;
   \        0x4   0x....             LDR.N    R0,??DataTable5_1
   \        0x6   0x8800             LDRH     R0,[R0, #+0]
   \        0x8   0x2400             MOVS     R4,#+0
   \        0xA   0x....'....        ADR.W    R8,halInternalButtonIsr
   \        0xE   0xF8AD 0x0008      STRH     R0,[SP, #+8]
     59            /* Initialize GPIO interrupt dispatcher */
     60            GPIOINT_Init();
   \       0x12   0x....'....        BL       GPIOINT_Init
     61          
     62            /* Enable GPIO in CMU */
     63          #if !defined(_SILICON_LABS_32B_SERIES_2)
     64            CMU_ClockEnable(cmuClock_HFPER, true);
     65            CMU_ClockEnable(cmuClock_GPIO, true);
     66          #endif
     67          
     68            uint8_t i;
     69            for ( i = 0; i < HAL_BUTTON_COUNT; i++ ) {
   \       0x16   0x....'....        LDR.W    R9,??DataTable5
   \       0x1A   0xAE02             ADD      R6,SP,#+8
     70              /* Configure pin as input */
     71              GPIO_PinModeSet(buttonArray[enableButtons[i]].port,
     72                              buttonArray[enableButtons[i]].pin,
     73                              BSP_BUTTON_GPIO_MODE,
     74                              BSP_BUTTON_GPIO_DOUT);
   \                     ??halInternalInitButton_0: (+1)
   \       0x1C   0x5D37             LDRB     R7,[R6, R4]
   \       0x1E   0x2300             MOVS     R3,#+0
   \       0x20   0x2201             MOVS     R2,#+1
   \       0x22   0xEB09 0x05C7      ADD      R5,R9,R7, LSL #+3
   \       0x26   0x6869             LDR      R1,[R5, #+4]
   \       0x28   0xF819 0x0037      LDRB     R0,[R9, R7, LSL #+3]
   \       0x2C   0x1C64             ADDS     R4,R4,#+1
   \       0x2E   0x....'....        BL       GPIO_PinModeSet
     75              /* Register callbacks before setting up and enabling pin interrupt. */
     76              GPIOINT_CallbackRegister(buttonArray[enableButtons[i]].pin,
     77                                       halInternalButtonIsr);
   \       0x32   0x686D             LDR      R5,[R5, #+4]
   \       0x34   0x4641             MOV      R1,R8
   \       0x36   0xB2E8             UXTB     R0,R5
   \       0x38   0x....'....        BL       GPIOINT_CallbackRegister
     78              /* Set rising and falling edge interrupts */
     79              GPIO_ExtIntConfig(buttonArray[enableButtons[i]].port,
     80                                buttonArray[enableButtons[i]].pin,
     81                                buttonArray[enableButtons[i]].pin,
     82                                true,
     83                                true,
     84                                true);
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0x9001             STR      R0,[SP, #+4]
   \       0x40   0x9000             STR      R0,[SP, #+0]
   \       0x42   0xF819 0x0037      LDRB     R0,[R9, R7, LSL #+3]
   \       0x46   0x2301             MOVS     R3,#+1
   \       0x48   0x462A             MOV      R2,R5
   \       0x4A   0x4629             MOV      R1,R5
   \       0x4C   0x....'....        BL       GPIO_ExtIntConfig
     85            }
   \       0x50   0x2C01             CMP      R4,#+1
   \       0x52   0xD9E3             BLS.N    ??halInternalInitButton_0
     86          #endif
     87          }
   \       0x54   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
     88          

   \                                 In section .text, align 2, keep-with-next
     89          uint8_t halButtonState(uint8_t button)
     90          {
   \                     halButtonState: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
     91            // Note: this returns the "soft" state rather than reading the port
     92            //  so it jives with the interrupts and their callbacks
     93          #if (HAL_BUTTON_COUNT > 0)
     94            uint8_t index = halInternalButtonIndex(button);
   \        0x2   0x....'....        BL       halInternalButtonIndex
     95            if ( index != HAL_BUTTON_INVALID_INDEX ) {
   \        0x6   0x2802             CMP      R0,#+2
   \        0x8   0xD002             BEQ.N    ??halButtonState_0
     96              return buttonState[index];
   \        0xA   0x....             LDR.N    R1,??DataTable5_2
   \        0xC   0x5C08             LDRB     R0,[R1, R0]
   \        0xE   0xBD02             POP      {R1,PC}
     97            }
     98          #endif
     99            // return BUTTON_RELEASED if no matching button was found
    100            return BUTTON_RELEASED;
   \                     ??halButtonState_0: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xBD02             POP      {R1,PC}          ;; return
    101          }
    102          

   \                                 In section .text, align 2, keep-with-next
    103          void halInternalButtonStateSet(uint8_t button, uint8_t state)
    104          {
   \                     halInternalButtonStateSet: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x460C             MOV      R4,R1
    105            // Note: this sets the "soft" state
    106            //  so it jives with the interrupts and their callbacks
    107          #if (HAL_BUTTON_COUNT > 0)
    108            uint8_t index = halInternalButtonIndex(button);
   \        0x4   0x....'....        BL       halInternalButtonIndex
    109            if ( index != HAL_BUTTON_INVALID_INDEX ) {
   \        0x8   0x2802             CMP      R0,#+2
   \        0xA   0xBF1C             ITT      NE 
   \        0xC   0x....             LDRNE.N  R1,??DataTable5_2
   \        0xE   0x540C             STRBNE   R4,[R1, R0]
    110              buttonState[index] = state;
    111            }
    112          #endif
    113          }
   \       0x10   0xBD10             POP      {R4,PC}          ;; return
    114          

   \                                 In section .text, align 2, keep-with-next
    115          void halInternalButtonToggleState(uint8_t button)
    116          {
   \                     halInternalButtonToggleState: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    117            // Note: this toggles the "soft" state
    118            //  so it jives with the interrupts and their callbacks
    119          #if (HAL_BUTTON_COUNT > 0)
    120            uint8_t index = halInternalButtonIndex(button);
   \        0x2   0x....'....        BL       halInternalButtonIndex
    121            if ( index != HAL_BUTTON_INVALID_INDEX ) {
   \        0x6   0x2802             CMP      R0,#+2
   \        0x8   0xD005             BEQ.N    ??halInternalButtonToggleState_0
    122              buttonState[index] = !buttonState[index];
   \        0xA   0x....             LDR.N    R1,??DataTable5_2
   \        0xC   0x5C0A             LDRB     R2,[R1, R0]
   \        0xE   0x1E52             SUBS     R2,R2,#+1
   \       0x10   0x4192             SBCS     R2,R2,R2
   \       0x12   0x0FD2             LSRS     R2,R2,#+31
   \       0x14   0x540A             STRB     R2,[R1, R0]
    123            }
    124          #endif
    125          }
   \                     ??halInternalButtonToggleState_0: (+1)
   \       0x16   0xBD01             POP      {R0,PC}          ;; return
    126          

   \                                 In section .text, align 2, keep-with-next
    127          uint8_t halButtonPinState(uint8_t button)
    128          {
   \                     halButtonPinState: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    129          #if (HAL_BUTTON_COUNT > 0)
    130            uint8_t index = halInternalButtonIndex(button);
   \        0x2   0x....'....        BL       halInternalButtonIndex
   \        0x6   0x4601             MOV      R1,R0
    131            if ( index != HAL_BUTTON_INVALID_INDEX ) {
   \        0x8   0x2902             CMP      R1,#+2
   \        0xA   0xD010             BEQ.N    ??halButtonPinState_0
    132              return (GPIO_PinInGet(buttonArray[index].port, buttonArray[index].pin)) ? BUTTON_RELEASED : BUTTON_PRESSED;
   \        0xC   0x....             LDR.N    R2,??DataTable5
   \        0xE   0xF812 0x4031      LDRB     R4,[R2, R1, LSL #+3]
   \       0x12   0x2030             MOVS     R0,#+48
   \       0x14   0x....             LDR.N    R3,??DataTable5_3  ;; 0x4003c000
   \       0x16   0x4344             MULS     R4,R0,R4
    133            }
   \       0x18   0xEB02 0x01C1      ADD      R1,R2,R1, LSL #+3
   \       0x1C   0x1918             ADDS     R0,R3,R4
   \       0x1E   0x6940             LDR      R0,[R0, #+20]
   \       0x20   0x684A             LDR      R2,[R1, #+4]
   \       0x22   0x40D0             LSRS     R0,R0,R2
   \       0x24   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x28   0xF080 0x0001      EOR      R0,R0,#0x1
   \       0x2C   0xBD10             POP      {R4,PC}
    134          #endif
    135            return BUTTON_RELEASED;
   \                     ??halButtonPinState_0: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xBD10             POP      {R4,PC}          ;; return
    136          }
    137          
    138          //DEBOUNCE operation is based upon the theory that when multiple reads in a row
    139          //return the same value, we have passed any debounce created by the mechanical
    140          //action of a button.  The define "DEBOUNCE" says how many reads in a row
    141          //should return the same value.  The value '5', below, is the recommended value
    142          //since this should require the signal to have stabalized for approximately
    143          //100us which should be much longer than any debounce action.
    144          //Uncomment the following line to enable software debounce operation:
    145          //#define DEBOUNCE 5
    146          
    147          //Typically, software debounce is disabled by defaulting to a value of '0'
    148          //which will cause the preprocessor to strip out the debounce code and save
    149          //flash space.
    150          #ifndef DEBOUNCE
    151          #define DEBOUNCE 5
    152          #endif//DEBOUNCE
    153          
    154          #if (HAL_BUTTON_COUNT > 0)

   \                                 In section .text, align 4, keep-with-next
    155          void halInternalButtonIsr(uint8_t pin)
    156          {
   \                     halInternalButtonIsr: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
    157            uint8_t buttonStateNow;
    158            #if (DEBOUNCE > 0)
    159            uint8_t buttonStatePrev;
    160            uint32_t debounce;
    161            #endif //(DEBOUNCE > 0)
    162          
    163            buttonStateNow = halButtonPinState(pin);
   \        0x4   0x....'....        BL       halButtonPinState
   \        0x8   0x4605             MOV      R5,R0
    164            #if (DEBOUNCE > 0)
    165            //read button until get "DEBOUNCE" number of consistent readings
    166            for ( debounce = 0;
   \                     ??halInternalButtonIsr_0: (+1)
   \        0xA   0x2600             MOVS     R6,#+0
    167                  debounce < DEBOUNCE;
    168                  debounce = (buttonStateNow == buttonStatePrev) ? debounce + 1 : 0 ) {
    169              buttonStatePrev = buttonStateNow;
    170              buttonStateNow = halButtonPinState(pin);
   \                     ??halInternalButtonIsr_1: (+1)
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x462F             MOV      R7,R5
   \       0x10   0x....'....        BL       halButtonPinState
   \       0x14   0x4605             MOV      R5,R0
    171            }
   \       0x16   0x42B8             CMP      R0,R7
   \       0x18   0xD1F7             BNE.N    ??halInternalButtonIsr_0
   \       0x1A   0x1C76             ADDS     R6,R6,#+1
   \       0x1C   0x2E05             CMP      R6,#+5
   \       0x1E   0xD3F5             BCC.N    ??halInternalButtonIsr_1
    172            #endif //(DEBOUNCE > 0)
    173          
    174            if (halButtonState(pin) != buttonStateNow) { //state changed, notify app
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0x....'....        BL       halButtonState
   \       0x26   0x4629             MOV      R1,R5
   \       0x28   0x4288             CMP      R0,R1
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0xD002             BEQ.N    ??halInternalButtonIsr_2
    175              halInternalButtonStateSet(pin, buttonStateNow);
   \       0x2E   0x....'....        BL       halInternalButtonStateSet
    176              halButtonIsr(pin, halButtonState(pin));
   \       0x32   0xE00B             B.N      ??halInternalButtonIsr_3
    177            } else {  //state unchanged, then notify app of a double-transition
    178              halInternalButtonToggleState(pin); //invert temporarily for calling Isr
   \                     ??halInternalButtonIsr_2: (+1)
   \       0x34   0x....'....        BL       halInternalButtonToggleState
    179              halButtonIsr(pin, halButtonState(pin));
   \       0x38   0x4620             MOV      R0,R4
   \       0x3A   0x....'....        BL       halButtonState
   \       0x3E   0x4601             MOV      R1,R0
   \       0x40   0x4620             MOV      R0,R4
   \       0x42   0x....'....        BL       halButtonIsr
    180              halInternalButtonToggleState(pin); //and put it back to current state
   \       0x46   0x4620             MOV      R0,R4
   \       0x48   0x....'....        BL       halInternalButtonToggleState
    181              halButtonIsr(pin, halButtonState(pin));
   \                     ??halInternalButtonIsr_3: (+1)
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0x....'....        BL       halButtonState
   \       0x52   0x4601             MOV      R1,R0
   \       0x54   0x4620             MOV      R0,R4
   \       0x56   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \       0x5A   0x....'....        B.W      halButtonIsr
    182            }
    183          }
    184          

   \                                 In section .text, align 2
    185          WEAK(void halButtonIsr(uint8_t button, uint8_t state)
    186          {
    187          })
   \                     halButtonIsr: (+1)
   \        0x0   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x....'....        DC32     buttonArray

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0x....'....        DC32     buttonState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \        0x0   0x4003'C000        DC32     0x4003c000

   \                                 In section .rodata, align 2
   \                     ?_0:
   \        0x0   0x00 0x01          DC8 0, 1
    188          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   halButtonIsr
       8   halButtonPinState
         8   -> halInternalButtonIndex
       8   halButtonState
         8   -> halInternalButtonIndex
       8   halInternalButtonIndex
      24   halInternalButtonIsr
         0   -> halButtonIsr
        24   -> halButtonIsr
        24   -> halButtonPinState
        24   -> halButtonState
        24   -> halInternalButtonStateSet
        24   -> halInternalButtonToggleState
       8   halInternalButtonStateSet
         8   -> halInternalButtonIndex
       8   halInternalButtonToggleState
         8   -> halInternalButtonIndex
      40   halInternalInitButton
        40   -> GPIOINT_CallbackRegister
        40   -> GPIOINT_Init
        40   -> GPIO_ExtIntConfig
        40   -> GPIO_PinModeSet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       2  ?_0
      16  buttonArray
       2  buttonState
       2  halButtonIsr
      50  halButtonPinState
      20  halButtonState
      32  halInternalButtonIndex
      94  halInternalButtonIsr
      18  halInternalButtonStateSet
      24  halInternalButtonToggleState
      88  halInternalInitButton

 
   2 bytes in section .bss
  18 bytes in section .rodata
 344 bytes in section .text
 
 342 bytes of CODE  memory (+ 2 bytes shared)
  18 bytes of CONST memory
   2 bytes of DATA  memory

Errors: none
Warnings: none
