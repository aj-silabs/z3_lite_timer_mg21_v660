###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:19:48
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\plugin\debug\rtt\SEGGER_RTT.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW3165.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\plugin\debug\rtt\SEGGER_RTT.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"SEGGER_RTT.c\"" -D PSSTORE_SIZE=0 -D
#        LONGTOKEN_SIZE=0 -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\plugin\debug\rtt\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\SEGGER_RTT.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\SEGGER_RTT.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\plugin\debug\rtt\SEGGER_RTT.c
      1          /*********************************************************************
      2           *               SEGGER MICROCONTROLLER GmbH & Co. KG                 *
      3           *       Solutions for real time microcontroller applications         *
      4           **********************************************************************
      5           *                                                                    *
      6           *       (c) 2014 - 2016  SEGGER Microcontroller GmbH & Co. KG        *
      7           *                                                                    *
      8           *       www.segger.com     Support: support@segger.com               *
      9           *                                                                    *
     10           **********************************************************************
     11           *                                                                    *
     12           *       SEGGER RTT * Real Time Transfer for embedded targets         *
     13           *                                                                    *
     14           **********************************************************************
     15           *                                                                    *
     16           * All rights reserved.                                               *
     17           *                                                                    *
     18           * * This software may in its unmodified form be freely redistributed *
     19           *   in source, linkable, or executable form.                         *
     20           * * The source code may be modified, provided the source code        *
     21           *   retains the above copyright notice, this list of conditions and  *
     22           *   the following disclaimer.                                        *
     23           * * Modified versions of this software in source, executable, or     *
     24           *   linkable form may not be distributed without prior consent of    *
     25           *   SEGGER.                                                          *
     26           * * This software may only be used for communication with SEGGER     *
     27           *   J-Link debug probes.                                             *
     28           *                                                                    *
     29           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND             *
     30           * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,        *
     31           * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF           *
     32           * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           *
     33           * DISCLAIMED. IN NO EVENT SHALL SEGGER Microcontroller BE LIABLE FOR *
     34           * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR           *
     35           * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  *
     36           * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;    *
     37           * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF      *
     38           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT          *
     39           * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  *
     40           * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH   *
     41           * DAMAGE.                                                            *
     42           *                                                                    *
     43           **********************************************************************
     44           *                                                                    *
     45           *       RTT version: 6.00d                                           *
     46           *                                                                    *
     47           **********************************************************************
     48           *    ---------------------------END-OF-HEADER------------------------------
     49           *    File    : SEGGER_RTT.c
     50           *    Purpose : Implementation of SEGGER real-time transfer (RTT) which
     51           *           allows real-time communication on targets which support
     52           *           debugger memory accesses while the CPU is running.
     53           *    Revision: $Rev: 3882 $
     54           *
     55           *    Additional information:
     56           *           Type "int" is assumed to be 32-bits in size
     57           *           H->T    Host to target communication
     58           *           T->H    Target to host communication
     59           *
     60           *           RTT channel 0 is always present and reserved for Terminal usage.
     61           *           Name is fixed to "Terminal"
     62           *
     63           *           Effective buffer size: SizeOfBuffer - 1
     64           *
     65           *           WrOff == RdOff:       Buffer is empty
     66           *           WrOff == (RdOff - 1): Buffer is full
     67           *           WrOff >  RdOff:       Free space includes wrap-around
     68           *           WrOff <  RdOff:       Used space includes wrap-around
     69           *           (WrOff == (SizeOfBuffer - 1)) && (RdOff == 0):
     70           *                                 Buffer full and wrap-around after next byte
     71           *
     72           *
     73           *    ----------------------------------------------------------------------
     74           */
     75          
     76          #include "SEGGER_RTT.h"
     77          
     78          #include <string.h>                 // for memcpy
     79          
     80          /*********************************************************************
     81           *
     82           *       Configuration, default values
     83           *
     84           **********************************************************************
     85           */
     86          
     87          #ifndef   BUFFER_SIZE_UP
     88            #define BUFFER_SIZE_UP                                  1024  // Size of the buffer for terminal output of target, up to host
     89          #endif
     90          
     91          #ifndef   BUFFER_SIZE_DOWN
     92            #define BUFFER_SIZE_DOWN                                16    // Size of the buffer for terminal input to target from host (Usually keyboard input)
     93          #endif
     94          
     95          #ifndef   SEGGER_RTT_MAX_NUM_UP_BUFFERS
     96            #define SEGGER_RTT_MAX_NUM_UP_BUFFERS                    2    // Number of up-buffers (T->H) available on this target
     97          #endif
     98          
     99          #ifndef   SEGGER_RTT_MAX_NUM_DOWN_BUFFERS
    100            #define SEGGER_RTT_MAX_NUM_DOWN_BUFFERS                  2    // Number of down-buffers (H->T) available on this target
    101          #endif
    102          
    103          #ifndef SEGGER_RTT_BUFFER_SECTION
    104            #if defined(SEGGER_RTT_SECTION)
    105              #define SEGGER_RTT_BUFFER_SECTION SEGGER_RTT_SECTION
    106            #endif
    107          #endif
    108          
    109          #ifndef   SEGGER_RTT_ALIGNMENT
    110            #define SEGGER_RTT_ALIGNMENT                            0
    111          #endif
    112          
    113          #ifndef   SEGGER_RTT_BUFFER_ALIGNMENT
    114            #define SEGGER_RTT_BUFFER_ALIGNMENT                     0
    115          #endif
    116          
    117          #ifndef   SEGGER_RTT_MODE_DEFAULT
    118            #define SEGGER_RTT_MODE_DEFAULT                         SEGGER_RTT_MODE_NO_BLOCK_SKIP
    119          #endif
    120          
    121          #ifndef   SEGGER_RTT_LOCK
    122            #define SEGGER_RTT_LOCK()
    123          #endif
    124          
    125          #ifndef   SEGGER_RTT_UNLOCK
    126            #define SEGGER_RTT_UNLOCK()
    127          #endif
    128          
    129          #ifndef   STRLEN
    130            #define STRLEN(a)                                       strlen((a))
    131          #endif
    132          
    133          #ifndef   MEMCPY
    134            #define MEMCPY(pDest, pSrc, NumBytes)                   memcpy((pDest), (pSrc), (NumBytes))
    135          #endif
    136          
    137          #ifndef   MIN
    138            #define MIN(a, b)         (((a) < (b)) ? (a) : (b))
    139          #endif
    140          
    141          #ifndef   MAX
    142            #define MAX(a, b)         (((a) > (b)) ? (a) : (b))
    143          #endif
    144          //
    145          // For some environments, NULL may not be defined until certain headers are included
    146          //
    147          #ifndef NULL
    148            #define NULL 0
    149          #endif
    150          
    151          /*********************************************************************
    152           *
    153           *       Defines, fixed
    154           *
    155           **********************************************************************
    156           */
    157          #if (defined __ICCARM__) || (defined __ICCRX__)
    158            #define RTT_PRAGMA(P) _Pragma(#P)
    159          #endif
    160          
    161          #if SEGGER_RTT_ALIGNMENT || SEGGER_RTT_BUFFER_ALIGNMENT
    162            #if (defined __GNUC__)
    163              #define SEGGER_RTT_ALIGN(Var, Alignment) Var __attribute__ ((aligned(Alignment)))
    164            #elif (defined __ICCARM__) || (defined __ICCRX__)
    165              #define PRAGMA(A) _Pragma(#A)
    166          #define SEGGER_RTT_ALIGN(Var, Alignment) RTT_PRAGMA(data_alignment = Alignment) \
    167            Var
    168            #elif (defined __CC_ARM__)
    169              #define SEGGER_RTT_ALIGN(Var, Alignment) Var __attribute__ ((aligned(Alignment)))
    170            #else
    171              #error "Alignment not supported for this compiler."
    172            #endif
    173          #else
    174            #define SEGGER_RTT_ALIGN(Var, Alignment) Var
    175          #endif
    176          
    177          #if defined(SEGGER_RTT_SECTION) || defined (SEGGER_RTT_BUFFER_SECTION)
    178            #if (defined __GNUC__)
    179              #define SEGGER_RTT_PUT_SECTION(Var, Section) __attribute__ ((section(Section))) Var
    180            #elif (defined __ICCARM__) || (defined __ICCRX__)
    181          #define SEGGER_RTT_PUT_SECTION(Var, Section) RTT_PRAGMA(location = Section) \
    182            Var
    183            #elif (defined __CC_ARM__)
    184              #define SEGGER_RTT_PUT_SECTION(Var, Section) __attribute__ ((section(Section), zero_init))  Var
    185            #else
    186              #error "Section placement not supported for this compiler."
    187            #endif
    188          #else
    189            #define SEGGER_RTT_PUT_SECTION(Var, Section) Var
    190          #endif
    191          
    192          #if SEGGER_RTT_ALIGNMENT
    193            #define SEGGER_RTT_CB_ALIGN(Var)  SEGGER_RTT_ALIGN(Var, SEGGER_RTT_ALIGNMENT)
    194          #else
    195            #define SEGGER_RTT_CB_ALIGN(Var)  Var
    196          #endif
    197          
    198          #if SEGGER_RTT_BUFFER_ALIGNMENT
    199            #define SEGGER_RTT_BUFFER_ALIGN(Var)  SEGGER_RTT_ALIGN(Var, SEGGER_RTT_BUFFER_ALIGNMENT)
    200          #else
    201            #define SEGGER_RTT_BUFFER_ALIGN(Var)  Var
    202          #endif
    203          
    204          #if defined(SEGGER_RTT_SECTION)
    205            #define SEGGER_RTT_PUT_CB_SECTION(Var) SEGGER_RTT_PUT_SECTION(Var, SEGGER_RTT_SECTION)
    206          #else
    207            #define SEGGER_RTT_PUT_CB_SECTION(Var) Var
    208          #endif
    209          
    210          #if defined(SEGGER_RTT_BUFFER_SECTION)
    211            #define SEGGER_RTT_PUT_BUFFER_SECTION(Var) SEGGER_RTT_PUT_SECTION(Var, SEGGER_RTT_BUFFER_SECTION)
    212          #else
    213            #define SEGGER_RTT_PUT_BUFFER_SECTION(Var) Var
    214          #endif
    215          
    216          /*********************************************************************
    217           *
    218           *       Static const data
    219           *
    220           **********************************************************************
    221           */
    222          

   \                                 In section .data, align 4
    223          static unsigned char _aTerminalId[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
   \                     _aTerminalId:
   \        0x0   0x30 0x31          DC8 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70
   \              0x32 0x33    
   \              0x34 0x35    
   \              0x36 0x37    
   \              0x38 0x39    
   \              0x41 0x42    
   \              0x43 0x44    
   \              0x45 0x46    
    224          
    225          /*********************************************************************
    226           *
    227           *       Static data
    228           *
    229           **********************************************************************
    230           */
    231          //
    232          // RTT Control Block and allocate buffers for channel 0
    233          //

   \                                 In section .bss, align 1024
    234          SEGGER_RTT_PUT_CB_SECTION(SEGGER_RTT_CB_ALIGN(SEGGER_RTT_CB _SEGGER_RTT));
   \                     _SEGGER_RTT:
   \        0x0                      DS8 168
    235          

   \                                 In section .bss, align 4
    236          SEGGER_RTT_PUT_BUFFER_SECTION(SEGGER_RTT_BUFFER_ALIGN(static char _acUpBuffer[BUFFER_SIZE_UP]));
   \                     _acUpBuffer:
   \        0x0                      DS8 16

   \                                 In section .bss, align 4
    237          SEGGER_RTT_PUT_BUFFER_SECTION(SEGGER_RTT_BUFFER_ALIGN(static char _acDownBuffer[BUFFER_SIZE_DOWN]));
   \                     _acDownBuffer:
   \        0x0                      DS8 16
    238          

   \                                 In section .bss, align 1
    239          static char _ActiveTerminal;
   \                     _ActiveTerminal:
   \        0x0                      DS8 1
    240          
    241          /*********************************************************************
    242           *
    243           *       Static functions
    244           *
    245           **********************************************************************
    246           */
    247          
    248          /*********************************************************************
    249           *
    250           *       _DoInit()
    251           *
    252           *  Function description
    253           *    Initializes the control block an buffers.
    254           *    May only be called via INIT() to avoid overriding settings.
    255           *
    256           */
    257          #define INIT()  do {                                \
    258              if (_SEGGER_RTT.acID[0] == '\0') { _DoInit(); } \
    259          } while (0)

   \                                 In section .text, align 2, keep-with-next
    260          static void _DoInit(void)
    261          {
   \                     _DoInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    262            SEGGER_RTT_CB* p;
    263            //
    264            // Initialize control block
    265            //
    266            p = &_SEGGER_RTT;
    267            p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
   \        0x2   0x....'....        LDR.W    R4,??DataTable12
   \        0x6   0x2003             MOVS     R0,#+3
   \        0x8   0x6120             STR      R0,[R4, #+16]
    268            p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
   \        0xA   0x6160             STR      R0,[R4, #+20]
    269            //
    270            // Initialize up buffer 0
    271            //
    272            p->aUp[0].sName         = "Terminal";
    273            p->aUp[0].pBuffer       = _acUpBuffer;
   \        0xC   0x....'....        LDR.W    R1,??DataTable12_1
   \       0x10   0x....'....        LDR.W    R0,??DataTable12_2
   \       0x14   0x61E1             STR      R1,[R4, #+28]
    274            p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
   \       0x16   0x2210             MOVS     R2,#+16
   \       0x18   0x61A0             STR      R0,[R4, #+24]
   \       0x1A   0x6222             STR      R2,[R4, #+32]
    275            p->aUp[0].RdOff         = 0u;
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x62A1             STR      R1,[R4, #+40]
    276            p->aUp[0].WrOff         = 0u;
    277            p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   \       0x20   0x62E1             STR      R1,[R4, #+44]
    278            //
    279            // Initialize down buffer 0
    280            //
    281            p->aDown[0].sName         = "Terminal";
   \       0x22   0x6620             STR      R0,[R4, #+96]
   \       0x24   0x2200             MOVS     R2,#+0
    282            p->aDown[0].pBuffer       = _acDownBuffer;
   \       0x26   0x....'....        LDR.W    R0,??DataTable12_3
    283            p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
   \       0x2A   0x2110             MOVS     R1,#+16
   \       0x2C   0x6262             STR      R2,[R4, #+36]
   \       0x2E   0x6660             STR      R0,[R4, #+100]
   \       0x30   0x66A1             STR      R1,[R4, #+104]
    284            p->aDown[0].RdOff         = 0u;
   \       0x32   0x6722             STR      R2,[R4, #+112]
    285            p->aDown[0].WrOff         = 0u;
   \       0x34   0x66E2             STR      R2,[R4, #+108]
    286            p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
   \       0x36   0x6762             STR      R2,[R4, #+116]
    287            //
    288            // Finish initialization of the control block.
    289            // Copy Id string in three steps to make sure "SEGGER RTT" is not found
    290            // in initializer memory (usually flash) by J-Link
    291            //
    292            (void) strcpy(&p->acID[7], "RTT");
   \       0x38   0x....'....        LDR.W    R1,??DataTable12_4
   \       0x3C   0x1DE0             ADDS     R0,R4,#+7
   \       0x3E   0x....'....        BL       strcpy
    293            (void) strcpy(&p->acID[0], "SEGGER");
   \       0x42   0x....'....        LDR.W    R1,??DataTable12_5
   \       0x46   0x4620             MOV      R0,R4
   \       0x48   0x....'....        BL       strcpy
    294            p->acID[6] = ' ';
   \       0x4C   0x2020             MOVS     R0,#+32
   \       0x4E   0x71A0             STRB     R0,[R4, #+6]
    295          }
   \       0x50   0xBD10             POP      {R4,PC}          ;; return
    296          
    297          /*********************************************************************
    298           *
    299           *       _WriteBlocking()
    300           *
    301           *  Function description
    302           *    Stores a specified number of characters in SEGGER RTT ring buffer
    303           *    and updates the associated write pointer which is periodically
    304           *    read by the host.
    305           *    The caller is responsible for managing the write chunk sizes as
    306           *    _WriteBlocking() will block until all data has been posted successfully.
    307           *
    308           *  Parameters
    309           *    pRing        Ring buffer to post to.
    310           *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    311           *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    312           *
    313           *  Return value
    314           *    >= 0 - Number of bytes written into buffer.
    315           */

   \                                 In section .text, align 2, keep-with-next
    316          static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes)
    317          {
   \                     _WriteBlocking: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4614             MOV      R4,R2
    318            unsigned NumBytesToWrite;
    319            unsigned NumBytesWritten;
    320            unsigned RdOff;
    321            unsigned WrOff;
    322            //
    323            // Write data to buffer and handle wrap-around if necessary
    324            //
    325            NumBytesWritten = 0u;
   \        0xA   0xF04F 0x0900      MOV      R9,#+0
    326            WrOff = pRing->WrOff;
   \        0xE   0x68EE             LDR      R6,[R5, #+12]
    327            do {
    328              RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
   \                     ??_WriteBlocking_0: (+1)
   \       0x10   0x692F             LDR      R7,[R5, #+16]
    329              if (RdOff > WrOff) {
   \       0x12   0x68A8             LDR      R0,[R5, #+8]
    330                NumBytesToWrite = RdOff - WrOff - 1u;
    331              } else {
    332                NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
    333              }
    334              NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));       // Number of bytes that can be written until buffer wrap-around
    335              NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
    336              (void) memcpy(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
   \       0x14   0x4641             MOV      R1,R8
   \       0x16   0x1B80             SUBS     R0,R0,R6
   \       0x18   0x42BE             CMP      R6,R7
   \       0x1A   0xBF34             ITE      CC 
   \       0x1C   0x1BBF             SUBCC    R7,R7,R6
   \       0x1E   0x183F             ADDCS    R7,R7,R0
   \       0x20   0x1E7F             SUBS     R7,R7,#+1
   \       0x22   0x4287             CMP      R7,R0
   \       0x24   0xBF28             IT       CS 
   \       0x26   0x4607             MOVCS    R7,R0
   \       0x28   0x42A7             CMP      R7,R4
   \       0x2A   0x6868             LDR      R0,[R5, #+4]
   \       0x2C   0xBF88             IT       HI 
   \       0x2E   0x4627             MOVHI    R7,R4
   \       0x30   0x463A             MOV      R2,R7
   \       0x32   0x1980             ADDS     R0,R0,R6
   \       0x34   0x....'....        BL       __aeabi_memcpy
    337              NumBytesWritten += NumBytesToWrite;
    338              pBuffer         += NumBytesToWrite;
    339              NumBytes        -= NumBytesToWrite;
    340              WrOff           += NumBytesToWrite;
    341              if (WrOff == pRing->SizeOfBuffer) {
   \       0x38   0x68A9             LDR      R1,[R5, #+8]
   \       0x3A   0x1BE4             SUBS     R4,R4,R7
   \       0x3C   0x19BE             ADDS     R6,R7,R6
   \       0x3E   0x428E             CMP      R6,R1
   \       0x40   0x44B9             ADD      R9,R7,R9
   \       0x42   0x44B8             ADD      R8,R8,R7
   \       0x44   0xBF08             IT       EQ 
   \       0x46   0x2600             MOVEQ    R6,#+0
    342                WrOff = 0u;
    343              }
    344              pRing->WrOff = WrOff;
   \       0x48   0x60EE             STR      R6,[R5, #+12]
    345            } while (NumBytes > 0u);
   \       0x4A   0x2C00             CMP      R4,#+0
   \       0x4C   0xD1E0             BNE.N    ??_WriteBlocking_0
    346            //
    347            return NumBytesWritten;
   \       0x4E   0x4648             MOV      R0,R9
   \       0x50   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    348          }
    349          
    350          /*********************************************************************
    351           *
    352           *       _WriteNoCheck()
    353           *
    354           *  Function description
    355           *    Stores a specified number of characters in SEGGER RTT ring buffer
    356           *    and updates the associated write pointer which is periodically
    357           *    read by the host.
    358           *    It is callers responsibility to make sure data actually fits in buffer.
    359           *
    360           *  Parameters
    361           *    pRing        Ring buffer to post to.
    362           *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    363           *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    364           *
    365           *  Notes
    366           *    (1) If there might not be enough space in the "Up"-buffer, call _WriteBlocking
    367           */

   \                                 In section .text, align 2, keep-with-next
    368          static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes)
    369          {
   \                     _WriteNoCheck: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
    370            unsigned NumBytesAtOnce;
    371            unsigned WrOff;
    372            unsigned Rem;
    373          
    374            WrOff = pRing->WrOff;
   \        0x6   0x68E7             LDR      R7,[R4, #+12]
    375            Rem = pRing->SizeOfBuffer - WrOff;
   \        0x8   0x68A5             LDR      R5,[R4, #+8]
    376            if (Rem > NumBytes) {
   \        0xA   0x6860             LDR      R0,[R4, #+4]
   \        0xC   0x4616             MOV      R6,R2
   \        0xE   0x1BED             SUBS     R5,R5,R7
   \       0x10   0x4688             MOV      R8,R1
   \       0x12   0x4438             ADD      R0,R0,R7
   \       0x14   0x42AE             CMP      R6,R5
   \       0x16   0xD203             BCS.N    ??_WriteNoCheck_0
    377              //
    378              // All data fits before wrap around
    379              //
    380              (void) memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
   \       0x18   0x....'....        BL       __aeabi_memcpy
    381              pRing->WrOff = WrOff + NumBytes;
   \       0x1C   0x19F6             ADDS     R6,R6,R7
   \       0x1E   0xE009             B.N      ??_WriteNoCheck_1
    382            } else {
    383              //
    384              // We reach the end of the buffer, so need to wrap around
    385              //
    386              NumBytesAtOnce = Rem;
    387              (void) memcpy(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
   \                     ??_WriteNoCheck_0: (+1)
   \       0x20   0x462A             MOV      R2,R5
   \       0x22   0x....'....        BL       __aeabi_memcpy
    388              NumBytesAtOnce = NumBytes - Rem;
    389              (void) memcpy(pRing->pBuffer, pData + Rem, NumBytesAtOnce);
   \       0x26   0x6860             LDR      R0,[R4, #+4]
   \       0x28   0x1B76             SUBS     R6,R6,R5
   \       0x2A   0x4632             MOV      R2,R6
   \       0x2C   0xEB08 0x0105      ADD      R1,R8,R5
   \       0x30   0x....'....        BL       __aeabi_memcpy
    390              pRing->WrOff = NumBytesAtOnce;
   \                     ??_WriteNoCheck_1: (+1)
   \       0x34   0x60E6             STR      R6,[R4, #+12]
    391            }
    392          }
   \       0x36   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    393          
    394          /*********************************************************************
    395           *
    396           *       _PostTerminalSwitch()
    397           *
    398           *  Function description
    399           *    Switch terminal to the given terminal ID.  It is the caller's
    400           *    responsibility to ensure the terminal ID is correct and there is
    401           *    enough space in the buffer for this to complete successfully.
    402           *
    403           *  Parameters
    404           *    pRing        Ring buffer to post to.
    405           *    TerminalId   Terminal ID to switch to.
    406           */

   \                                 In section .text, align 2, keep-with-next
    407          static void _PostTerminalSwitch(SEGGER_RTT_BUFFER_UP* pRing, unsigned char TerminalId)
    408          {
   \                     _PostTerminalSwitch: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    409            char ac[2];
    410          
    411            ac[0] = (char) 0xFFu;
   \        0x2   0x22FF             MOVS     R2,#+255
   \        0x4   0xF88D 0x2000      STRB     R2,[SP, #+0]
    412            ac[1] = (char) _aTerminalId[TerminalId];  // Caller made already sure that TerminalId does not exceed our terminal limit
   \        0x8   0x....'....        LDR.W    R3,??DataTable12_6
   \        0xC   0x5C59             LDRB     R1,[R3, R1]
    413            (void) _WriteBlocking(pRing, ac, 2u);
   \        0xE   0x2202             MOVS     R2,#+2
   \       0x10   0xF88D 0x1001      STRB     R1,[SP, #+1]
   \       0x14   0x4669             MOV      R1,SP
   \       0x16   0x....'....        BL       _WriteBlocking
    414          }
   \       0x1A   0xBD01             POP      {R0,PC}          ;; return
    415          
    416          /*********************************************************************
    417           *
    418           *       _GetAvailWriteSpace()
    419           *
    420           *  Function description
    421           *    Returns the number of bytes that can be written to the ring
    422           *    buffer without blocking.
    423           *
    424           *  Parameters
    425           *    pRing        Ring buffer to check.
    426           *
    427           *  Return value
    428           *    Number of bytes that are free in the buffer.
    429           */

   \                                 In section .text, align 2, keep-with-next
    430          static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing)
    431          {
   \                     _GetAvailWriteSpace: (+1)
   \        0x0   0x4601             MOV      R1,R0
    432            unsigned RdOff;
    433            unsigned WrOff;
    434            unsigned r;
    435            //
    436            // Avoid warnings regarding volatile access order.  It's not a problem
    437            // in this case, but dampen compiler enthusiasm.
    438            //
    439            RdOff = pRing->RdOff;
   \        0x2   0x6908             LDR      R0,[R1, #+16]
    440            WrOff = pRing->WrOff;
   \        0x4   0x68CA             LDR      R2,[R1, #+12]
    441            if (RdOff <= WrOff) {
   \        0x6   0x4282             CMP      R2,R0
   \        0x8   0xD304             BCC.N    ??_GetAvailWriteSpace_0
    442              r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
   \        0xA   0x6889             LDR      R1,[R1, #+8]
   \        0xC   0x1E49             SUBS     R1,R1,#+1
   \        0xE   0x1A8A             SUBS     R2,R1,R2
   \       0x10   0x1880             ADDS     R0,R0,R2
   \       0x12   0x4770             BX       LR
    443            } else {
    444              r = RdOff - WrOff - 1u;
   \                     ??_GetAvailWriteSpace_0: (+1)
   \       0x14   0x1A80             SUBS     R0,R0,R2
   \       0x16   0x1E40             SUBS     R0,R0,#+1
    445            }
    446            return r;
   \       0x18   0x4770             BX       LR               ;; return
    447          }
    448          
    449          /*********************************************************************
    450           *
    451           *       Public code
    452           *
    453           **********************************************************************
    454           */
    455          
    456          /*********************************************************************
    457           *
    458           *       SEGGER_RTT_ReadNoLock()
    459           *
    460           *  Function description
    461           *    Reads characters from SEGGER real-time-terminal control block
    462           *    which have been previously stored by the host.
    463           *    Do not lock against interrupts and multiple access.
    464           *
    465           *  Parameters
    466           *    BufferIndex  Index of Down-buffer to be used (e.g. 0 for "Terminal").
    467           *    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-down-buffer to.
    468           *    BufferSize   Size of the target application buffer.
    469           *
    470           *  Return value
    471           *    Number of bytes that have been read.
    472           */

   \                                 In section .text, align 2, keep-with-next
    473          unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize)
    474          {
   \                     SEGGER_RTT_ReadNoLock: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
    475            unsigned NumBytesRem;
    476            unsigned NumBytesRead;
    477            unsigned RdOff;
    478            unsigned WrOff;
    479            unsigned char*          pBuffer;
    480            SEGGER_RTT_BUFFER_DOWN* pRing;
    481            //
    482            INIT();
   \        0x6   0x....'....        LDR.W    R5,??DataTable12
   \        0xA   0x7828             LDRB     R0,[R5, #+0]
   \        0xC   0x4688             MOV      R8,R1
   \        0xE   0x4691             MOV      R9,R2
   \       0x10   0xB908             CBNZ.N   R0,??SEGGER_RTT_ReadNoLock_0
   \       0x12   0x....'....        BL       _DoInit
    483            pRing = &_SEGGER_RTT.aDown[BufferIndex];
   \                     ??SEGGER_RTT_ReadNoLock_0: (+1)
   \       0x16   0x2018             MOVS     R0,#+24
   \       0x18   0x4344             MULS     R4,R0,R4
   \       0x1A   0x1928             ADDS     R0,R5,R4
   \       0x1C   0xF100 0x0660      ADD      R6,R0,#+96
    484            pBuffer = (unsigned char*)pData;
    485            RdOff = pRing->RdOff;
   \       0x20   0x6937             LDR      R7,[R6, #+16]
    486            WrOff = pRing->WrOff;
   \       0x22   0x68F5             LDR      R5,[R6, #+12]
    487            NumBytesRead = 0u;
   \       0x24   0x2400             MOVS     R4,#+0
    488            //
    489            // Read from current read position to wrap-around of buffer, first
    490            //
    491            if (RdOff > WrOff) {
   \       0x26   0x42BD             CMP      R5,R7
   \       0x28   0xD212             BCS.N    ??SEGGER_RTT_ReadNoLock_1
    492              NumBytesRem = pRing->SizeOfBuffer - RdOff;
   \       0x2A   0x68B4             LDR      R4,[R6, #+8]
    493              NumBytesRem = MIN(NumBytesRem, BufferSize);
    494              (void) memcpy(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
   \       0x2C   0x6870             LDR      R0,[R6, #+4]
   \       0x2E   0x1BE4             SUBS     R4,R4,R7
   \       0x30   0x454C             CMP      R4,R9
   \       0x32   0xBF88             IT       HI 
   \       0x34   0x464C             MOVHI    R4,R9
   \       0x36   0x19C1             ADDS     R1,R0,R7
   \       0x38   0x4622             MOV      R2,R4
   \       0x3A   0x4640             MOV      R0,R8
   \       0x3C   0x....'....        BL       __aeabi_memcpy
    495              NumBytesRead += NumBytesRem;
    496              pBuffer      += NumBytesRem;
    497              BufferSize   -= NumBytesRem;
    498              RdOff        += NumBytesRem;
    499              //
    500              // Handle wrap-around of buffer
    501              //
    502              if (RdOff == pRing->SizeOfBuffer) {
   \       0x40   0x68B1             LDR      R1,[R6, #+8]
   \       0x42   0x19E7             ADDS     R7,R4,R7
   \       0x44   0x44A0             ADD      R8,R8,R4
   \       0x46   0x428F             CMP      R7,R1
   \       0x48   0xEBA9 0x0904      SUB      R9,R9,R4
   \       0x4C   0xBF08             IT       EQ 
   \       0x4E   0x2700             MOVEQ    R7,#+0
    503                RdOff = 0u;
    504              }
    505            }
    506            //
    507            // Read remaining items of buffer
    508            //
    509            NumBytesRem = WrOff - RdOff;
   \                     ??SEGGER_RTT_ReadNoLock_1: (+1)
   \       0x50   0x1BED             SUBS     R5,R5,R7
    510            NumBytesRem = MIN(NumBytesRem, BufferSize);
   \       0x52   0x454D             CMP      R5,R9
   \       0x54   0xBF88             IT       HI 
   \       0x56   0x464D             MOVHI    R5,R9
    511            if (NumBytesRem > 0u) {
   \       0x58   0xB13D             CBZ.N    R5,??SEGGER_RTT_ReadNoLock_2
    512              (void) memcpy(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
   \       0x5A   0x6870             LDR      R0,[R6, #+4]
   \       0x5C   0x462A             MOV      R2,R5
    513              NumBytesRead += NumBytesRem;
   \       0x5E   0x192C             ADDS     R4,R5,R4
   \       0x60   0x19C1             ADDS     R1,R0,R7
   \       0x62   0x4640             MOV      R0,R8
   \       0x64   0x....'....        BL       __aeabi_memcpy
    514              RdOff        += NumBytesRem;
   \       0x68   0x19EF             ADDS     R7,R5,R7
    515            }
    516            if (NumBytesRead > 0u) {
   \                     ??SEGGER_RTT_ReadNoLock_2: (+1)
   \       0x6A   0xB104             CBZ.N    R4,??SEGGER_RTT_ReadNoLock_3
    517              pRing->RdOff = RdOff;
   \       0x6C   0x6137             STR      R7,[R6, #+16]
    518            }
    519            //
    520            return NumBytesRead;
   \                     ??SEGGER_RTT_ReadNoLock_3: (+1)
   \       0x6E   0x4620             MOV      R0,R4
   \       0x70   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    521          }
    522          
    523          /*********************************************************************
    524           *
    525           *       SEGGER_RTT_Read
    526           *
    527           *  Function description
    528           *    Reads characters from SEGGER real-time-terminal control block
    529           *    which have been previously stored by the host.
    530           *
    531           *  Parameters
    532           *    BufferIndex  Index of Down-buffer to be used (e.g. 0 for "Terminal").
    533           *    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-down-buffer to.
    534           *    BufferSize   Size of the target application buffer.
    535           *
    536           *  Return value
    537           *    Number of bytes that have been read.
    538           */

   \                                 In section .text, align 2, keep-with-next
    539          unsigned SEGGER_RTT_Read(unsigned BufferIndex, void* pBuffer, unsigned BufferSize)
    540          {
   \                     SEGGER_RTT_Read: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   \        0x6   0x4616             MOV      R6,R2
    541            unsigned NumBytesRead;
    542            //
    543            SEGGER_RTT_LOCK();
   \        0x8   0x....'....        BL       CORE_EnterAtomic
   \        0xC   0x4607             MOV      R7,R0
    544            //
    545            // Call the non-locking read function
    546            //
    547            NumBytesRead = SEGGER_RTT_ReadNoLock(BufferIndex, pBuffer, BufferSize);
   \        0xE   0x4632             MOV      R2,R6
   \       0x10   0x4629             MOV      R1,R5
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x....'....        BL       SEGGER_RTT_ReadNoLock
   \       0x18   0x....             B.N      ?Subroutine1
    548            //
    549            // Finish up.
    550            //
    551            SEGGER_RTT_UNLOCK();
    552            //
    553            return NumBytesRead;
    554          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0x4638             MOV      R0,R7
   \        0x4   0x....'....        BL       CORE_ExitAtomic
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    555          
    556          /*********************************************************************
    557           *
    558           *       SEGGER_RTT_WriteWithOverwriteNoLock
    559           *
    560           *  Function description
    561           *    Stores a specified number of characters in SEGGER RTT
    562           *    control block.
    563           *    SEGGER_RTT_WriteWithOverwriteNoLock does not lock the application
    564           *    and overwrites data if the data does not fit into the buffer.
    565           *
    566           *  Parameters
    567           *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
    568           *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    569           *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    570           *
    571           *  Notes
    572           *    (1) If there is not enough space in the "Up"-buffer, data is overwritten.
    573           *    (2) For performance reasons this function does not call Init()
    574           *        and may only be called after RTT has been initialized.
    575           *        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
    576           *    (3) Do not use SEGGER_RTT_WriteWithOverwriteNoLock if a J-Link
    577           *        connection reads RTT data.
    578           */

   \                                 In section .text, align 2, keep-with-next
    579          void SEGGER_RTT_WriteWithOverwriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes)
    580          {
   \                     SEGGER_RTT_WriteWithOverwriteNoLock: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x460D             MOV      R5,R1
    581            const char*           pData;
    582            SEGGER_RTT_BUFFER_UP* pRing;
    583            unsigned Avail;
    584          
    585            pData = (const char *)pBuffer;
    586            //
    587            // Get "to-host" ring buffer and copy some elements into local variables.
    588            //
    589            pRing = &_SEGGER_RTT.aUp[BufferIndex];
   \        0x4   0x2118             MOVS     R1,#+24
   \        0x6   0x4348             MULS     R0,R1,R0
   \        0x8   0x4614             MOV      R4,R2
   \        0xA   0x....'....        LDR.W    R2,??DataTable12
   \        0xE   0x4410             ADD      R0,R2,R0
   \       0x10   0xF100 0x0618      ADD      R6,R0,#+24
    590            //
    591            // Check if we will overwrite data and need to adjust the RdOff.
    592            //
    593            if (pRing->WrOff == pRing->RdOff) {
   \       0x14   0x68F1             LDR      R1,[R6, #+12]
   \       0x16   0x6930             LDR      R0,[R6, #+16]
   \       0x18   0x4281             CMP      R1,R0
   \       0x1A   0xBF08             IT       EQ 
   \       0x1C   0x68B1             LDREQ    R1,[R6, #+8]
    594              Avail = pRing->SizeOfBuffer - 1u;
   \       0x1E   0xD007             BEQ.N    ??SEGGER_RTT_WriteWithOverwriteNoLock_0
    595            } else if ( pRing->WrOff < pRing->RdOff) {
   \       0x20   0x6930             LDR      R0,[R6, #+16]
   \       0x22   0x6932             LDR      R2,[R6, #+16]
   \       0x24   0x4281             CMP      R1,R0
   \       0x26   0xBF31             ITEEE    CC 
   \       0x28   0x1A51             SUBCC    R1,R2,R1
   \       0x2A   0x1A51             SUBCS    R1,R2,R1
   \       0x2C   0x68B0             LDRCS    R0,[R6, #+8]
   \       0x2E   0x1841             ADDCS    R1,R0,R1
    596              Avail = pRing->RdOff - pRing->WrOff - 1u;
    597            } else {
    598              Avail = pRing->RdOff - pRing->WrOff - 1u + pRing->SizeOfBuffer;
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_0: (+1)
   \       0x30   0x1E49             SUBS     R1,R1,#+1
    599            }
    600            if (NumBytes > Avail) {
   \       0x32   0x42A1             CMP      R1,R4
   \       0x34   0xD20B             BCS.N    ??SEGGER_RTT_WriteWithOverwriteNoLock_1
    601              pRing->RdOff += (NumBytes - Avail);
   \       0x36   0x6930             LDR      R0,[R6, #+16]
   \       0x38   0x1820             ADDS     R0,R4,R0
   \       0x3A   0x1A41             SUBS     R1,R0,R1
   \       0x3C   0x6131             STR      R1,[R6, #+16]
   \       0x3E   0xE002             B.N      ??SEGGER_RTT_WriteWithOverwriteNoLock_2
    602              while (pRing->RdOff >= pRing->SizeOfBuffer) {
    603                pRing->RdOff -= pRing->SizeOfBuffer;
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_3: (+1)
   \       0x40   0x6931             LDR      R1,[R6, #+16]
   \       0x42   0x1A08             SUBS     R0,R1,R0
   \       0x44   0x6130             STR      R0,[R6, #+16]
    604              }
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_2: (+1)
   \       0x46   0x68B0             LDR      R0,[R6, #+8]
   \       0x48   0x6931             LDR      R1,[R6, #+16]
   \       0x4A   0x4281             CMP      R1,R0
   \       0x4C   0xD2F8             BCS.N    ??SEGGER_RTT_WriteWithOverwriteNoLock_3
    605            }
    606            //
    607            // Write all data, no need to check the RdOff, but possibly handle multiple wrap-arounds
    608            //
    609            Avail = pRing->SizeOfBuffer - pRing->WrOff;
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_1: (+1)
   \       0x4E   0x68B0             LDR      R0,[R6, #+8]
   \       0x50   0x68F7             LDR      R7,[R6, #+12]
   \       0x52   0x1BC7             SUBS     R7,R0,R7
    610            do {
    611              if (Avail > NumBytes) {
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_4: (+1)
   \       0x54   0x68F1             LDR      R1,[R6, #+12]
   \       0x56   0x6870             LDR      R0,[R6, #+4]
   \       0x58   0x42BC             CMP      R4,R7
   \       0x5A   0x4408             ADD      R0,R0,R1
   \       0x5C   0xD30C             BCC.N    ??SEGGER_RTT_WriteWithOverwriteNoLock_5
    612                //
    613                // Last round
    614                //
    615          #if 1 // memcpy() is good for large amounts of data, but the overhead is too big for small amounts. Use a simple byte loop instead.
    616                char* pDst;
    617                pDst = pRing->pBuffer + pRing->WrOff;
    618                pRing->WrOff += NumBytes;
    619                do {
    620                  *pDst++ = *pData++;
    621                } while (--NumBytes > 0u);
    622          #else
    623                (void) memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
    624                pRing->WrOff += NumBytes;
    625          #endif
    626                break;  //Alternatively: NumBytes = 0;
    627              } else {
    628                //
    629                //  Wrap-around necessary, write until wrap-around and reset WrOff
    630                //
    631                (void) memcpy(pRing->pBuffer + pRing->WrOff, pData, Avail);
    632                pData += Avail;
    633                pRing->WrOff = 0;
    634                NumBytes -= Avail;
   \       0x5E   0x1BE4             SUBS     R4,R4,R7
   \       0x60   0x463A             MOV      R2,R7
   \       0x62   0x4629             MOV      R1,R5
   \       0x64   0x443D             ADD      R5,R5,R7
   \       0x66   0x....'....        BL       __aeabi_memcpy
    635                Avail = (pRing->SizeOfBuffer - 1u);
   \       0x6A   0x68B7             LDR      R7,[R6, #+8]
   \       0x6C   0x2100             MOVS     R1,#+0
   \       0x6E   0x60F1             STR      R1,[R6, #+12]
   \       0x70   0x1E7F             SUBS     R7,R7,#+1
    636              }
    637            } while (NumBytes > 0u);
   \       0x72   0x2C00             CMP      R4,#+0
   \       0x74   0xD1EE             BNE.N    ??SEGGER_RTT_WriteWithOverwriteNoLock_4
   \       0x76   0xBDF1             POP      {R0,R4-R7,PC}
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_5: (+1)
   \       0x78   0x1861             ADDS     R1,R4,R1
   \       0x7A   0x60F1             STR      R1,[R6, #+12]
   \                     ??SEGGER_RTT_WriteWithOverwriteNoLock_6: (+1)
   \       0x7C   0xF815 0x1B01      LDRB     R1,[R5], #+1
   \       0x80   0x1E64             SUBS     R4,R4,#+1
   \       0x82   0xF800 0x1B01      STRB     R1,[R0], #+1
   \       0x86   0xD1F9             BNE.N    ??SEGGER_RTT_WriteWithOverwriteNoLock_6
    638          }
   \       0x88   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    639          
    640          /*********************************************************************
    641           *
    642           *       SEGGER_RTT_WriteSkipNoLock
    643           *
    644           *  Function description
    645           *    Stores a specified number of characters in SEGGER RTT
    646           *    control block which is then read by the host.
    647           *    SEGGER_RTT_WriteSkipNoLock does not lock the application and
    648           *    skips all data, if the data does not fit into the buffer.
    649           *
    650           *  Parameters
    651           *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
    652           *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    653           *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    654           *
    655           *  Return value
    656           *    Number of bytes which have been stored in the "Up"-buffer.
    657           *
    658           *  Notes
    659           *    (1) If there is not enough space in the "Up"-buffer, all data is dropped.
    660           *    (2) For performance reasons this function does not call Init()
    661           *        and may only be called after RTT has been initialized.
    662           *        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
    663           */

   \                                 In section .text, align 2, keep-with-next
    664          unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes)
    665          {
   \                     SEGGER_RTT_WriteSkipNoLock: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4688             MOV      R8,R1
    666            const char*           pData;
    667            SEGGER_RTT_BUFFER_UP* pRing;
    668            unsigned Avail;
    669            unsigned RdOff;
    670            unsigned WrOff;
    671            unsigned Rem;
    672          
    673            pData = (const char *)pBuffer;
    674            //
    675            // Get "to-host" ring buffer and copy some elements into local variables.
    676            //
    677            pRing = &_SEGGER_RTT.aUp[BufferIndex];
   \        0x6   0x....'....        BL       ?Subroutine7
    678            RdOff = pRing->RdOff;
   \                     ??CrossCallReturnLabel_6: (+1)
   \        0xA   0x6930             LDR      R0,[R6, #+16]
    679            WrOff = pRing->WrOff;
   \        0xC   0x68F3             LDR      R3,[R6, #+12]
    680            //
    681            // Handle the most common cases fastest.
    682            // Which is:
    683            //    RdOff <= WrOff -> Space until wrap around is free.
    684            //  AND
    685            //    WrOff + NumBytes < SizeOfBuffer -> No Wrap around necessary.
    686            //
    687            //  OR
    688            //
    689            //    RdOff > WrOff -> Space until RdOff - 1 is free.
    690            //  AND
    691            //    WrOff + NumBytes < RdOff -> Data fits into buffer
    692            //
    693            if (RdOff <= WrOff) {
   \        0xE   0x18EC             ADDS     R4,R5,R3
   \       0x10   0x4283             CMP      R3,R0
   \       0x12   0xD327             BCC.N    ??SEGGER_RTT_WriteSkipNoLock_0
    694              //
    695              // Get space until WrOff will be at wrap around.
    696              //
    697              Avail = pRing->SizeOfBuffer - 1u - WrOff;
   \       0x14   0x68B7             LDR      R7,[R6, #+8]
   \       0x16   0x1E79             SUBS     R1,R7,#+1
   \       0x18   0x1AC9             SUBS     R1,R1,R3
    698              if (Avail >= NumBytes) {
   \       0x1A   0x42A9             CMP      R1,R5
   \       0x1C   0xD308             BCC.N    ??SEGGER_RTT_WriteSkipNoLock_1
    699          #if 1 // memcpy() is good for large amounts of data, but the overhead is too big for small amounts. Use a simple byte loop instead.
    700                char* pDst;
    701                pDst = pRing->pBuffer + WrOff;
   \       0x1E   0x6870             LDR      R0,[R6, #+4]
   \       0x20   0x4418             ADD      R0,R0,R3
    702                WrOff += NumBytes;
    703                do {
    704                  *pDst++ = *pData++;
   \                     ??SEGGER_RTT_WriteSkipNoLock_2: (+1)
   \       0x22   0xF818 0x1B01      LDRB     R1,[R8], #+1
    705                } while (--NumBytes > 0u);
   \       0x26   0x1E6D             SUBS     R5,R5,#+1
   \       0x28   0xF800 0x1B01      STRB     R1,[R0], #+1
   \       0x2C   0xD1F9             BNE.N    ??SEGGER_RTT_WriteSkipNoLock_2
    706                pRing->WrOff = WrOff + NumBytes;
   \       0x2E   0xE023             B.N      ??SEGGER_RTT_WriteSkipNoLock_3
    707          #else
    708                (void) memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
    709                pRing->WrOff = WrOff + NumBytes;
    710          #endif
    711                return 1;
    712              }
    713              //
    714              // If data did not fit into space until wrap around calculate complete space in buffer.
    715              //
    716              Avail += RdOff;
    717              //
    718              // If there is still no space for the whole of this output, don't bother.
    719              //
    720              if (Avail >= NumBytes) {
   \                     ??SEGGER_RTT_WriteSkipNoLock_1: (+1)
   \       0x30   0x1840             ADDS     R0,R0,R1
   \       0x32   0x42A8             CMP      R0,R5
   \       0x34   0xD323             BCC.N    ??SEGGER_RTT_WriteSkipNoLock_4
    721                //
    722                //  OK, we have enough space in buffer. Copy in one or 2 chunks
    723                //
    724                Rem = pRing->SizeOfBuffer - WrOff;      // Space until end of buffer
    725                if (Rem > NumBytes) {
   \       0x36   0x6870             LDR      R0,[R6, #+4]
   \       0x38   0x1AFF             SUBS     R7,R7,R3
   \       0x3A   0x42BD             CMP      R5,R7
   \       0x3C   0x4418             ADD      R0,R0,R3
   \       0x3E   0xD204             BCS.N    ??SEGGER_RTT_WriteSkipNoLock_5
    726                  (void) memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
   \       0x40   0x462A             MOV      R2,R5
   \       0x42   0x4641             MOV      R1,R8
   \       0x44   0x....'....        BL       __aeabi_memcpy
    727                  pRing->WrOff = WrOff + NumBytes;
   \       0x48   0xE016             B.N      ??SEGGER_RTT_WriteSkipNoLock_3
    728                } else {
    729                  //
    730                  // We reach the end of the buffer, so need to wrap around
    731                  //
    732                  (void) memcpy(pRing->pBuffer + WrOff, pData, Rem);
   \                     ??SEGGER_RTT_WriteSkipNoLock_5: (+1)
   \       0x4A   0x463A             MOV      R2,R7
   \       0x4C   0x4641             MOV      R1,R8
   \       0x4E   0x....'....        BL       __aeabi_memcpy
    733                  (void) memcpy(pRing->pBuffer, pData + Rem, NumBytes - Rem);
   \       0x52   0x6870             LDR      R0,[R6, #+4]
   \       0x54   0x1BED             SUBS     R5,R5,R7
   \       0x56   0x462A             MOV      R2,R5
   \       0x58   0xEB08 0x0107      ADD      R1,R8,R7
   \       0x5C   0x....'....        BL       __aeabi_memcpy
    734                  pRing->WrOff = NumBytes - Rem;
   \       0x60   0x60F5             STR      R5,[R6, #+12]
    735                }
    736                return 1;
   \       0x62   0xE00A             B.N      ??SEGGER_RTT_WriteSkipNoLock_6
    737              }
    738            } else {
    739              Avail = RdOff - WrOff - 1u;
    740              if (Avail >= NumBytes) {
   \                     ??SEGGER_RTT_WriteSkipNoLock_0: (+1)
   \       0x64   0x1AC0             SUBS     R0,R0,R3
   \       0x66   0x1E40             SUBS     R0,R0,#+1
   \       0x68   0x42A8             CMP      R0,R5
   \       0x6A   0xD308             BCC.N    ??SEGGER_RTT_WriteSkipNoLock_4
    741                (void) memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
   \       0x6C   0x6870             LDR      R0,[R6, #+4]
   \       0x6E   0x462A             MOV      R2,R5
   \       0x70   0x4641             MOV      R1,R8
   \       0x72   0x4418             ADD      R0,R0,R3
   \       0x74   0x....'....        BL       __aeabi_memcpy
    742                pRing->WrOff = WrOff + NumBytes;
   \                     ??SEGGER_RTT_WriteSkipNoLock_3: (+1)
   \       0x78   0x60F4             STR      R4,[R6, #+12]
    743                return 1;
   \                     ??SEGGER_RTT_WriteSkipNoLock_6: (+1)
   \       0x7A   0x2001             MOVS     R0,#+1
   \       0x7C   0xE000             B.N      ??SEGGER_RTT_WriteSkipNoLock_7
    744              }
    745            }
    746            //
    747            // If we reach this point no data has been written
    748            //
    749            return 0;
   \                     ??SEGGER_RTT_WriteSkipNoLock_4: (+1)
   \       0x7E   0x2000             MOVS     R0,#+0
   \                     ??SEGGER_RTT_WriteSkipNoLock_7: (+1)
   \       0x80   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    750          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x2118             MOVS     R1,#+24
   \        0x2   0x4348             MULS     R0,R1,R0
   \        0x4   0x4615             MOV      R5,R2
   \        0x6   0x....'....        LDR.W    R2,??DataTable12
   \        0xA   0x4410             ADD      R0,R2,R0
   \        0xC   0xF100 0x0618      ADD      R6,R0,#+24
   \       0x10   0x4770             BX       LR
    751          
    752          /*********************************************************************
    753           *
    754           *       SEGGER_RTT_WriteNoLock
    755           *
    756           *  Function description
    757           *    Stores a specified number of characters in SEGGER RTT
    758           *    control block which is then read by the host.
    759           *    SEGGER_RTT_WriteNoLock does not lock the application.
    760           *
    761           *  Parameters
    762           *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
    763           *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    764           *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    765           *
    766           *  Return value
    767           *    Number of bytes which have been stored in the "Up"-buffer.
    768           *
    769           *  Notes
    770           *    (1) If there is not enough space in the "Up"-buffer, remaining characters of pBuffer are dropped.
    771           *    (2) For performance reasons this function does not call Init()
    772           *        and may only be called after RTT has been initialized.
    773           *        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
    774           */

   \                                 In section .text, align 2, keep-with-next
    775          unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes)
    776          {
   \                     SEGGER_RTT_WriteNoLock: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x460C             MOV      R4,R1
    777            unsigned Status;
    778            unsigned Avail;
    779            const char*           pData;
    780            SEGGER_RTT_BUFFER_UP* pRing;
    781          
    782            pData = (const char *)pBuffer;
    783            //
    784            // Get "to-host" ring buffer.
    785            //
    786            pRing = &_SEGGER_RTT.aUp[BufferIndex];
   \        0x4   0x....'....        BL       ?Subroutine7
    787            //
    788            // How we output depends upon the mode...
    789            //
    790            switch (pRing->Flags) {
   \                     ??CrossCallReturnLabel_7: (+1)
   \        0x8   0x6972             LDR      R2,[R6, #+20]
   \        0xA   0xB11A             CBZ.N    R2,??SEGGER_RTT_WriteNoLock_0
   \        0xC   0x2A02             CMP      R2,#+2
   \        0xE   0xD013             BEQ.N    ??SEGGER_RTT_WriteNoLock_1
   \       0x10   0xD306             BCC.N    ??SEGGER_RTT_WriteNoLock_2
   \       0x12   0xE018             B.N      ??SEGGER_RTT_WriteNoLock_3
    791              case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
    792                //
    793                // If we are in skip mode and there is no space for the whole
    794                // of this output, don't bother.
    795                //
    796                Avail = _GetAvailWriteSpace(pRing);
    797                if (Avail < NumBytes) {
   \                     ??SEGGER_RTT_WriteNoLock_0: (+1)
   \       0x14   0x4630             MOV      R0,R6
   \       0x16   0x....'....        BL       _GetAvailWriteSpace
   \       0x1A   0x42A8             CMP      R0,R5
   \       0x1C   0xD206             BCS.N    ??SEGGER_RTT_WriteNoLock_4
    798                  Status = 0u;
   \       0x1E   0xE012             B.N      ??SEGGER_RTT_WriteNoLock_3
    799                } else {
    800                  Status = NumBytes;
    801                  _WriteNoCheck(pRing, pData, NumBytes);
    802                }
    803                break;
    804              case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
    805                //
    806                // If we are in trim mode, trim to what we can output without blocking.
    807                //
    808                Avail = _GetAvailWriteSpace(pRing);
   \                     ??SEGGER_RTT_WriteNoLock_2: (+1)
   \       0x20   0x4630             MOV      R0,R6
   \       0x22   0x....'....        BL       _GetAvailWriteSpace
    809                Status = Avail < NumBytes ? Avail : NumBytes;
   \       0x26   0x42A8             CMP      R0,R5
   \       0x28   0xBF98             IT       LS 
   \       0x2A   0x4605             MOVLS    R5,R0
    810                _WriteNoCheck(pRing, pData, Status);
   \                     ??SEGGER_RTT_WriteNoLock_4: (+1)
   \       0x2C   0x462A             MOV      R2,R5
   \       0x2E   0x4621             MOV      R1,R4
   \       0x30   0x4630             MOV      R0,R6
   \       0x32   0x....'....        BL       _WriteNoCheck
    811                break;
   \       0x36   0xE007             B.N      ??SEGGER_RTT_WriteNoLock_5
    812              case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
    813                //
    814                // If we are in blocking mode, output everything.
    815                //
    816                Status = _WriteBlocking(pRing, pData, NumBytes);
   \                     ??SEGGER_RTT_WriteNoLock_1: (+1)
   \       0x38   0x462A             MOV      R2,R5
   \       0x3A   0x4621             MOV      R1,R4
   \       0x3C   0x4630             MOV      R0,R6
   \       0x3E   0x....'....        BL       _WriteBlocking
   \       0x42   0x4605             MOV      R5,R0
    817                break;
   \       0x44   0xE000             B.N      ??SEGGER_RTT_WriteNoLock_5
    818              default:
    819                Status = 0u;
   \                     ??SEGGER_RTT_WriteNoLock_3: (+1)
   \       0x46   0x2500             MOVS     R5,#+0
    820                break;
    821            }
    822            //
    823            // Finish up.
    824            //
    825            return Status;
   \                     ??SEGGER_RTT_WriteNoLock_5: (+1)
   \       0x48   0x4628             MOV      R0,R5
   \       0x4A   0xBD70             POP      {R4-R6,PC}       ;; return
    826          }
    827          
    828          /*********************************************************************
    829           *
    830           *       SEGGER_RTT_Write
    831           *
    832           *  Function description
    833           *    Stores a specified number of characters in SEGGER RTT
    834           *    control block which is then read by the host.
    835           *
    836           *  Parameters
    837           *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
    838           *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    839           *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    840           *
    841           *  Return value
    842           *    Number of bytes which have been stored in the "Up"-buffer.
    843           *
    844           *  Notes
    845           *    (1) If there is not enough space in the "Up"-buffer, remaining characters of pBuffer are dropped.
    846           */

   \                                 In section .text, align 2, keep-with-next
    847          unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes)
    848          {
   \                     SEGGER_RTT_Write: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4604             MOV      R4,R0
    849            unsigned Status;
    850            //
    851            INIT();
   \        0x6   0x....'....        LDR.W    R1,??DataTable12
   \        0xA   0x7808             LDRB     R0,[R1, #+0]
   \        0xC   0x4616             MOV      R6,R2
   \        0xE   0xB908             CBNZ.N   R0,??SEGGER_RTT_Write_0
   \       0x10   0x....'....        BL       _DoInit
    852            SEGGER_RTT_LOCK();
   \                     ??SEGGER_RTT_Write_0: (+1)
   \       0x14   0x....'....        BL       CORE_EnterAtomic
   \       0x18   0x4607             MOV      R7,R0
    853            //
    854            // Call the non-locking write function
    855            //
    856            Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);
   \       0x1A   0x4632             MOV      R2,R6
   \       0x1C   0x4629             MOV      R1,R5
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0x....'....        BL       SEGGER_RTT_WriteNoLock
   \       0x24                      REQUIRE ?Subroutine1
   \       0x24                      ;; // Fall through to label ?Subroutine1
    857            //
    858            // Finish up.
    859            //
    860            SEGGER_RTT_UNLOCK();
    861            //
    862            return Status;
    863          }
    864          
    865          /*********************************************************************
    866           *
    867           *       SEGGER_RTT_WriteString
    868           *
    869           *  Function description
    870           *    Stores string in SEGGER RTT control block.
    871           *    This data is read by the host.
    872           *
    873           *  Parameters
    874           *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
    875           *    s            Pointer to string.
    876           *
    877           *  Return value
    878           *    Number of bytes which have been stored in the "Up"-buffer.
    879           *
    880           *  Notes
    881           *    (1) If there is not enough space in the "Up"-buffer, depending on configuration,
    882           *        remaining characters may be dropped or RTT module waits until there is more space in the buffer.
    883           *    (2) String passed to this function has to be \0 terminated
    884           *    (3) \0 termination character is *not* stored in RTT buffer
    885           */

   \                                 In section .text, align 2, keep-with-next
    886          unsigned SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s)
    887          {
   \                     SEGGER_RTT_WriteString: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    888            unsigned Len;
    889          
    890            Len = STRLEN(s);
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x....'....        BL       strlen
    891            return SEGGER_RTT_Write(BufferIndex, s, Len);
   \        0xC   0x4602             MOV      R2,R0
   \        0xE   0x4629             MOV      R1,R5
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x16   0x....             B.N      SEGGER_RTT_Write
    892          }
    893          
    894          /*********************************************************************
    895           *
    896           *       SEGGER_RTT_GetKey
    897           *
    898           *  Function description
    899           *    Reads one character from the SEGGER RTT buffer.
    900           *    Host has previously stored data there.
    901           *
    902           *  Return value
    903           *    <  0 -   No character available (buffer empty).
    904           *    >= 0 -   Character which has been read. (Possible values: 0 - 255)
    905           *
    906           *  Notes
    907           *    (1) This function is only specified for accesses to RTT buffer 0.
    908           */

   \                                 In section .text, align 2, keep-with-next
    909          int SEGGER_RTT_GetKey(void)
    910          {
   \                     SEGGER_RTT_GetKey: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    911            char c;
    912            int r;
    913          
    914            r = (int)SEGGER_RTT_Read(0u, &c, 1u);
    915            if (r == 1) {
   \        0x2   0x2201             MOVS     R2,#+1
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x....'....        BL       SEGGER_RTT_Read
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD102             BNE.N    ??SEGGER_RTT_GetKey_0
    916              r = (int)(unsigned char)c;
   \       0x10   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x14   0xBD02             POP      {R1,PC}
    917            } else {
    918              r = -1;
   \                     ??SEGGER_RTT_GetKey_0: (+1)
   \       0x16   0xF04F 0x30FF      MOV      R0,#-1
    919            }
    920            return r;
   \       0x1A   0xBD02             POP      {R1,PC}          ;; return
    921          }
    922          
    923          /*********************************************************************
    924           *
    925           *       SEGGER_RTT_WaitKey
    926           *
    927           *  Function description
    928           *    Waits until at least one character is avaible in the SEGGER RTT buffer.
    929           *    Once a character is available, it is read and this function returns.
    930           *
    931           *  Return value
    932           *    >=0 -   Character which has been read.
    933           *
    934           *  Notes
    935           *    (1) This function is only specified for accesses to RTT buffer 0
    936           *    (2) This function is blocking if no character is present in RTT buffer
    937           */

   \                                 In section .text, align 2, keep-with-next
    938          int SEGGER_RTT_WaitKey(void)
    939          {
   \                     SEGGER_RTT_WaitKey: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    940            int r;
    941          
    942            do {
    943              r = SEGGER_RTT_GetKey();
   \                     ??SEGGER_RTT_WaitKey_0: (+1)
   \        0x2   0x....'....        BL       SEGGER_RTT_GetKey
    944            } while (r < 0);
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD4FB             BMI.N    ??SEGGER_RTT_WaitKey_0
    945            return r;
   \        0xA   0xBD02             POP      {R1,PC}          ;; return
    946          }
    947          
    948          /*********************************************************************
    949           *
    950           *       SEGGER_RTT_HasKey
    951           *
    952           *  Function description
    953           *    Checks if at least one character for reading is available in the SEGGER RTT buffer.
    954           *
    955           *  Return value
    956           *    == 0 -     No characters are available to read.
    957           *    == 1 -     At least one character is available.
    958           *
    959           *  Notes
    960           *    (1) This function is only specified for accesses to RTT buffer 0
    961           */

   \                                 In section .text, align 2, keep-with-next
    962          int SEGGER_RTT_HasKey(void)
    963          {
   \                     SEGGER_RTT_HasKey: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    964            unsigned RdOff;
    965            int r;
    966          
    967            INIT();
   \        0x2   0x....             LDR.N    R4,??DataTable12
   \        0x4   0x7820             LDRB     R0,[R4, #+0]
   \        0x6   0xB908             CBNZ.N   R0,??SEGGER_RTT_HasKey_0
   \        0x8   0x....'....        BL       _DoInit
    968            RdOff = _SEGGER_RTT.aDown[0].RdOff;
    969            if (RdOff != _SEGGER_RTT.aDown[0].WrOff) {
   \                     ??SEGGER_RTT_HasKey_0: (+1)
   \        0xC   0x6F20             LDR      R0,[R4, #+112]
   \        0xE   0x6EE1             LDR      R1,[R4, #+108]
   \       0x10   0x4288             CMP      R0,R1
   \       0x12   0xD001             BEQ.N    ??SEGGER_RTT_HasKey_1
    970              r = 1;
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xBD10             POP      {R4,PC}
    971            } else {
    972              r = 0;
   \                     ??SEGGER_RTT_HasKey_1: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
    973            }
    974            return r;
   \       0x1A   0xBD10             POP      {R4,PC}          ;; return
    975          }
    976          
    977          /*********************************************************************
    978           *
    979           *       SEGGER_RTT_HasData
    980           *
    981           *  Function description
    982           *    Check if there is data from the host in the given buffer.
    983           *
    984           *  Return value:
    985           *  ==0:  No data
    986           *  !=0:  Data in buffer
    987           *
    988           */

   \                                 In section .text, align 2, keep-with-next
    989          unsigned SEGGER_RTT_HasData(unsigned BufferIndex)
    990          {
    991            SEGGER_RTT_BUFFER_DOWN* pRing;
    992            unsigned v;
    993          
    994            pRing = &_SEGGER_RTT.aDown[BufferIndex];
   \                     SEGGER_RTT_HasData: (+1)
   \        0x0   0x2118             MOVS     R1,#+24
   \        0x2   0x4348             MULS     R0,R1,R0
   \        0x4   0x....             LDR.N    R2,??DataTable12
   \        0x6   0x4410             ADD      R0,R2,R0
   \        0x8   0xF100 0x0160      ADD      R1,R0,#+96
    995            v = pRing->WrOff;
   \        0xC   0x68C8             LDR      R0,[R1, #+12]
    996            return v - pRing->RdOff;
   \        0xE   0x6909             LDR      R1,[R1, #+16]
   \       0x10   0x1A40             SUBS     R0,R0,R1
   \       0x12   0x4770             BX       LR               ;; return
    997          }
    998          
    999          /*********************************************************************
   1000           *
   1001           *       SEGGER_RTT_AllocDownBuffer
   1002           *
   1003           *  Function description
   1004           *    Run-time configuration of the next down-buffer (H->T).
   1005           *    The next buffer, which is not used yet is configured.
   1006           *    This includes: Buffer address, size, name, flags, ...
   1007           *
   1008           *  Parameters
   1009           *    sName        Pointer to a constant name string.
   1010           *    pBuffer      Pointer to a buffer to be used.
   1011           *    BufferSize   Size of the buffer.
   1012           *    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
   1013           *
   1014           *  Return value
   1015           *    >= 0 - O.K. Buffer Index
   1016           *     < 0 - Error
   1017           */

   \                                 In section .text, align 2, keep-with-next
   1018          int SEGGER_RTT_AllocDownBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags)
   1019          {
   \                     SEGGER_RTT_AllocDownBuffer: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x....'....        BL       ?Subroutine4
   1020            int BufferIndex;
   1021          
   1022            INIT();
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0x8   0xB908             CBNZ.N   R0,??SEGGER_RTT_AllocDownBuffer_0
   \        0xA   0x....'....        BL       _DoInit
   1023            SEGGER_RTT_LOCK();
   \                     ??SEGGER_RTT_AllocDownBuffer_0: (+1)
   \        0xE   0x....'....        BL       CORE_EnterAtomic
   \       0x12   0x4601             MOV      R1,R0
   1024            BufferIndex = 0;
   \       0x14   0x2700             MOVS     R7,#+0
   \       0x16   0x6972             LDR      R2,[R6, #+20]
   \       0x18   0x2318             MOVS     R3,#+24
   \       0x1A   0xF106 0x0C64      ADD      R12,R6,#+100
   1025            do {
   1026              if (_SEGGER_RTT.aDown[BufferIndex].pBuffer == NULL) {
   \                     ??SEGGER_RTT_AllocDownBuffer_1: (+1)
   \       0x1E   0xFB03 0xFE07      MUL      LR,R3,R7
   \       0x22   0xF85C 0x000E      LDR      R0,[R12, LR]
   \       0x26   0xB110             CBZ.N    R0,??SEGGER_RTT_AllocDownBuffer_2
   1027                break;
   1028              }
   1029              BufferIndex++;
   \       0x28   0x1C7F             ADDS     R7,R7,#+1
   1030            } while (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers);
   \       0x2A   0x4297             CMP      R7,R2
   \       0x2C   0xDBF7             BLT.N    ??SEGGER_RTT_AllocDownBuffer_1
   1031            if (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers) {
   \                     ??SEGGER_RTT_AllocDownBuffer_2: (+1)
   \       0x2E   0x4297             CMP      R7,R2
   \       0x30   0xDA0B             BGE.N    ??SEGGER_RTT_AllocDownBuffer_3
   1032              _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
   \       0x32   0x437B             MULS     R3,R3,R7
   1033              _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
   1034              _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
   1035              _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
   \       0x34   0x2200             MOVS     R2,#+0
   \       0x36   0x18F0             ADDS     R0,R6,R3
   \       0x38   0x6604             STR      R4,[R0, #+96]
   \       0x3A   0x6645             STR      R5,[R0, #+100]
   \       0x3C   0xF8C0 0x8068      STR      R8,[R0, #+104]
   \       0x40   0x6702             STR      R2,[R0, #+112]
   1036              _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
   \       0x42   0x66C2             STR      R2,[R0, #+108]
   1037              _SEGGER_RTT.aDown[BufferIndex].Flags        = Flags;
   \       0x44   0xF8C0 0x9074      STR      R9,[R0, #+116]
   \       0x48   0xE001             B.N      ??SEGGER_RTT_AllocDownBuffer_4
   1038            } else {
   1039              BufferIndex = -1;
   \                     ??SEGGER_RTT_AllocDownBuffer_3: (+1)
   \       0x4A   0xF04F 0x37FF      MOV      R7,#-1
   1040            }
   1041            SEGGER_RTT_UNLOCK();
   \                     ??SEGGER_RTT_AllocDownBuffer_4: (+1)
   \       0x4E   0x....             B.N      ?Subroutine0
   1042            return BufferIndex;
   1043          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x4608             MOV      R0,R1
   \        0x2   0x....'....        BL       CORE_ExitAtomic
   \        0x6   0x4638             MOV      R0,R7
   \        0x8   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0x....             LDR.N    R6,??DataTable12
   \        0x4   0x7830             LDRB     R0,[R6, #+0]
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4690             MOV      R8,R2
   \        0xA   0x4699             MOV      R9,R3
   \        0xC   0x4770             BX       LR
   1044          
   1045          /*********************************************************************
   1046           *
   1047           *       SEGGER_RTT_AllocUpBuffer
   1048           *
   1049           *  Function description
   1050           *    Run-time configuration of the next up-buffer (T->H).
   1051           *    The next buffer, which is not used yet is configured.
   1052           *    This includes: Buffer address, size, name, flags, ...
   1053           *
   1054           *  Parameters
   1055           *    sName        Pointer to a constant name string.
   1056           *    pBuffer      Pointer to a buffer to be used.
   1057           *    BufferSize   Size of the buffer.
   1058           *    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
   1059           *
   1060           *  Return value
   1061           *    >= 0 - O.K. Buffer Index
   1062           *     < 0 - Error
   1063           */

   \                                 In section .text, align 2, keep-with-next
   1064          int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags)
   1065          {
   \                     SEGGER_RTT_AllocUpBuffer: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x....'....        BL       ?Subroutine4
   1066            int BufferIndex;
   1067          
   1068            INIT();
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0x8   0xB908             CBNZ.N   R0,??SEGGER_RTT_AllocUpBuffer_0
   \        0xA   0x....'....        BL       _DoInit
   1069            SEGGER_RTT_LOCK();
   \                     ??SEGGER_RTT_AllocUpBuffer_0: (+1)
   \        0xE   0x....'....        BL       CORE_EnterAtomic
   \       0x12   0x4601             MOV      R1,R0
   1070            BufferIndex = 0;
   \       0x14   0x2700             MOVS     R7,#+0
   \       0x16   0x6932             LDR      R2,[R6, #+16]
   \       0x18   0x2318             MOVS     R3,#+24
   \       0x1A   0xF106 0x0C1C      ADD      R12,R6,#+28
   1071            do {
   1072              if (_SEGGER_RTT.aUp[BufferIndex].pBuffer == NULL) {
   \                     ??SEGGER_RTT_AllocUpBuffer_1: (+1)
   \       0x1E   0xFB03 0xFE07      MUL      LR,R3,R7
   \       0x22   0xF85C 0x000E      LDR      R0,[R12, LR]
   \       0x26   0xB110             CBZ.N    R0,??SEGGER_RTT_AllocUpBuffer_2
   1073                break;
   1074              }
   1075              BufferIndex++;
   \       0x28   0x1C7F             ADDS     R7,R7,#+1
   1076            } while (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers);
   \       0x2A   0x4297             CMP      R7,R2
   \       0x2C   0xDBF7             BLT.N    ??SEGGER_RTT_AllocUpBuffer_1
   1077            if (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers) {
   \                     ??SEGGER_RTT_AllocUpBuffer_2: (+1)
   \       0x2E   0x4297             CMP      R7,R2
   \       0x30   0xDA0B             BGE.N    ??SEGGER_RTT_AllocUpBuffer_3
   1078              _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
   \       0x32   0x437B             MULS     R3,R3,R7
   1079              _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
   1080              _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
   1081              _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
   \       0x34   0x2200             MOVS     R2,#+0
   \       0x36   0x18F0             ADDS     R0,R6,R3
   \       0x38   0x6184             STR      R4,[R0, #+24]
   \       0x3A   0x61C5             STR      R5,[R0, #+28]
   \       0x3C   0xF8C0 0x8020      STR      R8,[R0, #+32]
   \       0x40   0x6282             STR      R2,[R0, #+40]
   1082              _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
   \       0x42   0x6242             STR      R2,[R0, #+36]
   1083              _SEGGER_RTT.aUp[BufferIndex].Flags        = Flags;
   \       0x44   0xF8C0 0x902C      STR      R9,[R0, #+44]
   \       0x48   0xE001             B.N      ??SEGGER_RTT_AllocUpBuffer_4
   1084            } else {
   1085              BufferIndex = -1;
   \                     ??SEGGER_RTT_AllocUpBuffer_3: (+1)
   \       0x4A   0xF04F 0x37FF      MOV      R7,#-1
   1086            }
   1087            SEGGER_RTT_UNLOCK();
   \                     ??SEGGER_RTT_AllocUpBuffer_4: (+1)
   \       0x4E                      REQUIRE ?Subroutine0
   \       0x4E                      ;; // Fall through to label ?Subroutine0
   1088            return BufferIndex;
   1089          }
   1090          
   1091          /*********************************************************************
   1092           *
   1093           *       SEGGER_RTT_ConfigUpBuffer
   1094           *
   1095           *  Function description
   1096           *    Run-time configuration of a specific up-buffer (T->H).
   1097           *    Buffer to be configured is specified by index.
   1098           *    This includes: Buffer address, size, name, flags, ...
   1099           *
   1100           *  Parameters
   1101           *    BufferIndex  Index of the buffer to configure.
   1102           *    sName        Pointer to a constant name string.
   1103           *    pBuffer      Pointer to a buffer to be used.
   1104           *    BufferSize   Size of the buffer.
   1105           *    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
   1106           *
   1107           *  Return value
   1108           *    >= 0 - O.K.
   1109           *     < 0 - Error
   1110           */

   \                                 In section .text, align 2, keep-with-next
   1111          int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags)
   1112          {
   \                     SEGGER_RTT_ConfigUpBuffer: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine5
   1113            int r;
   1114          
   1115            INIT();
   \                     ??CrossCallReturnLabel_2: (+1)
   \        0x8   0xB908             CBNZ.N   R0,??SEGGER_RTT_ConfigUpBuffer_0
   \        0xA   0x....'....        BL       _DoInit
   1116            if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
   \                     ??SEGGER_RTT_ConfigUpBuffer_0: (+1)
   \        0xE   0x6938             LDR      R0,[R7, #+16]
   \       0x10   0x4284             CMP      R4,R0
   \       0x12   0xD212             BCS.N    ??SEGGER_RTT_ConfigUpBuffer_1
   1117              SEGGER_RTT_LOCK();
   \       0x14   0x....'....        BL       CORE_EnterAtomic
   1118              if (BufferIndex > 0u) {
   \       0x18   0x2118             MOVS     R1,#+24
   \       0x1A   0x4361             MULS     R1,R1,R4
   \       0x1C   0x187A             ADDS     R2,R7,R1
   \       0x1E   0xB134             CBZ.N    R4,??SEGGER_RTT_ConfigUpBuffer_2
   1119                _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
   \       0x20   0x6195             STR      R5,[R2, #+24]
   1120                _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
   \       0x22   0x61D6             STR      R6,[R2, #+28]
   1121                _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
   \       0x24   0xF8C2 0x8020      STR      R8,[R2, #+32]
   1122                _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x6291             STR      R1,[R2, #+40]
   1123                _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
   \       0x2C   0x6251             STR      R1,[R2, #+36]
   \                     ??SEGGER_RTT_ConfigUpBuffer_2: (+1)
   \       0x2E   0x9906             LDR      R1,[SP, #+24]
   1124              }
   1125              _SEGGER_RTT.aUp[BufferIndex].Flags          = Flags;
   \       0x30   0x62D1             STR      R1,[R2, #+44]
   1126              SEGGER_RTT_UNLOCK();
   \       0x32   0x....'....        BL       CORE_ExitAtomic
   1127              r =  0;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xE001             B.N      ??SEGGER_RTT_ConfigUpBuffer_3
   1128            } else {
   1129              r = -1;
   \                     ??SEGGER_RTT_ConfigUpBuffer_1: (+1)
   \       0x3A   0xF04F 0x30FF      MOV      R0,#-1
   1130            }
   1131            return r;
   \                     ??SEGGER_RTT_ConfigUpBuffer_3: (+1)
   \       0x3E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1132          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0x....             LDR.N    R7,??DataTable12
   \        0x4   0x7838             LDRB     R0,[R7, #+0]
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x4698             MOV      R8,R3
   \        0xC   0x4770             BX       LR
   1133          
   1134          /*********************************************************************
   1135           *
   1136           *       SEGGER_RTT_ConfigDownBuffer
   1137           *
   1138           *  Function description
   1139           *    Run-time configuration of a specific down-buffer (H->T).
   1140           *    Buffer to be configured is specified by index.
   1141           *    This includes: Buffer address, size, name, flags, ...
   1142           *
   1143           *  Parameters
   1144           *    BufferIndex  Index of the buffer to configure.
   1145           *    sName        Pointer to a constant name string.
   1146           *    pBuffer      Pointer to a buffer to be used.
   1147           *    BufferSize   Size of the buffer.
   1148           *    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
   1149           *
   1150           *  Return value
   1151           *    >= 0  O.K.
   1152           *     < 0  Error
   1153           */

   \                                 In section .text, align 2, keep-with-next
   1154          int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags)
   1155          {
   \                     SEGGER_RTT_ConfigDownBuffer: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine5
   1156            int r;
   1157          
   1158            INIT();
   \                     ??CrossCallReturnLabel_3: (+1)
   \        0x8   0xB908             CBNZ.N   R0,??SEGGER_RTT_ConfigDownBuffer_0
   \        0xA   0x....'....        BL       _DoInit
   1159            if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
   \                     ??SEGGER_RTT_ConfigDownBuffer_0: (+1)
   \        0xE   0x6978             LDR      R0,[R7, #+20]
   \       0x10   0x4284             CMP      R4,R0
   \       0x12   0xD212             BCS.N    ??SEGGER_RTT_ConfigDownBuffer_1
   1160              SEGGER_RTT_LOCK();
   \       0x14   0x....'....        BL       CORE_EnterAtomic
   1161              if (BufferIndex > 0u) {
   \       0x18   0x2118             MOVS     R1,#+24
   \       0x1A   0x4361             MULS     R1,R1,R4
   \       0x1C   0x187A             ADDS     R2,R7,R1
   \       0x1E   0xB134             CBZ.N    R4,??SEGGER_RTT_ConfigDownBuffer_2
   1162                _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
   1163                _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
   1164                _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
   1165                _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x6615             STR      R5,[R2, #+96]
   \       0x24   0x6656             STR      R6,[R2, #+100]
   \       0x26   0xF8C2 0x8068      STR      R8,[R2, #+104]
   \       0x2A   0x6711             STR      R1,[R2, #+112]
   1166                _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
   \       0x2C   0x66D1             STR      R1,[R2, #+108]
   \                     ??SEGGER_RTT_ConfigDownBuffer_2: (+1)
   \       0x2E   0x9906             LDR      R1,[SP, #+24]
   1167              }
   1168              _SEGGER_RTT.aDown[BufferIndex].Flags          = Flags;
   \       0x30   0x6751             STR      R1,[R2, #+116]
   1169              SEGGER_RTT_UNLOCK();
   \       0x32   0x....'....        BL       CORE_ExitAtomic
   1170              r =  0;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xE001             B.N      ??SEGGER_RTT_ConfigDownBuffer_3
   1171            } else {
   1172              r = -1;
   \                     ??SEGGER_RTT_ConfigDownBuffer_1: (+1)
   \       0x3A   0xF04F 0x30FF      MOV      R0,#-1
   1173            }
   1174            return r;
   \                     ??SEGGER_RTT_ConfigDownBuffer_3: (+1)
   \       0x3E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1175          }
   1176          
   1177          /*********************************************************************
   1178           *
   1179           *       SEGGER_RTT_SetNameUpBuffer
   1180           *
   1181           *  Function description
   1182           *    Run-time configuration of a specific up-buffer name (T->H).
   1183           *    Buffer to be configured is specified by index.
   1184           *
   1185           *  Parameters
   1186           *    BufferIndex  Index of the buffer to renamed.
   1187           *    sName        Pointer to a constant name string.
   1188           *
   1189           *  Return value
   1190           *    >= 0  O.K.
   1191           *     < 0  Error
   1192           */

   \                                 In section .text, align 2, keep-with-next
   1193          int SEGGER_RTT_SetNameUpBuffer(unsigned BufferIndex, const char* sName)
   1194          {
   \                     SEGGER_RTT_SetNameUpBuffer: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x....'....        BL       ?Subroutine6
   1195            int r;
   1196          
   1197            INIT();
   \                     ??CrossCallReturnLabel_4: (+1)
   \        0x6   0xB908             CBNZ.N   R0,??SEGGER_RTT_SetNameUpBuffer_0
   \        0x8   0x....'....        BL       _DoInit
   1198            if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
   \                     ??SEGGER_RTT_SetNameUpBuffer_0: (+1)
   \        0xC   0x6930             LDR      R0,[R6, #+16]
   \        0xE   0x4284             CMP      R4,R0
   \       0x10   0xD206             BCS.N    ??SEGGER_RTT_SetNameUpBuffer_1
   1199              SEGGER_RTT_LOCK();
   \       0x12   0x....'....        BL       CORE_EnterAtomic
   1200              _SEGGER_RTT.aUp[BufferIndex].sName = sName;
   \       0x16   0x2118             MOVS     R1,#+24
   \       0x18   0x434C             MULS     R4,R1,R4
   \       0x1A   0x1931             ADDS     R1,R6,R4
   \       0x1C   0x618D             STR      R5,[R1, #+24]
   1201              SEGGER_RTT_UNLOCK();
   \       0x1E   0x....             B.N      ?Subroutine2
   1202              r =  0;
   1203            } else {
   1204              r = -1;
   \                     ??SEGGER_RTT_SetNameUpBuffer_1: (+1)
   \       0x20   0x....             B.N      ?Subroutine3
   1205            }
   1206            return r;
   1207          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xF04F 0x30FF      MOV      R0,#-1
   \        0x4   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0x....             LDR.N    R6,??DataTable12
   \        0x4   0x7830             LDRB     R0,[R6, #+0]
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x....'....        BL       CORE_ExitAtomic
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xBD70             POP      {R4-R6,PC}
   1208          
   1209          /*********************************************************************
   1210           *
   1211           *       SEGGER_RTT_SetNameDownBuffer
   1212           *
   1213           *  Function description
   1214           *    Run-time configuration of a specific Down-buffer name (T->H).
   1215           *    Buffer to be configured is specified by index.
   1216           *
   1217           *  Parameters
   1218           *    BufferIndex  Index of the buffer to renamed.
   1219           *    sName        Pointer to a constant name string.
   1220           *
   1221           *  Return value
   1222           *    >= 0  O.K.
   1223           *     < 0  Error
   1224           */

   \                                 In section .text, align 2, keep-with-next
   1225          int SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName)
   1226          {
   \                     SEGGER_RTT_SetNameDownBuffer: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x....'....        BL       ?Subroutine6
   1227            int r;
   1228          
   1229            INIT();
   \                     ??CrossCallReturnLabel_5: (+1)
   \        0x6   0xB908             CBNZ.N   R0,??SEGGER_RTT_SetNameDownBuffer_0
   \        0x8   0x....'....        BL       _DoInit
   1230            if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
   \                     ??SEGGER_RTT_SetNameDownBuffer_0: (+1)
   \        0xC   0x6970             LDR      R0,[R6, #+20]
   \        0xE   0x4284             CMP      R4,R0
   \       0x10   0xD206             BCS.N    ??SEGGER_RTT_SetNameDownBuffer_1
   1231              SEGGER_RTT_LOCK();
   \       0x12   0x....'....        BL       CORE_EnterAtomic
   1232              _SEGGER_RTT.aDown[BufferIndex].sName = sName;
   \       0x16   0x2118             MOVS     R1,#+24
   \       0x18   0x434C             MULS     R4,R1,R4
   \       0x1A   0x1931             ADDS     R1,R6,R4
   \       0x1C   0x660D             STR      R5,[R1, #+96]
   1233              SEGGER_RTT_UNLOCK();
   \       0x1E   0x....             B.N      ?Subroutine2
   1234              r =  0;
   1235            } else {
   1236              r = -1;
   \                     ??SEGGER_RTT_SetNameDownBuffer_1: (+1)
   \       0x20                      REQUIRE ?Subroutine3
   \       0x20                      ;; // Fall through to label ?Subroutine3
   1237            }
   1238            return r;
   1239          }
   1240          
   1241          /*********************************************************************
   1242           *
   1243           *       SEGGER_RTT_Init
   1244           *
   1245           *  Function description
   1246           *    Initializes the RTT Control Block.
   1247           *    Should be used in RAM targets, at start of the application.
   1248           *
   1249           */

   \                                 In section .text, align 2, keep-with-next
   1250          void SEGGER_RTT_Init(void)
   1251          {
   1252            _DoInit();
   \                     SEGGER_RTT_Init: (+1)
   \        0x0   0x....             B.N      _DoInit
   1253          }
   1254          
   1255          /*********************************************************************
   1256           *
   1257           *       SEGGER_RTT_SetTerminal
   1258           *
   1259           *  Function description
   1260           *    Sets the terminal to be used for output on channel 0.
   1261           *
   1262           *  Parameters
   1263           *    TerminalId  Index of the terminal.
   1264           *
   1265           *  Return value
   1266           *    >= 0  O.K.
   1267           *     < 0  Error (e.g. if RTT is configured for non-blocking mode and there was no space in the buffer to set the new terminal Id)
   1268           */

   \                                 In section .text, align 2, keep-with-next
   1269          int SEGGER_RTT_SetTerminal(char TerminalId)
   1270          {
   \                     SEGGER_RTT_SetTerminal: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4605             MOV      R5,R0
   1271            char ac[2];
   1272            SEGGER_RTT_BUFFER_UP* pRing;
   1273            unsigned Avail;
   1274            int r;
   1275            //
   1276            INIT();
   \        0x6   0x....             LDR.N    R4,??DataTable12
   \        0x8   0x7820             LDRB     R0,[R4, #+0]
   \        0xA   0xB908             CBNZ.N   R0,??SEGGER_RTT_SetTerminal_0
   \        0xC   0x....'....        BL       _DoInit
   1277            //
   1278            r = 0;
   \                     ??SEGGER_RTT_SetTerminal_0: (+1)
   \       0x10   0x2600             MOVS     R6,#+0
   1279            ac[0] = (char) 0xFFU;
   \       0x12   0x20FF             MOVS     R0,#+255
   \       0x14   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1280            if ((unsigned char)TerminalId < (unsigned char)sizeof(_aTerminalId)) { // We only support a certain number of channels
   \       0x18   0xF04F 0x39FF      MOV      R9,#-1
   \       0x1C   0x2D10             CMP      R5,#+16
   \       0x1E   0xDA22             BGE.N    ??SEGGER_RTT_SetTerminal_1
   1281              ac[1] = (char) _aTerminalId[(unsigned char)TerminalId];
   \       0x20   0x....             LDR.N    R1,??DataTable12_6
   \       0x22   0x5D48             LDRB     R0,[R1, R5]
   \       0x24   0x....             LDR.N    R7,??DataTable12_7
   \       0x26   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1282              pRing = &_SEGGER_RTT.aUp[0];    // Buffer 0 is always reserved for terminal I/O, so we can use index 0 here, fixed
   1283              SEGGER_RTT_LOCK();    // Lock to make sure that no other task is writing into buffer, while we are and number of free bytes in buffer does not change downwards after checking and before writing
   \       0x2A   0x....'....        BL       CORE_EnterAtomic
   \       0x2E   0x4680             MOV      R8,R0
   1284              if ((pRing->Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
   \       0x30   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \       0x34   0xF000 0x0003      AND      R0,R0,#0x3
   \       0x38   0x2802             CMP      R0,#+2
   \       0x3A   0xD104             BNE.N    ??SEGGER_RTT_SetTerminal_2
   1285                _ActiveTerminal = TerminalId;
   \       0x3C   0x....'....        BL       ?Subroutine9
   1286                (void) _WriteBlocking(pRing, ac, 2u);
   1287              } else {                                                                            // Skipping mode or trim mode? => We cannot trim this command so handling is the same for both modes
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x40   0x....'....        BL       _WriteBlocking
   \       0x44   0xE00B             B.N      ??SEGGER_RTT_SetTerminal_3
   1288                Avail = _GetAvailWriteSpace(pRing);
   1289                if (Avail >= 2u) {
   \                     ??SEGGER_RTT_SetTerminal_2: (+1)
   \       0x46   0xF104 0x0018      ADD      R0,R4,#+24
   \       0x4A   0x....'....        BL       _GetAvailWriteSpace
   \       0x4E   0x2802             CMP      R0,#+2
   \       0x50   0xD304             BCC.N    ??SEGGER_RTT_SetTerminal_4
   1290                  _ActiveTerminal = TerminalId;    // Only change active terminal in case of success
   \       0x52   0x....'....        BL       ?Subroutine9
   1291                  _WriteNoCheck(pRing, ac, 2u);
   1292                } else {
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x56   0x....'....        BL       _WriteNoCheck
   \       0x5A   0xE000             B.N      ??SEGGER_RTT_SetTerminal_3
   1293                  r = -1;
   \                     ??SEGGER_RTT_SetTerminal_4: (+1)
   \       0x5C   0x464E             MOV      R6,R9
   1294                }
   1295              }
   1296              SEGGER_RTT_UNLOCK();
   \                     ??SEGGER_RTT_SetTerminal_3: (+1)
   \       0x5E   0x4640             MOV      R0,R8
   \       0x60   0x....'....        BL       CORE_ExitAtomic
   \       0x64   0xE000             B.N      ??SEGGER_RTT_SetTerminal_5
   1297            } else {
   1298              r = -1;
   \                     ??SEGGER_RTT_SetTerminal_1: (+1)
   \       0x66   0x464E             MOV      R6,R9
   1299            }
   1300            return r;
   \                     ??SEGGER_RTT_SetTerminal_5: (+1)
   \       0x68   0x4630             MOV      R0,R6
   \       0x6A   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1301          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x703D             STRB     R5,[R7, #+0]
   \        0x2   0x2202             MOVS     R2,#+2
   \        0x4   0x4669             MOV      R1,SP
   \        0x6   0xF104 0x0018      ADD      R0,R4,#+24
   \        0xA   0x4770             BX       LR
   1302          
   1303          /*********************************************************************
   1304           *
   1305           *       SEGGER_RTT_TerminalOut
   1306           *
   1307           *  Function description
   1308           *    Writes a string to the given terminal
   1309           *     without changing the terminal for channel 0.
   1310           *
   1311           *  Parameters
   1312           *    TerminalId   Index of the terminal.
   1313           *    s            String to be printed on the terminal.
   1314           *
   1315           *  Return value
   1316           *    >= 0 - Number of bytes written.
   1317           *     < 0 - Error.
   1318           *
   1319           */

   \                                 In section .text, align 2, keep-with-next
   1320          int SEGGER_RTT_TerminalOut(char TerminalId, const char* s)
   1321          {
   \                     SEGGER_RTT_TerminalOut: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4605             MOV      R5,R0
   1322            int Status;
   1323            unsigned FragLen;
   1324            unsigned Avail;
   1325            SEGGER_RTT_BUFFER_UP* pRing;
   1326            //
   1327            INIT();
   \        0x6   0x....             LDR.N    R4,??DataTable12
   \        0x8   0x7820             LDRB     R0,[R4, #+0]
   \        0xA   0x468A             MOV      R10,R1
   \        0xC   0xB908             CBNZ.N   R0,??SEGGER_RTT_TerminalOut_0
   \        0xE   0x....'....        BL       _DoInit
   1328            //
   1329            // Validate terminal ID.
   1330            //
   1331            if (TerminalId < (char)sizeof(_aTerminalId)) { // We only support a certain number of channels
   \                     ??SEGGER_RTT_TerminalOut_0: (+1)
   \       0x12   0xF04F 0x3BFF      MOV      R11,#-1
   \       0x16   0x2D10             CMP      R5,#+16
   \       0x18   0xDA36             BGE.N    ??SEGGER_RTT_TerminalOut_1
   1332              //
   1333              // Get "to-host" ring buffer.
   1334              //
   1335              pRing = &_SEGGER_RTT.aUp[0];
   1336              //
   1337              // Need to be able to change terminal, write data, change back.
   1338              // Compute the fixed and variable sizes.
   1339              //
   1340              FragLen = strlen(s);
   \       0x1A   0x4650             MOV      R0,R10
   \       0x1C   0x....'....        BL       strlen
   \       0x20   0x4680             MOV      R8,R0
   1341              //
   1342              // How we output depends upon the mode...
   1343              //
   1344              SEGGER_RTT_LOCK();
   \       0x22   0x....'....        BL       CORE_EnterAtomic
   \       0x26   0x4681             MOV      R9,R0
   1345              Avail = _GetAvailWriteSpace(pRing);
   \       0x28   0xF104 0x0018      ADD      R0,R4,#+24
   \       0x2C   0x....'....        BL       _GetAvailWriteSpace
   \       0x30   0x4606             MOV      R6,R0
   1346              switch (pRing->Flags & SEGGER_RTT_MODE_MASK) {
   \       0x32   0xF894 0x002C      LDRB     R0,[R4, #+44]
   \       0x36   0x....             LDR.N    R7,??DataTable12_7
   \       0x38   0xF010 0x0003      ANDS     R0,R0,#0x3
   \       0x3C   0xD003             BEQ.N    ??SEGGER_RTT_TerminalOut_2
   \       0x3E   0x2802             CMP      R0,#+2
   \       0x40   0xD011             BEQ.N    ??SEGGER_RTT_TerminalOut_3
   \       0x42   0xD307             BCC.N    ??SEGGER_RTT_TerminalOut_4
   \       0x44   0xE01D             B.N      ??SEGGER_RTT_TerminalOut_5
   1347                case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
   1348                  //
   1349                  // If we are in skip mode and there is no space for the whole
   1350                  // of this output, don't bother switching terminals at all.
   1351                  //
   1352                  if (Avail < (FragLen + 4u)) {
   \                     ??SEGGER_RTT_TerminalOut_2: (+1)
   \       0x46   0xF108 0x0104      ADD      R1,R8,#+4
   \       0x4A   0x428E             CMP      R6,R1
   \       0x4C   0xD20B             BCS.N    ??SEGGER_RTT_TerminalOut_3
   1353                    Status = 0;
   \       0x4E   0xF04F 0x0B00      MOV      R11,#+0
   \       0x52   0xE016             B.N      ??SEGGER_RTT_TerminalOut_5
   1354                  } else {
   1355                    _PostTerminalSwitch(pRing, (unsigned char) TerminalId);
   1356                    Status = (int)_WriteBlocking(pRing, s, FragLen);
   1357                    _PostTerminalSwitch(pRing, (unsigned char) _ActiveTerminal);
   1358                  }
   1359                  break;
   1360                case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
   1361                  //
   1362                  // If we are in trim mode and there is not enough space for everything,
   1363                  // trim the output but always include the terminal switch.  If no room
   1364                  // for terminal switch, skip that totally.
   1365                  //
   1366                  if (Avail < 4u) {
   \                     ??SEGGER_RTT_TerminalOut_4: (+1)
   \       0x54   0x2E03             CMP      R6,#+3
   \       0x56   0xD914             BLS.N    ??SEGGER_RTT_TerminalOut_5
   1367                    Status = -1;
   1368                  } else {
   1369                    _PostTerminalSwitch(pRing, (unsigned char) TerminalId);
   \       0x58   0x....'....        BL       ?Subroutine8
   1370                    Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x5C   0x1F36             SUBS     R6,R6,#+4
   \       0x5E   0x45B0             CMP      R8,R6
   \       0x60   0xD903             BLS.N    ??CrossCallReturnLabel_8
   \       0x62   0x46B0             MOV      R8,R6
   \       0x64   0xE001             B.N      ??CrossCallReturnLabel_8
   1371                    _PostTerminalSwitch(pRing, (unsigned char) _ActiveTerminal);
   1372                  }
   1373                  break;
   1374                case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
   1375                  //
   1376                  // If we are in blocking mode, output everything.
   1377                  //
   1378                  _PostTerminalSwitch(pRing, (unsigned char) TerminalId);
   \                     ??SEGGER_RTT_TerminalOut_3: (+1)
   \       0x66   0x....'....        BL       ?Subroutine8
   1379                  Status = (int)_WriteBlocking(pRing, s, FragLen);
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x6A   0x4642             MOV      R2,R8
   \       0x6C   0x4651             MOV      R1,R10
   \       0x6E   0xF104 0x0018      ADD      R0,R4,#+24
   \       0x72   0x....'....        BL       _WriteBlocking
   1380                  _PostTerminalSwitch(pRing, (unsigned char) _ActiveTerminal);
   \       0x76   0x7839             LDRB     R1,[R7, #+0]
   \       0x78   0x4683             MOV      R11,R0
   \       0x7A   0xF104 0x0018      ADD      R0,R4,#+24
   \       0x7E   0x....'....        BL       _PostTerminalSwitch
   1381                  break;
   1382                default:
   1383                  Status = -1;
   1384                  break;
   1385              }
   1386              //
   1387              // Finish up.
   1388              //
   1389              SEGGER_RTT_UNLOCK();
   \                     ??SEGGER_RTT_TerminalOut_5: (+1)
   \       0x82   0x4648             MOV      R0,R9
   \       0x84   0x....'....        BL       CORE_ExitAtomic
   1390            } else {
   1391              Status = -1;
   1392            }
   1393            return Status;
   \                     ??SEGGER_RTT_TerminalOut_1: (+1)
   \       0x88   0x4658             MOV      R0,R11
   \       0x8A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1394          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x4629             MOV      R1,R5
   \        0x2   0xF104 0x0018      ADD      R0,R4,#+24
   \        0x6   0x....             B.N      _PostTerminalSwitch

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x....'....        DC32     _SEGGER_RTT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0x....'....        DC32     _acUpBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0x....'....        DC32     _acDownBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \        0x0   0x....'....        DC32     _aTerminalId

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \        0x0   0x....'....        DC32     _ActiveTerminal

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x54 0x65          DC8 "Terminal"
   \              0x72 0x6D    
   \              0x69 0x6E    
   \              0x61 0x6C    
   \              0x00         
   \        0x9   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x52 0x54          DC8 "RTT"
   \              0x54 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x53 0x45          DC8 "SEGGER"
   \              0x47 0x47    
   \              0x45 0x52    
   \              0x00         
   \        0x7   0x00               DC8 0
   1395          
   1396          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   SEGGER_RTT_AllocDownBuffer
        32   -> CORE_EnterAtomic
        32   -> CORE_ExitAtomic
        32   -> _DoInit
      32   SEGGER_RTT_AllocUpBuffer
        32   -> CORE_EnterAtomic
        32   -> CORE_ExitAtomic
        32   -> _DoInit
      24   SEGGER_RTT_ConfigDownBuffer
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> _DoInit
      24   SEGGER_RTT_ConfigUpBuffer
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> _DoInit
       8   SEGGER_RTT_GetKey
         8   -> SEGGER_RTT_Read
       0   SEGGER_RTT_HasData
       8   SEGGER_RTT_HasKey
         8   -> _DoInit
       0   SEGGER_RTT_Init
         0   -> _DoInit
      24   SEGGER_RTT_Read
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> SEGGER_RTT_ReadNoLock
      32   SEGGER_RTT_ReadNoLock
        32   -> _DoInit
        32   -> __aeabi_memcpy
      16   SEGGER_RTT_SetNameDownBuffer
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
        16   -> _DoInit
      16   SEGGER_RTT_SetNameUpBuffer
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
        16   -> _DoInit
      32   SEGGER_RTT_SetTerminal
        32   -> CORE_EnterAtomic
        32   -> CORE_ExitAtomic
        32   -> _DoInit
        32   -> _GetAvailWriteSpace
        32   -> _WriteBlocking
        32   -> _WriteNoCheck
      40   SEGGER_RTT_TerminalOut
        40   -> CORE_EnterAtomic
        40   -> CORE_ExitAtomic
        40   -> _DoInit
        40   -> _GetAvailWriteSpace
        40   -> _PostTerminalSwitch
        40   -> _WriteBlocking
        40   -> strlen
       8   SEGGER_RTT_WaitKey
         8   -> SEGGER_RTT_GetKey
      24   SEGGER_RTT_Write
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> SEGGER_RTT_WriteNoLock
        24   -> _DoInit
      16   SEGGER_RTT_WriteNoLock
        16   -> _GetAvailWriteSpace
        16   -> _WriteBlocking
        16   -> _WriteNoCheck
      24   SEGGER_RTT_WriteSkipNoLock
        24   -> __aeabi_memcpy
      16   SEGGER_RTT_WriteString
         0   -> SEGGER_RTT_Write
        16   -> strlen
      24   SEGGER_RTT_WriteWithOverwriteNoLock
        24   -> __aeabi_memcpy
       8   _DoInit
         8   -> strcpy
       0   _GetAvailWriteSpace
       8   _PostTerminalSwitch
         8   -> _WriteBlocking
      32   _WriteBlocking
        32   -> __aeabi_memcpy
      24   _WriteNoCheck
        24   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
      12  ?Subroutine0
      12  ?Subroutine1
       8  ?Subroutine2
       6  ?Subroutine3
      14  ?Subroutine4
      14  ?Subroutine5
      10  ?Subroutine6
      18  ?Subroutine7
       8  ?Subroutine8
      12  ?Subroutine9
      12  ?_0
       4  ?_1
       8  ?_2
      80  SEGGER_RTT_AllocDownBuffer
      78  SEGGER_RTT_AllocUpBuffer
      66  SEGGER_RTT_ConfigDownBuffer
      66  SEGGER_RTT_ConfigUpBuffer
      28  SEGGER_RTT_GetKey
      20  SEGGER_RTT_HasData
      28  SEGGER_RTT_HasKey
       2  SEGGER_RTT_Init
      26  SEGGER_RTT_Read
     116  SEGGER_RTT_ReadNoLock
      32  SEGGER_RTT_SetNameDownBuffer
      34  SEGGER_RTT_SetNameUpBuffer
     110  SEGGER_RTT_SetTerminal
     142  SEGGER_RTT_TerminalOut
      12  SEGGER_RTT_WaitKey
      36  SEGGER_RTT_Write
      76  SEGGER_RTT_WriteNoLock
     132  SEGGER_RTT_WriteSkipNoLock
      24  SEGGER_RTT_WriteString
     138  SEGGER_RTT_WriteWithOverwriteNoLock
       1  _ActiveTerminal
      82  _DoInit
      26  _GetAvailWriteSpace
      28  _PostTerminalSwitch
     168  _SEGGER_RTT
      84  _WriteBlocking
      58  _WriteNoCheck
      16  _aTerminalId
      16  _acDownBuffer
      16  _acUpBuffer

 
   201 bytes in section .bss
    16 bytes in section .data
    24 bytes in section .rodata
 1 670 bytes in section .text
 
 1 670 bytes of CODE  memory
    24 bytes of CONST memory
   217 bytes of DATA  memory

Errors: none
Warnings: none
