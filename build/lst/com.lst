###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:30
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\plugin\serial\cortexm\efm32\com.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EWFBA9.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\plugin\serial\cortexm\efm32\com.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"com.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0 -D
#        LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D EMBER_AF_USE_HWCONF
#        -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\plugin\serial\cortexm\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\com.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\com.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\plugin\serial\cortexm\efm32\com.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief COM Layer.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc. Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement. This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          #include PLATFORM_HEADER
     18          #include "stack/include/ember-types.h"
     19          #include "stack/include/error.h"
     20          
     21          #include "hal/hal.h"
     22          
     23          #include <stdarg.h>
     24          
     25          #ifdef CORTEXM3_EFM32_MICRO
     26          #include "em_device.h"
     27          #include "em_usart.h"
     28          #include "em_core.h"
     29          #endif
     30          
     31          #include "serial/com.h"
     32          #include "serial/com_config.h"
     33          #include "serial/ember-printf.h"
     34          
     35          // Set COM_UART_ENABLE if at least one UART is enabled
     36          #if (defined(COM_USART0_ENABLE)  \
     37            || defined(COM_USART1_ENABLE)  \
     38            || defined(COM_USART2_ENABLE)  \
     39            || defined(COM_USART3_ENABLE)  \
     40            || defined(COM_LEUART0_ENABLE) \
     41            || defined(COM_LEUART1_ENABLE))
     42          #define COM_UART_ENABLE
     43          #endif
     44          
     45          #if defined (COM_VCP_ENABLE) || defined (COM_UART_ENABLE)
     46          // Only include code if COM ports are enabled. Stub functions out otherwise.
     47          
     48          // --------------------------------
     49          // Static declarations
     50          static inline bool checkValidPort(COM_Port_t port);
     51          static bool checkValidThresholds(COM_Handle_t comhandle);
     52          static void dequeueFifoBuffer(COM_Handle_t comhandle, uint16_t count);
     53          static COM_Handle_t getComHandleFromPort(COM_Port_t port);
     54          static inline bool getOutputFifoSpace(COM_Handle_t comhandle, uint8_t extraByteCount);
     55          static inline bool getInputFifoSpace(COM_Handle_t comhandle, uint8_t extraByteCount);
     56          static Ecode_t setComHandleQueues(COM_Port_t port);
     57          static void txBuffer(COM_Port_t port, uint8_t *data, uint16_t length);
     58          static void updateBuffer(COM_FifoQueue_t *q, uint16_t xferred, uint16_t size);
     59          
     60          #if defined(COM_VCP_ENABLE)
     61          static inline bool checkValidVcpPort(COM_Port_t port);
     62          
     63          #endif
     64          
     65          #if defined(COM_UART_ENABLE)
     66          static inline bool checkValidUartPort(COM_Port_t port);
     67          static void enableRxIrq(COM_Port_t port, bool enable);
     68          static UARTDRV_Handle_t getUartHandleFromPort(COM_Port_t port);
     69          static void rxCallback(UARTDRV_Handle_t handle,
     70                                 Ecode_t transferStatus,
     71                                 uint8_t *data,
     72                                 UARTDRV_Count_t transferCount);
     73          static void rxNextBuffer(COM_Handle_t handle);
     74          static Ecode_t setUartBufferQueues(COM_Port_t port, COM_Init_t * init);
     75          static void txCatchUp(COM_Handle_t comhandle);
     76          static void txCallback(UARTDRV_Handle_t handle,
     77                                 Ecode_t transferStatus,
     78                                 uint8_t *data,
     79                                 UARTDRV_Count_t transferCount);
     80          
     81          #endif
     82          
     83          #if HAL_SERIAL_RXWAKE_ENABLE
     84          static void rxGpioIntEnable(void);
     85          static void rxGpioIntDisable(void);
     86          #endif
     87          /* Initialization data and buffer queues */
     88          
     89          // -------------------------------------------------------------------------
     90          // The macro DEFINE_BUF_QUEUE() can only be used for static definition of
     91          // buffer queues, which includes a struct typedef. Since it is always used
     92          // in a standalone fashion, this expansion will not interfere with any other
     93          // logic and does not require enclosing parentheses
     94          // -------------------------------------------------------------------------
     95          #ifdef COM_VCP_ENABLE
     96          //add VCP support
     97            #include "hal/plugin/debug-jtag/debug-channel.h"
     98          
     99          /* FIFO Buffers */
    100          DEFINE_FIFO_QUEUE(COM_VCP_RX_QUEUE_SIZE, comFifoQueueRxVcp)
    101          DEFINE_FIFO_QUEUE(COM_VCP_TX_QUEUE_SIZE, comFifoQueueTxVcp)
    102          #endif //COM_VCP_ENABLE
    103          
    104          #ifdef COM_USART0_ENABLE
    105          
    106          /* UARTDRV buffer queues */

   \                                 In section .data, align 4
    107          DEFINE_BUF_QUEUE(EMDRV_UARTDRV_MAX_CONCURRENT_RX_BUFS, comBufferQueueRxUsart0);
   \                     comBufferQueueRxUsart0:
   \        0x0   0x0000 0x0000      DC16 0, 0, 0, 6
   \               0x0000 0x000
   \              6            
   \        0x8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x18   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x28   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x38   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x48   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x58   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x68   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x78   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
    108          DEFINE_BUF_QUEUE(EMDRV_UARTDRV_MAX_CONCURRENT_TX_BUFS, comBufferQueueTxUsart0);
   \                     comBufferQueueTxUsart0:
   \        0x0   0x0000 0x0000      DC16 0, 0, 0, 6
   \               0x0000 0x000
   \              6            
   \        0x8   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x18   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x28   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x38   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x48   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x58   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x68   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \       0x78   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    109          
    110          /* COM FIFO Buffers */

   \                                 In section .bss, align 4
    111          DEFINE_FIFO_QUEUE(COM_USART0_RX_QUEUE_SIZE, comFifoQueueRxUsart0)
   \                     comFifoQueueRxUsart0:
   \        0x0                      DS8 136

   \                                 In section .bss, align 4
    112          DEFINE_FIFO_QUEUE(COM_USART0_TX_QUEUE_SIZE, comFifoQueueTxUsart0)
   \                     comFifoQueueTxUsart0:
   \        0x0                      DS8 136
    113          #endif
    114          
    115          #ifdef COM_USART1_ENABLE
    116          
    117          /* UARTDRV buffer queues */
    118          DEFINE_BUF_QUEUE(EMDRV_UARTDRV_MAX_CONCURRENT_RX_BUFS, comBufferQueueRxUsart1);
    119          DEFINE_BUF_QUEUE(EMDRV_UARTDRV_MAX_CONCURRENT_TX_BUFS, comBufferQueueTxUsart1);
    120          
    121          /* COM FIFO Buffers */
    122          DEFINE_FIFO_QUEUE(COM_USART1_RX_QUEUE_SIZE, comFifoQueueRxUsart1)
    123          DEFINE_FIFO_QUEUE(COM_USART1_TX_QUEUE_SIZE, comFifoQueueTxUsart1)
    124          #endif
    125          
    126          #ifdef COM_USART2_ENABLE
    127          
    128          /* UARTDRV buffer queues */
    129          DEFINE_BUF_QUEUE(EMDRV_UARTDRV_MAX_CONCURRENT_RX_BUFS, comBufferQueueRxUsart2);
    130          DEFINE_BUF_QUEUE(EMDRV_UARTDRV_MAX_CONCURRENT_TX_BUFS, comBufferQueueTxUsart2);
    131          
    132          /* COM FIFO Buffers */
    133          DEFINE_FIFO_QUEUE(COM_USART2_RX_QUEUE_SIZE, comFifoQueueRxUsart2)
    134          DEFINE_FIFO_QUEUE(COM_USART2_TX_QUEUE_SIZE, comFifoQueueTxUsart2)
    135          #endif
    136          
    137          #ifdef COM_USART3_ENABLE
    138          
    139          /* UARTDRV buffer queues */
    140          DEFINE_BUF_QUEUE(EMDRV_UARTDRV_MAX_CONCURRENT_RX_BUFS, comBufferQueueRxUsart3);
    141          DEFINE_BUF_QUEUE(EMDRV_UARTDRV_MAX_CONCURRENT_TX_BUFS, comBufferQueueTxUsart3);
    142          
    143          /* COM FIFO Buffers */
    144          DEFINE_FIFO_QUEUE(COM_USART3_RX_QUEUE_SIZE, comFifoQueueRxUsart3)
    145          DEFINE_FIFO_QUEUE(COM_USART3_TX_QUEUE_SIZE, comFifoQueueTxUsart3)
    146          #endif
    147          
    148          #ifdef COM_USB_ENABLE
    149          
    150          /* COM FIFO Buffers */
    151          DEFINE_FIFO_QUEUE(COM_USB_RX_QUEUE_SIZE, comFifoQueueRxUsb)
    152          DEFINE_FIFO_QUEUE(COM_USB_TX_QUEUE_SIZE, comFifoQueueTxUsb)
    153          #endif
    154          
    155          #ifdef COM_LEUART0_ENABLE
    156          
    157          /* UARTDRV buffer queues */
    158          DEFINE_BUF_QUEUE(EMDRV_UARTDRV_MAX_CONCURRENT_RX_BUFS, comBufferQueueRxLeuart0);
    159          DEFINE_BUF_QUEUE(EMDRV_UARTDRV_MAX_CONCURRENT_TX_BUFS, comBufferQueueTxLeuart0);
    160          
    161          /* COM FIFO Buffers */
    162          DEFINE_FIFO_QUEUE(COM_LEUART0_RX_QUEUE_SIZE, comFifoQueueRxLeuart0)
    163          DEFINE_FIFO_QUEUE(COM_LEUART0_TX_QUEUE_SIZE, comFifoQueueTxLeuart0)
    164          #endif
    165          
    166          #ifdef COM_LEUART1_ENABLE
    167          
    168          /* UARTDRV buffer queues */
    169          DEFINE_BUF_QUEUE(EMDRV_UARTDRV_MAX_CONCURRENT_RX_BUFS, comBufferQueueRxLeuart1);
    170          DEFINE_BUF_QUEUE(EMDRV_UARTDRV_MAX_CONCURRENT_TX_BUFS, comBufferQueueTxLeuart1);
    171          
    172          /* COM FIFO Buffers */
    173          DEFINE_FIFO_QUEUE(COM_LEUART1_RX_QUEUE_SIZE, comFifoQueueRxLeuart1)
    174          DEFINE_FIFO_QUEUE(COM_LEUART1_TX_QUEUE_SIZE, comFifoQueueTxLeuart1)
    175          #endif
    176          // -------------------------------------------------------------------------
    177          // -------------------------------------------------------------------------
    178          // --------------------------------
    179          // COM handle array indexes
    180          typedef enum COM_HandleIndex {
    181          #ifdef COM_VCP_ENABLE
    182            comHandleIndexVcp,
    183          #endif
    184          #ifdef COM_USART0_ENABLE
    185            comHandleIndexUsart0,
    186          #endif
    187          #ifdef COM_USART1_ENABLE
    188            comHandleIndexUsart1,
    189          #endif
    190          #ifdef COM_USART2_ENABLE
    191            comHandleIndexUsart2,
    192          #endif
    193          #ifdef COM_USART3_ENABLE
    194            comHandleIndexUsart3,
    195          #endif
    196          #ifdef COM_USB_ENABLE
    197            comHandleIndexUsb,
    198          #endif
    199          #ifdef COM_LEUART0_ENABLE
    200            comHandleIndexLeuart0,
    201          #endif
    202          #ifdef COM_LEUART1_ENABLE
    203            comHandleIndexLeuart1,
    204          #endif
    205            comHandleIndexSize
    206          } COM_HandleIndex_t;
    207          // COM handles

   \                                 In section .bss, align 4
    208          static COM_HandleData_t comhandledata[comHandleIndexSize];
   \                     comhandledata:
   \        0x0                      DS8 28
    209          
    210          // --------------------------------
    211          // UART handle array indexes
    212          #if defined(COM_UART_ENABLE)
    213          typedef enum COM_UartHandleIndex {
    214          #ifdef COM_USART0_ENABLE
    215            comUartHandleIndexUsart0,
    216          #endif
    217          #ifdef COM_USART1_ENABLE
    218            comUartHandleIndexUsart1,
    219          #endif
    220          #ifdef COM_USART2_ENABLE
    221            comUartHandleIndexUsart2,
    222          #endif
    223          #ifdef COM_USART3_ENABLE
    224            comUartHandleIndexUsart3,
    225          #endif
    226          #ifdef COM_LEUART0_ENABLE
    227            comUartHandleIndexLeuart0,
    228          #endif
    229          #ifdef COM_LEUART1_ENABLE
    230            comUartHandleIndexLeuart1,
    231          #endif
    232            comUartHandleIndexSize
    233          } COM_UartHandleIndex_t;
    234          // UART handles

   \                                 In section .bss, align 4
    235          static UARTDRV_HandleData_t uarthandledata[comUartHandleIndexSize];
   \                     uarthandledata:
   \        0x0                      DS8 52
    236          #endif
    237          
    238          // DMA interrupt state

   \                                 In section .bss, align 4
    239          uint32_t dma_IEN;
   \                     dma_IEN:
   \        0x0                      DS8 4
    240          
    241          static inline bool checkValidPort(COM_Port_t port)
    242          {
    243            switch (port) {
    244          #ifdef COM_VCP_ENABLE
    245              case COM_VCP:
    246              case comPortVcp:
    247                return true;
    248          #endif
    249          #ifdef COM_USART0_ENABLE
    250              case COM_USART0:
    251              case comPortUsart0:
    252                return true;
    253          #endif
    254          #ifdef COM_USART1_ENABLE
    255              case COM_USART1:
    256              case comPortUsart1:
    257                return true;
    258          #endif
    259          #ifdef COM_USART2_ENABLE
    260              case COM_USART2:
    261              case comPortUsart2:
    262                return true;
    263          #endif
    264          #ifdef COM_USART3_ENABLE
    265              case comPortUsart3:
    266                return true;
    267          #endif
    268          #ifdef COM_USB_ENABLE
    269              case COM_USB:
    270              case comPortUsb:
    271                return true;
    272          #endif
    273          #ifdef COM_LEUART0_ENABLE
    274              case COM_LEUART0:
    275              case comPortLeuart0:
    276                return true;
    277          #endif
    278          #ifdef COM_LEUART1_ENABLE
    279              case COM_LEUART1:
    280              case comPortLeuart1:
    281                return true;
    282          #endif
    283              default:
    284                return false;
    285            }
    286          }
    287          
    288          static bool checkValidThresholds(COM_Handle_t comhandle)
    289          {
    290            // COM will issue an XOFF when free buffer space <= rxStop bytes and an XON
    291            // when free buffer space >= rxStart bytes.
    292            // Stop threshold must be lower than the start threshold or else it's
    293            // unclear whether or not to start/stop when buffer is in between.
    294            if (comhandle->rxStart < comhandle->rxStop) {
    295              return false;
    296            }
    297          
    298            // Start threshold and size must be multiples of the stop threshold unless
    299            // using software flow control.
    300            if ( (comhandle->uarthandle->fcType != uartdrvFlowControlSw)
    301                 && ( (comhandle->rxsize % comhandle->rxStop != 0)
    302                      || (comhandle->rxStart % comhandle->rxStop != 0) ) ) {
    303              return false;
    304            }
    305          
    306            // return true if no bad configuration found
    307            return true;
    308          }
    309          
    310          static void dequeueFifoBuffer(COM_Handle_t comhandle, uint16_t count)
    311          {
    312            CORE_DECLARE_IRQ_STATE;
    313            CORE_ENTER_ATOMIC();
    314            FIFO_DEQUEUE_MULTIPLE(comhandle->txQueue, comhandle->txsize, count);
    315            CORE_EXIT_ATOMIC();
    316          }
    317          
    318          /**
    319           * @brief Convert a COM_Port_t into a pointer to COM handle
    320           *
    321           * @param[in] port COM port number
    322           *
    323           * @return Pointer to COM handle
    324           */

   \                                 In section .text, align 2, keep-with-next
    325          static COM_Handle_t getComHandleFromPort(COM_Port_t port)
    326          {
    327            size_t index;
    328          
    329            switch (port) {
   \                     getComHandleFromPort: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xB510             PUSH     {R4,LR}
   \        0x4   0x....'....        LDR.W    R4,??DataTable10
   \        0x8   0xBF18             IT       NE 
   \        0xA   0x2820             CMPNE    R0,#+32
   \        0xC   0xD005             BEQ.N    ??getComHandleFromPort_0
    330          #ifdef COM_VCP_ENABLE
    331              case COM_VCP:
    332              case comPortVcp:
    333                index = comHandleIndexVcp;
    334                break;
    335          #endif
    336          #ifdef COM_USART0_ENABLE
    337              case COM_USART0:
    338              case comPortUsart0:
    339                index = comHandleIndexUsart0;
    340                break;
    341          #endif
    342          #ifdef COM_USART1_ENABLE
    343              case COM_USART1:
    344              case comPortUsart1:
    345                index = comHandleIndexUsart1;
    346                break;
    347          #endif
    348          #ifdef COM_USART2_ENABLE
    349              case COM_USART2:
    350              case comPortUsart2:
    351                index = comHandleIndexUsart2;
    352                break;
    353          #endif
    354          #ifdef COM_USART3_ENABLE
    355              case comPortUsart3:
    356                index = comHandleIndexUsart3;
    357                break;
    358          #endif
    359          #ifdef COM_USB_ENABLE
    360              case COM_USB:
    361              case comPortUsb:
    362                index = comHandleIndexUsart0;
    363                break;
    364          #endif
    365          #ifdef COM_LEUART0_ENABLE
    366              case COM_LEUART0:
    367              case comPortLeuart0:
    368                index = comHandleIndexLeuart0;
    369                break;
    370          #endif
    371          #ifdef COM_LEUART1_ENABLE
    372              case COM_LEUART1:
    373              case comPortLeuart1:
    374                index = comHandleIndexLeuart1;
    375                break;
    376          #endif
    377              default:
    378                assert(false);
   \        0xE   0xF44F 0x71BD      MOV      R1,#+378
   \       0x12   0x....'....        LDR.W    R0,??DataTable10_1
   \       0x16   0x....'....        BL       halInternalAssertFailed
    379                // Will never reach this line
    380                return comhandledata;
   \                     ??getComHandleFromPort_0: (+1)
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0xBD10             POP      {R4,PC}          ;; return
    381            }
    382          
    383            return &comhandledata[index];
    384          }
    385          

   \                                 In section .text, align 2, keep-with-next
    386          static inline bool getOutputFifoSpace(COM_Handle_t comhandle, uint8_t extraByteCount)
    387          {
    388            return (comhandle->txQueue->used < comhandle->txsize - extraByteCount);
   \                     getOutputFifoSpace: (+1)
   \        0x0   0x6842             LDR      R2,[R0, #+4]
   \        0x2   0x8893             LDRH     R3,[R2, #+4]
   \        0x4   0x8940             LDRH     R0,[R0, #+10]
   \        0x6   0x1A41             SUBS     R1,R0,R1
   \        0x8   0x428B             CMP      R3,R1
   \        0xA   0xDA01             BGE.N    ??getOutputFifoSpace_0
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x4770             BX       LR
   \                     ??getOutputFifoSpace_0: (+1)
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x4770             BX       LR               ;; return
    389          }
    390          
    391          static inline bool getInputFifoSpace(COM_Handle_t comhandle, uint8_t extraByteCount)
    392          {
    393            return (comhandle->rxQueue->used < comhandle->rxsize - extraByteCount);
    394          }
    395          

   \                                 In section .text, align 2, keep-with-next
    396          static void pumpRx(COM_Port_t port)
    397          {
    398            if (checkValidPort(port) == false) {
   \                     pumpRx: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xB53E             PUSH     {R1-R5,LR}
   \        0x4   0xBF18             IT       NE 
   \        0x6   0x2820             CMPNE    R0,#+32
   \        0x8   0xD132             BNE.N    ??CrossCallReturnLabel_14
    399              return;
    400            }
    401            // UART
    402          #if defined(COM_UART_ENABLE)
    403            if (checkValidUartPort(port)) {
   \        0xA   0x2801             CMP      R0,#+1
   \        0xC   0xBF18             IT       NE 
   \        0xE   0x2820             CMPNE    R0,#+32
   \       0x10   0xD12E             BNE.N    ??CrossCallReturnLabel_14
    404              COM_Handle_t comhandle = getComHandleFromPort(port);
   \       0x12   0x....'....        BL       getComHandleFromPort
   \       0x16   0x4604             MOV      R4,R0
    405              uint8_t *buf;
    406              UARTDRV_Count_t xferred, remaining;
    407              CORE_ATOMIC_SECTION(
    408                UARTDRV_GetReceiveStatus(comhandle->uarthandle, &buf, &xferred, &remaining);
    409                updateBuffer(comhandle->rxQueue, xferred, comhandle->rxsize);
    410                )
   \       0x18   0x....'....        BL       CORE_EnterAtomic
   \       0x1C   0x4605             MOV      R5,R0
   \       0x1E   0x69A0             LDR      R0,[R4, #+24]
   \       0x20   0xAB01             ADD      R3,SP,#+4
   \       0x22   0x466A             MOV      R2,SP
   \       0x24   0xA902             ADD      R1,SP,#+8
   \       0x26   0x....'....        BL       UARTDRV_GetReceiveStatus
   \       0x2A   0x9900             LDR      R1,[SP, #+0]
   \       0x2C   0x8922             LDRH     R2,[R4, #+8]
   \       0x2E   0x6820             LDR      R0,[R4, #+0]
   \       0x30   0xB289             UXTH     R1,R1
   \       0x32   0x....'....        BL       updateBuffer
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0x....'....        BL       CORE_ExitAtomic
    411              // Enable flow control if appropriate after updating buffer
    412              if ((UARTDRV_FlowControlGetSelfStatus(comhandle->uarthandle) == uartdrvFlowControlOff)
    413                  && ((comhandle->rxsize - comhandle->rxQueue->used)
    414                      >= comhandle->rxStart)) {
   \       0x3C   0x69A0             LDR      R0,[R4, #+24]
   \       0x3E   0x....'....        BL       UARTDRV_FlowControlGetSelfStatus
   \       0x42   0x2801             CMP      R0,#+1
   \       0x44   0xD114             BNE.N    ??CrossCallReturnLabel_14
   \       0x46   0x6822             LDR      R2,[R4, #+0]
   \       0x48   0x8921             LDRH     R1,[R4, #+8]
   \       0x4A   0x8890             LDRH     R0,[R2, #+4]
   \       0x4C   0x8A22             LDRH     R2,[R4, #+16]
   \       0x4E   0x1A09             SUBS     R1,R1,R0
   \       0x50   0x4291             CMP      R1,R2
   \       0x52   0xDB0D             BLT.N    ??CrossCallReturnLabel_14
    415                // Only enable flow control if DMAs are set up when using HW flow control
    416                if (((comhandle->uarthandle->fcType == uartdrvFlowControlHw)
    417                     && (UARTDRV_GetReceiveDepth(comhandle->uarthandle) >= 2))
    418                    || (comhandle->uarthandle->fcType == uartdrvFlowControlSw)) {
   \       0x54   0x69A0             LDR      R0,[R4, #+24]
   \       0x56   0xF890 0x1031      LDRB     R1,[R0, #+49]
   \       0x5A   0x2902             CMP      R1,#+2
   \       0x5C   0xD103             BNE.N    ??pumpRx_0
   \       0x5E   0x....'....        BL       UARTDRV_GetReceiveDepth
   \       0x62   0x2802             CMP      R0,#+2
   \       0x64   0xDA02             BGE.N    ??pumpRx_1
   \                     ??pumpRx_0: (+1)
   \       0x66   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x6A   0xD101             BNE.N    ??CrossCallReturnLabel_14
    419                  UARTDRV_FlowControlSet(comhandle->uarthandle, uartdrvFlowControlOn);
   \                     ??pumpRx_1: (+1)
   \       0x6C   0x....'....        BL       ?Subroutine6
    420                }
    421              }
    422            }
    423          #endif
    424          #ifdef COM_VCP_ENABLE
    425            if (port == COM_VCP || port == comPortVcp) {
    426              emDebugReceiveData();
    427              return;
    428            }
    429          #endif
    430          }
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x70   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x69A0             LDR      R0,[R4, #+24]
   \                     ??Subroutine6_0: (+1)
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x....'....        B.W      UARTDRV_FlowControlSet

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x69A0             LDR      R0,[R4, #+24]
   \                     ??Subroutine5_0: (+1)
   \        0x2   0xF890 0x1031      LDRB     R1,[R0, #+49]
   \        0x6   0x2901             CMP      R1,#+1
   \        0x8   0x4770             BX       LR
    431          
    432          #if HAL_SERIAL_RXWAKE_ENABLE
    433          /* Enable interrupt on the UART RX pin, in order to be able to wakeup on rx
    434           * activity in energy modes where the UART is not available. */
    435          static void rxGpioIntEnable(void)
    436          {
    437          #ifdef CORTEXM3_EFM32_MICRO
    438            GPIO_IntClear(1 << UART_RX_INT_PIN);
    439            GPIO_IntEnable(1 << UART_RX_INT_PIN);
    440          #endif
    441          }
    442          
    443          /* Disable interrupt on the UART RX pin */
    444          static void rxGpioIntDisable(void)
    445          {
    446          #ifdef CORTEXM3_EFM32_MICRO
    447            GPIO_IntDisable(1 << UART_RX_INT_PIN);
    448            GPIO_IntClear(1 << UART_RX_INT_PIN);
    449          #endif
    450          }
    451          #endif
    452          
    453          /**
    454           * Set RX/TX queues in COM handle based on given COM port
    455           */
    456          static Ecode_t setComHandleQueues(COM_Port_t port)
    457          {
    458            COM_Handle_t comhandle = getComHandleFromPort(port);
    459            switch (port) {
    460          #ifdef COM_VCP_ENABLE
    461              case COM_VCP:
    462              case comPortVcp:
    463                comhandle->rxQueue = (COM_FifoQueue_t *)&comFifoQueueRxVcp;
    464                comhandle->txQueue = (COM_FifoQueue_t *)&comFifoQueueTxVcp;
    465                comhandle->rxsize = COM_VCP_RX_QUEUE_SIZE;
    466                comhandle->txsize = COM_VCP_TX_QUEUE_SIZE;
    467                break;
    468          #endif
    469          #ifdef COM_USART0_ENABLE
    470              case COM_USART0:
    471              case comPortUsart0:
    472                comhandle->rxQueue = (COM_FifoQueue_t *)&comFifoQueueRxUsart0;
    473                comhandle->txQueue = (COM_FifoQueue_t *)&comFifoQueueTxUsart0;
    474                comhandle->rxsize = COM_USART0_RX_QUEUE_SIZE;
    475                comhandle->txsize = COM_USART0_TX_QUEUE_SIZE;
    476                break;
    477          #endif
    478          #ifdef COM_USART1_ENABLE
    479              case COM_USART1:
    480              case comPortUsart1:
    481                comhandle->rxQueue = (COM_FifoQueue_t *)&comFifoQueueRxUsart1;
    482                comhandle->txQueue = (COM_FifoQueue_t *)&comFifoQueueTxUsart1;
    483                comhandle->rxsize = COM_USART1_RX_QUEUE_SIZE;
    484                comhandle->txsize = COM_USART1_TX_QUEUE_SIZE;
    485                break;
    486          #endif
    487          #ifdef COM_USART2_ENABLE
    488              case COM_USART2:
    489              case comPortUsart2:
    490                comhandle->rxQueue = (COM_FifoQueue_t *)&comFifoQueueRxUsart2;
    491                comhandle->txQueue = (COM_FifoQueue_t *)&comFifoQueueTxUsart2;
    492                comhandle->rxsize = COM_USART2_RX_QUEUE_SIZE;
    493                comhandle->txsize = COM_USART2_TX_QUEUE_SIZE;
    494                break;
    495          #endif
    496          #ifdef COM_USART3_ENABLE
    497              case comPortUsart3:
    498                comhandle->rxQueue = (COM_FifoQueue_t *)&comFifoQueueRxUsart3;
    499                comhandle->txQueue = (COM_FifoQueue_t *)&comFifoQueueTxUsart3;
    500                comhandle->rxsize = COM_USART3_RX_QUEUE_SIZE;
    501                comhandle->txsize = COM_USART3_TX_QUEUE_SIZE;
    502                break;
    503          #endif
    504          #ifdef COM_LEUART0_ENABLE
    505              case COM_LEUART0:
    506              case comPortLeuart0:
    507                comhandle->rxQueue = (COM_FifoQueue_t *)&comFifoQueueRxLeuart0;
    508                comhandle->txQueue = (COM_FifoQueue_t *)&comFifoQueueTxLeuart0;
    509                comhandle->rxsize = COM_LEUART0_RX_QUEUE_SIZE;
    510                comhandle->txsize = COM_LEUART0_TX_QUEUE_SIZE;
    511                break;
    512          #endif
    513          #ifdef COM_LEUART1_ENABLE
    514              case COM_LEUART1:
    515              case comPortLeuart1:
    516                comhandle->rxQueue = (COM_FifoQueue_t *)&comFifoQueueRxLeuart1;
    517                comhandle->txQueue = (COM_FifoQueue_t *)&comFifoQueueTxLeuart1;
    518                comhandle->rxsize = COM_LEUART1_RX_QUEUE_SIZE;
    519                comhandle->txsize = COM_LEUART1_TX_QUEUE_SIZE;
    520                break;
    521          #endif
    522              default:
    523                return EMBER_ERR_FATAL;
    524                break;
    525            }
    526          
    527            return EMBER_SUCCESS;
    528          }
    529          
    530          /* reload buffer callbacks */

   \                                 In section .text, align 2, keep-with-next
    531          static void updateBuffer(COM_FifoQueue_t *q, uint16_t xferred, uint16_t size)
    532          {
   \                     updateBuffer: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4615             MOV      R5,R2
    533            // Update tail with additional xferred. Data should already be there
    534            CORE_DECLARE_IRQ_STATE;
    535            CORE_ENTER_ATOMIC();
   \        0x8   0x....'....        BL       CORE_EnterAtomic
    536            if (xferred > q->pumped) {
   \        0xC   0x88E2             LDRH     R2,[R4, #+6]
   \        0xE   0x42B2             CMP      R2,R6
   \       0x10   0xD20C             BCS.N    ??updateBuffer_0
    537              q->head = ((q->head - q->pumped + xferred) % size);
   \       0x12   0x8821             LDRH     R1,[R4, #+0]
   \       0x14   0x1A8B             SUBS     R3,R1,R2
   \       0x16   0x18F3             ADDS     R3,R6,R3
   \       0x18   0xFB93 0xF1F5      SDIV     R1,R3,R5
   \       0x1C   0xFB05 0x3511      MLS      R5,R5,R1,R3
   \       0x20   0x8025             STRH     R5,[R4, #+0]
    538              q->used += xferred - q->pumped;
   \       0x22   0x88A3             LDRH     R3,[R4, #+4]
   \       0x24   0x18F3             ADDS     R3,R6,R3
   \       0x26   0x1A9A             SUBS     R2,R3,R2
   \       0x28   0x80A2             STRH     R2,[R4, #+4]
    539              q->pumped = xferred;
   \       0x2A   0x80E6             STRH     R6,[R4, #+6]
    540            }
    541            CORE_EXIT_ATOMIC();
   \                     ??updateBuffer_0: (+1)
   \       0x2C                      REQUIRE ?Subroutine0
   \       0x2C                      ;; // Fall through to label ?Subroutine0
    542          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xE8BD 0x4070      POP      {R4-R6,LR}
   \        0x4   0x....'....        B.W      CORE_ExitAtomic
    543          

   \                                 In section .text, align 2, keep-with-next
    544          static void txBuffer(COM_Port_t port, uint8_t *data, uint16_t length)
    545          {
    546          #if defined(COM_UART_ENABLE)
    547            if (checkValidUartPort(port)) {
   \                     txBuffer: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xB5F8             PUSH     {R3-R7,LR}
   \        0x4   0x460C             MOV      R4,R1
   \        0x6   0x4615             MOV      R5,R2
   \        0x8   0xBF18             IT       NE 
   \        0xA   0x2820             CMPNE    R0,#+32
   \        0xC   0xD118             BNE.N    ??txBuffer_0
    548              COM_Handle_t comhandle = getComHandleFromPort(port);
   \        0xE   0x....'....        BL       getComHandleFromPort
   \       0x12   0x4606             MOV      R6,R0
    549              // Skip transmit if paused
    550              if (comhandle->txPaused) {
   \       0x14   0x7B30             LDRB     R0,[R6, #+12]
   \       0x16   0xB110             CBZ.N    R0,??txBuffer_1
    551                comhandle->txCatchUp = true;
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0x7371             STRB     R1,[R6, #+13]
    552                return;
   \       0x1C   0xBDF1             POP      {R0,R4-R7,PC}
    553              }
    554              // Catch up from skipped transmit(s) from before
    555              if (comhandle->txCatchUp) {
   \                     ??txBuffer_1: (+1)
   \       0x1E   0x7B70             LDRB     R0,[R6, #+13]
   \       0x20   0xB118             CBZ.N    R0,??txBuffer_2
    556                txCatchUp(comhandle);
   \       0x22   0x4630             MOV      R0,R6
   \       0x24   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \       0x28   0x....             B.N      txCatchUp
    557              } else if (UARTDRV_Transmit(comhandle->uarthandle, data, length, txCallback) != EMBER_SUCCESS) {
   \                     ??txBuffer_2: (+1)
   \       0x2A   0x69B0             LDR      R0,[R6, #+24]
   \       0x2C   0x....'....        ADR.W    R7,txCallback
   \       0x30   0x....'....        BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x34   0xB120             CBZ.N    R0,??txBuffer_0
    558                while (UARTDRV_Transmit(comhandle->uarthandle, data, length, txCallback) != EMBER_SUCCESS) {
   \                     ??txBuffer_3: (+1)
   \       0x36   0x69B0             LDR      R0,[R6, #+24]
   \       0x38   0x....'....        BL       ?Subroutine4
    559                }
    560              }
    561            }
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD1FA             BNE.N    ??txBuffer_3
    562          #endif
    563            return;
   \                     ??txBuffer_0: (+1)
   \       0x40   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    564          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x463B             MOV      R3,R7
   \        0x2   0x462A             MOV      R2,R5
   \        0x4   0x4621             MOV      R1,R4
   \        0x6   0x....'....        B.W      UARTDRV_Transmit
    565          
    566          /**
    567           * VCP-only static functions
    568           */
    569          #if defined(COM_VCP_ENABLE)
    570          static inline bool checkValidVcpPort(COM_Port_t port)
    571          {
    572            switch (port) {
    573          #ifdef COM_VCP_ENABLE
    574              case COM_VCP:
    575              case comPortVcp:
    576                return true;
    577          #endif
    578              default:
    579                return false;
    580            }
    581          }
    582          
    583          #endif
    584          
    585          /**
    586           * UART-only static functions
    587           */
    588          #if defined(COM_UART_ENABLE)
    589          static inline bool checkValidLeuartPort(COM_Port_t port)
    590          {
    591          #if (defined(COM_LEUART0_ENABLE) || defined(COM_LEUART1_ENABLE))
    592            switch (port) {
    593          #ifdef COM_LEUART0_ENABLE
    594              case COM_LEUART0:
    595              case comPortLeuart0:
    596                return true;
    597          #endif
    598          #ifdef COM_LEUART1_ENABLE
    599              case COM_LEUART1:
    600              case comPortLeuart1:
    601                return true;
    602          #endif
    603              default:
    604                return false;
    605            }
    606          #else
    607            return false;
    608          #endif
    609          }
    610          
    611          static inline bool checkValidUartPort(COM_Port_t port)
    612          {
    613            switch (port) {
    614          #ifdef COM_USART0_ENABLE
    615              case COM_USART0:
    616              case comPortUsart0:
    617                return true;
    618          #endif
    619          #ifdef COM_USART1_ENABLE
    620              case COM_USART1:
    621              case comPortUsart1:
    622                return true;
    623          #endif
    624          #ifdef COM_USART2_ENABLE
    625              case COM_USART2:
    626              case comPortUsart2:
    627                return true;
    628          #endif
    629          #ifdef COM_USART3_ENABLE
    630              case comPortUsart3:
    631                return true;
    632          #endif
    633          #ifdef COM_LEUART0_ENABLE
    634              case COM_LEUART0:
    635              case comPortLeuart0:
    636                return true;
    637          #endif
    638          #ifdef COM_LEUART1_ENABLE
    639              case COM_LEUART1:
    640              case comPortLeuart1:
    641                return true;
    642          #endif
    643              default:
    644                return false;
    645            }
    646          }
    647          

   \                                 In section .text, align 2, keep-with-next
    648          static void enableRxIrq(COM_Port_t port, bool enable)
    649          {
   \                     enableRxIrq: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
    650            COM_Handle_t comhandle = getComHandleFromPort(port);
   \        0x6   0x....'....        BL       getComHandleFromPort
    651            IRQn_Type irqn;
    652            switch (port) {
   \        0xA   0x2D01             CMP      R5,#+1
   \        0xC   0x4602             MOV      R2,R0
   \        0xE   0xBF18             IT       NE 
   \       0x10   0x2D20             CMPNE    R5,#+32
   \       0x12   0xD12C             BNE.N    ??enableRxIrq_0
    653            #ifdef COM_USART0_ENABLE
    654              case COM_USART0:
    655              case comPortUsart0:
    656                irqn = USART0_RX_IRQn;
    657                break;
    658            #endif
    659            #ifdef COM_USART1_ENABLE
    660              case COM_USART1:
    661              case comPortUsart1:
    662                irqn = USART1_RX_IRQn;
    663                break;
    664            #endif
    665            #ifdef COM_USART2_ENABLE
    666              case COM_USART2:
    667              case comPortUsart2:
    668                irqn = USART2_RX_IRQn;
    669                break;
    670            #endif
    671            #ifdef COM_USART3_ENABLE
    672              case comPortUsart3:
    673                irqn = USART3_RX_IRQn;
    674                break;
    675            #endif
    676            #ifdef COM_LEUART0_ENABLE
    677              case COM_LEUART0:
    678              case comPortLeuart0:
    679                irqn = LEUART0_IRQn;
    680                break;
    681            #endif
    682            #ifdef COM_LEUART1_ENABLE
    683              case COM_LEUART1:
    684              case comPortLeuart1:
    685                irqn = LEUART1_IRQn;
    686                break;
    687            #endif
    688              default:
    689                return;
    690            }
    691            if (comhandle->uarthandle->type == uartdrvUartTypeUart) {
   \       0x14   0x6993             LDR      R3,[R2, #+24]
   \       0x16   0xF893 0x0032      LDRB     R0,[R3, #+50]
   \       0x1A   0xBB40             CBNZ.N   R0,??enableRxIrq_0
    692              /* Clear previous RX interrupts */
    693              USART_IntClear(comhandle->uarthandle->peripheral.uart, USART_IF_RXDATAV);
   \       0x1C   0x6818             LDR      R0,[R3, #+0]
   \       0x1E   0x2104             MOVS     R1,#+4
   \       0x20   0xF242 0x0548      MOVW     R5,#+8264
   \       0x24   0x5141             STR      R1,[R0, R5]
    694              NVIC_ClearPendingIRQ(irqn);
   \       0x26   0xF44F 0x6000      MOV      R0,#+2048
   \       0x2A   0x....'....        LDR.W    R1,??DataTable10_2  ;; 0xe000e280
   \       0x2E   0x6008             STR      R0,[R1, #+0]
    695          
    696              if (enable) {
   \       0x30   0x2C00             CMP      R4,#+0
   \       0x32   0x6819             LDR      R1,[R3, #+0]
   \       0x34   0xD009             BEQ.N    ??enableRxIrq_1
    697                /* Enable RX interrupts */
    698                USART_IntEnable(comhandle->uarthandle->peripheral.uart, USART_IF_RXDATAV);
   \       0x36   0x6CCA             LDR      R2,[R1, #+76]
   \       0x38   0xF042 0x0204      ORR      R2,R2,#0x4
   \       0x3C   0x64CA             STR      R2,[R1, #+76]
    699                NVIC_EnableIRQ(irqn);
   \       0x3E   0x....'....        LDR.W    R1,??DataTable10_3  ;; 0xe000e100
   \       0x42   0x6008             STR      R0,[R1, #+0]
    700          
    701                USART_Enable(comhandle->uarthandle->peripheral.uart, usartEnable);
   \       0x44   0x2105             MOVS     R1,#+5
   \       0x46   0x6818             LDR      R0,[R3, #+0]
   \       0x48   0xE00D             B.N      ??enableRxIrq_2
    702              } else {
    703                /* Disable RX interrupts */
    704                USART_IntDisable(comhandle->uarthandle->peripheral.uart, USART_IF_RXDATAV);
   \                     ??enableRxIrq_1: (+1)
   \       0x4A   0x6CCB             LDR      R3,[R1, #+76]
   \       0x4C   0xF023 0x0304      BIC      R3,R3,#0x4
   \       0x50   0x64CB             STR      R3,[R1, #+76]
    705                NVIC_DisableIRQ(irqn);
   \       0x52   0x....'....        LDR.W    R1,??DataTable10_4  ;; 0xe000e180
   \       0x56   0x6008             STR      R0,[R1, #+0]
   \       0x58   0xF3BF 0x8F4F      DSB      SY
   \       0x5C   0xF3BF 0x8F6F      ISB      SY
    706          
    707                USART_Enable(comhandle->uarthandle->peripheral.uart, usartDisable);
   \       0x60   0x6990             LDR      R0,[R2, #+24]
   \       0x62   0x2100             MOVS     R1,#+0
   \       0x64   0x6800             LDR      R0,[R0, #+0]
   \                     ??enableRxIrq_2: (+1)
   \       0x66   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x6A   0x....'....        B.W      USART_Enable
    708              }
    709            } else {
    710          #if defined(LEUART_PRESENT)
    711              /* Clear previous RX interrupts */
    712              LEUART_IntClear(comhandle->uarthandle->peripheral.leuart, LEUART_IF_RXDATAV);
    713              NVIC_ClearPendingIRQ(irqn);
    714          
    715              if (enable) {
    716                /* Enable RX interrupts */
    717                LEUART_IntEnable(comhandle->uarthandle->peripheral.leuart, LEUART_IF_RXDATAV);
    718                NVIC_EnableIRQ(irqn);
    719          
    720                LEUART_Enable(comhandle->uarthandle->peripheral.leuart, leuartEnable);
    721              } else {
    722                /* Disable RX interrupts */
    723                LEUART_IntDisable(comhandle->uarthandle->peripheral.leuart, LEUART_IF_RXDATAV);
    724                NVIC_DisableIRQ(irqn);
    725          
    726                LEUART_Enable(comhandle->uarthandle->peripheral.leuart, leuartDisable);
    727              }
    728          #endif // LEUART_PRESENT
    729            }
    730          }
   \                     ??enableRxIrq_0: (+1)
   \       0x6E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    731          
    732          /**
    733           * @brief Convert a COM_Port_t into a pointer to UART handle
    734           *
    735           * @param[in] port COM port number
    736           *
    737           * @return Pointer to UART handle
    738           */
    739          static UARTDRV_Handle_t getUartHandleFromPort(COM_Port_t port)
    740          {
    741            size_t index;
    742          
    743            switch (port) {
    744          #ifdef COM_USART0_ENABLE
    745              case COM_USART0:
    746              case comPortUsart0:
    747                index = comUartHandleIndexUsart0;
    748                break;
    749          #endif
    750          #ifdef COM_USART1_ENABLE
    751              case COM_USART1:
    752              case comPortUsart1:
    753                index = comUartHandleIndexUsart1;
    754                break;
    755          #endif
    756          #ifdef COM_USART2_ENABLE
    757              case COM_USART2:
    758              case comPortUsart2:
    759                index = comUartHandleIndexUsart2;
    760                break;
    761          #endif
    762          #ifdef COM_USART3_ENABLE
    763              case comPortUsart3:
    764                index = comUartHandleIndexUsart3;
    765                break;
    766          #endif
    767          #ifdef COM_LEUART0_ENABLE
    768              case COM_LEUART0:
    769              case comPortLeuart0:
    770                index = comUartHandleIndexLeuart0;
    771                break;
    772          #endif
    773          #ifdef COM_LEUART1_ENABLE
    774              case COM_LEUART1:
    775              case comPortLeuart1:
    776                index = comUartHandleIndexLeuart1;
    777                break;
    778          #endif
    779              default:
    780                return NULL;
    781            }
    782          
    783            return &uarthandledata[index];
    784          }
    785          

   \                                 In section .text, align 2, keep-with-next
    786          static void rxCallback(UARTDRV_Handle_t handle,
    787                                 Ecode_t transferStatus,
    788                                 uint8_t *data,
    789                                 UARTDRV_Count_t transferCount)
    790          {
   \                     rxCallback: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
    791            uint16_t nextRx;
    792            COM_Handle_t comhandle;
    793          
    794            // Don't process callback if the transfer was aborted
    795            if (transferStatus == ECODE_EMDRV_UARTDRV_ABORTED) {
   \        0x4   0x....'....        LDR.W    R0,??DataTable10_5  ;; 0xf0007009
   \        0x8   0x4281             CMP      R1,R0
   \        0xA   0xD02F             BEQ.N    ??rxCallback_0
    796              return;
    797            }
    798          
    799            // Figure out which com port this is
    800            for (uint8_t i = 0; i < comHandleIndexSize; i++) {
   \        0xC   0x....'....        LDR.W    R5,??DataTable10
   \       0x10   0x69A8             LDR      R0,[R5, #+24]
   \       0x12   0x42A0             CMP      R0,R4
   \       0x14   0xD12A             BNE.N    ??rxCallback_0
    801              comhandle = &comhandledata[i];
    802              if (comhandle->uarthandle == handle) {
    803                // update fifo
    804                updateBuffer(comhandle->rxQueue, transferCount, comhandle->rxsize);
   \       0x16   0x892A             LDRH     R2,[R5, #+8]
   \       0x18   0x6828             LDR      R0,[R5, #+0]
   \       0x1A   0xB299             UXTH     R1,R3
   \       0x1C   0x....'....        BL       updateBuffer
    805                // reset pumped bytes (already in interrupt context)
    806                comhandle->rxQueue->pumped = 0;
   \       0x20   0x6828             LDR      R0,[R5, #+0]
   \       0x22   0x2100             MOVS     R1,#+0
   \       0x24   0x80C1             STRH     R1,[R0, #+6]
    807                // set up next receive operation
    808                // will return current number of rx operations (including current one)
    809                // Should set up buffers until there will be 2 after this exits
    810                while (UARTDRV_GetReceiveDepth(handle) < 3) {
   \                     ??rxCallback_1: (+1)
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x....'....        BL       UARTDRV_GetReceiveDepth
   \       0x2C   0x2802             CMP      R0,#+2
   \       0x2E   0xDC1D             BGT.N    ??rxCallback_0
    811                  nextRx = comhandle->bufferIndex * comhandle->rxStop;
   \       0x30   0x89E9             LDRH     R1,[R5, #+14]
   \       0x32   0x8A6A             LDRH     R2,[R5, #+18]
    812                  if (comhandle->rxQueue->used > 0) {
   \       0x34   0x682B             LDR      R3,[R5, #+0]
   \       0x36   0x434A             MULS     R2,R1,R2
   \       0x38   0x8898             LDRH     R0,[R3, #+4]
   \       0x3A   0xB292             UXTH     R2,R2
   \       0x3C   0xB160             CBZ.N    R0,??rxCallback_2
    813                    // Check to see if there are used bytes in the next buffer by
    814                    // comparing head and tail positions with the buffer start/stop
    815                    if (((comhandle->rxQueue->tail < (nextRx + comhandle->rxStop))
    816                         && (nextRx < comhandle->rxQueue->head))
    817                        || ((comhandle->rxQueue->head < comhandle->rxQueue->tail)
    818                            && (((nextRx + comhandle->rxStop) > comhandle->rxQueue->tail)
    819                                || (nextRx < comhandle->rxQueue->head)))) {
   \       0x3E   0x8858             LDRH     R0,[R3, #+2]
   \       0x40   0x881B             LDRH     R3,[R3, #+0]
   \       0x42   0x1889             ADDS     R1,R1,R2
   \       0x44   0x4288             CMP      R0,R1
   \       0x46   0xBFB8             IT       LT 
   \       0x48   0x429A             CMPLT    R2,R3
   \       0x4A   0xDB09             BLT.N    ??rxCallback_3
   \       0x4C   0x4283             CMP      R3,R0
   \       0x4E   0xD203             BCS.N    ??rxCallback_2
   \       0x50   0x4288             CMP      R0,R1
   \       0x52   0xBFA8             IT       GE 
   \       0x54   0x429A             CMPGE    R2,R3
   \       0x56   0xDB03             BLT.N    ??rxCallback_3
    820                      // Apply flow control since next buffer couldn't be allocated
    821                      UARTDRV_FlowControlSet(handle, uartdrvFlowControlOff);
    822                      break;
    823                    }
    824                  }
    825                  rxNextBuffer(comhandle);
   \                     ??rxCallback_2: (+1)
   \       0x58   0x4628             MOV      R0,R5
   \       0x5A   0x....'....        BL       rxNextBuffer
   \       0x5E   0xE7E2             B.N      ??rxCallback_1
   \                     ??rxCallback_3: (+1)
   \       0x60   0x4620             MOV      R0,R4
   \       0x62   0x2101             MOVS     R1,#+1
   \       0x64   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x68   0x....'....        B.W      UARTDRV_FlowControlSet
    826                }
    827              }
    828            }
    829          }
   \                     ??rxCallback_0: (+1)
   \       0x6C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    830          
    831          /* Set up next RX operation (not used for SW flow control) */

   \                                 In section .text, align 2, keep-with-next
    832          static void rxNextBuffer(COM_Handle_t handle)
    833          {
   \                     rxNextBuffer: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
    834            UARTDRV_Receive(handle->uarthandle,
    835                            &handle->rxQueue->fifo[handle->bufferIndex * handle->rxStop],
    836                            handle->rxStop,
    837                            rxCallback);
   \        0x4   0x89E0             LDRH     R0,[R4, #+14]
   \        0x6   0x8A66             LDRH     R6,[R4, #+18]
   \        0x8   0x6825             LDR      R5,[R4, #+0]
   \        0xA   0x4602             MOV      R2,R0
   \        0xC   0x4370             MULS     R0,R0,R6
   \        0xE   0x....'....        LDR.W    R3,??DataTable10_6
   \       0x12   0x182E             ADDS     R6,R5,R0
   \       0x14   0x69A0             LDR      R0,[R4, #+24]
   \       0x16   0xF106 0x0108      ADD      R1,R6,#+8
   \       0x1A   0x....'....        BL       UARTDRV_Receive
    838            // manually ensure flow control is set after receive
    839            if (UARTDRV_GetReceiveDepth(handle->uarthandle) >= 2) {
   \       0x1E   0x69A0             LDR      R0,[R4, #+24]
   \       0x20   0x....'....        BL       UARTDRV_GetReceiveDepth
   \       0x24   0x2801             CMP      R0,#+1
   \       0x26   0xDD01             BLE.N    ??CrossCallReturnLabel_13
    840              UARTDRV_FlowControlSet(handle->uarthandle, uartdrvFlowControlOn);
   \       0x28   0x....'....        BL       ?Subroutine6
    841            }
    842            handle->bufferIndex = (handle->bufferIndex + 1) % handle->bufferLimit;
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x2C   0x8A60             LDRH     R0,[R4, #+18]
   \       0x2E   0x8AA1             LDRH     R1,[R4, #+20]
   \       0x30   0x1C40             ADDS     R0,R0,#+1
   \       0x32   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \       0x36   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \       0x3A   0x8260             STRH     R0,[R4, #+18]
    843          }
   \       0x3C   0xBD70             POP      {R4-R6,PC}       ;; return
    844          
    845          /**
    846           * Set correct UARTDRV FifoQueues into init struct based on port
    847           */
    848          static Ecode_t setUartBufferQueues(COM_Port_t port, COM_Init_t * init)
    849          {
    850            switch (port) {
    851          #ifdef COM_USART0_ENABLE
    852              case COM_USART0:
    853              case comPortUsart0:
    854                init->uartdrvinit.uartinit.rxQueue = (UARTDRV_Buffer_FifoQueue_t *)&comBufferQueueRxUsart0;
    855                init->uartdrvinit.uartinit.txQueue = (UARTDRV_Buffer_FifoQueue_t *)&comBufferQueueTxUsart0;
    856                break;
    857          #endif
    858          #ifdef COM_USART1_ENABLE
    859              case COM_USART1:
    860              case comPortUsart1:
    861                init->uartdrvinit.uartinit.rxQueue = (UARTDRV_Buffer_FifoQueue_t *)&comBufferQueueRxUsart1;
    862                init->uartdrvinit.uartinit.txQueue = (UARTDRV_Buffer_FifoQueue_t *)&comBufferQueueTxUsart1;
    863                break;
    864          #endif
    865          #ifdef COM_USART2_ENABLE
    866              case COM_USART2:
    867              case comPortUsart2:
    868                init->uartdrvinit.uartinit.rxQueue = (UARTDRV_Buffer_FifoQueue_t *)&comBufferQueueRxUsart2;
    869                init->uartdrvinit.uartinit.txQueue = (UARTDRV_Buffer_FifoQueue_t *)&comBufferQueueTxUsart2;
    870                break;
    871          #endif
    872          #ifdef COM_USART3_ENABLE
    873              case comPortUsart3:
    874                init->uartdrvinit.uartinit.rxQueue = (UARTDRV_Buffer_FifoQueue_t *)&comBufferQueueRxUsart3;
    875                init->uartdrvinit.uartinit.txQueue = (UARTDRV_Buffer_FifoQueue_t *)&comBufferQueueTxUsart3;
    876                break;
    877          #endif
    878          #ifdef COM_LEUART0_ENABLE
    879              case COM_LEUART0:
    880              case comPortLeuart0:
    881                init->uartdrvinit.leuartinit.rxQueue = (UARTDRV_Buffer_FifoQueue_t *)&comBufferQueueRxLeuart0;
    882                init->uartdrvinit.leuartinit.txQueue = (UARTDRV_Buffer_FifoQueue_t *)&comBufferQueueTxLeuart0;
    883                break;
    884          #endif
    885          #ifdef COM_LEUART1_ENABLE
    886              case COM_LEUART1:
    887              case comPortLeuart1:
    888                init->uartdrvinit.leuartinit.rxQueue = (UARTDRV_Buffer_FifoQueue_t *)&comBufferQueueRxLeuart1;
    889                init->uartdrvinit.leuartinit.txQueue = (UARTDRV_Buffer_FifoQueue_t *)&comBufferQueueTxLeuart1;
    890                break;
    891          #endif
    892              default:
    893                return EMBER_ERR_FATAL;
    894            }
    895            return EMBER_SUCCESS;
    896          }
    897          

   \                                 In section .text, align 2, keep-with-next
    898          static void txCatchUp(COM_Handle_t comhandle)
    899          {
   \                     txCatchUp: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
    900            if (!comhandle->txPaused) {
   \        0x4   0x7B20             LDRB     R0,[R4, #+12]
   \        0x6   0xBB68             CBNZ.N   R0,??txCatchUp_0
    901              uint8_t *fifotail;
    902              uint8_t length;
    903              uint8_t *buffer;
    904              uint32_t sent;
    905              uint32_t remaining;
    906              // Get current FIFO head
    907              fifotail = &comhandle->txQueue->fifo[comhandle->txQueue->tail];
   \        0x8   0x6860             LDR      R0,[R4, #+4]
    908              // Check for active transmit
    909              UARTDRV_GetTransmitStatus(comhandle->uarthandle, &buffer, &sent, &remaining);
   \        0xA   0x466B             MOV      R3,SP
   \        0xC   0xAA01             ADD      R2,SP,#+4
   \        0xE   0x8841             LDRH     R1,[R0, #+2]
   \       0x10   0x....'....        ADR.W    R6,txCallback
   \       0x14   0x4408             ADD      R0,R0,R1
   \       0x16   0xF100 0x0708      ADD      R7,R0,#+8
   \       0x1A   0x69A0             LDR      R0,[R4, #+24]
   \       0x1C   0xA902             ADD      R1,SP,#+8
   \       0x1E   0x....'....        BL       UARTDRV_GetTransmitStatus
    910              // Determine bytes to "catch up"
    911              length = comhandle->txQueue->used - remaining - sent;
   \       0x22   0x6861             LDR      R1,[R4, #+4]
   \       0x24   0x888A             LDRH     R2,[R1, #+4]
   \       0x26   0x9800             LDR      R0,[SP, #+0]
   \       0x28   0x9D01             LDR      R5,[SP, #+4]
   \       0x2A   0x1A12             SUBS     R2,R2,R0
    912              // wrap
    913              if (comhandle->txQueue->head < comhandle->txQueue->tail) {
   \       0x2C   0x8808             LDRH     R0,[R1, #+0]
   \       0x2E   0x1B55             SUBS     R5,R2,R5
   \       0x30   0x884A             LDRH     R2,[R1, #+2]
   \       0x32   0x4290             CMP      R0,R2
   \       0x34   0xD20E             BCS.N    ??txCatchUp_1
    914                if (UARTDRV_Transmit(comhandle->uarthandle,
    915                                     fifotail,
    916                                     comhandle->txsize - comhandle->txQueue->tail,
    917                                     txCallback)
    918                    != EMBER_SUCCESS) {
   \       0x36   0x8961             LDRH     R1,[R4, #+10]
   \       0x38   0x69A0             LDR      R0,[R4, #+24]
   \       0x3A   0x4633             MOV      R3,R6
   \       0x3C   0x1A8A             SUBS     R2,R1,R2
   \       0x3E   0x4639             MOV      R1,R7
   \       0x40   0x....'....        BL       UARTDRV_Transmit
   \       0x44   0xB970             CBNZ.N   R0,??txCatchUp_0
    919                  return;
    920                }
    921                length -= comhandle->txsize - comhandle->txQueue->tail;
   \       0x46   0x6862             LDR      R2,[R4, #+4]
   \       0x48   0x8961             LDRH     R1,[R4, #+10]
   \       0x4A   0x8850             LDRH     R0,[R2, #+2]
    922                fifotail = comhandle->txQueue->fifo;
   \       0x4C   0xF102 0x0708      ADD      R7,R2,#+8
   \       0x50   0x1A6D             SUBS     R5,R5,R1
   \       0x52   0x1945             ADDS     R5,R0,R5
    923              }
    924              if (UARTDRV_Transmit(comhandle->uarthandle, fifotail, length, txCallback)
    925                  == EMBER_SUCCESS) {
   \                     ??txCatchUp_1: (+1)
   \       0x54   0x69A0             LDR      R0,[R4, #+24]
   \       0x56   0x4633             MOV      R3,R6
   \       0x58   0xB2EA             UXTB     R2,R5
   \       0x5A   0x4639             MOV      R1,R7
   \       0x5C   0x....'....        BL       UARTDRV_Transmit
   \       0x60   0xB900             CBNZ.N   R0,??txCatchUp_0
    926                comhandle->txCatchUp = false;
   \       0x62   0x7360             STRB     R0,[R4, #+13]
    927              }
    928            }
    929          }
   \                     ??txCatchUp_0: (+1)
   \       0x64   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
    930          

   \                                 In section .text, align 4, keep-with-next
    931          static void txCallback(UARTDRV_Handle_t handle,
    932                                 Ecode_t transferStatus,
    933                                 uint8_t *data,
    934                                 UARTDRV_Count_t transferCount)
    935          {
   \                     txCallback: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
    936            COM_Handle_t comhandle;
    937            // Figure out which com port this is
    938            //
    939            for (uint8_t i = 0; i < comHandleIndexSize; i++) {
   \        0x2   0x....'....        LDR.W    R4,??DataTable10
   \        0x6   0x69A1             LDR      R1,[R4, #+24]
   \        0x8   0x461D             MOV      R5,R3
   \        0xA   0x4281             CMP      R1,R0
   \        0xC   0xD115             BNE.N    ??txCallback_0
    940              comhandle = &comhandledata[i];
    941              if (comhandle->uarthandle == handle) {
    942                dequeueFifoBuffer(comhandle,
    943                                  (transferCount > comhandle->txQueue->used)
    944                                  ? comhandle->txQueue->used
    945                                  : transferCount);
   \        0xE   0x6860             LDR      R0,[R4, #+4]
   \       0x10   0x8881             LDRH     R1,[R0, #+4]
   \       0x12   0x42A9             CMP      R1,R5
   \       0x14   0xBF38             IT       CC 
   \       0x16   0x8885             LDRHCC   R5,[R0, #+4]
   \       0x18   0x....'....        BL       CORE_EnterAtomic
   \       0x1C   0x6862             LDR      R2,[R4, #+4]
   \       0x1E   0xB2A9             UXTH     R1,R5
   \       0x20   0x8853             LDRH     R3,[R2, #+2]
   \       0x22   0x18CB             ADDS     R3,R1,R3
   \       0x24   0x8961             LDRH     R1,[R4, #+10]
   \       0x26   0xFB93 0xF6F1      SDIV     R6,R3,R1
   \       0x2A   0xFB01 0x3316      MLS      R3,R1,R6,R3
   \       0x2E   0x8053             STRH     R3,[R2, #+2]
   \       0x30   0x6861             LDR      R1,[R4, #+4]
   \       0x32   0x888A             LDRH     R2,[R1, #+4]
   \       0x34   0x1B55             SUBS     R5,R2,R5
   \       0x36   0x808D             STRH     R5,[R1, #+4]
   \       0x38   0x....             B.N      ?Subroutine0
    946              }
    947            }
    948          }
   \                     ??txCallback_0: (+1)
   \       0x3A   0xBD70             POP      {R4-R6,PC}       ;; return
    949          
    950          #endif //defined(COM_UART_ENABLE)
    951          
    952          static void COM_RX_IRQHandler(COM_Handle_t comhandle, uint8_t byte)
                             ^
Warning[Pe177]: function "COM_RX_IRQHandler" was declared but never referenced
    953          {
    954            UARTDRV_FlowControlState_t fcState;
    955            uint16_t freeSpace;
    956          
    957            // Intercept and handle flow control bytes
    958            if (byte == UARTDRV_FC_SW_XON) {
    959              UARTDRV_FlowControlSetPeerStatus(comhandle->uarthandle, uartdrvFlowControlOn);
    960              comhandle->txPaused = false;
    961              // Transmit queued data in the TX FIFO queue
    962              txCatchUp(comhandle);
    963            } else if (byte == UARTDRV_FC_SW_XOFF) {
    964              UARTDRV_FlowControlSetPeerStatus(comhandle->uarthandle, uartdrvFlowControlOff);
    965              comhandle->txPaused = true;
    966            } else {
    967              // store byte in RX FIFO
    968              FIFO_ENQUEUE(comhandle->rxQueue, byte, comhandle->rxsize);
    969              // Send flow control byte if threshold exceeded
    970              fcState = UARTDRV_FlowControlGetSelfStatus(comhandle->uarthandle);
    971              freeSpace = comhandle->rxsize - comhandle->rxQueue->used;
    972              if ((fcState == uartdrvFlowControlOn) && (freeSpace <= comhandle->rxStop)) {
    973                UARTDRV_FlowControlSet(comhandle->uarthandle, uartdrvFlowControlOff);
    974              } else if ((fcState == uartdrvFlowControlOff) && (freeSpace >= comhandle->rxStart)) {
    975                UARTDRV_FlowControlSet(comhandle->uarthandle, uartdrvFlowControlOn);
    976              }
    977            }
    978          }
    979          
    980          #if !defined (_SILICON_LABS_32B_SERIES_2)
    981          #ifdef COM_USART0_ENABLE
    982          void USART0_RX_IRQHandler(void)
    983          {
    984            COM_Handle_t comhandle = getComHandleFromPort(comPortUsart0);
    985          
    986            if (comhandle->uarthandle->fcType == uartdrvFlowControlSw) {
    987              if (USART0->STATUS & USART_STATUS_RXDATAV) {
    988                COM_RX_IRQHandler(comhandle, USART_Rx(USART0));
    989              }
    990            } else {
    991              USART0->IEN &= ~USART_IEN_RXDATAV;
    992            }
    993          }
    994          #endif // COM_USART0_ENABLE
    995          #endif // !defined (_SILICON_LABS_32B_SERIES_2)
    996          
    997          #ifdef COM_USART1_ENABLE
    998          void USART1_RX_IRQHandler(void)
    999          {
   1000            COM_Handle_t comhandle = getComHandleFromPort(comPortUsart1);
   1001          
   1002            if (comhandle->uarthandle->fcType == uartdrvFlowControlSw) {
   1003              if (USART1->STATUS & USART_STATUS_RXDATAV) {
   1004                COM_RX_IRQHandler(comhandle, USART_Rx(USART1));
   1005              }
   1006            } else {
   1007              USART1->IEN &= ~USART_IEN_RXDATAV;
   1008            }
   1009          }
   1010          
   1011          #endif
   1012          
   1013          #ifdef COM_USART2_ENABLE
   1014          void USART2_RX_IRQHandler(void)
   1015          {
   1016            COM_Handle_t comhandle = getComHandleFromPort(comPortUsart2);
   1017          
   1018            if (comhandle->uarthandle->fcType == uartdrvFlowControlSw) {
   1019              if (USART2->STATUS & USART_STATUS_RXDATAV) {
   1020                COM_RX_IRQHandler(comhandle, USART_Rx(USART2));
   1021              }
   1022            } else {
   1023              USART2->IEN &= ~USART_IEN_RXDATAV;
   1024            }
   1025          }
   1026          
   1027          #endif
   1028          
   1029          #ifdef COM_USART3_ENABLE
   1030          void USART3_RX_IRQHandler(void)
   1031          {
   1032            COM_Handle_t comhandle = getComHandleFromPort(comPortUsart3);
   1033          
   1034            if (comhandle->uarthandle->fcType == uartdrvFlowControlSw) {
   1035              if (USART3->STATUS & USART_STATUS_RXDATAV) {
   1036                COM_RX_IRQHandler(comhandle, USART_Rx(USART3));
   1037              }
   1038            } else {
   1039              USART3->IEN &= ~USART_IEN_RXDATAV;
   1040            }
   1041          }
   1042          
   1043          #endif
   1044          
   1045          /* "power down" COM by switching from DMA to UART byte interrupts in EM1
   1046           *  or to GPIO interrupts otherwise
   1047           */

   \                                 In section .text, align 2, keep-with-next
   1048          void COM_InternalPowerDown(bool idle)
   1049          {
   \                     COM_InternalPowerDown: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD000             BEQ.N    ??COM_InternalPowerDown_0
   \        0x4   0x4770             BX       LR
   \                     ??COM_InternalPowerDown_0: (+1)
   \        0x6   0xB580             PUSH     {R7,LR}
   1050            if (idle == false) {
   1051              #ifdef COM_USART0_ENABLE
   1052              USART_Enable(USART0, usartDisable);
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x....'....        LDR.W    R0,??DataTable10_7  ;; 0x40058000
   \        0xE   0x....'....        BL       USART_Enable
   1053                #ifdef _SILICON_LABS_32B_SERIES_2 // Reduces sleep current per EMHAL-1791
   1054              GPIO_PinModeSet(BSP_USART0_TX_PORT, BSP_USART0_TX_PIN, gpioModeDisabled, 1);
   \       0x12   0x2301             MOVS     R3,#+1
   \       0x14   0x2200             MOVS     R2,#+0
   \       0x16   0x....             B.N      ?Subroutine1
   1055                #endif
   1056              #endif
   1057              #ifdef COM_USART1_ENABLE
   1058              USART_Enable(USART1, usartDisable);
   1059                #ifdef _SILICON_LABS_32B_SERIES_2 // Reduces sleep current
   1060              GPIO_PinModeSet(BSP_USART1_TX_PORT, BSP_USART1_TX_PIN, gpioModeDisabled, 1);
   1061                #endif
   1062              #endif
   1063              #ifdef COM_USART2_ENABLE
   1064              USART_Enable(USART2, usartDisable);
   1065                #ifdef _SILICON_LABS_32B_SERIES_2 // Reduces sleep current
   1066              GPIO_PinModeSet(BSP_USART2_TX_PORT, BSP_USART2_TX_PIN, gpioModeDisabled, 1);
   1067                #endif
   1068              #endif
   1069              #ifdef COM_USART3_ENABLE
   1070              USART_Enable(USART3, usartDisable);
   1071                #ifdef _SILICON_LABS_32B_SERIES_2 // Reduces sleep current
   1072              GPIO_PinModeSet(BSP_USART3_TX_PORT, BSP_USART3_TX_PIN, gpioModeDisabled, 1);
   1073                #endif
   1074              #endif
   1075          
   1076              #if (HAL_SERIAL_RXWAKE_ENABLE)
   1077              rxGpioIntEnable();
   1078              #endif
   1079            } else {
   1080              #if HAL_SERIAL_IDLE_WAKE_ENABLE
   1081                #ifdef COM_USART0_ENABLE
   1082              NVIC_ClearPendingIRQ(USART0_RX_IRQn);
   1083              NVIC_EnableIRQ(USART0_RX_IRQn);
   1084              USART_IntEnable(USART0, USART_IF_RXDATAV);
   1085                #endif
   1086                #ifdef COM_USART1_ENABLE
   1087              NVIC_ClearPendingIRQ(USART1_RX_IRQn);
   1088              NVIC_EnableIRQ(USART1_RX_IRQn);
   1089              USART_IntEnable(USART1, USART_IF_RXDATAV);
   1090                #endif
   1091                #ifdef COM_USART2_ENABLE
   1092              NVIC_ClearPendingIRQ(USART2_RX_IRQn);
   1093              NVIC_EnableIRQ(USART2_RX_IRQn);
   1094              USART_IntEnable(USART2, USART_IF_RXDATAV);
   1095                #endif
   1096                #ifdef COM_USART3_ENABLE
   1097              NVIC_ClearPendingIRQ(USART3_RX_IRQn);
   1098              NVIC_EnableIRQ(USART3_RX_IRQn);
   1099              USART_IntEnable(USART3, USART_IF_RXDATAV);
   1100                #endif
   1101              #endif
   1102            }
   1103          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x2105             MOVS     R1,#+5
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0xE8BD 0x5000      POP      {R12,LR}
   \        0x8   0x....'....        B.W      GPIO_PinModeSet
   1104          
   1105          /* "power up" COM by switching back to DMA interrupts */

   \                                 In section .text, align 2, keep-with-next
   1106          void COM_InternalPowerUp(bool idle)
   1107          {
   \                     COM_InternalPowerUp: (+1)
   \        0x0   0x2800             CMP      R0,#+0
   \        0x2   0xD000             BEQ.N    ??COM_InternalPowerUp_0
   \        0x4   0x4770             BX       LR
   \                     ??COM_InternalPowerUp_0: (+1)
   \        0x6   0xB580             PUSH     {R7,LR}
   1108            if (idle == false) {
   1109              #ifdef COM_USART0_ENABLE
   1110              USART_Enable(USART0, usartEnable);
   \        0x8   0x2105             MOVS     R1,#+5
   \        0xA   0x....'....        LDR.W    R0,??DataTable10_7  ;; 0x40058000
   \        0xE   0x....'....        BL       USART_Enable
   1111                #ifdef _SILICON_LABS_32B_SERIES_2 // Re-enable TX GPIO after sleep
   1112              GPIO_PinModeSet(BSP_USART0_TX_PORT, BSP_USART0_TX_PIN, gpioModePushPull, 1);
   \       0x12   0x2301             MOVS     R3,#+1
   \       0x14   0x2204             MOVS     R2,#+4
   \       0x16                      REQUIRE ?Subroutine1
   \       0x16                      ;; // Fall through to label ?Subroutine1
   1113                #endif
   1114              #endif
   1115              #ifdef COM_USART1_ENABLE
   1116              USART_Enable(USART1, usartEnable);
   1117                #ifdef _SILICON_LABS_32B_SERIES_2 // Re-enable TX GPIO after sleep
   1118              GPIO_PinModeSet(BSP_USART1_TX_PORT, BSP_USART1_TX_PIN, gpioModePushPull, 1);
   1119                #endif
   1120              #endif
   1121              #ifdef COM_USART2_ENABLE
   1122              USART_Enable(USART2, usartEnable);
   1123                #ifdef _SILICON_LABS_32B_SERIES_2 // Re-enable TX GPIO after sleep
   1124              GPIO_PinModeSet(BSP_USART2_TX_PORT, BSP_USART2_TX_PIN, gpioModePushPull, 1);
   1125                #endif
   1126              #endif
   1127              #ifdef COM_USART3_ENABLE
   1128              USART_Enable(USART3, usartEnable);
   1129                #ifdef _SILICON_LABS_32B_SERIES_2 // Re-enable TX GPIO after sleep
   1130              GPIO_PinModeSet(BSP_USART3_TX_PORT, BSP_USART3_TX_PIN, gpioModePushPull, 1);
   1131                #endif
   1132              #endif
   1133          
   1134              #if (HAL_SERIAL_RXWAKE_ENABLE)
   1135              rxGpioIntDisable();
   1136              #endif
   1137            } else {
   1138              #if HAL_SERIAL_IDLE_WAKE_ENABLE
   1139                #ifdef COM_USART0_ENABLE
   1140              NVIC_ClearPendingIRQ(USART0_RX_IRQn);
   1141              NVIC_DisableIRQ(USART0_RX_IRQn);
   1142                #endif
   1143                #ifdef COM_USART1_ENABLE
   1144              NVIC_ClearPendingIRQ(USART1_RX_IRQn);
   1145              NVIC_DisableIRQ(USART1_RX_IRQn);
   1146                #endif
   1147                #ifdef COM_USART2_ENABLE
   1148              NVIC_ClearPendingIRQ(USART2_RX_IRQn);
   1149              NVIC_DisableIRQ(USART2_RX_IRQn);
   1150                #endif
   1151                #ifdef COM_USART3_ENABLE
   1152              NVIC_ClearPendingIRQ(USART3_RX_IRQn);
   1153              NVIC_DisableIRQ(USART3_RX_IRQn);
   1154                #endif
   1155              #endif
   1156            }
   1157          }
   1158          
   1159          /* Inject data into the RX FIFO */

   \                                 In section .text, align 2, keep-with-next
   1160          Ecode_t COM_InternalReceiveData(COM_Port_t port, uint8_t *data, uint32_t length)
   1161          {
   \                     COM_InternalReceiveData: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4615             MOV      R5,R2
   1162            COM_Handle_t comhandle = getComHandleFromPort(port);
   \        0x6   0x....'....        BL       getComHandleFromPort
   \        0xA   0x4606             MOV      R6,R0
   1163            // Check for space for this message in the FIFO
   1164            if (!getInputFifoSpace(comhandle, length)) {
   \        0xC   0x6830             LDR      R0,[R6, #+0]
   \        0xE   0x8881             LDRH     R1,[R0, #+4]
   \       0x10   0x8932             LDRH     R2,[R6, #+8]
   \       0x12   0xB2E8             UXTB     R0,R5
   \       0x14   0x1A12             SUBS     R2,R2,R0
   \       0x16   0x4291             CMP      R1,R2
   \       0x18   0xDB01             BLT.N    ??COM_InternalReceiveData_0
   1165              return EMBER_ERR_FATAL;
   \       0x1A   0x2001             MOVS     R0,#+1
   \       0x1C   0xBDF2             POP      {R1,R4-R7,PC}
   1166            }
   1167          
   1168            for (uint32_t i = 0; i < length; i++) {
   \                     ??COM_InternalReceiveData_0: (+1)
   \       0x1E   0x2700             MOVS     R7,#+0
   \       0x20   0xE00D             B.N      ??CrossCallReturnLabel_1
   1169              CORE_DECLARE_IRQ_STATE;
   1170              CORE_ENTER_ATOMIC();
   \                     ??COM_InternalReceiveData_1: (+1)
   \       0x22   0x....'....        BL       CORE_EnterAtomic
   1171              FIFO_ENQUEUE(comhandle->rxQueue, *data, comhandle->rxsize);
   \       0x26   0x6831             LDR      R1,[R6, #+0]
   \       0x28   0xF814 0x2B01      LDRB     R2,[R4], #+1
   \       0x2C   0x1C7F             ADDS     R7,R7,#+1
   \       0x2E   0xF101 0x0308      ADD      R3,R1,#+8
   \       0x32   0x8809             LDRH     R1,[R1, #+0]
   \       0x34   0x545A             STRB     R2,[R3, R1]
   \       0x36   0x6831             LDR      R1,[R6, #+0]
   \       0x38   0x8933             LDRH     R3,[R6, #+8]
   \       0x3A   0x....'....        BL       ?Subroutine2
   1172              CORE_EXIT_ATOMIC();
   1173              data++;
   1174            }
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x3E   0x42AF             CMP      R7,R5
   \       0x40   0xD3EF             BCC.N    ??COM_InternalReceiveData_1
   1175          
   1176            return EMBER_SUCCESS;
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1177          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x880A             LDRH     R2,[R1, #+0]
   \        0x2   0x1C52             ADDS     R2,R2,#+1
   \        0x4   0xFB92 0xFCF3      SDIV     R12,R2,R3
   \        0x8   0xFB03 0x221C      MLS      R2,R3,R12,R2
   \        0xC   0x800A             STRH     R2,[R1, #+0]
   \        0xE   0x888A             LDRH     R2,[R1, #+4]
   \       0x10   0x1C52             ADDS     R2,R2,#+1
   \       0x12   0x808A             STRH     R2,[R1, #+4]
   \       0x14   0x....'....        B.W      CORE_ExitAtomic
   1178          

   \                                 In section .text, align 2, keep-with-next
   1179          bool COM_InternalRxIsPaused(COM_Port_t port)
   1180          {
   1181            // UART
   1182          #if defined(COM_UART_ENABLE)
   1183            if (checkValidUartPort(port)) {
   \                     COM_InternalRxIsPaused: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xB580             PUSH     {R7,LR}
   \        0x4   0xBF18             IT       NE 
   \        0x6   0x2820             CMPNE    R0,#+32
   \        0x8   0xD106             BNE.N    ??COM_InternalRxIsPaused_0
   1184              COM_Handle_t comhandle = getComHandleFromPort(port);
   \        0xA   0x....'....        BL       getComHandleFromPort
   1185              return (UARTDRV_FlowControlGetSelfStatus(comhandle->uarthandle) == uartdrvFlowControlOff);
   \        0xE   0x6980             LDR      R0,[R0, #+24]
   \       0x10   0x....'....        BL       UARTDRV_FlowControlGetSelfStatus
   \       0x14   0x2801             CMP      R0,#+1
   \       0x16   0xD000             BEQ.N    ??COM_InternalRxIsPaused_1
   \                     ??COM_InternalRxIsPaused_0: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \                     ??COM_InternalRxIsPaused_1: (+1)
   \       0x1A   0xBD02             POP      {R1,PC}          ;; return
   1186            }
   1187          #endif
   1188            return false;
   1189          }
   1190          

   \                                 In section .text, align 2, keep-with-next
   1191          bool COM_InternalTxIsIdle(COM_Port_t port)
   1192          {
   1193            // UART
   1194          #if defined(COM_UART_ENABLE)
   1195            if (checkValidUartPort(port)) {
   \                     COM_InternalTxIsIdle: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xB510             PUSH     {R4,LR}
   \        0x4   0xBF18             IT       NE 
   \        0x6   0x2820             CMPNE    R0,#+32
   \        0x8   0xD107             BNE.N    ??COM_InternalTxIsIdle_0
   1196              COM_Handle_t comhandle = getComHandleFromPort(port);
   \        0xA   0x....'....        BL       getComHandleFromPort
   \        0xE   0x4604             MOV      R4,R0
   1197              return ((UARTDRV_GetPeripheralStatus(comhandle->uarthandle) & UARTDRV_STATUS_TXIDLE)
   1198                      && (comhandle->txQueue->used == 0)
   1199                      && (UARTDRV_GetTransmitDepth(comhandle->uarthandle) == 0));
   \       0x10   0x69A0             LDR      R0,[R4, #+24]
   \       0x12   0x....'....        BL       UARTDRV_GetPeripheralStatus
   \       0x16   0x0480             LSLS     R0,R0,#+18
   \       0x18   0xD401             BMI.N    ??COM_InternalTxIsIdle_1
   \                     ??COM_InternalTxIsIdle_0: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xBD10             POP      {R4,PC}          ;; return
   \                     ??COM_InternalTxIsIdle_1: (+1)
   \       0x1E   0x6861             LDR      R1,[R4, #+4]
   \       0x20   0x8888             LDRH     R0,[R1, #+4]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD1F9             BNE.N    ??COM_InternalTxIsIdle_0
   \       0x26   0x69A0             LDR      R0,[R4, #+24]
   \       0x28   0x....'....        BL       UARTDRV_GetTransmitDepth
   \       0x2C   0x1E40             SUBS     R0,R0,#+1
   \       0x2E   0x4180             SBCS     R0,R0,R0
   \       0x30   0x0FC0             LSRS     R0,R0,#+31
   \       0x32   0xBD10             POP      {R4,PC}
   1200            }
   1201          #endif
   1202            return false;
   1203          }
   1204          

   \                                 In section .text, align 2, keep-with-next
   1205          bool COM_InternalTxIsPaused(COM_Port_t port)
   1206          {
   \                     COM_InternalTxIsPaused: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1207            COM_Handle_t comhandle = getComHandleFromPort(port);
   \        0x2   0x....'....        BL       getComHandleFromPort
   1208            return comhandle->txPaused;
   \        0x6   0x7B00             LDRB     R0,[R0, #+12]
   \        0x8   0xBD02             POP      {R1,PC}          ;; return
   1209          }
   1210          
   1211          //------------------------------------------------------
   1212          // Serial initialization
   1213          

   \                                 In section .text, align 2, keep-with-next
   1214          Ecode_t COM_Init(COM_Port_t port, COM_Init_t *init)
   1215          {
   1216            if (checkValidPort(port) == false) {
   \                     COM_Init: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xB5F8             PUSH     {R3-R7,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0xBF18             IT       NE 
   \        0xA   0x2820             CMPNE    R0,#+32
   \        0xC   0xD13A             BNE.N    ??COM_Init_0
   1217              return EMBER_ERR_FATAL;
   1218            }
   1219            if (!COM_Unused(port)) {
   \        0xE   0x....'....        BL       COM_Unused
   \       0x12   0xB910             CBNZ.N   R0,??COM_Init_1
   1220              // Port already configured; reinitialize
   1221              COM_DeInit(port);
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x....'....        BL       COM_DeInit
   1222            }
   1223          
   1224            COM_Handle_t comhandle = getComHandleFromPort(port);
   \                     ??COM_Init_1: (+1)
   \       0x1A   0x4620             MOV      R0,R4
   \       0x1C   0x....'....        BL       getComHandleFromPort
   \       0x20   0x4606             MOV      R6,R0
   1225          
   1226            if (setComHandleQueues(port) != EMBER_SUCCESS) {
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x....'....        BL       getComHandleFromPort
   \       0x28   0x2C01             CMP      R4,#+1
   \       0x2A   0xBF18             IT       NE 
   \       0x2C   0x2C20             CMPNE    R4,#+32
   \       0x2E   0xD129             BNE.N    ??COM_Init_0
   \       0x30   0x....'....        LDR.W    R1,??DataTable10_8
   \       0x34   0x6001             STR      R1,[R0, #+0]
   \       0x36   0x....'....        LDR.W    R2,??DataTable10_9
   \       0x3A   0x2380             MOVS     R3,#+128
   1227              return EMBER_ERR_FATAL;
   1228            }
   1229          
   1230            // VCP
   1231          #if (COM_VCP_PORTS > 0) && defined(COM_VCP_ENABLE)
   1232            if (checkValidVcpPort(port)) {
   1233              return emDebugInit();
   1234            }
   1235          #endif
   1236          
   1237            // UART
   1238          #if defined(COM_UART_ENABLE)
   1239            if (checkValidUartPort(port)) {
   \       0x3C   0x2C01             CMP      R4,#+1
   \       0x3E   0x6042             STR      R2,[R0, #+4]
   \       0x40   0x8103             STRH     R3,[R0, #+8]
   \       0x42   0x8143             STRH     R3,[R0, #+10]
   \       0x44   0xBF18             IT       NE 
   \       0x46   0x2C20             CMPNE    R4,#+32
   \       0x48   0xD153             BNE.N    ??CrossCallReturnLabel_4
   1240              Ecode_t status;
   1241          
   1242              comhandle->uarthandle = getUartHandleFromPort(port);
   \       0x4A   0x2C01             CMP      R4,#+1
   \       0x4C   0xBF16             ITET     NE 
   \       0x4E   0x2C20             CMPNE    R4,#+32
   \       0x50   0x....'....        LDREQ.W  R0,??DataTable10_10
   \       0x54   0x2000             MOVNE    R0,#+0
   1243          
   1244              // add rx/tx buffer queue to initdata
   1245              if (setUartBufferQueues(port, init) != EMBER_SUCCESS) {
   \       0x56   0x2C01             CMP      R4,#+1
   \       0x58   0x61B0             STR      R0,[R6, #+24]
   \       0x5A   0xBF18             IT       NE 
   \       0x5C   0x2C20             CMPNE    R4,#+32
   \       0x5E   0xD111             BNE.N    ??COM_Init_0
   \       0x60   0x....'....        LDR.W    R1,??DataTable10_11
   \       0x64   0x6229             STR      R1,[R5, #+32]
   1246                return EMBER_ERR_FATAL;
   1247              }
   1248          
   1249              // store RX flow control thresholds
   1250              comhandle->rxStop = init->rxStop;
   \       0x66   0x8CA9             LDRH     R1,[R5, #+36]
   \       0x68   0x....'....        LDR.W    R0,??DataTable10_12
   \       0x6C   0x61E8             STR      R0,[R5, #+28]
   \       0x6E   0x81F1             STRH     R1,[R6, #+14]
   1251              comhandle->rxStart = init->rxStart;
   \       0x70   0x8CEB             LDRH     R3,[R5, #+38]
   \       0x72   0x8233             STRH     R3,[R6, #+16]
   1252          
   1253              if (!checkValidThresholds(comhandle)) {
   \       0x74   0x428B             CMP      R3,R1
   \       0x76   0xD207             BCS.N    ??COM_Init_2
   1254                // Reset COM handle
   1255                memset(comhandle, 0, sizeof(COM_HandleData_t));
   \                     ??COM_Init_3: (+1)
   \       0x78   0x211C             MOVS     R1,#+28
   \       0x7A   0x4630             MOV      R0,R6
   \       0x7C   0x....'....        BL       __aeabi_memclr4
   1256                return EMBER_BAD_ARGUMENT;
   \       0x80   0x2002             MOVS     R0,#+2
   \       0x82   0xBDF2             POP      {R1,R4-R7,PC}
   1257              }
   \                     ??COM_Init_0: (+1)
   \       0x84   0x2001             MOVS     R0,#+1
   \       0x86   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??COM_Init_2: (+1)
   \       0x88   0x69B2             LDR      R2,[R6, #+24]
   \       0x8A   0xF892 0x0031      LDRB     R0,[R2, #+49]
   \       0x8E   0x2801             CMP      R0,#+1
   \       0x90   0xD00C             BEQ.N    ??COM_Init_4
   \       0x92   0x8930             LDRH     R0,[R6, #+8]
   \       0x94   0xFB90 0xF7F1      SDIV     R7,R0,R1
   \       0x98   0xFB01 0x0017      MLS      R0,R1,R7,R0
   \       0x9C   0x2800             CMP      R0,#+0
   \       0x9E   0xBF02             ITTT     EQ 
   \       0xA0   0xFB93 0xF0F1      SDIVEQ   R0,R3,R1
   \       0xA4   0xFB01 0x3110      MLSEQ    R1,R1,R0,R3
   \       0xA8   0x2900             CMPEQ    R1,#+0
   \       0xAA   0xD1E5             BNE.N    ??COM_Init_3
   1258          
   1259              // iniitalize hardware
   1260              if (checkValidLeuartPort(port)) {
   1261          #if defined(LEUART_PRESENT)
   1262                status = UARTDRV_InitLeuart(comhandle->uarthandle, &init->uartdrvinit.leuartinit);
   1263          #endif // LEUART_PRESENT
   1264              } else { //USART
   1265                status = UARTDRV_InitUart(comhandle->uarthandle, &init->uartdrvinit.uartinit);
   \                     ??COM_Init_4: (+1)
   \       0xAC   0x4629             MOV      R1,R5
   \       0xAE   0x4610             MOV      R0,R2
   \       0xB0   0x....'....        BL       UARTDRV_InitUart
   1266              }
   1267              if (status != EMBER_SUCCESS) {
   \       0xB4   0xB9F0             CBNZ.N   R0,??COM_Init_5
   1268                return status;
   1269              }
   1270              GPIO_PinModeSet(comhandle->uarthandle->rxPort,
   1271                              comhandle->uarthandle->rxPin,
   1272                              gpioModeInputPull,
   1273                              1);
   \       0xB6   0x69B0             LDR      R0,[R6, #+24]
   \       0xB8   0x2301             MOVS     R3,#+1
   \       0xBA   0x2202             MOVS     R2,#+2
   \       0xBC   0xF890 0x1020      LDRB     R1,[R0, #+32]
   \       0xC0   0x7F00             LDRB     R0,[R0, #+28]
   \       0xC2   0x....'....        BL       GPIO_PinModeSet
   1274          
   1275              if (
   1276                #if defined(LEUART_PRESENT)
   1277                (checkValidLeuartPort(port)
   1278                 && (init->uartdrvinit.leuartinit.fcType == uartdrvFlowControlSw))
   1279                ||
   1280                #endif // LEUART_PRESENT
   1281                (!checkValidLeuartPort(port)
   1282                 && (init->uartdrvinit.uartinit.fcType == uartdrvFlowControlSw))) {
   \       0xC6   0x7D28             LDRB     R0,[R5, #+20]
   \       0xC8   0x2801             CMP      R0,#+1
   \       0xCA   0xD107             BNE.N    ??COM_Init_6
   1283                enableRxIrq(port, true);
   \       0xCC   0x2101             MOVS     R1,#+1
   \       0xCE   0x4620             MOV      R0,R4
   \       0xD0   0x....'....        BL       enableRxIrq
   1284                // begin by sending XON
   1285                UARTDRV_FlowControlSet(comhandle->uarthandle, uartdrvFlowControlOn);
   \       0xD4   0x69B0             LDR      R0,[R6, #+24]
   \       0xD6   0x....'....        BL       ??Subroutine6_0
   1286              } else {
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0xDA   0xE00A             B.N      ??CrossCallReturnLabel_4
   1287                comhandle->bufferIndex = 0;
   \                     ??COM_Init_6: (+1)
   \       0xDC   0x2000             MOVS     R0,#+0
   \       0xDE   0x8270             STRH     R0,[R6, #+18]
   1288                comhandle->bufferLimit = comhandle->rxsize / comhandle->rxStop;
   \       0xE0   0x8931             LDRH     R1,[R6, #+8]
   \       0xE2   0x89F0             LDRH     R0,[R6, #+14]
   \       0xE4   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \       0xE8   0x82B0             STRH     R0,[R6, #+20]
   1289          
   1290                // start ping pong buffers for FIFO
   1291                rxNextBuffer(comhandle);
   \       0xEA   0x....'....        BL       ?Subroutine3
   1292                rxNextBuffer(comhandle);
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0xEE   0x....'....        BL       ?Subroutine3
   1293              }
   1294            }
   1295          #endif // COM_UART_ENABLE
   1296            COM_RxGpioWakeInit();
   1297          
   1298            return EMBER_SUCCESS;
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0xF2   0x2000             MOVS     R0,#+0
   \                     ??COM_Init_5: (+1)
   \       0xF4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1299          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x4630             MOV      R0,R6
   \        0x2   0x....'....        B.W      rxNextBuffer
   1300          

   \                                 In section .text, align 2, keep-with-next
   1301          Ecode_t COM_DeInit(COM_Port_t port)
   1302          {
   1303            COM_Handle_t comhandle;
   1304            Ecode_t status;
   1305          
   1306            if (checkValidPort(port) == false) {
   \                     COM_DeInit: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xB558             PUSH     {R3,R4,R6,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0xBF18             IT       NE 
   \        0x8   0x2820             CMPNE    R0,#+32
   \        0xA   0xD112             BNE.N    ??COM_DeInit_0
   1307              return EMBER_ERR_FATAL;
   1308            }
   1309            if (COM_Unused(port)) {
   \        0xC   0x....'....        BL       COM_Unused
   \       0x10   0xB9E8             CBNZ.N   R0,??COM_DeInit_1
   1310              return EMBER_SUCCESS;
   1311            }
   1312          
   1313            COM_FlushRx(port);
   \       0x12   0x4620             MOV      R0,R4
   \       0x14   0x....'....        BL       COM_FlushRx
   1314          
   1315            comhandle = getComHandleFromPort(port);
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x....'....        BL       getComHandleFromPort
   1316          
   1317          #if defined(COM_UART_ENABLE)
   1318            if (checkValidUartPort(port)) {
   \       0x1E   0x2C01             CMP      R4,#+1
   \       0x20   0x4606             MOV      R6,R0
   \       0x22   0xBF18             IT       NE 
   \       0x24   0x2C20             CMPNE    R4,#+32
   \       0x26   0xD10E             BNE.N    ??COM_DeInit_2
   1319              status = UARTDRV_DeInit(comhandle->uarthandle);
   \       0x28   0x69B0             LDR      R0,[R6, #+24]
   \       0x2A   0x....'....        BL       UARTDRV_DeInit
   1320              if (status != ECODE_EMDRV_UARTDRV_OK) {
   \       0x2E   0xB110             CBZ.N    R0,??COM_DeInit_3
   1321                return status;
   \       0x30   0xBD52             POP      {R1,R4,R6,PC}
   1322              }
   \                     ??COM_DeInit_0: (+1)
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0xBD52             POP      {R1,R4,R6,PC}
   1323          
   1324              if (comhandle->uarthandle->fcType == uartdrvFlowControlSw) {
   \                     ??COM_DeInit_3: (+1)
   \       0x36   0x69B0             LDR      R0,[R6, #+24]
   \       0x38   0x....'....        BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x3C   0xD103             BNE.N    ??COM_DeInit_2
   1325                enableRxIrq(port, false);
   \       0x3E   0x2100             MOVS     R1,#+0
   \       0x40   0x4620             MOV      R0,R4
   \       0x42   0x....'....        BL       enableRxIrq
   1326              }
   1327          #if (HAL_SERIAL_RXWAKE_ENABLE)
   1328              rxGpioIntDisable();
   1329          #endif
   1330            }
   1331          #endif
   1332            memset(comhandle, 0, sizeof(COM_HandleData_t));
   \                     ??COM_DeInit_2: (+1)
   \       0x46   0x211C             MOVS     R1,#+28
   \       0x48   0x4630             MOV      R0,R6
   \       0x4A   0x....'....        BL       __aeabi_memclr4
   1333            return EMBER_SUCCESS;
   \                     ??COM_DeInit_1: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \       0x50   0xBD52             POP      {R1,R4,R6,PC}    ;; return
   1334          }
   1335          
   1336          //------------------------------------------------------
   1337          // Serial Input
   1338          
   1339          // returns # bytes available for reading

   \                                 In section .text, align 2, keep-with-next
   1340          uint16_t COM_ReadAvailable(COM_Port_t port)
   1341          {
   \                     COM_ReadAvailable: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   1342            COM_Handle_t comhandle = getComHandleFromPort(port);
   \        0x4   0x....'....        BL       getComHandleFromPort
   \        0x8   0x4605             MOV      R5,R0
   1343            // make sure rx buffer is updated
   1344            pumpRx(port);
   \        0xA   0x4620             MOV      R0,R4
   \        0xC   0x....'....        BL       pumpRx
   1345            return comhandle->rxQueue->used;
   \       0x10   0x6828             LDR      R0,[R5, #+0]
   \       0x12   0x8880             LDRH     R0,[R0, #+4]
   \       0x14   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1346          }
   1347          

   \                                 In section .text, align 2, keep-with-next
   1348          Ecode_t COM_ReadByte(COM_Port_t port, uint8_t *dataByte)
   1349          {
   1350            uint16_t nextRx;
   1351            if (checkValidPort(port) == false) {
   \                     COM_ReadByte: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xB5F8             PUSH     {R3-R7,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460F             MOV      R7,R1
   \        0x8   0xBF18             IT       NE 
   \        0xA   0x2820             CMPNE    R0,#+32
   \        0xC   0x462E             MOV      R6,R5
   \        0xE   0xD10A             BNE.N    ??COM_ReadByte_0
   1352              return EMBER_ERR_FATAL;
   1353            }
   1354            COM_Handle_t comhandle = getComHandleFromPort(port);
   \       0x10   0x....'....        BL       getComHandleFromPort
   \       0x14   0x4604             MOV      R4,R0
   1355            // make sure rx buffer is updated
   1356            pumpRx(port);
   \       0x16   0x4628             MOV      R0,R5
   \       0x18   0x....'....        BL       pumpRx
   1357            if (comhandle->rxQueue->used > 0) {
   \       0x1C   0x6821             LDR      R1,[R4, #+0]
   \       0x1E   0x8888             LDRH     R0,[R1, #+4]
   \       0x20   0xB918             CBNZ.N   R0,??COM_ReadByte_1
   1358              CORE_DECLARE_IRQ_STATE;
   1359              CORE_ENTER_ATOMIC();
   1360              *dataByte = FIFO_DEQUEUE(comhandle->rxQueue, comhandle->rxsize);
   1361          
   1362                #ifdef COM_UART_ENABLE
   1363              if (checkValidUartPort(port)
   1364                  && comhandle->uarthandle->fcType != uartdrvFlowControlSw) {
   1365                while (UARTDRV_GetReceiveDepth(comhandle->uarthandle) < 2) {
   1366                  nextRx = comhandle->bufferIndex * comhandle->rxStop;
   1367                  if (((comhandle->rxQueue->tail < (nextRx + comhandle->rxStop))
   1368                       && (nextRx < comhandle->rxQueue->head))
   1369                      || ((comhandle->rxQueue->head < comhandle->rxQueue->tail)
   1370                          && (((nextRx + comhandle->rxStop) > comhandle->rxQueue->tail)
   1371                              || (nextRx < comhandle->rxQueue->head)))) {
   1372                    break;
   1373                  }
   1374                  rxNextBuffer(comhandle);
   1375                }
   1376              }
   1377                #endif //COM_UART_ENABLE
   1378              CORE_EXIT_ATOMIC();
   1379              return EMBER_SUCCESS;
   1380            }
   1381            return EMBER_SERIAL_RX_EMPTY;
   \       0x22   0x2026             MOVS     R0,#+38
   \       0x24   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??COM_ReadByte_0: (+1)
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??COM_ReadByte_1: (+1)
   \       0x2A   0x....'....        BL       CORE_EnterAtomic
   \       0x2E   0x4605             MOV      R5,R0
   \       0x30   0x6820             LDR      R0,[R4, #+0]
   \       0x32   0x8841             LDRH     R1,[R0, #+2]
   \       0x34   0x4408             ADD      R0,R0,R1
   \       0x36   0x7A02             LDRB     R2,[R0, #+8]
   \       0x38   0x703A             STRB     R2,[R7, #+0]
   \       0x3A   0x6820             LDR      R0,[R4, #+0]
   \       0x3C   0x8922             LDRH     R2,[R4, #+8]
   \       0x3E   0x8841             LDRH     R1,[R0, #+2]
   \       0x40   0x1C49             ADDS     R1,R1,#+1
   \       0x42   0xFB91 0xF3F2      SDIV     R3,R1,R2
   \       0x46   0xFB02 0x1113      MLS      R1,R2,R3,R1
   \       0x4A   0x8041             STRH     R1,[R0, #+2]
   \       0x4C   0x8881             LDRH     R1,[R0, #+4]
   \       0x4E   0x1E4A             SUBS     R2,R1,#+1
   \       0x50   0x2E01             CMP      R6,#+1
   \       0x52   0x8082             STRH     R2,[R0, #+4]
   \       0x54   0xBF18             IT       NE 
   \       0x56   0x2E20             CMPNE    R6,#+32
   \       0x58   0xD102             BNE.N    ??COM_ReadByte_2
   \       0x5A   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x5E   0xD119             BNE.N    ??COM_ReadByte_3
   \                     ??COM_ReadByte_2: (+1)
   \       0x60   0x4628             MOV      R0,R5
   \       0x62   0x....'....        BL       CORE_ExitAtomic
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??COM_ReadByte_4: (+1)
   \       0x6A   0x89E0             LDRH     R0,[R4, #+14]
   \       0x6C   0x8A61             LDRH     R1,[R4, #+18]
   \       0x6E   0x6822             LDR      R2,[R4, #+0]
   \       0x70   0x4341             MULS     R1,R0,R1
   \       0x72   0x8853             LDRH     R3,[R2, #+2]
   \       0x74   0x8812             LDRH     R2,[R2, #+0]
   \       0x76   0xB289             UXTH     R1,R1
   \       0x78   0x1840             ADDS     R0,R0,R1
   \       0x7A   0x4283             CMP      R3,R0
   \       0x7C   0xBFB8             IT       LT 
   \       0x7E   0x4291             CMPLT    R1,R2
   \       0x80   0xDBEE             BLT.N    ??COM_ReadByte_2
   \       0x82   0x429A             CMP      R2,R3
   \       0x84   0xD203             BCS.N    ??COM_ReadByte_5
   \       0x86   0x4283             CMP      R3,R0
   \       0x88   0xBFA8             IT       GE 
   \       0x8A   0x4291             CMPGE    R1,R2
   \       0x8C   0xDBE8             BLT.N    ??COM_ReadByte_2
   \                     ??COM_ReadByte_5: (+1)
   \       0x8E   0x4620             MOV      R0,R4
   \       0x90   0x....'....        BL       rxNextBuffer
   \                     ??COM_ReadByte_3: (+1)
   \       0x94   0x69A0             LDR      R0,[R4, #+24]
   \       0x96   0x....'....        BL       UARTDRV_GetReceiveDepth
   \       0x9A   0x2802             CMP      R0,#+2
   \       0x9C   0xDBE5             BLT.N    ??COM_ReadByte_4
   \       0x9E   0xE7DF             B.N      ??COM_ReadByte_2
   1382          }
   1383          

   \                                 In section .text, align 2, keep-with-next
   1384          Ecode_t COM_ReadData(COM_Port_t port,
   1385                               uint8_t *data,
   1386                               uint16_t length,
   1387                               uint16_t *bytesRead)
   1388          {
   1389            if (checkValidPort(port) == false) {
   \                     COM_ReadData: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0xBF1C             ITT      NE 
   \        0xC   0x2820             CMPNE    R0,#+32
   \        0xE   0x2001             MOVNE    R0,#+1
   \       0x10   0x4616             MOV      R6,R2
   \       0x12   0x461C             MOV      R4,R3
   1390              return EMBER_ERR_FATAL;
   \       0x14   0xD114             BNE.N    ??COM_ReadData_0
   1391            }
   1392            uint16_t bytesReadInternal = 0;
   \       0x16   0x2700             MOVS     R7,#+0
   \       0x18   0xE001             B.N      ??COM_ReadData_1
   1393            Ecode_t status;
   1394          
   1395            while (bytesReadInternal < length) {
   1396              status = COM_ReadByte(port, data);
   1397          
   1398              switch (status) {
   1399                case EMBER_SUCCESS:
   1400                  ++data;
   \                     ??COM_ReadData_2: (+1)
   \       0x1A   0x1C6D             ADDS     R5,R5,#+1
   1401                  ++bytesReadInternal;
   \       0x1C   0x1C7F             ADDS     R7,R7,#+1
   1402                  break;
   \                     ??COM_ReadData_1: (+1)
   \       0x1E   0xB2B8             UXTH     R0,R7
   \       0x20   0x42B0             CMP      R0,R6
   \       0x22   0xD20A             BCS.N    ??COM_ReadData_3
   \       0x24   0x4629             MOV      R1,R5
   \       0x26   0x4640             MOV      R0,R8
   \       0x28   0x....'....        BL       COM_ReadByte
   \       0x2C   0x0001             MOVS     R1,R0
   \       0x2E   0xD0F4             BEQ.N    ??COM_ReadData_2
   \       0x30   0x2826             CMP      R0,#+38
   \       0x32   0xD0F4             BEQ.N    ??COM_ReadData_1
   1403          
   1404                case EMBER_SERIAL_RX_EMPTY:
   1405                  // empty queue is not an error for us, we just want to keep waiting
   1406                  break;
   1407          
   1408                default:
   1409                  // only store number of bytes read if the caller provided a non-NULL pointer
   1410                  if (bytesRead) {
   \       0x34   0xB124             CBZ.N    R4,??COM_ReadData_0
   1411                    *bytesRead = bytesReadInternal;
   \       0x36   0x8027             STRH     R7,[R4, #+0]
   1412                  }
   1413                  return status;
   \       0x38   0xE002             B.N      ??COM_ReadData_0
   1414              }
   1415            }
   1416          
   1417            // only store number of bytes read if the caller provided a non-NULL pointer
   1418            if (bytesRead) {
   \                     ??COM_ReadData_3: (+1)
   \       0x3A   0xB104             CBZ.N    R4,??COM_ReadData_4
   1419              *bytesRead = bytesReadInternal;
   \       0x3C   0x8027             STRH     R7,[R4, #+0]
   1420            }
   1421          
   1422            return EMBER_SUCCESS;
   \                     ??COM_ReadData_4: (+1)
   \       0x3E   0x2000             MOVS     R0,#+0
   \                     ??COM_ReadData_0: (+1)
   \       0x40   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1423          }
   1424          
   1425          #ifndef EMBER_TEST

   \                                 In section .text, align 2, keep-with-next
   1426          Ecode_t COM_ReadDataTimeout(COM_Port_t port,
   1427                                      uint8_t *data,
   1428                                      uint16_t length,
   1429                                      uint16_t *bytesRead,
   1430                                      uint16_t firstByteTimeout,
   1431                                      uint16_t subsequentByteTimeout)
   1432          {
   1433            if (checkValidPort(port) == false) {
   \                     COM_ReadDataTimeout: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x6   0x4680             MOV      R8,R0
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0xBF1C             ITT      NE 
   \        0xC   0x2820             CMPNE    R0,#+32
   \        0xE   0x2001             MOVNE    R0,#+1
   \       0x10   0x4691             MOV      R9,R2
   \       0x12   0x461C             MOV      R4,R3
   1434              return EMBER_ERR_FATAL;
   \       0x14   0xD121             BNE.N    ??COM_ReadDataTimeout_0
   \       0x16   0xF8DD 0xB028      LDR      R11,[SP, #+40]
   1435            }
   1436            uint16_t bytesReadInternal = 0;
   1437            Ecode_t status;
   1438            uint16_t timeout = firstByteTimeout;
   1439            uint16_t startTime = halCommonGetInt16uMillisecondTick();
   \       0x1A   0x....'....        BL       halCommonGetInt16uMillisecondTick
   \       0x1E   0x2600             MOVS     R6,#+0
   \       0x20   0x4682             MOV      R10,R0
   \       0x22   0x9F0B             LDR      R7,[SP, #+44]
   \       0x24   0xE005             B.N      ??COM_ReadDataTimeout_1
   1440          
   1441            // loop until we read the max number of bytes or the timeout elapses
   1442            while (bytesReadInternal < length
   1443                   && elapsedTimeInt16u(startTime, halCommonGetInt16uMillisecondTick()) < timeout) {
   1444              status = COM_ReadByte(port, data);
   1445          
   1446              switch (status) {
   1447                case EMBER_SUCCESS:
   1448                  ++data;
   1449                  ++bytesReadInternal;
   1450                  // reset timer and timeout for next character
   1451                  startTime = halCommonGetInt16uMillisecondTick();
   \                     ??COM_ReadDataTimeout_2: (+1)
   \       0x26   0x....'....        BL       halCommonGetInt16uMillisecondTick
   \       0x2A   0x1C6D             ADDS     R5,R5,#+1
   \       0x2C   0x1C76             ADDS     R6,R6,#+1
   \       0x2E   0x4682             MOV      R10,R0
   1452                  timeout = subsequentByteTimeout;
   \       0x30   0x46BB             MOV      R11,R7
   1453                  break;
   \                     ??COM_ReadDataTimeout_1: (+1)
   \       0x32   0xB2B0             UXTH     R0,R6
   \       0x34   0x4548             CMP      R0,R9
   \       0x36   0xD212             BCS.N    ??COM_ReadDataTimeout_3
   \       0x38   0x....'....        BL       halCommonGetInt16uMillisecondTick
   \       0x3C   0xEBA0 0x000A      SUB      R0,R0,R10
   \       0x40   0xB280             UXTH     R0,R0
   \       0x42   0x4558             CMP      R0,R11
   \       0x44   0xD20B             BCS.N    ??COM_ReadDataTimeout_3
   \       0x46   0x4629             MOV      R1,R5
   \       0x48   0x4640             MOV      R0,R8
   \       0x4A   0x....'....        BL       COM_ReadByte
   \       0x4E   0x0001             MOVS     R1,R0
   \       0x50   0xD0E9             BEQ.N    ??COM_ReadDataTimeout_2
   \       0x52   0x2826             CMP      R0,#+38
   \       0x54   0xD0ED             BEQ.N    ??COM_ReadDataTimeout_1
   1454          
   1455                case EMBER_SERIAL_RX_EMPTY:
   1456                  // empty queue is not an error for us, we just want to keep waiting
   1457                  break;
   1458          
   1459                default:
   1460                  // only store number of bytes read if the caller provided a non-NULL pointer
   1461                  if (bytesRead) {
   \       0x56   0xB104             CBZ.N    R4,??COM_ReadDataTimeout_0
   1462                    *bytesRead = bytesReadInternal;
   \       0x58   0x8026             STRH     R6,[R4, #+0]
   1463                  }
   1464                  return status;
   \                     ??COM_ReadDataTimeout_0: (+1)
   \       0x5A   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1465              }
   1466            }
   1467          
   1468            // only store number of bytes read if the caller provided a non-NULL pointer
   1469            if (bytesRead) {
   \                     ??COM_ReadDataTimeout_3: (+1)
   \       0x5E   0xB104             CBZ.N    R4,??COM_ReadDataTimeout_4
   1470              *bytesRead = bytesReadInternal;
   \       0x60   0x8026             STRH     R6,[R4, #+0]
   1471            }
   1472          
   1473            return bytesReadInternal == length ? EMBER_SUCCESS : EMBER_SERIAL_RX_EMPTY;
   \                     ??COM_ReadDataTimeout_4: (+1)
   \       0x62   0xB2B6             UXTH     R6,R6
   \       0x64   0x454E             CMP      R6,R9
   \       0x66   0xBF0C             ITE      EQ 
   \       0x68   0x2000             MOVEQ    R0,#+0
   \       0x6A   0x2026             MOVNE    R0,#+38
   \       0x6C   0xE7F5             B.N      ??COM_ReadDataTimeout_0
   1474          }
   1475          
   1476          #endif // EMBER_TEST
   1477          

   \                                 In section .text, align 2, keep-with-next
   1478          Ecode_t COM_ReadPartialLine(COM_Port_t port, char *data, uint8_t max, uint8_t * index)
   1479          {
   1480            if (checkValidPort(port) == false) {
   \                     COM_ReadPartialLine: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xB5F8             PUSH     {R3-R7,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0xBF18             IT       NE 
   \        0xA   0x2820             CMPNE    R0,#+32
   \        0xC   0x4616             MOV      R6,R2
   \        0xE   0x461F             MOV      R7,R3
   \       0x10   0xD106             BNE.N    ??COM_ReadPartialLine_0
   1481              return EMBER_ERR_FATAL;
   1482            }
   1483            Ecode_t err;
   1484            uint8_t ch;
   1485          
   1486            if (((*index) == 0) || ((*index) >= max)) {
   \       0x12   0x7838             LDRB     R0,[R7, #+0]
   \       0x14   0xB108             CBZ.N    R0,??COM_ReadPartialLine_1
   \       0x16   0x42B0             CMP      R0,R6
   \       0x18   0xD30A             BCC.N    ??COM_ReadPartialLine_2
   1487              data[0] = '\0';
   \                     ??COM_ReadPartialLine_1: (+1)
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0x7028             STRB     R0,[R5, #+0]
   \       0x1E   0xE007             B.N      ??COM_ReadPartialLine_2
   1488            }
   \                     ??COM_ReadPartialLine_0: (+1)
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xBDF2             POP      {R1,R4-R7,PC}
   1489          
   1490            for (;; ) {
   1491              err = COM_ReadByte(port, &ch);
   1492          
   1493              // no new serial port char?, keep looping
   1494              if (err) {
   1495                return err;
   1496              }
   1497          
   1498              // handle bogus characters
   1499              if ( ch > 0x7F ) {
   1500                continue;
   1501              }
   1502          
   1503              // handle leading newline - fogBUGZ # 584
   1504              if (((*index) == 0)
   1505                  && ((ch == '\n') || (ch == 0))) {
   1506                continue;
   1507              }
   1508          
   1509              // Drop the CR, or NULL that is part of EOL sequence.
   1510              if ((*index) >= max) {
   1511                *index = 0;
   1512                if ((ch == '\r') || (ch == 0)) {
   1513                  continue;
   1514                }
   1515              }
   1516          
   1517              // handle backspace
   1518              if ( ch == 0x8 || ch == 0x7F ) {
   1519                if ((*index) > 0 ) {
   1520                  // delete the last character from our string
   1521                  (*index)--;
   1522                  data[*index] = '\0';
   1523                  // echo backspace
   1524                  COM_WriteString(port, "\b \b");
   1525                }
   1526                // don't add or process this character
   1527                continue;
   1528              }
   1529          
   1530              //if the string is about to overflow, fake in a CR
   1531              if ((*index) + 2 > max ) {
   1532                ch = '\r';
   1533              }
   1534          
   1535              COM_WriteByte(port, ch);  // term char echo
   1536          
   1537              //upcase that char
   1538              if ( ch >= 'a' && ch <= 'z') {
   1539                ch = ch - ('a' - 'A');
   1540              }
   1541          
   1542              // build a string until we press enter
   1543              if ((ch == '\r') || (ch == '\n')) {
   1544                data[*index] = '\0';
   1545          
   1546                if (ch == '\r') {
   1547                  COM_WriteByte(port, '\n');  // "append" LF
   1548                  *index = 0;                       // Reset for next line; \n next
   1549                } else {
   1550                  COM_WriteByte(port, '\r');  // "append" CR
   1551                  *index = max;                     // Reset for next line; \r,\0 next
   1552                }
   1553          
   1554                return EMBER_SUCCESS;
   1555              }
   1556          
   1557              data[(*index)++] = ch;
   \                     ??COM_ReadPartialLine_3: (+1)
   \       0x24   0x7838             LDRB     R0,[R7, #+0]
   \       0x26   0x1C41             ADDS     R1,R0,#+1
   \       0x28   0x7039             STRB     R1,[R7, #+0]
   \       0x2A   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \       0x2E   0x542A             STRB     R2,[R5, R0]
   \                     ??COM_ReadPartialLine_2: (+1)
   \       0x30   0x4669             MOV      R1,SP
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0x....'....        BL       COM_ReadByte
   \       0x38   0x2800             CMP      R0,#+0
   \       0x3A   0xD157             BNE.N    ??COM_ReadPartialLine_4
   \       0x3C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x40   0x2880             CMP      R0,#+128
   \       0x42   0xDAF5             BGE.N    ??COM_ReadPartialLine_2
   \       0x44   0x7839             LDRB     R1,[R7, #+0]
   \       0x46   0xB919             CBNZ.N   R1,??COM_ReadPartialLine_5
   \       0x48   0x280A             CMP      R0,#+10
   \       0x4A   0xBF18             IT       NE 
   \       0x4C   0x2800             CMPNE    R0,#+0
   \       0x4E   0xD0EF             BEQ.N    ??COM_ReadPartialLine_2
   \                     ??COM_ReadPartialLine_5: (+1)
   \       0x50   0x42B1             CMP      R1,R6
   \       0x52   0xD307             BCC.N    ??COM_ReadPartialLine_6
   \       0x54   0x2100             MOVS     R1,#+0
   \       0x56   0x7039             STRB     R1,[R7, #+0]
   \       0x58   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x5C   0x280D             CMP      R0,#+13
   \       0x5E   0xBF18             IT       NE 
   \       0x60   0x2800             CMPNE    R0,#+0
   \       0x62   0xD0E5             BEQ.N    ??COM_ReadPartialLine_2
   \                     ??COM_ReadPartialLine_6: (+1)
   \       0x64   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0x68   0x2808             CMP      R0,#+8
   \       0x6A   0xBF18             IT       NE 
   \       0x6C   0x287F             CMPNE    R0,#+127
   \       0x6E   0xD10D             BNE.N    ??COM_ReadPartialLine_7
   \       0x70   0x7838             LDRB     R0,[R7, #+0]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD0DC             BEQ.N    ??COM_ReadPartialLine_2
   \       0x76   0x1E40             SUBS     R0,R0,#+1
   \       0x78   0x7038             STRB     R0,[R7, #+0]
   \       0x7A   0x2100             MOVS     R1,#+0
   \       0x7C   0xB2C0             UXTB     R0,R0
   \       0x7E   0x5429             STRB     R1,[R5, R0]
   \       0x80   0x....'....        LDR.W    R1,??DataTable10_13
   \       0x84   0x4620             MOV      R0,R4
   \       0x86   0x....'....        BL       COM_WriteString
   \       0x8A   0xE7D1             B.N      ??COM_ReadPartialLine_2
   \                     ??COM_ReadPartialLine_7: (+1)
   \       0x8C   0x7839             LDRB     R1,[R7, #+0]
   \       0x8E   0x1C89             ADDS     R1,R1,#+2
   \       0x90   0x428E             CMP      R6,R1
   \       0x92   0xBFBC             ITT      LT 
   \       0x94   0x200D             MOVLT    R0,#+13
   \       0x96   0xF88D 0x0000      STRBLT   R0,[SP, #+0]
   \       0x9A   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x9E   0x4620             MOV      R0,R4
   \       0xA0   0x....'....        BL       COM_WriteByte
   \       0xA4   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xA8   0x3861             SUBS     R0,R0,#+97
   \       0xAA   0x281A             CMP      R0,#+26
   \       0xAC   0xD205             BCS.N    ??COM_ReadPartialLine_8
   \       0xAE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xB2   0xF1A0 0x0120      SUB      R1,R0,#+32
   \       0xB6   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \                     ??COM_ReadPartialLine_8: (+1)
   \       0xBA   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xBE   0x280D             CMP      R0,#+13
   \       0xC0   0xBF18             IT       NE 
   \       0xC2   0x280A             CMPNE    R0,#+10
   \       0xC4   0xD1AE             BNE.N    ??COM_ReadPartialLine_3
   \       0xC6   0x7838             LDRB     R0,[R7, #+0]
   \       0xC8   0x2100             MOVS     R1,#+0
   \       0xCA   0x5429             STRB     R1,[R5, R0]
   \       0xCC   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \       0xD0   0x2A0D             CMP      R2,#+13
   \       0xD2   0xD105             BNE.N    ??COM_ReadPartialLine_9
   \       0xD4   0x210A             MOVS     R1,#+10
   \       0xD6   0x4620             MOV      R0,R4
   \       0xD8   0x....'....        BL       COM_WriteByte
   \       0xDC   0x2600             MOVS     R6,#+0
   \       0xDE   0xE003             B.N      ??COM_ReadPartialLine_10
   \                     ??COM_ReadPartialLine_9: (+1)
   \       0xE0   0x210D             MOVS     R1,#+13
   \       0xE2   0x4620             MOV      R0,R4
   \       0xE4   0x....'....        BL       COM_WriteByte
   \                     ??COM_ReadPartialLine_10: (+1)
   \       0xE8   0x703E             STRB     R6,[R7, #+0]
   \       0xEA   0x2000             MOVS     R0,#+0
   \                     ??COM_ReadPartialLine_4: (+1)
   \       0xEC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1558            }
   1559          }
   1560          

   \                                 In section .text, align 2, keep-with-next
   1561          Ecode_t COM_ReadLine(COM_Port_t port, char *data, uint8_t max)
   1562          {
   1563            if (checkValidPort(port) == false) {
   \                     COM_ReadLine: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xB57C             PUSH     {R2-R6,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0xBF18             IT       NE 
   \        0xA   0x2820             CMPNE    R0,#+32
   \        0xC   0x4616             MOV      R6,R2
   \        0xE   0xD001             BEQ.N    ??COM_ReadLine_0
   1564              return EMBER_ERR_FATAL;
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0xBD76             POP      {R1,R2,R4-R6,PC}
   1565            }
   1566            uint8_t index = 0;
   \                     ??COM_ReadLine_0: (+1)
   \       0x14   0x2000             MOVS     R0,#+0
   \       0x16   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x1A   0xE001             B.N      ??COM_ReadLine_1
   1567          
   1568            while (COM_ReadPartialLine(port, data, max, &index) != EMBER_SUCCESS) {
   1569              halResetWatchdog();
   \                     ??COM_ReadLine_2: (+1)
   \       0x1C   0x....'....        BL       halInternalResetWatchDog
   1570            }
   \                     ??COM_ReadLine_1: (+1)
   \       0x20   0x466B             MOV      R3,SP
   \       0x22   0x4632             MOV      R2,R6
   \       0x24   0x4629             MOV      R1,R5
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x....'....        BL       COM_ReadPartialLine
   \       0x2C   0x2800             CMP      R0,#+0
   \       0x2E   0xD1F5             BNE.N    ??COM_ReadLine_2
   \       0x30   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1571            return EMBER_SUCCESS;
   1572          }
   1573          
   1574          //------------------------------------------------------
   1575          // Serial Output
   1576          
   1577          // returns # bytes (if fifo mode)/messages (if buffer mode) that can be written

   \                                 In section .text, align 2, keep-with-next
   1578          uint16_t COM_WriteAvailable(COM_Port_t port)
   1579          {
   \                     COM_WriteAvailable: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1580            COM_Handle_t comhandle = getComHandleFromPort(port);
   \        0x2   0x....'....        BL       getComHandleFromPort
   \        0x6   0x4601             MOV      R1,R0
   1581            return comhandle->txsize - comhandle->txQueue->used;
   \        0x8   0x684A             LDR      R2,[R1, #+4]
   \        0xA   0x8948             LDRH     R0,[R1, #+10]
   \        0xC   0x8891             LDRH     R1,[R2, #+4]
   \        0xE   0x1A40             SUBS     R0,R0,R1
   \       0x10   0xB280             UXTH     R0,R0
   \       0x12   0xBD02             POP      {R1,PC}          ;; return
   1582          }
   1583          

   \                                 In section .text, align 2, keep-with-next
   1584          uint16_t COM_WriteUsed(COM_Port_t port)
   1585          {
   \                     COM_WriteUsed: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1586            COM_Handle_t comhandle = getComHandleFromPort(port);
   \        0x2   0x....'....        BL       getComHandleFromPort
   1587            return comhandle->txQueue->used;
   \        0x6   0x6840             LDR      R0,[R0, #+4]
   \        0x8   0x8880             LDRH     R0,[R0, #+4]
   \        0xA   0xBD02             POP      {R1,PC}          ;; return
   1588          }
   1589          

   \                                 In section .text, align 2, keep-with-next
   1590          Ecode_t COM_WriteByte(COM_Port_t port, uint8_t dataByte)
   1591          {
   1592            if (checkValidPort(port) == false) {
   \                     COM_WriteByte: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xB502             PUSH     {R1,LR}
   \        0x4   0xBF18             IT       NE 
   \        0x6   0x2820             CMPNE    R0,#+32
   \        0x8   0xD104             BNE.N    ??COM_WriteByte_0
   1593              return EMBER_ERR_FATAL;
   1594            }
   1595            return COM_WriteData(port, &dataByte, 1);
   \        0xA   0x2201             MOVS     R2,#+1
   \        0xC   0x4669             MOV      R1,SP
   \        0xE   0x....'....        BL       COM_WriteData
   \       0x12   0xBD02             POP      {R1,PC}
   \                     ??COM_WriteByte_0: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xBD02             POP      {R1,PC}          ;; return
   1596          }
   1597          

   \                                 In section .text, align 2, keep-with-next
   1598          Ecode_t COM_WriteHex(COM_Port_t port, uint8_t dataByte)
   1599          {
   1600            if (checkValidPort(port) == false) {
   \                     COM_WriteHex: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xB51C             PUSH     {R2-R4,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0xBF18             IT       NE 
   \        0x8   0x2820             CMPNE    R0,#+32
   \        0xA   0xD109             BNE.N    ??COM_WriteHex_0
   1601              return EMBER_ERR_FATAL;
   1602            }
   1603            uint8_t hex[2];
   1604            emWriteHexInternal(hex, dataByte, 2);
   \        0xC   0x2202             MOVS     R2,#+2
   \        0xE   0x4668             MOV      R0,SP
   \       0x10   0x....'....        BL       emWriteHexInternal
   1605            return COM_WriteData(port, hex, 2);
   \       0x14   0x2202             MOVS     R2,#+2
   \       0x16   0x4669             MOV      R1,SP
   \       0x18   0x4620             MOV      R0,R4
   \       0x1A   0x....'....        BL       COM_WriteData
   \       0x1E   0xBD16             POP      {R1,R2,R4,PC}
   \                     ??COM_WriteHex_0: (+1)
   \       0x20   0x2001             MOVS     R0,#+1
   \       0x22   0xBD16             POP      {R1,R2,R4,PC}    ;; return
   1606          }
   1607          

   \                                 In section .text, align 2, keep-with-next
   1608          Ecode_t COM_WriteString(COM_Port_t port, PGM_P string)
   1609          {
   1610            if (checkValidPort(port) == false) {
   \                     COM_WriteString: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x4689             MOV      R9,R1
   \        0xA   0xBF1C             ITT      NE 
   \        0xC   0x2820             CMPNE    R0,#+32
   \        0xE   0x2001             MOVNE    R0,#+1
   1611              return EMBER_ERR_FATAL;
   \       0x10   0xD113             BNE.N    ??COM_WriteString_0
   1612            }
   1613          #ifdef COM_VCP_ENABLE
   1614            if (checkValidVcpPort(port)) {
   1615              emDebugSendVuartMessage((uint8_t*)string, strlen(string));
   1616              return EMBER_SUCCESS;
   1617            }
   1618          #endif //COM_VCP_ENABLE
   1619            COM_Handle_t comhandle = getComHandleFromPort(port);
   \       0x12   0x....'....        BL       getComHandleFromPort
   \       0x16   0x4605             MOV      R5,R0
   1620            uint8_t *fifohead = &comhandle->txQueue->fifo[comhandle->txQueue->head];
   \       0x18   0x6868             LDR      R0,[R5, #+4]
   1621            uint8_t length = 0;
   \       0x1A   0x2600             MOVS     R6,#+0
   1622            uint8_t wraplength = 0;
   \       0x1C   0x2700             MOVS     R7,#+0
   \       0x1E   0x8801             LDRH     R1,[R0, #+0]
   \       0x20   0x4408             ADD      R0,R0,R1
   \       0x22   0xF100 0x0808      ADD      R8,R0,#+8
   1623            uint8_t txlength = 0;
   \       0x26   0xE023             B.N      ??COM_WriteString_1
   1624            while (*string != '\0') {
   1625              while (!getOutputFifoSpace(comhandle, 0)) {
   1626                if (comhandle->txPaused) {
   1627                  return EMBER_SERIAL_TX_OVERFLOW;
   1628                }
   1629              }
   1630              ;
   1631              CORE_DECLARE_IRQ_STATE;
   1632              CORE_ENTER_ATOMIC();
   1633              FIFO_ENQUEUE(comhandle->txQueue, *string, comhandle->txsize);
   1634              CORE_EXIT_ATOMIC();
   1635              string++;
   1636              length++;
   1637              // queue just wrapped
   1638              if (comhandle->txQueue->head == 0) {
   1639                // store first transmit length
   1640                txlength = length - wraplength;
   1641                // transmit chunk
   1642                txBuffer(port, fifohead, txlength);
   1643                wraplength += txlength;
   1644                // move fifohead back to start
   1645                fifohead = comhandle->txQueue->fifo;
   1646              }
   1647            }
   1648          
   1649            if ( length > wraplength) {
   \                     ??COM_WriteString_2: (+1)
   \       0x28   0xB2F0             UXTB     R0,R6
   \       0x2A   0x4287             CMP      R7,R0
   \       0x2C   0xDA04             BGE.N    ??CrossCallReturnLabel_18
   1650              txBuffer(port, fifohead, length - wraplength);
   \       0x2E   0xB2F6             UXTB     R6,R6
   \       0x30   0x1BF6             SUBS     R6,R6,R7
   \       0x32   0xB2B2             UXTH     R2,R6
   \       0x34   0x....'....        BL       ?Subroutine7
   1651            }
   1652            return EMBER_SUCCESS;
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x38   0x2000             MOVS     R0,#+0
   \                     ??COM_WriteString_0: (+1)
   \       0x3A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \                     ??COM_WriteString_3: (+1)
   \       0x3E   0x....'....        BL       CORE_EnterAtomic
   \       0x42   0x6869             LDR      R1,[R5, #+4]
   \       0x44   0xF819 0x2B01      LDRB     R2,[R9], #+1
   \       0x48   0x1C76             ADDS     R6,R6,#+1
   \       0x4A   0x880B             LDRH     R3,[R1, #+0]
   \       0x4C   0x4419             ADD      R1,R1,R3
   \       0x4E   0x720A             STRB     R2,[R1, #+8]
   \       0x50   0x6869             LDR      R1,[R5, #+4]
   \       0x52   0x896B             LDRH     R3,[R5, #+10]
   \       0x54   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x58   0x6869             LDR      R1,[R5, #+4]
   \       0x5A   0x8808             LDRH     R0,[R1, #+0]
   \       0x5C   0xB940             CBNZ.N   R0,??COM_WriteString_1
   \       0x5E   0xB2F4             UXTB     R4,R6
   \       0x60   0x1BE4             SUBS     R4,R4,R7
   \       0x62   0xB2E2             UXTB     R2,R4
   \       0x64   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x68   0x6869             LDR      R1,[R5, #+4]
   \       0x6A   0x19E7             ADDS     R7,R4,R7
   \       0x6C   0xF101 0x0808      ADD      R8,R1,#+8
   \                     ??COM_WriteString_1: (+1)
   \       0x70   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \       0x74   0x2800             CMP      R0,#+0
   \       0x76   0xD0D7             BEQ.N    ??COM_WriteString_2
   \                     ??COM_WriteString_4: (+1)
   \       0x78   0x2100             MOVS     R1,#+0
   \       0x7A   0x4628             MOV      R0,R5
   \       0x7C   0x....'....        BL       getOutputFifoSpace
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD1DC             BNE.N    ??COM_WriteString_3
   \       0x84   0x7B28             LDRB     R0,[R5, #+12]
   \       0x86   0x2800             CMP      R0,#+0
   \       0x88   0xD0F6             BEQ.N    ??COM_WriteString_4
   \       0x8A   0x2022             MOVS     R0,#+34
   \       0x8C   0xE7D5             B.N      ??COM_WriteString_0
   1653          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x4641             MOV      R1,R8
   \                     ??Subroutine7_0: (+1)
   \        0x2   0x4650             MOV      R0,R10
   \        0x4   0x....             B.N      txBuffer
   1654          

   \                                 In section .text, align 2, keep-with-next
   1655          Ecode_t COM_PrintCarriageReturn(COM_Port_t port)
   1656          {
   1657            if (checkValidPort(port) == false) {
   \                     COM_PrintCarriageReturn: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xBF12             ITEE     NE 
   \        0x4   0x2820             CMPNE    R0,#+32
   1658              return EMBER_ERR_FATAL;
   1659            }
   1660            return COM_Printf(port, "\r\n");
   \        0x6   0x....             LDREQ.N  R1,??DataTable10_14
   \        0x8   0x....'....        BEQ.W    COM_Printf
   \        0xC   0x2001             MOVS     R0,#+1
   \        0xE   0x4770             BX       LR               ;; return
   1661          }
   1662          

   \                                 In section .text, align 2, keep-with-next
   1663          Ecode_t COM_PrintfVarArg(COM_Port_t port, PGM_P formatString, va_list ap)
   1664          {
   1665            if (checkValidPort(port) == false) {
   \                     COM_PrintfVarArg: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xB510             PUSH     {R4,LR}
   \        0x4   0x4613             MOV      R3,R2
   \        0x6   0xBF18             IT       NE 
   \        0x8   0x2820             CMPNE    R0,#+32
   \        0xA   0xD10A             BNE.N    ??COM_PrintfVarArg_0
   1666              return EMBER_ERR_FATAL;
   1667            }
   1668            Ecode_t stat = EMBER_SUCCESS;
   1669            if (!emPrintfInternal(COM_WriteData, port, formatString, ap)) {
   \        0xC   0x460A             MOV      R2,R1
   \        0xE   0x4601             MOV      R1,R0
   \       0x10   0x....'....        ADR.W    R0,COM_WriteData
   \       0x14   0x2400             MOVS     R4,#+0
   \       0x16   0x....'....        BL       emPrintfInternal
   \       0x1A   0xB900             CBNZ.N   R0,??COM_PrintfVarArg_1
   1670              stat = EMBER_ERR_FATAL;
   \       0x1C   0x2401             MOVS     R4,#+1
   1671            }
   1672            return stat;
   \                     ??COM_PrintfVarArg_1: (+1)
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0xBD10             POP      {R4,PC}          ;; return
   \                     ??COM_PrintfVarArg_0: (+1)
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0xBD10             POP      {R4,PC}
   1673          }
   1674          

   \                                 In section .text, align 2, keep-with-next
   1675          Ecode_t COM_Printf(COM_Port_t port, PGM_P formatString, ...)
   1676          {
   1677            if (checkValidPort(port) == false) {
   \                     COM_Printf: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xB40C             PUSH     {R2,R3}
   \        0x4   0xB580             PUSH     {R7,LR}
   \        0x6   0xBF18             IT       NE 
   \        0x8   0x2820             CMPNE    R0,#+32
   \        0xA   0xD103             BNE.N    ??COM_Printf_0
   1678              return EMBER_ERR_FATAL;
   1679            }
   1680            Ecode_t stat;
   1681            va_list ap;
   1682            va_start(ap, formatString);
   \        0xC   0xAA02             ADD      R2,SP,#+8
   1683            stat = COM_PrintfVarArg(port, formatString, ap);
   1684            va_end(ap);
   1685            return stat;
   \        0xE   0x....'....        BL       COM_PrintfVarArg
   \       0x12   0xE000             B.N      ??COM_Printf_1
   \                     ??COM_Printf_0: (+1)
   \       0x14   0x2001             MOVS     R0,#+1
   \                     ??COM_Printf_1: (+1)
   \       0x16   0xBC02             POP      {R1}
   \       0x18   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
   1686          }
   1687          

   \                                 In section .text, align 2, keep-with-next
   1688          Ecode_t COM_PrintfLine(COM_Port_t port, PGM_P formatString, ...)
   1689          {
   1690            if (checkValidPort(port) == false) {
   \                     COM_PrintfLine: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xB40C             PUSH     {R2,R3}
   \        0x4   0xB538             PUSH     {R3-R5,LR}
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0xBF18             IT       NE 
   \        0xA   0x2820             CMPNE    R0,#+32
   \        0xC   0xD108             BNE.N    ??COM_PrintfLine_0
   1691              return EMBER_ERR_FATAL;
   1692            }
   1693            Ecode_t stat;
   1694            va_list ap;
   1695            va_start(ap, formatString);
   \        0xE   0xAA04             ADD      R2,SP,#+16
   1696            stat = COM_PrintfVarArg(port, formatString, ap);
   \       0x10   0x....'....        BL       COM_PrintfVarArg
   \       0x14   0x4605             MOV      R5,R0
   1697            va_end(ap);
   1698            COM_PrintCarriageReturn(port);
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x....'....        BL       COM_PrintCarriageReturn
   1699            return stat;
   \       0x1C   0x4628             MOV      R0,R5
   \       0x1E   0xE000             B.N      ??COM_PrintfLine_1
   \                     ??COM_PrintfLine_0: (+1)
   \       0x20   0x2001             MOVS     R0,#+1
   \                     ??COM_PrintfLine_1: (+1)
   \       0x22   0xBC32             POP      {R1,R4,R5}
   \       0x24   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
   1700          }
   1701          

   \                                 In section .text, align 4, keep-with-next
   1702          Ecode_t COM_WriteData(COM_Port_t port, uint8_t *data, uint8_t length)
   1703          {
   1704            if (checkValidPort(port) == false) {
   \                     COM_WriteData: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x6   0x4682             MOV      R10,R0
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0xBF1C             ITT      NE 
   \        0xC   0x2820             CMPNE    R0,#+32
   \        0xE   0x2001             MOVNE    R0,#+1
   \       0x10   0x4691             MOV      R9,R2
   1705              return EMBER_ERR_FATAL;
   \       0x12   0xD113             BNE.N    ??COM_WriteData_0
   1706            }
   1707          #ifdef COM_VCP_ENABLE
   1708            if (checkValidVcpPort(port)) {
   1709              emDebugSendVuartMessage(data, length);
   1710              return EMBER_SUCCESS;
   1711            }
   1712          #endif //COM_VCP_ENABLE
   1713            COM_Handle_t comhandle = getComHandleFromPort(port);
   \       0x14   0x....'....        BL       getComHandleFromPort
   \       0x18   0x4604             MOV      R4,R0
   1714          
   1715            uint8_t *fifohead = &comhandle->txQueue->fifo[comhandle->txQueue->head];
   \       0x1A   0x6860             LDR      R0,[R4, #+4]
   1716            uint8_t wraplength = 0;
   \       0x1C   0x2600             MOVS     R6,#+0
   1717            uint8_t txlength = 0;
   1718            bool wrap = false;
   1719            for (uint8_t i = 0; i < length; i++) {
   \       0x1E   0x2700             MOVS     R7,#+0
   \       0x20   0x8801             LDRH     R1,[R0, #+0]
   \       0x22   0x4408             ADD      R0,R0,R1
   \       0x24   0xF100 0x0B08      ADD      R11,R0,#+8
   \       0x28   0xE032             B.N      ??COM_WriteData_1
   1720              while (!getOutputFifoSpace(comhandle, 0)) {
   1721                if (comhandle->txPaused) {
   1722                  return EMBER_SERIAL_TX_OVERFLOW;
   1723                }
   1724              }
   1725              ;
   1726              CORE_DECLARE_IRQ_STATE;
   1727              CORE_ENTER_ATOMIC();
   1728              FIFO_ENQUEUE(comhandle->txQueue, *data, comhandle->txsize);
   1729              wrap = comhandle->txQueue->head == 0 ? true : false;
   1730              CORE_EXIT_ATOMIC();
   1731              data++;
   1732              // queue just wrapped
   1733              if (wrap) {
   1734                // store first transmit length
   1735                txlength = i + 1 - wraplength;
   1736                // transmit chunk
   1737                txBuffer(port, fifohead, txlength);
   1738                wraplength += txlength;
   1739                // move fifohead back to start
   1740                fifohead = comhandle->txQueue->fifo;
   1741              }
   1742            }
   1743            if (length > wraplength) {
   \                     ??COM_WriteData_2: (+1)
   \       0x2A   0x454E             CMP      R6,R9
   \       0x2C   0xDA05             BGE.N    ??CrossCallReturnLabel_16
   1744              txBuffer(port, fifohead, length - wraplength);
   \       0x2E   0xEBA9 0x0006      SUB      R0,R9,R6
   \       0x32   0xB282             UXTH     R2,R0
   \       0x34   0x4659             MOV      R1,R11
   \       0x36   0x....'....        BL       ??Subroutine7_0
   1745            }
   1746            return EMBER_SUCCESS;
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x3A   0x2000             MOVS     R0,#+0
   \                     ??COM_WriteData_0: (+1)
   \       0x3C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??COM_WriteData_3: (+1)
   \       0x40   0x....'....        BL       CORE_EnterAtomic
   \       0x44   0x6861             LDR      R1,[R4, #+4]
   \       0x46   0xF818 0x2B01      LDRB     R2,[R8], #+1
   \       0x4A   0x880B             LDRH     R3,[R1, #+0]
   \       0x4C   0x4419             ADD      R1,R1,R3
   \       0x4E   0x720A             STRB     R2,[R1, #+8]
   \       0x50   0x6861             LDR      R1,[R4, #+4]
   \       0x52   0x8963             LDRH     R3,[R4, #+10]
   \       0x54   0x880A             LDRH     R2,[R1, #+0]
   \       0x56   0x1C52             ADDS     R2,R2,#+1
   \       0x58   0xFB92 0xFCF3      SDIV     R12,R2,R3
   \       0x5C   0xFB03 0x221C      MLS      R2,R3,R12,R2
   \       0x60   0x800A             STRH     R2,[R1, #+0]
   \       0x62   0x888A             LDRH     R2,[R1, #+4]
   \       0x64   0x1C52             ADDS     R2,R2,#+1
   \       0x66   0x808A             STRH     R2,[R1, #+4]
   \       0x68   0x8809             LDRH     R1,[R1, #+0]
   \       0x6A   0x1E4D             SUBS     R5,R1,#+1
   \       0x6C   0x41AD             SBCS     R5,R5,R5
   \       0x6E   0x0FED             LSRS     R5,R5,#+31
   \       0x70   0x....'....        BL       CORE_ExitAtomic
   \       0x74   0xB15D             CBZ.N    R5,??COM_WriteData_4
   \       0x76   0xB2FD             UXTB     R5,R7
   \       0x78   0x1C6D             ADDS     R5,R5,#+1
   \       0x7A   0x1BAD             SUBS     R5,R5,R6
   \       0x7C   0xB2EA             UXTB     R2,R5
   \       0x7E   0x4659             MOV      R1,R11
   \       0x80   0x....'....        BL       ??Subroutine7_0
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x84   0x6860             LDR      R0,[R4, #+4]
   \       0x86   0x19AE             ADDS     R6,R5,R6
   \       0x88   0xB2F6             UXTB     R6,R6
   \       0x8A   0xF100 0x0B08      ADD      R11,R0,#+8
   \                     ??COM_WriteData_4: (+1)
   \       0x8E   0x1C7F             ADDS     R7,R7,#+1
   \                     ??COM_WriteData_1: (+1)
   \       0x90   0xB2F8             UXTB     R0,R7
   \       0x92   0x4548             CMP      R0,R9
   \       0x94   0xD2C9             BCS.N    ??COM_WriteData_2
   \                     ??COM_WriteData_5: (+1)
   \       0x96   0x2100             MOVS     R1,#+0
   \       0x98   0x4620             MOV      R0,R4
   \       0x9A   0x....'....        BL       getOutputFifoSpace
   \       0x9E   0x2800             CMP      R0,#+0
   \       0xA0   0xD1CE             BNE.N    ??COM_WriteData_3
   \       0xA2   0x7B20             LDRB     R0,[R4, #+12]
   \       0xA4   0x2800             CMP      R0,#+0
   \       0xA6   0xD0F6             BEQ.N    ??COM_WriteData_5
   \       0xA8   0x2022             MOVS     R0,#+34
   \       0xAA   0xE7C7             B.N      ??COM_WriteData_0
   1747          }
   1748          

   \                                 In section .text, align 2, keep-with-next
   1749          Ecode_t COM_ForceWriteData(COM_Port_t port, uint8_t *data, uint8_t length)
   1750          {
   \                     COM_ForceWriteData: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   1751            Ecode_t status = EMBER_ERR_FATAL;
   \        0x2   0x2601             MOVS     R6,#+1
   1752            if (checkValidPort(port) == false) {
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x2F01             CMP      R7,#+1
   \        0x8   0x460C             MOV      R4,R1
   \        0xA   0x4615             MOV      R5,R2
   \        0xC   0xBF18             IT       NE 
   \        0xE   0x2F20             CMPNE    R7,#+32
   \       0x10   0xD10D             BNE.N    ??COM_ForceWriteData_0
   1753              return status;
   1754            }
   1755          #ifdef COM_VCP_ENABLE
   1756            if (checkValidVcpPort(port)) {
   1757              emDebugSendVuartMessage(data, length);
   1758              status = EMBER_SUCCESS;
   1759            }
   1760          #endif //COM_VCP_ENABLE
   1761          #if defined(COM_UART_ENABLE)
   1762            COM_Handle_t comhandle = getComHandleFromPort(port);
   \       0x12   0x....'....        BL       getComHandleFromPort
   1763            if (checkValidUartPort(port)) {
   \       0x16   0x2F01             CMP      R7,#+1
   \       0x18   0xBF18             IT       NE 
   \       0x1A   0x2F20             CMPNE    R7,#+32
   \       0x1C   0xD105             BNE.N    ??COM_ForceWriteData_1
   1764              status = UARTDRV_ForceTransmit(comhandle->uarthandle, data, length);
   \       0x1E   0x6980             LDR      R0,[R0, #+24]
   \       0x20   0x462A             MOV      R2,R5
   \       0x22   0x4621             MOV      R1,R4
   \       0x24   0x....'....        BL       UARTDRV_ForceTransmit
   \       0x28   0x4606             MOV      R6,R0
   1765            }
   1766          #endif
   1767            return status;
   \                     ??COM_ForceWriteData_1: (+1)
   \       0x2A   0x4630             MOV      R0,R6
   \       0x2C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??COM_ForceWriteData_0: (+1)
   \       0x2E   0x2001             MOVS     R0,#+1
   \       0x30   0xBDF2             POP      {R1,R4-R7,PC}
   1768          }
   1769          

   \                                 In section .text, align 2, keep-with-next
   1770          Ecode_t COM_GuaranteedPrintf(COM_Port_t port, PGM_P formatString, ...)
   1771          {
   \                     COM_GuaranteedPrintf: (+1)
   \        0x0   0xB40C             PUSH     {R2,R3}
   \        0x2   0x460A             MOV      R2,R1
   1772            if (checkValidPort(port) == false) {
   \        0x4   0x4601             MOV      R1,R0
   \        0x6   0x2901             CMP      R1,#+1
   \        0x8   0xB510             PUSH     {R4,LR}
   \        0xA   0xBF18             IT       NE 
   \        0xC   0x2920             CMPNE    R1,#+32
   \        0xE   0xD10A             BNE.N    ??COM_GuaranteedPrintf_0
   1773              return EMBER_ERR_FATAL;
   1774            }
   1775            Ecode_t stat = EMBER_SUCCESS;
   1776            va_list ap;
   1777            va_start(ap, formatString);
   \       0x10   0xAB02             ADD      R3,SP,#+8
   1778            if (!emPrintfInternal(COM_ForceWriteData, port, formatString, ap)) {
   \       0x12   0x....             LDR.N    R0,??DataTable10_15
   \       0x14   0x2400             MOVS     R4,#+0
   \       0x16   0x....'....        BL       emPrintfInternal
   \       0x1A   0xB900             CBNZ.N   R0,??COM_GuaranteedPrintf_1
   1779              stat = EMBER_ERR_FATAL;
   \       0x1C   0x2401             MOVS     R4,#+1
   1780            }
   1781            va_end(ap);
   1782            return stat;
   \                     ??COM_GuaranteedPrintf_1: (+1)
   \       0x1E   0x4620             MOV      R0,R4
   \                     ??COM_GuaranteedPrintf_2: (+1)
   \       0x20   0xBC10             POP      {R4}
   \       0x22   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
   \                     ??COM_GuaranteedPrintf_0: (+1)
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0xE7FA             B.N      ??COM_GuaranteedPrintf_2
   1783          }
   1784          

   \                                 In section .text, align 2, keep-with-next
   1785          Ecode_t COM_WaitSend(COM_Port_t port)
   1786          {
   \                     COM_WaitSend: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1787            if (checkValidPort(port) == false) {
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x2C01             CMP      R4,#+1
   \        0x6   0xBF18             IT       NE 
   \        0x8   0x2C20             CMPNE    R4,#+32
   \        0xA   0xD11B             BNE.N    ??COM_WaitSend_0
   1788              return EMBER_ERR_FATAL;
   1789            }
   1790            COM_Handle_t comhandle = getComHandleFromPort(port);
   \        0xC   0x....'....        BL       getComHandleFromPort
   1791          
   1792          #if defined(COM_VCP_ENABLE)
   1793            if (checkValidVcpPort(port)) {
   1794              while (comhandle->txQueue->used > 0) {
   1795              }
   1796            }
   1797          #endif
   1798          #if defined(COM_UART_ENABLE)
   1799            if (checkValidUartPort(port)) {
   \       0x10   0x2C01             CMP      R4,#+1
   \       0x12   0x4605             MOV      R5,R0
   \       0x14   0xBF18             IT       NE 
   \       0x16   0x2C20             CMPNE    R4,#+32
   \       0x18   0xD112             BNE.N    ??COM_WaitSend_1
   1800              while ((comhandle->txQueue->used > 0)
   1801                     || (UARTDRV_GetTransmitDepth(comhandle->uarthandle) > 0)
   1802                     || !((UARTDRV_GetPeripheralStatus(comhandle->uarthandle) & UARTDRV_STATUS_TXC)
   1803                          && (UARTDRV_GetPeripheralStatus(comhandle->uarthandle) & UARTDRV_STATUS_TXIDLE)
   1804                          )) {
   \                     ??COM_WaitSend_2: (+1)
   \       0x1A   0x6869             LDR      R1,[R5, #+4]
   \       0x1C   0x8888             LDRH     R0,[R1, #+4]
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD1FB             BNE.N    ??COM_WaitSend_2
   \       0x22   0x69A8             LDR      R0,[R5, #+24]
   \       0x24   0x....'....        BL       UARTDRV_GetTransmitDepth
   \       0x28   0x2800             CMP      R0,#+0
   \       0x2A   0xD1F6             BNE.N    ??COM_WaitSend_2
   \       0x2C   0x69A8             LDR      R0,[R5, #+24]
   \       0x2E   0x....'....        BL       UARTDRV_GetPeripheralStatus
   \       0x32   0x0680             LSLS     R0,R0,#+26
   \       0x34   0xD5F1             BPL.N    ??COM_WaitSend_2
   \       0x36   0x69A8             LDR      R0,[R5, #+24]
   \       0x38   0x....'....        BL       UARTDRV_GetPeripheralStatus
   \       0x3C   0x0480             LSLS     R0,R0,#+18
   \       0x3E   0xD5EC             BPL.N    ??COM_WaitSend_2
   1805              }
   1806            }
   1807          #endif
   1808          
   1809            return EMBER_SUCCESS;
   \                     ??COM_WaitSend_1: (+1)
   \       0x40   0x2000             MOVS     R0,#+0
   \       0x42   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??COM_WaitSend_0: (+1)
   \       0x44   0x2001             MOVS     R0,#+1
   \       0x46   0xBD32             POP      {R1,R4,R5,PC}
   1810          }
   1811          
   1812          //------------------------------------------------------
   1813          // Serial buffer maintenance

   \                                 In section .text, align 2, keep-with-next
   1814          void COM_FlushRx(COM_Port_t port)
   1815          {
   \                     COM_FlushRx: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   1816            COM_Handle_t comhandle = getComHandleFromPort(port);
   \        0x4   0x....'....        BL       getComHandleFromPort
   1817            COM_FifoQueue_t *q = comhandle->rxQueue;
   1818          
   1819          #if defined(COM_UART_ENABLE)
   1820            if (checkValidUartPort(port)) {
   \        0x8   0x2D01             CMP      R5,#+1
   \        0xA   0x4606             MOV      R6,R0
   \        0xC   0x6834             LDR      R4,[R6, #+0]
   \        0xE   0xBF18             IT       NE 
   \       0x10   0x2D20             CMPNE    R5,#+32
   \       0x12   0xD10C             BNE.N    ??CrossCallReturnLabel_2
   1821              if (comhandle->uarthandle->fcType != uartdrvFlowControlSw) {
   \       0x14   0x69B0             LDR      R0,[R6, #+24]
   \       0x16   0x....'....        BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x1A   0xD008             BEQ.N    ??CrossCallReturnLabel_2
   1822                UARTDRV_Abort(comhandle->uarthandle, uartdrvAbortReceive);
   \       0x1C   0x2102             MOVS     R1,#+2
   \       0x1E   0x....'....        BL       UARTDRV_Abort
   1823          
   1824                // reset buffer index
   1825                comhandle->bufferIndex = 0;
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x8270             STRH     R0,[R6, #+18]
   1826          
   1827                // restart buffers for FIFO
   1828                rxNextBuffer(comhandle);
   \       0x26   0x....'....        BL       ?Subroutine3
   1829                rxNextBuffer(comhandle);
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x2A   0x....'....        BL       ?Subroutine3
   1830              }
   1831            }
   1832          #endif
   1833          
   1834            {
   1835              DECLARE_INTERRUPT_STATE_LITE;
   1836              DISABLE_INTERRUPTS_LITE();
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x2E   0x....'....        BL       CORE_EnterAtomic
   1837              q->used = 0;
   \       0x32   0x2100             MOVS     R1,#+0
   \       0x34   0x80A1             STRH     R1,[R4, #+4]
   1838              q->head = 0;
   \       0x36   0x8021             STRH     R1,[R4, #+0]
   1839              q->tail = 0;
   \       0x38   0x8061             STRH     R1,[R4, #+2]
   1840              q->pumped = 0;
   \       0x3A   0x80E1             STRH     R1,[R4, #+6]
   1841              RESTORE_INTERRUPTS_LITE();
   \       0x3C   0x....'....        B.W      ?Subroutine0
   1842            }
   1843          }
   1844          

   \                                 In section .text, align 2, keep-with-next
   1845          bool COM_Unused(COM_Port_t port)
   1846          {
   1847            if (checkValidPort(port) == false) {
   \                     COM_Unused: (+1)
   \        0x0   0x2801             CMP      R0,#+1
   \        0x2   0xB580             PUSH     {R7,LR}
   \        0x4   0xBF18             IT       NE 
   \        0x6   0x2820             CMPNE    R0,#+32
   \        0x8   0xD106             BNE.N    ??COM_Unused_0
   1848              return true;
   1849            }
   1850          
   1851            COM_Handle_t comhandle = getComHandleFromPort(port);
   \        0xA   0x....'....        BL       getComHandleFromPort
   1852            if (comhandle == NULL) {
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xBF1C             ITT      NE 
   \       0x12   0x6800             LDRNE    R0,[R0, #+0]
   \       0x14   0x2800             CMPNE    R0,#+0
   1853              return true;
   1854            }
   1855            // use rxQueue as a proxy for a COM port being initialized. Will be a null
   1856            // pointer if uninitialized
   1857            return (comhandle->rxQueue == NULL);
   \       0x16   0xD101             BNE.N    ??COM_Unused_1
   \                     ??COM_Unused_0: (+1)
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0xBD02             POP      {R1,PC}
   \                     ??COM_Unused_1: (+1)
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xBD02             POP      {R1,PC}          ;; return
   1858          }
   1859          
   1860          /* Initialize the UART RX pin as a GPIO Interrupt. GPIO Interrupt is used
   1861           * in order to be able to wakeup on rx activity in energy modes when the
   1862           * UART peripheral is not available. */

   \                                 In section .text, align 2, keep-with-next
   1863          void COM_RxGpioWakeInit(void)
   1864          {
   1865          #if HAL_SERIAL_RXWAKE_ENABLE
   1866            GPIO_ExtIntConfig(UART_RX_INT_PORT, UART_RX_INT_PIN, UART_RX_INT_PIN, false, true, false);
   1867          #endif
   1868          }
   \                     COM_RxGpioWakeInit: (+1)
   \        0x0   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0x....'....        DC32     comhandledata

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0xE000'E280        DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \        0x0   0xE000'E180        DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \        0x0   0xF000'7009        DC32     0xf0007009

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \        0x0   0x....'....        DC32     rxCallback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \        0x0   0x4005'8000        DC32     0x40058000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \        0x0   0x....'....        DC32     comFifoQueueRxUsart0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \        0x0   0x....'....        DC32     comFifoQueueTxUsart0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \        0x0   0x....'....        DC32     uarthandledata

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \        0x0   0x....'....        DC32     comBufferQueueTxUsart0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \        0x0   0x....'....        DC32     comBufferQueueRxUsart0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \        0x0   0x....'....        DC32     COM_ForceWriteData

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x63 0x6F          DC8 "com.c"
   \              0x6D 0x2E    
   \              0x63 0x00    
   \        0x6   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x08 0x20          DC8 "\010 \010"
   \              0x08 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x0D 0x0A          DC8 "\015\012"
   \              0x00         
   \        0x3   0x00               DC8 0
   1869          
   1870          #else // defined (COM_VCP_ENABLE) || defined (COM_UART_ENABLE)
   1871          // COM API stubs if no COM ports are enabled
   1872          void COM_InternalPowerDown(bool idle)
   1873          {
   1874          }
   1875          void COM_InternalPowerUp(bool idle)
   1876          {
   1877          }
   1878          bool COM_InternalTxIsIdle(COM_Port_t port)
   1879          {
   1880            return true;
   1881          }
   1882          bool COM_InternalRxIsPaused(COM_Port_t port)
   1883          {
   1884            return false;
   1885          }
   1886          bool COM_InternalTxIsPaused(COM_Port_t port)
   1887          {
   1888            return false;
   1889          }
   1890          Ecode_t COM_InternalReceiveData(COM_Port_t port, uint8_t *data, uint32_t length)
   1891          {
   1892            return ECODE_EMDRV_UARTDRV_OK;
   1893          }
   1894          
   1895          Ecode_t COM_Init(COM_Port_t port, COM_Init_t *init)
   1896          {
   1897            return ECODE_EMDRV_UARTDRV_OK;
   1898          }
   1899          Ecode_t COM_DeInit(COM_Port_t port)
   1900          {
   1901            return ECODE_EMDRV_UARTDRV_OK;
   1902          }
   1903          uint16_t COM_ReadAvailable(COM_Port_t port)
   1904          {
   1905            return 0;
   1906          }
   1907          Ecode_t COM_ReadByte(COM_Port_t port, uint8_t *dataByte)
   1908          {
   1909            return ECODE_EMDRV_UARTDRV_OK;
   1910          }
   1911          Ecode_t COM_ReadData(COM_Port_t port,
   1912                               uint8_t *data,
   1913                               uint16_t length,
   1914                               uint16_t *bytesRead)
   1915          {
   1916            return ECODE_EMDRV_UARTDRV_OK;
   1917          }
   1918          Ecode_t COM_ReadDataTimeout(COM_Port_t port,
   1919                                      uint8_t *data,
   1920                                      uint16_t length,
   1921                                      uint16_t *bytesRead,
   1922                                      uint16_t firstByteTimeout,
   1923                                      uint16_t subsequentByteTimeout)
   1924          {
   1925            return ECODE_EMDRV_UARTDRV_OK;
   1926          }
   1927          Ecode_t COM_ReadPartialLine(COM_Port_t port, char *data, uint8_t max, uint8_t * index)
   1928          {
   1929            return ECODE_EMDRV_UARTDRV_OK;
   1930          }
   1931          Ecode_t COM_ReadLine(COM_Port_t port, char *data, uint8_t max)
   1932          {
   1933            return ECODE_EMDRV_UARTDRV_OK;
   1934          }
   1935          
   1936          Ecode_t COM_ForceWriteData(COM_Port_t port, uint8_t *data, uint8_t length)
   1937          {
   1938            return ECODE_EMDRV_UARTDRV_OK;
   1939          }
   1940          uint16_t COM_WriteAvailable(COM_Port_t port)
   1941          {
   1942            return 0;
   1943          }
   1944          uint16_t COM_WriteUsed(COM_Port_t port)
   1945          {
   1946            return 0;
   1947          }
   1948          Ecode_t COM_WriteByte(COM_Port_t port, uint8_t dataByte)
   1949          {
   1950            return ECODE_EMDRV_UARTDRV_OK;
   1951          }
   1952          Ecode_t COM_WriteHex(COM_Port_t port, uint8_t dataByte)
   1953          {
   1954            return ECODE_EMDRV_UARTDRV_OK;
   1955          }
   1956          Ecode_t COM_WriteString(COM_Port_t port, PGM_P string)
   1957          {
   1958            return ECODE_EMDRV_UARTDRV_OK;
   1959          }
   1960          Ecode_t COM_PrintCarriageReturn(COM_Port_t port)
   1961          {
   1962            return ECODE_EMDRV_UARTDRV_OK;
   1963          }
   1964          Ecode_t COM_Printf(COM_Port_t port, PGM_P formatString, ...)
   1965          {
   1966            return ECODE_EMDRV_UARTDRV_OK;
   1967          }
   1968          Ecode_t COM_PrintfVarArg(COM_Port_t port, PGM_P formatString, va_list ap)
   1969          {
   1970            return ECODE_EMDRV_UARTDRV_OK;
   1971          }
   1972          Ecode_t COM_PrintfLine(COM_Port_t port, PGM_P formatString, ...)
   1973          {
   1974            return ECODE_EMDRV_UARTDRV_OK;
   1975          }
   1976          Ecode_t COM_WriteData(COM_Port_t port, uint8_t *data, uint8_t length)
   1977          {
   1978            return ECODE_EMDRV_UARTDRV_OK;
   1979          }
   1980          Ecode_t COM_GuaranteedPrintf(COM_Port_t port, PGM_P formatString, ...)
   1981          {
   1982            return ECODE_EMDRV_UARTDRV_OK;
   1983          }
   1984          Ecode_t COM_WaitSend(COM_Port_t port)
   1985          {
   1986            return ECODE_EMDRV_UARTDRV_OK;
   1987          }
   1988          void COM_FlushRx(COM_Port_t port)
   1989          {
   1990          }
   1991          bool COM_Unused(COM_Port_t port)
   1992          {
   1993            return true;
   1994          }
   1995          void COM_RxGpioWakeInit(void)
   1996          {
   1997          }
   1998          
   1999          #endif // defined (COM_VCP_ENABLE) || defined (COM_UART_ENABLE)

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   COM_DeInit
        16   -> COM_FlushRx
        16   -> COM_Unused
        16   -> UARTDRV_DeInit
        16   -> __aeabi_memclr4
        16   -> enableRxIrq
        16   -> getComHandleFromPort
      16   COM_FlushRx
        16   -> CORE_EnterAtomic
         0   -> CORE_ExitAtomic
        16   -> UARTDRV_Abort
        16   -> getComHandleFromPort
        16   -> rxNextBuffer
      24   COM_ForceWriteData
        24   -> UARTDRV_ForceTransmit
        24   -> getComHandleFromPort
      16   COM_GuaranteedPrintf
        16   -> emPrintfInternal
      24   COM_Init
        24   -> COM_DeInit
        24   -> COM_Unused
        24   -> GPIO_PinModeSet
        24   -> UARTDRV_FlowControlSet
        24   -> UARTDRV_InitUart
        24   -> __aeabi_memclr4
        24   -> enableRxIrq
        24   -> getComHandleFromPort
        24   -> rxNextBuffer
       8   COM_InternalPowerDown
         0   -> GPIO_PinModeSet
         8   -> USART_Enable
       8   COM_InternalPowerUp
         0   -> GPIO_PinModeSet
         8   -> USART_Enable
      24   COM_InternalReceiveData
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> getComHandleFromPort
       8   COM_InternalRxIsPaused
         8   -> UARTDRV_FlowControlGetSelfStatus
         8   -> getComHandleFromPort
       8   COM_InternalTxIsIdle
         8   -> UARTDRV_GetPeripheralStatus
         8   -> UARTDRV_GetTransmitDepth
         8   -> getComHandleFromPort
       8   COM_InternalTxIsPaused
         8   -> getComHandleFromPort
       0   COM_PrintCarriageReturn
         0   -> COM_Printf
      16   COM_Printf
        16   -> COM_PrintfVarArg
      24   COM_PrintfLine
        24   -> COM_PrintCarriageReturn
        24   -> COM_PrintfVarArg
       8   COM_PrintfVarArg
         8   -> emPrintfInternal
      16   COM_ReadAvailable
        16   -> getComHandleFromPort
        16   -> pumpRx
      24   COM_ReadByte
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> UARTDRV_GetReceiveDepth
        24   -> getComHandleFromPort
        24   -> pumpRx
        24   -> rxNextBuffer
      24   COM_ReadData
        24   -> COM_ReadByte
      40   COM_ReadDataTimeout
        40   -> COM_ReadByte
        40   -> halCommonGetInt16uMillisecondTick
      24   COM_ReadLine
        24   -> COM_ReadPartialLine
        24   -> halInternalResetWatchDog
      24   COM_ReadPartialLine
        24   -> COM_ReadByte
        24   -> COM_WriteByte
        24   -> COM_WriteString
       0   COM_RxGpioWakeInit
       8   COM_Unused
         8   -> getComHandleFromPort
      16   COM_WaitSend
        16   -> UARTDRV_GetPeripheralStatus
        16   -> UARTDRV_GetTransmitDepth
        16   -> getComHandleFromPort
       8   COM_WriteAvailable
         8   -> getComHandleFromPort
       8   COM_WriteByte
         8   -> COM_WriteData
      40   COM_WriteData
        40   -> CORE_EnterAtomic
        40   -> CORE_ExitAtomic
        40   -> getComHandleFromPort
        40   -> getOutputFifoSpace
        40   -> txBuffer
      16   COM_WriteHex
        16   -> COM_WriteData
        16   -> emWriteHexInternal
      32   COM_WriteString
        32   -> CORE_EnterAtomic
        32   -> CORE_ExitAtomic
        32   -> getComHandleFromPort
        32   -> getOutputFifoSpace
        32   -> txBuffer
       8   COM_WriteUsed
         8   -> getComHandleFromPort
      16   enableRxIrq
         0   -> USART_Enable
        16   -> getComHandleFromPort
       8   getComHandleFromPort
         8   -> halInternalAssertFailed
       0   getOutputFifoSpace
      24   pumpRx
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> UARTDRV_FlowControlGetSelfStatus
        24   -> UARTDRV_FlowControlSet
        24   -> UARTDRV_GetReceiveDepth
        24   -> UARTDRV_GetReceiveStatus
        24   -> getComHandleFromPort
        24   -> updateBuffer
      16   rxCallback
         0   -> UARTDRV_FlowControlSet
        16   -> UARTDRV_GetReceiveDepth
        16   -> rxNextBuffer
        16   -> updateBuffer
      16   rxNextBuffer
        16   -> UARTDRV_FlowControlSet
        16   -> UARTDRV_GetReceiveDepth
        16   -> UARTDRV_Receive
      24   txBuffer
        24   -> UARTDRV_Transmit
        24   -> getComHandleFromPort
         0   -> txCatchUp
      16   txCallback
        16   -> CORE_EnterAtomic
         0   -> CORE_ExitAtomic
      32   txCatchUp
        32   -> UARTDRV_GetTransmitStatus
        32   -> UARTDRV_Transmit
      16   updateBuffer
        16   -> CORE_EnterAtomic
         0   -> CORE_ExitAtomic


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       8  ?Subroutine0
      12  ?Subroutine1
      24  ?Subroutine2
       6  ?Subroutine3
      10  ?Subroutine4
      10  ?Subroutine5
       8  ?Subroutine6
       6  ?Subroutine7
       8  ?_0
       4  ?_1
       4  ?_2
      82  COM_DeInit
      64  COM_FlushRx
      50  COM_ForceWriteData
      42  COM_GuaranteedPrintf
     246  COM_Init
      24  COM_InternalPowerDown
      22  COM_InternalPowerUp
      70  COM_InternalReceiveData
      28  COM_InternalRxIsPaused
      52  COM_InternalTxIsIdle
      10  COM_InternalTxIsPaused
      16  COM_PrintCarriageReturn
      28  COM_Printf
      40  COM_PrintfLine
      38  COM_PrintfVarArg
      22  COM_ReadAvailable
     160  COM_ReadByte
      68  COM_ReadData
     110  COM_ReadDataTimeout
      50  COM_ReadLine
     238  COM_ReadPartialLine
       2  COM_RxGpioWakeInit
      32  COM_Unused
      72  COM_WaitSend
      20  COM_WriteAvailable
      24  COM_WriteByte
     172  COM_WriteData
      36  COM_WriteHex
     142  COM_WriteString
      12  COM_WriteUsed
     128  comBufferQueueRxUsart0
     128  comBufferQueueTxUsart0
     136  comFifoQueueRxUsart0
     136  comFifoQueueTxUsart0
      28  comhandledata
       4  dma_IEN
     112  enableRxIrq
      30  getComHandleFromPort
      20  getOutputFifoSpace
     114  pumpRx
     110  rxCallback
      62  rxNextBuffer
      66  txBuffer
      60  txCallback
     102  txCatchUp
      52  uarthandledata
      44  updateBuffer

 
   356 bytes in section .bss
   256 bytes in section .data
    16 bytes in section .rodata
 2 840 bytes in section .text
 
 2 840 bytes of CODE  memory
    16 bytes of CONST memory
   612 bytes of DATA  memory

Errors: none
Warnings: 1
