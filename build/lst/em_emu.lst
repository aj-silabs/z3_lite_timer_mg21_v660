###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:49
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\em_emu.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW4BF3.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\em_emu.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"em_emu.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0 -D
#        LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D EMBER_AF_USE_HWCONF
#        -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\em_emu.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\em_emu.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\em_emu.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Energy Management Unit (EMU) Peripheral API
      4           * @version 5.8.0
      5           *******************************************************************************
      6           * # License
      7           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      8           *******************************************************************************
      9           *
     10           * SPDX-License-Identifier: Zlib
     11           *
     12           * The licensor of this software is Silicon Laboratories Inc.
     13           *
     14           * This software is provided 'as-is', without any express or implied
     15           * warranty. In no event will the authors be held liable for any damages
     16           * arising from the use of this software.
     17           *
     18           * Permission is granted to anyone to use this software for any purpose,
     19           * including commercial applications, and to alter it and redistribute it
     20           * freely, subject to the following restrictions:
     21           *
     22           * 1. The origin of this software must not be misrepresented; you must not
     23           *    claim that you wrote the original software. If you use this software
     24           *    in a product, an acknowledgment in the product documentation would be
     25           *    appreciated but is not required.
     26           * 2. Altered source versions must be plainly marked as such, and must not be
     27           *    misrepresented as being the original software.
     28           * 3. This notice may not be removed or altered from any source distribution.
     29           *
     30           ******************************************************************************/
     31          
     32          #include <limits.h>
     33          
     34          #include "em_emu.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void SystemCoreClockUpdate(void)
   \                     SystemCoreClockUpdate: (+1)
   \        0x0   0x....'....        B.W      SystemHCLKGet
     35          #if defined(EMU_PRESENT) && (EMU_COUNT > 0)
     36          
     37          #include "em_assert.h"
     38          #include "em_cmu.h"
     39          #include "em_common.h"
     40          #include "em_system.h"
     41          
     42          /***************************************************************************//**
     43           * @addtogroup emlib
     44           * @{
     45           ******************************************************************************/
     46          
     47          /***************************************************************************//**
     48           * @addtogroup EMU
     49           * @brief Energy Management Unit (EMU) Peripheral API
     50           * @details
     51           *  This module contains functions to control the EMU peripheral of Silicon
     52           *  Labs 32-bit MCUs and SoCs. The EMU handles the different low energy modes
     53           *  in Silicon Labs microcontrollers.
     54           * @{
     55           ******************************************************************************/
     56          
     57          /* Consistency check, since restoring assumes similar bit positions in */
     58          /* CMU OSCENCMD and STATUS regs. */
     59          #if (CMU_STATUS_AUXHFRCOENS != CMU_OSCENCMD_AUXHFRCOEN)
     60          #error Conflict in AUXHFRCOENS and AUXHFRCOEN bitpositions
     61          #endif
     62          #if (CMU_STATUS_HFXOENS != CMU_OSCENCMD_HFXOEN)
     63          #error Conflict in HFXOENS and HFXOEN bitpositions
     64          #endif
     65          #if (CMU_STATUS_LFRCOENS != CMU_OSCENCMD_LFRCOEN)
     66          #error Conflict in LFRCOENS and LFRCOEN bitpositions
     67          #endif
     68          #if (CMU_STATUS_LFXOENS != CMU_OSCENCMD_LFXOEN)
     69          #error Conflict in LFXOENS and LFXOEN bitpositions
     70          #endif
     71          
     72          /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
     73          #if defined(_SILICON_LABS_32B_SERIES_0)
     74          /* Fix for errata EMU_E107 - non-WIC interrupt masks. */
     75          #if defined(_EFM32_GECKO_FAMILY)
     76          #define ERRATA_FIX_EMU_E107_ENABLE
     77          #define NON_WIC_INT_MASK_0    (~(0x0dfc0323U))
     78          #define NON_WIC_INT_MASK_1    (~(0x0U))
     79          
     80          #elif defined(_EFM32_TINY_FAMILY)
     81          #define ERRATA_FIX_EMU_E107_ENABLE
     82          #define NON_WIC_INT_MASK_0    (~(0x001be323U))
     83          #define NON_WIC_INT_MASK_1    (~(0x0U))
     84          
     85          #elif defined(_EFM32_GIANT_FAMILY)
     86          #define ERRATA_FIX_EMU_E107_ENABLE
     87          #define NON_WIC_INT_MASK_0    (~(0xff020e63U))
     88          #define NON_WIC_INT_MASK_1    (~(0x00000046U))
     89          
     90          #elif defined(_EFM32_WONDER_FAMILY)
     91          #define ERRATA_FIX_EMU_E107_ENABLE
     92          #define NON_WIC_INT_MASK_0    (~(0xff020e63U))
     93          #define NON_WIC_INT_MASK_1    (~(0x00000046U))
     94          
     95          #elif defined(_EFM32_ZERO_FAMILY)
     96          #define ERRATA_FIX_EMU_E107_ENABLE
     97          #define NON_WIC_INT_MASK_0    (~(0x00005c6bU))
     98          #define NON_WIC_INT_MASK_1    (~(0x00000000U))
     99          
    100          #elif defined(_EFM32_HAPPY_FAMILY)
    101          #define ERRATA_FIX_EMU_E107_ENABLE
    102          #define NON_WIC_INT_MASK_0    (~(0x00085c6bU))
    103          #define NON_WIC_INT_MASK_1    (~(0x00000000U))
    104          
    105          #endif
    106          #endif
    107          
    108          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_74) \
    109            || (defined(_SILICON_LABS_32B_SERIES_0)         \
    110            && (defined(_EFM32_HAPPY_FAMILY) || defined(_EFM32_ZERO_FAMILY)))
    111          // Fix for errata EMU_E110 - Potential Hard Fault when Exiting EM2.
    112          #include "em_core.h"
    113          #include "em_ramfunc.h"
    114          #define ERRATA_FIX_EMU_E110_ENABLE
    115          #endif
    116          
    117          /* Fix for errata EMU_E108 - High Current Consumption on EM4 Entry. */
    118          #if defined(_SILICON_LABS_32B_SERIES_0) && defined(_EFM32_HAPPY_FAMILY)
    119          #define ERRATA_FIX_EMU_E108_ENABLE
    120          #endif
    121          
    122          /* Fix for errata EMU_E208 - Occasional Full Reset After Exiting EM4H. */
    123          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
    124          #define ERRATA_FIX_EMU_E208_ENABLE
    125          #endif
    126          
    127          /* Enable FETCNT tuning errata fix. */
    128          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
    129          #define ERRATA_FIX_DCDC_FETCNT_SET_ENABLE
    130          #endif
    131          
    132          /* Enable LN handshake errata fix. */
    133          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
    134          #define ERRATA_FIX_DCDC_LNHS_BLOCK_ENABLE
    135          typedef enum {
    136            errataFixDcdcHsInit,
    137            errataFixDcdcHsTrimSet,
    138            errataFixDcdcHsBypassLn,
    139            errataFixDcdcHsLnWaitDone
    140          } errataFixDcdcHs_TypeDef;
    141          static errataFixDcdcHs_TypeDef errataFixDcdcHsState = errataFixDcdcHsInit;
    142          #endif
    143          
    144          /* Fix for errata for EFM32GG11 and EFM32TG11. If a device is entering EM4S
    145           * while powering the analog peripherals from DVDD, firmware must switch
    146           * over to powering the analog peripherals from AVDD and delay the EM4S entry
    147           * with 30 us. */
    148          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_100) \
    149            || defined(_SILICON_LABS_GECKO_INTERNAL_SDID_103)
    150          #define ERRATA_FIX_EM4S_DELAY_ENTRY
    151          #endif
    152          
    153          /* Used to figure out if a memory address is inside or outside of a RAM block.
    154           * A memory address is inside a RAM block if the address is greater than the
    155           * RAM block address. */
    156          #define ADDRESS_NOT_IN_BLOCK(addr, block)  ((addr) <= (block) ? 1UL : 0UL)
    157          
    158          /* RAM Block layout for various device families. Note that some devices
    159           * have special layout in RAM0 and some devices have a special RAM block
    160           * at the end of their block layout. */
    161          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_84)
    162          #define RAM1_BLOCKS            2U
    163          #define RAM1_BLOCK_SIZE  0x10000U // 64 kB blocks
    164          #define RAM2_BLOCKS            1U
    165          #define RAM2_BLOCK_SIZE    0x800U // 2 kB block
    166          #elif defined(_SILICON_LABS_GECKO_INTERNAL_SDID_89)
    167          #define RAM0_BLOCKS            2U
    168          #define RAM0_BLOCK_SIZE   0x4000U
    169          #define RAM1_BLOCKS            2U
    170          #define RAM1_BLOCK_SIZE   0x4000U // 16 kB blocks
    171          #define RAM2_BLOCKS            1U
    172          #define RAM2_BLOCK_SIZE    0x800U // 2 kB block
    173          #elif defined(_SILICON_LABS_GECKO_INTERNAL_SDID_95)
    174          #define RAM0_BLOCKS            1U
    175          #define RAM0_BLOCK_SIZE   0x4000U // 16 kB block
    176          #define RAM1_BLOCKS            1U
    177          #define RAM1_BLOCK_SIZE   0x4000U // 16 kB block
    178          #define RAM2_BLOCKS            1U
    179          #define RAM2_BLOCK_SIZE    0x800U // 2 kB block
    180          #elif defined(_SILICON_LABS_GECKO_INTERNAL_SDID_103)
    181          #define RAM0_BLOCKS            4U
    182          #define RAM0_BLOCK_SIZE   0x2000U //  8 kB blocks
    183          #elif defined(_SILICON_LABS_32B_SERIES_0) && defined(_EFM32_GIANT_FAMILY)
    184          #define RAM0_BLOCKS            4U
    185          #define RAM0_BLOCK_SIZE   0x8000U // 32 kB blocks
    186          #elif defined(_SILICON_LABS_32B_SERIES_0) && defined(_EFM32_GECKO_FAMILY)
    187          #define RAM0_BLOCKS            4U
    188          #define RAM0_BLOCK_SIZE   0x1000U //  4 kB blocks
    189          #elif defined(_SILICON_LABS_GECKO_INTERNAL_SDID_100)
    190          #define RAM0_BLOCKS            8U
    191          #define RAM0_BLOCK_SIZE   0x4000U // 16 kB blocks
    192          #define RAM1_BLOCKS            8U
    193          #define RAM1_BLOCK_SIZE   0x4000U // 16 kB blocks
    194          #define RAM2_BLOCKS            4U
    195          #define RAM2_BLOCK_SIZE  0x10000U // 64 kB blocks
    196          #elif defined(_SILICON_LABS_GECKO_INTERNAL_SDID_106)
    197          #define RAM0_BLOCKS            4U
    198          #define RAM0_BLOCK_SIZE   0x4000U // 16 kB blocks
    199          #define RAM1_BLOCKS            4U
    200          #define RAM1_BLOCK_SIZE   0x4000U // 16 kB blocks
    201          #define RAM2_BLOCKS            4U
    202          #define RAM2_BLOCK_SIZE   0x4000U // 16 kB blocks
    203          #elif defined(_SILICON_LABS_32B_SERIES_2_CONFIG_1)
    204          #define RAM0_BLOCKS            6U
    205          #define RAM0_BLOCK_SIZE   0x4000U // 16 kB blocks
    206          #elif defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
    207          #define RAM0_BLOCKS            2U
    208          #define RAM0_BLOCK_SIZE   0x4000U // 16 kB blocks
    209          #endif
    210          
    211          #if defined(_SILICON_LABS_32B_SERIES_0)
    212          /* RAM_MEM_END on Gecko devices have a value larger than the SRAM_SIZE. */
    213          #define RAM0_END    (SRAM_BASE + SRAM_SIZE - 1)
    214          #else
    215          #define RAM0_END    RAM_MEM_END
    216          #endif
    217          
    218          #if defined(CMU_STATUS_HFXOSHUNTOPTRDY)
    219          #define HFXO_STATUS_READY_FLAGS  (CMU_STATUS_HFXOPEAKDETRDY | CMU_STATUS_HFXOSHUNTOPTRDY)
    220          #elif defined(CMU_STATUS_HFXOPEAKDETRDY)
    221          #define HFXO_STATUS_READY_FLAGS  (CMU_STATUS_HFXOPEAKDETRDY)
    222          #endif
    223          
    224          /** @endcond */
    225          
    226          #if defined(_EMU_DCDCCTRL_MASK)
    227          /* DCDCTODVDD output range minimum/maximum. */
    228          #if !defined(PWRCFG_DCDCTODVDD_VMIN)
    229          #define PWRCFG_DCDCTODVDD_VMIN          1800U
    230          #endif
    231          #if !defined(PWRCFG_DCDCTODVDD_VMAX)
    232          #define PWRCFG_DCDCTODVDD_VMAX          3000U
    233          #endif
    234          #endif
    235          
    236          /*******************************************************************************
    237           ***************************  LOCAL VARIABLES   ********************************
    238           ******************************************************************************/
    239          
    240          /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
    241          
    242          /* Static user configuration. */
    243          #if defined(_EMU_DCDCCTRL_MASK)
    244          static uint16_t dcdcMaxCurrent_mA;
    245          static uint16_t dcdcEm01LoadCurrent_mA;
    246          static EMU_DcdcLnReverseCurrentControl_TypeDef dcdcReverseCurrentControl;
    247          #endif
    248          #if defined(EMU_VSCALE_PRESENT)
    249          static EMU_EM01Init_TypeDef vScaleEM01Config = { false };
    250          #endif
    251          /** @endcond */
    252          
    253          /*******************************************************************************
    254           **************************   LOCAL FUNCTIONS   ********************************
    255           ******************************************************************************/
    256          
    257          /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
    258          
    259          #if defined(EMU_VSCALE_PRESENT)
    260          /* Convert from level to EM0 and 1 command bit */
    261          __STATIC_INLINE uint32_t vScaleEM01Cmd(EMU_VScaleEM01_TypeDef level)
    262          {
    263            return EMU_CMD_EM01VSCALE0 << (_EMU_STATUS_VSCALE_VSCALE0 - (uint32_t)level);
    264          }
    265          #endif
    266          
    267          #if defined(ERRATA_FIX_EMU_E110_ENABLE)
    268          SL_RAMFUNC_DECLARATOR static void __attribute__ ((noinline)) ramWFI(void);
    269          SL_RAMFUNC_DEFINITION_BEGIN
    270          static void __attribute__ ((noinline)) ramWFI(void)
    271          {
    272            __WFI();                      // Enter EM2 or EM3
    273            *(volatile uint32_t*)4;       // Clear faulty read data after wakeup
    274          }
    275          SL_RAMFUNC_DEFINITION_END
    276          #endif
    277          
    278          /***************************************************************************//**
    279           * @brief
    280           *   Save/restore/update oscillator, core clock and voltage scaling configuration on
    281           *   EM2 or EM3 entry/exit.
    282           *
    283           * @details
    284           *   Hardware may automatically change the oscillator and the voltage scaling configuration
    285           *   when going into or out of an energy mode. Static data in this function keeps track of
    286           *   such configuration bits and is used to restore state if needed.
    287           *
    288           ******************************************************************************/
    289          typedef enum {
    290            emState_Save,         /* Save EMU and CMU state. */
    291            emState_Restore,      /* Restore and unlock.     */
    292          } emState_TypeDef;
    293          
    294          static void emState(emState_TypeDef action)
    295          {
    296          #if defined(_SILICON_LABS_32B_SERIES_2)
    297            /* Series-2 devices automatically save and restore clock state */
    298            (void) action;
    299          #else
    300            uint32_t oscEnCmd;
    301            uint32_t cmuLocked;
    302            static uint32_t cmuStatus;
    303            static CMU_Select_TypeDef hfClock;
    304          #if defined(EMU_VSCALE_PRESENT)
    305            static uint8_t vScaleStatus;
    306            static uint32_t hfrcoCtrl;
    307          #endif
    308          
    309            /* Save or update state. */
    310            if (action == emState_Save) {
    311              /* Save configuration. */
    312              cmuStatus = CMU->STATUS;
    313              hfClock = CMU_ClockSelectGet(cmuClock_HF);
    314          #if defined(EMU_VSCALE_PRESENT)
    315              /* Save vscale. */
    316              EMU_VScaleWait();
    317              vScaleStatus = (uint8_t)((EMU->STATUS & _EMU_STATUS_VSCALE_MASK)
    318                                       >> _EMU_STATUS_VSCALE_SHIFT);
    319              hfrcoCtrl = CMU->HFRCOCTRL;
    320          #endif
    321            } else { /* Restore state. */
    322              /* Apply saved configuration. */
    323          #if defined(EMU_VSCALE_PRESENT)
    324              /* Restore EM0 and 1 voltage scaling level. @ref EMU_VScaleWait() is called later,
    325                 just before HF clock select is set. */
    326              EMU->CMD = vScaleEM01Cmd((EMU_VScaleEM01_TypeDef)vScaleStatus);
    327          #endif
    328          
    329              /* CMU registers may be locked. */
    330              cmuLocked = CMU->LOCK & CMU_LOCK_LOCKKEY_LOCKED;
    331              CMU_Unlock();
    332          
    333          #if defined(_CMU_OSCENCMD_MASK)
    334              /* AUXHFRCO are automatically disabled (except if using debugger). */
    335              /* HFRCO, USHFRCO and HFXO are automatically disabled. */
    336              /* LFRCO/LFXO may be disabled by SW in EM3. */
    337              /* Restore according to status prior to entering energy mode. */
    338              oscEnCmd = 0;
    339              oscEnCmd |= (cmuStatus & CMU_STATUS_HFRCOENS) != 0U
    340                          ? CMU_OSCENCMD_HFRCOEN : 0U;
    341              oscEnCmd |= (cmuStatus & CMU_STATUS_AUXHFRCOENS) != 0U
    342                          ? CMU_OSCENCMD_AUXHFRCOEN : 0U;
    343              oscEnCmd |= (cmuStatus & CMU_STATUS_LFRCOENS) != 0U
    344                          ? CMU_OSCENCMD_LFRCOEN : 0U;
    345              oscEnCmd |= (cmuStatus & CMU_STATUS_HFXOENS) != 0U
    346                          ? CMU_OSCENCMD_HFXOEN : 0U;
    347              oscEnCmd |= (cmuStatus & CMU_STATUS_LFXOENS) != 0U
    348                          ? CMU_OSCENCMD_LFXOEN : 0U;
    349          #if defined(_CMU_STATUS_USHFRCOENS_MASK)
    350              oscEnCmd |= (cmuStatus & CMU_STATUS_USHFRCOENS) != 0U
    351                          ? CMU_OSCENCMD_USHFRCOEN : 0U;
    352          #endif
    353              CMU->OSCENCMD = oscEnCmd;
    354          #endif
    355          
    356          #if defined(_EMU_STATUS_VSCALE_MASK)
    357              /* Wait for upscale to complete and then restore selected clock. */
    358              EMU_VScaleWait();
    359              if ((EMU->CTRL & _EMU_CTRL_EM23VSCALEAUTOWSEN_MASK) != 0U) {
    360                /* Restore HFRCO frequency which was automatically adjusted by hardware. */
    361                while ((CMU->SYNCBUSY & CMU_SYNCBUSY_HFRCOBSY) != 0U) {
    362                }
    363                CMU->HFRCOCTRL = hfrcoCtrl;
    364                if (hfClock == cmuSelect_HFRCO) {
    365                  /* Optimize wait state after EM2/EM3 wakeup because hardware has
    366                   * modified them. */
    367                  CMU_UpdateWaitStates(SystemHfrcoFreq, EMU_VScaleGet());
    368                }
    369              }
    370          #endif
    371          
    372              if (hfClock != cmuSelect_HFRCO) {
    373                CMU_ClockSelectSet(cmuClock_HF, hfClock);
    374              }
    375          
    376          #if defined(_CMU_OSCENCMD_MASK)
    377              /* If HFRCO was disabled before entering Energy Mode, turn it off again */
    378              /* as it is automatically enabled by wake up */
    379              if ((cmuStatus & CMU_STATUS_HFRCOENS) == 0U) {
    380                CMU->OSCENCMD = CMU_OSCENCMD_HFRCODIS;
    381              }
    382          #endif
    383          
    384              /* Restore CMU register locking */
    385              if (cmuLocked != 0U) {
    386                CMU_Lock();
    387              }
    388            }
    389          #endif
    390          }
    391          
    392          #if defined(ERRATA_FIX_EMU_E107_ENABLE)
    393          /* Get enable conditions for errata EMU_E107 fix. */
    394          __STATIC_INLINE bool getErrataFixEmuE107En(void)
    395          {
    396          #if defined(_EFM32_ZERO_FAMILY) || defined(_EFM32_HAPPY_FAMILY)
    397            return true;
    398          #else
    399            /* SYSTEM_ChipRevisionGet could have been used here, but we would like a
    400             * faster implementation in this case.
    401             */
    402            uint16_t majorMinorRev;
    403          
    404            /* CHIP MAJOR bit [3:0]. */
    405            majorMinorRev = ((ROMTABLE->PID0 & _ROMTABLE_PID0_REVMAJOR_MASK)
    406                             >> _ROMTABLE_PID0_REVMAJOR_SHIFT)
    407                            << 8;
    408            /* CHIP MINOR bit [7:4]. */
    409            majorMinorRev |= ((ROMTABLE->PID2 & _ROMTABLE_PID2_REVMINORMSB_MASK)
    410                              >> _ROMTABLE_PID2_REVMINORMSB_SHIFT)
    411                             << 4;
    412            /* CHIP MINOR bit [3:0]. */
    413            majorMinorRev |= (ROMTABLE->PID3 & _ROMTABLE_PID3_REVMINORLSB_MASK)
    414                             >> _ROMTABLE_PID3_REVMINORLSB_SHIFT;
    415          
    416          #if defined(_EFM32_GECKO_FAMILY)
    417            return (majorMinorRev <= 0x0103);
    418          #elif defined(_EFM32_TINY_FAMILY)
    419            return (majorMinorRev <= 0x0102);
    420          #elif defined(_EFM32_GIANT_FAMILY)
    421            return (majorMinorRev <= 0x0103) || (majorMinorRev == 0x0204);
    422          #elif defined(_EFM32_WONDER_FAMILY)
    423            return (majorMinorRev == 0x0100);
    424          #else
    425            /* Invalid configuration. */
    426            EFM_ASSERT(false);
    427            /* Return when assertions are disabled. */
    428            return false;
    429          #endif
    430          #endif /* #if defined(_EFM32_ZERO_FAMILY) || defined(_EFM32_HAPPY_FAMILY) #else */
    431          }
    432          #endif /* #if defined(ERRATA_FIX_EMU_E107_ENABLE) */
    433          
    434          /* LP prepare / LN restore P/NFET count. */
    435          #define DCDC_LP_PFET_CNT        7
    436          #define DCDC_LP_NFET_CNT        7
    437          #if defined(ERRATA_FIX_DCDC_FETCNT_SET_ENABLE)
    438          static void currentLimitersUpdate(void);
    439          static void dcdcFetCntSet(bool lpModeSet)
    440          {
    441            uint32_t tmp;
    442            static uint32_t emuDcdcMiscCtrlReg;
    443          
    444            if (lpModeSet) {
    445              emuDcdcMiscCtrlReg = EMU->DCDCMISCCTRL;
    446              tmp  = EMU->DCDCMISCCTRL
    447                     & ~(_EMU_DCDCMISCCTRL_PFETCNT_MASK | _EMU_DCDCMISCCTRL_NFETCNT_MASK);
    448              tmp |= (DCDC_LP_PFET_CNT << _EMU_DCDCMISCCTRL_PFETCNT_SHIFT)
    449                     | (DCDC_LP_NFET_CNT << _EMU_DCDCMISCCTRL_NFETCNT_SHIFT);
    450              EMU->DCDCMISCCTRL = tmp;
    451              currentLimitersUpdate();
    452            } else {
    453              EMU->DCDCMISCCTRL = emuDcdcMiscCtrlReg;
    454              currentLimitersUpdate();
    455            }
    456          }
    457          #endif
    458          
    459          #if defined(ERRATA_FIX_DCDC_LNHS_BLOCK_ENABLE)
    460          static void dcdcHsFixLnBlock(void)
    461          {
    462          #define EMU_DCDCSTATUS  (*(volatile uint32_t *)(EMU_BASE + 0x7C))
    463            if ((errataFixDcdcHsState == errataFixDcdcHsTrimSet)
    464                || (errataFixDcdcHsState == errataFixDcdcHsBypassLn)) {
    465              /* Wait for LNRUNNING */
    466              if ((EMU->DCDCCTRL & _EMU_DCDCCTRL_DCDCMODE_MASK) == EMU_DCDCCTRL_DCDCMODE_LOWNOISE) {
    467                while (!(EMU_DCDCSTATUS & (0x1 << 16))) {
    468                }
    469              }
    470              errataFixDcdcHsState = errataFixDcdcHsLnWaitDone;
    471            }
    472          }
    473          #endif
    474          
    475          #if defined(_EMU_CTRL_EM23VSCALE_MASK)
    476          /* Configure EMU and CMU for EM2 and 3 voltage downscale. */
    477          static void vScaleDownEM23Setup(void)
    478          {
    479            /* Wait until previous scaling is done. */
    480            EMU_VScaleWait();
    481          
    482            uint32_t em23vs = (EMU->CTRL & _EMU_CTRL_EM23VSCALE_MASK) >> _EMU_CTRL_EM23VSCALE_SHIFT;
    483            uint32_t em01vs = (EMU->STATUS & _EMU_STATUS_VSCALE_MASK) >> _EMU_STATUS_VSCALE_SHIFT;
    484          
    485            /* Inverse coding. */
    486            if (em23vs > em01vs) {
    487              EMU->CTRL |= EMU_CTRL_EM23VSCALEAUTOWSEN;
    488          #if defined(_MSC_RAMCTRL_RAMWSEN_MASK)
    489              /* Set RAM wait states for safe EM2 wakeup. */
    490              BUS_RegMaskedSet(&MSC->RAMCTRL, (MSC_RAMCTRL_RAMWSEN
    491                                               | MSC_RAMCTRL_RAM1WSEN
    492                                               | MSC_RAMCTRL_RAM2WSEN));
    493          #endif
    494            } else {
    495              EMU->CTRL &= ~EMU_CTRL_EM23VSCALEAUTOWSEN;
    496            }
    497          }
    498          
    499          /* Handle automatic HFRCO adjustment that may have occurred during EM2/EM3. */
    500          static void vScaleAfterWakeup(void)
    501          {
    502            if ((EMU->CTRL & EMU_CTRL_EM23VSCALEAUTOWSEN) != 0U) {
    503              /* The hardware may have updated the HFRCOCTRL register during EM2/EM3
    504               * entry if voltage scaling in EM2/EM3 is enabled. The hardware would
    505               * then update the HFRCO frequency to 19 MHz automatically. */
    506              uint32_t freqRange = (CMU->HFRCOCTRL & _CMU_HFRCOCTRL_FREQRANGE_MASK)
    507                                   >> _CMU_HFRCOCTRL_FREQRANGE_SHIFT;
    508              if (freqRange == 0x08U) {
    509                SystemHfrcoFreq = 19000000;
    510              }
    511            }
    512          }
    513          #endif
    514          /** @endcond */
    515          
    516          /*******************************************************************************
    517           **************************   GLOBAL FUNCTIONS   *******************************
    518           ******************************************************************************/
    519          
    520          /***************************************************************************//**
    521           * @brief
    522           *   Energy mode 2/3 pre-sleep hook function.
    523           *
    524           * @details
    525           *   This function is called by EMU_EnterEM2() and EMU_EnterEM3() functions
    526           *   just prior to execution of the WFI instruction. The function implementation
    527           *   does not perform anything, but it is SL_WEAK so that it can be re-
    528           *   implemented in application code if actions are needed.
    529           *
    530           * @note
    531           *   The function is primarily meant to be used in systems with EFP circuitry.
    532           *   (EFP = Energy Friendly Pmic (PMIC = Power Management IC)).
    533           *   In such systems there is a need to drive certain signals to EFP pins to
    534           *   notify about energy mode transitions.
    535           ******************************************************************************/

   \                                 In section .text, align 2
    536          SL_WEAK void EMU_EM23PresleepHook(void)
    537          {
    538          }
   \                     EMU_EM23PresleepHook: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    539          
    540          /***************************************************************************//**
    541           * @brief
    542           *   Energy mode 2/3 post-sleep hook function.
    543           *
    544           * @details
    545           *   This function is called by EMU_EnterEM2() and EMU_EnterEM3() functions
    546           *   just after wakeup from the WFI instruction. The function implementation
    547           *   does not perform anything, but it is SL_WEAK so that it can be re-
    548           *   implemented in application code if actions are needed.
    549           *
    550           * @note
    551           *   The function is primarily meant to be used in systems with EFP circuitry.
    552           *   (EFP = Energy Friendly Pmic (PMIC = Power Management IC)).
    553           *   In such systems there is a need to drive certain signals to EFP pins to
    554           *   notify about energy mode transitions.
    555           ******************************************************************************/

   \                                 In section .text, align 2
    556          SL_WEAK void EMU_EM23PostsleepHook(void)
    557          {
    558          }
   \                     EMU_EM23PostsleepHook: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    559          
    560          /***************************************************************************//**
    561           * @brief
    562           *   Enter energy mode 2 (EM2).
    563           *
    564           * @details
    565           *   When entering EM2, high-frequency clocks are disabled, i.e., HFXO, HFRCO
    566           *   and AUXHFRCO (for AUXHFRCO, see exception note below). When re-entering
    567           *   EM0, HFRCO is re-enabled and the core will be clocked by the configured
    568           *   HFRCO band. This ensures a quick wakeup from EM2.
    569           *
    570           *   However, prior to entering EM2, the core may have been using another
    571           *   oscillator than HFRCO. The @p restore parameter gives the user the option
    572           *   to restore all HF oscillators according to state prior to entering EM2,
    573           *   as well as the clock used to clock the core. This restore procedure is
    574           *   handled by SW. However, since handled by SW, it will not be restored
    575           *   before completing the interrupt function(s) waking up the core!
    576           *
    577           * @note
    578           *   If restoring core clock to use the HFXO oscillator, which has been
    579           *   disabled during EM2 mode, this function will stall until the oscillator
    580           *   has stabilized. Stalling time can be reduced by adding interrupt
    581           *   support detecting stable oscillator, and an asynchronous switch to the
    582           *   original oscillator. See CMU documentation. Such a feature is however
    583           *   outside the scope of the implementation in this function.
    584           * @note
    585           *   If ERRATA_FIX_EMU_E110_ENABLE is active, the core's SLEEPONEXIT feature
    586           *   can not be used.
    587           * @par
    588           *   If HFXO is re-enabled by this function, and NOT used to clock the core,
    589           *   this function will not wait for HFXO to stabilize. This must be considered
    590           *   by the application if trying to use features relying on that oscillator
    591           *   upon return.
    592           * @par
    593           *   If a debugger is attached, the AUXHFRCO will not be disabled if enabled
    594           *   upon entering EM2. It will thus remain enabled when returning to EM0
    595           *   regardless of the @p restore parameter.
    596           * @par
    597           *   If HFXO autostart and select is enabled by using @ref CMU_HFXOAutostartEnable(),
    598           *   the starting and selecting of the core clocks will be identical to the user
    599           *   independently of the value of the @p restore parameter when waking up on
    600           *   the wakeup sources corresponding to the autostart and select setting.
    601           * @par
    602           *   If voltage scaling is supported, the restore parameter is true and the EM0
    603           *   voltage scaling level is set higher than the EM2 level, then the EM0 level is
    604           *   also restored.
    605           *
    606           *   Note that the hardware will automatically update the HFRCO frequency in the
    607           *   case where voltage scaling is used in EM2/EM3 and not in EM0/EM1. When the
    608           *   restore argument to this function is true then software will restore the
    609           *   original HFRCO frequency after EM2/EM3 wake up. If the restore argument is
    610           *   false then the HFRCO frequency is 19 MHz when coming out of EM2/EM3 and
    611           *   all wait states are at a safe value.
    612           *
    613           * @param[in] restore
    614           *   @li true - save and restore oscillators, clocks and voltage scaling, see
    615           *   function details.
    616           *   @li false - do not save and restore oscillators and clocks, see function
    617           *   details.
    618           * @par
    619           *   The @p restore option should only be used if all clock control is done
    620           *   via the CMU API.
    621           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    622          void EMU_EnterEM2(bool restore)
    623          {
   \                     EMU_EnterEM2: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....'....        BL       ?Subroutine1
    624          #if defined(ERRATA_FIX_EMU_E107_ENABLE)
    625            bool errataFixEmuE107En;
    626            uint32_t nonWicIntEn[2];
    627          #endif
    628          
    629            /* Only save EMU and CMU state if restored on wake-up. */
    630            if (restore) {
    631              emState(emState_Save);
    632            }
    633          
    634          #if defined(_EMU_CTRL_EM23VSCALE_MASK)
    635            vScaleDownEM23Setup();
    636          #endif
    637          
    638            /* Enter Cortex deep sleep mode. */
    639            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
    640          
    641            /* Fix for errata EMU_E107 - store non-WIC interrupt enable flags.
    642               Disable the enabled non-WIC interrupts. */
    643          #if defined(ERRATA_FIX_EMU_E107_ENABLE)
    644            errataFixEmuE107En = getErrataFixEmuE107En();
    645            if (errataFixEmuE107En) {
    646              nonWicIntEn[0] = NVIC->ISER[0] & NON_WIC_INT_MASK_0;
    647              NVIC->ICER[0] = nonWicIntEn[0];
    648          #if (NON_WIC_INT_MASK_1 != (~(0x0U)))
    649              nonWicIntEn[1] = NVIC->ISER[1] & NON_WIC_INT_MASK_1;
    650              NVIC->ICER[1] = nonWicIntEn[1];
    651          #endif
    652            }
    653          #endif
    654          
    655          #if defined(ERRATA_FIX_DCDC_FETCNT_SET_ENABLE)
    656            dcdcFetCntSet(true);
    657          #endif
    658          #if defined(ERRATA_FIX_DCDC_LNHS_BLOCK_ENABLE)
    659            dcdcHsFixLnBlock();
    660          #endif
    661          
    662            EMU_EM23PresleepHook();
    663          #if defined(ERRATA_FIX_EMU_E110_ENABLE)
    664            CORE_CRITICAL_SECTION(ramWFI(); )
    665          #else
    666            __WFI();
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0x6   0xBF30             WFI      
    667          #endif
    668            EMU_EM23PostsleepHook();
   \        0x8   0x....'....        BL       EMU_EM23PostsleepHook
    669          
    670          #if defined(ERRATA_FIX_DCDC_FETCNT_SET_ENABLE)
    671            dcdcFetCntSet(false);
    672          #endif
    673          
    674            /* Fix for errata EMU_E107 - restore state of non-WIC interrupt enable flags. */
    675          #if defined(ERRATA_FIX_EMU_E107_ENABLE)
    676            if (errataFixEmuE107En) {
    677              NVIC->ISER[0] = nonWicIntEn[0];
    678          #if (NON_WIC_INT_MASK_1 != (~(0x0U)))
    679              NVIC->ISER[1] = nonWicIntEn[1];
    680          #endif
    681            }
    682          #endif
    683          
    684            /* Restore oscillators/clocks and voltage scaling if supported. */
    685            if (restore) {
   \        0xC   0xB904             CBNZ.N   R4,??EMU_EnterEM2_0
    686              emState(emState_Restore);
    687            } else {
    688          #if defined(_EMU_CTRL_EM23VSCALE_MASK)
    689              vScaleAfterWakeup();
    690          #endif
    691              /* If not restoring, and original clock was not HFRCO, we have to */
    692              /* update CMSIS core clock variable since HF clock has changed */
    693              /* to HFRCO. */
    694              SystemCoreClockUpdate();
   \        0xE   0x....             B.N      ?Subroutine0
    695            }
    696          }
   \                     ??EMU_EnterEM2_0: (+1)
   \       0x10   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0x....             LDR.N    R0,??DataTable5  ;; 0xe000ed10
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0xF041 0x0104      ORR      R1,R1,#0x4
   \        0xA   0x6001             STR      R1,[R0, #+0]
   \        0xC   0x....'....        B.W      EMU_EM23PresleepHook

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xE8BD 0x4010      POP      {R4,LR}
   \        0x4   0x....             B.N      SystemCoreClockUpdate
    697          
    698          /***************************************************************************//**
    699           * @brief
    700           *   Enter energy mode 3 (EM3).
    701           *
    702           * @details
    703           *   When entering EM3, the high-frequency clocks are disabled by hardware, i.e., HFXO,
    704           *   HFRCO, and AUXHFRCO (for AUXHFRCO, see exception note below). In addition,
    705           *   the low-frequency clocks, i.e., LFXO and LFRCO are disabled by software. When
    706           *   re-entering EM0, HFRCO is re-enabled and the core will be clocked by the
    707           *   configured HFRCO band. This ensures a quick wakeup from EM3.
    708           *
    709           *   However, prior to entering EM3, the core may have been using an
    710           *   oscillator other than HFRCO. The @p restore parameter gives the user the option
    711           *   to restore all HF/LF oscillators according to state prior to entering EM3,
    712           *   as well as the clock used to clock the core. This restore procedure is
    713           *   handled by software. However, since it is handled by software, it will not be restored
    714           *   before completing the interrupt function(s) waking up the core!
    715           *
    716           * @note
    717           *   If restoring core clock to use an oscillator other than HFRCO, this
    718           *   function will stall until the oscillator has stabilized. Stalling time
    719           *   can be reduced by adding interrupt support detecting stable oscillator,
    720           *   and an asynchronous switch to the original oscillator. See CMU
    721           *   documentation. This feature is, however, outside the scope of the
    722           *   implementation in this function.
    723           * @note
    724           *   If ERRATA_FIX_EMU_E110_ENABLE is active, the core's SLEEPONEXIT feature
    725           *   can't be used.
    726           * @par
    727           *   If HFXO/LFXO/LFRCO are re-enabled by this function, and NOT used to clock
    728           *   the core, this function will not wait for those oscillators to stabilize.
    729           *   This must be considered by the application if trying to use features
    730           *   relying on those oscillators upon return.
    731           * @par
    732           *   If a debugger is attached, the AUXHFRCO will not be disabled if enabled
    733           *   upon entering EM3. It will, therefore, remain enabled when returning to EM0
    734           *   regardless of the @p restore parameter.
    735           * @par
    736           *   If voltage scaling is supported, the restore parameter is true and the EM0
    737           *   voltage scaling level is set higher than the EM3 level, then the EM0 level is
    738           *   also restored.
    739           *
    740           * @param[in] restore
    741           *   @li true - save and restore oscillators, clocks and voltage scaling, see
    742           *   function details.
    743           *   @li false - do not save and restore oscillators and clocks, see function
    744           *   details.
    745           * @par
    746           *   The @p restore option should only be used if all clock control is done
    747           *   via the CMU API.
    748           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    749          void EMU_EnterEM3(bool restore)
    750          {
   \                     EMU_EnterEM3: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....'....        BL       ?Subroutine1
    751          #if defined(ERRATA_FIX_EMU_E107_ENABLE)
    752            bool errataFixEmuE107En;
    753            uint32_t nonWicIntEn[2];
    754          #endif
    755          
    756            /* Only save EMU and CMU state if restored on wake-up. */
    757            if (restore) {
    758              emState(emState_Save);
    759            }
    760          
    761          #if defined(EMU_VSCALE_PRESENT)
    762            vScaleDownEM23Setup();
    763          #endif
    764          
    765          #if defined(_CMU_OSCENCMD_MASK)
    766            uint32_t cmuLocked;
    767            cmuLocked = CMU->LOCK & CMU_LOCK_LOCKKEY_LOCKED;
    768            CMU_Unlock();
    769          
    770            /* Disable LF oscillators. */
    771            CMU->OSCENCMD = CMU_OSCENCMD_LFXODIS | CMU_OSCENCMD_LFRCODIS;
    772          
    773            /* Restore CMU register locking. */
    774            if (cmuLocked != 0U) {
    775              CMU_Lock();
    776            }
    777          #endif
    778          
    779            /* Enter Cortex deep sleep mode. */
    780            SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
    781          
    782            /* Fix for errata EMU_E107 - store non-WIC interrupt enable flags.
    783               Disable the enabled non-WIC interrupts. */
    784          #if defined(ERRATA_FIX_EMU_E107_ENABLE)
    785            errataFixEmuE107En = getErrataFixEmuE107En();
    786            if (errataFixEmuE107En) {
    787              nonWicIntEn[0] = NVIC->ISER[0] & NON_WIC_INT_MASK_0;
    788              NVIC->ICER[0] = nonWicIntEn[0];
    789          #if (NON_WIC_INT_MASK_1 != (~(0x0U)))
    790              nonWicIntEn[1] = NVIC->ISER[1] & NON_WIC_INT_MASK_1;
    791              NVIC->ICER[1] = nonWicIntEn[1];
    792          #endif
    793            }
    794          #endif
    795          
    796          #if defined(ERRATA_FIX_DCDC_FETCNT_SET_ENABLE)
    797            dcdcFetCntSet(true);
    798          #endif
    799          #if defined(ERRATA_FIX_DCDC_LNHS_BLOCK_ENABLE)
    800            dcdcHsFixLnBlock();
    801          #endif
    802          
    803            EMU_EM23PresleepHook();
    804          #if defined(ERRATA_FIX_EMU_E110_ENABLE)
    805            CORE_CRITICAL_SECTION(ramWFI(); )
    806          #else
    807            __WFI();
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0x6   0xBF30             WFI      
    808          #endif
    809            EMU_EM23PostsleepHook();
   \        0x8   0x....'....        BL       EMU_EM23PostsleepHook
    810          
    811          #if defined(ERRATA_FIX_DCDC_FETCNT_SET_ENABLE)
    812            dcdcFetCntSet(false);
    813          #endif
    814          
    815            /* Fix for errata EMU_E107 - restore state of non-WIC interrupt enable flags. */
    816          #if defined(ERRATA_FIX_EMU_E107_ENABLE)
    817            if (errataFixEmuE107En) {
    818              NVIC->ISER[0] = nonWicIntEn[0];
    819          #if (NON_WIC_INT_MASK_1 != (~(0x0U)))
    820              NVIC->ISER[1] = nonWicIntEn[1];
    821          #endif
    822            }
    823          #endif
    824          
    825            /* Restore oscillators/clocks and voltage scaling if supported. */
    826            if (restore) {
   \        0xC   0xB904             CBNZ.N   R4,??EMU_EnterEM3_0
    827              emState(emState_Restore);
    828            } else {
    829          #if defined(_EMU_CTRL_EM23VSCALE_MASK)
    830              vScaleAfterWakeup();
    831          #endif
    832              /* If not restoring, and original clock was not HFRCO. */
    833              /* As a result, the CMSIS core clock variable must be updated. */
    834              /* to HFRCO. */
    835              SystemCoreClockUpdate();
   \        0xE   0x....             B.N      ?Subroutine0
    836            }
    837          }
   \                     ??EMU_EnterEM3_0: (+1)
   \       0x10   0xBD10             POP      {R4,PC}          ;; return
    838          
    839          /***************************************************************************//**
    840           * @brief
    841           *   Save the CMU HF clock select state, oscillator enable, and voltage scaling
    842           *   (if available) before @ref EMU_EnterEM2() or @ref EMU_EnterEM3() are called
    843           *   with the restore parameter set to false. Calling this function is
    844           *   equivalent to calling @ref EMU_EnterEM2() or @ref EMU_EnterEM3() with the
    845           *   restore parameter set to true, but it allows the state to be saved without
    846           *   going to sleep. The state can be restored manually by calling
    847           *   @ref EMU_Restore().
    848           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    849          void EMU_Save(void)
    850          {
    851            emState(emState_Save);
    852          }
   \                     EMU_Save: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    853          
    854          /***************************************************************************//**
    855           * @brief
    856           *   Restore CMU HF clock select state, oscillator enable, and voltage scaling
    857           *   (if available) after @ref EMU_EnterEM2() or @ref EMU_EnterEM3() are called
    858           *   with the restore parameter set to false. Calling this function is
    859           *   equivalent to calling @ref EMU_EnterEM2() or @ref EMU_EnterEM3() with the
    860           *   restore parameter set to true, but it allows the application to evaluate the
    861           *   wakeup reason before restoring state.
    862           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    863          void EMU_Restore(void)
    864          {
    865            emState(emState_Restore);
    866          }
   \                     EMU_Restore: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    867          
    868          /***************************************************************************//**
    869           * @brief
    870           *   Enter energy mode 4 (EM4).
    871           *
    872           * @note
    873           *   Only a power on reset or external reset pin can wake the device from EM4.
    874           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    875          void EMU_EnterEM4(void)
    876          {
    877            int i;
    878          
    879          #if defined(_EMU_EM4CTRL_EM4ENTRY_SHIFT)
    880            uint32_t em4seq2 = (EMU->EM4CTRL & ~_EMU_EM4CTRL_EM4ENTRY_MASK)
    881                               | (2U << _EMU_EM4CTRL_EM4ENTRY_SHIFT);
   \                     EMU_EnterEM4: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable5_1  ;; 0x40004060
   \        0x2   0x68CA             LDR      R2,[R1, #+12]
    882            uint32_t em4seq3 = (EMU->EM4CTRL & ~_EMU_EM4CTRL_EM4ENTRY_MASK)
    883                               | (3U << _EMU_EM4CTRL_EM4ENTRY_SHIFT);
   \        0x4   0x68CB             LDR      R3,[R1, #+12]
    884          #else
    885            uint32_t em4seq2 = (EMU->CTRL & ~_EMU_CTRL_EM4CTRL_MASK)
    886                               | (2U << _EMU_CTRL_EM4CTRL_SHIFT);
    887            uint32_t em4seq3 = (EMU->CTRL & ~_EMU_CTRL_EM4CTRL_MASK)
    888                               | (3U << _EMU_CTRL_EM4CTRL_SHIFT);
    889          #endif
    890          
    891            /* Make sure that the register write lock is disabled. */
    892            EMU_Unlock();
   \        0x6   0xF64A 0x50E8      MOVW     R0,#+44520
   \        0xA   0x0892             LSRS     R2,R2,#+2
   \        0xC   0x0092             LSLS     R2,R2,#+2
   \        0xE   0x6008             STR      R0,[R1, #+0]
   \       0x10   0xF042 0x0202      ORR      R2,R2,#0x2
   \       0x14   0xF043 0x0303      ORR      R3,R3,#0x3
    893          
    894          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
    895            /* The DCDC is not supported in EM4S. EFM32xG1 and EFR32xG1 devices should
    896             * switch to bypass mode before entering EM4S. Other devices handle this
    897             * automatically at the hardware level. */
    898            if ((EMU->EM4CTRL & _EMU_EM4CTRL_EM4STATE_MASK) == EMU_EM4CTRL_EM4STATE_EM4S) {
    899              uint32_t dcdcMode = EMU->DCDCCTRL & _EMU_DCDCCTRL_DCDCMODE_MASK;
    900              if (dcdcMode == EMU_DCDCCTRL_DCDCMODE_LOWNOISE
    901                  || dcdcMode == EMU_DCDCCTRL_DCDCMODE_LOWPOWER) {
    902                EMU_DCDCModeSet(emuDcdcMode_Bypass);
    903              }
    904            }
    905          #endif
    906          
    907          #if defined(_EMU_EM4CTRL_MASK) && defined(ERRATA_FIX_EMU_E208_ENABLE)
    908            if (EMU->EM4CTRL & EMU_EM4CTRL_EM4STATE_EM4H) {
    909              /* Fix for errata EMU_E208 - Occasional Full Reset After Exiting EM4H.
    910               * Full description of errata fix can be found in the errata document. */
    911              __disable_irq();
    912              *(volatile uint32_t *)(EMU_BASE + 0x190UL)  = 0x0000ADE8UL;
    913              *(volatile uint32_t *)(EMU_BASE + 0x198UL) |= (0x1UL << 7);
    914              *(volatile uint32_t *)(EMU_BASE + 0x88UL)  |= (0x1UL << 8);
    915            }
    916          #endif
    917          
    918          #if defined(ERRATA_FIX_EMU_E108_ENABLE)
    919            /* Fix for errata EMU_E108 - High Current Consumption on EM4 Entry. */
    920            __disable_irq();
    921            *(volatile uint32_t *)0x400C80E4 = 0;
    922          #endif
    923          
    924          #if defined(ERRATA_FIX_DCDC_FETCNT_SET_ENABLE)
    925            dcdcFetCntSet(true);
    926          #endif
    927          #if defined(ERRATA_FIX_DCDC_LNHS_BLOCK_ENABLE)
    928            dcdcHsFixLnBlock();
    929          #endif
    930          
    931          #if defined(ERRATA_FIX_EM4S_DELAY_ENTRY)
    932            /* Fix for errata where firmware must clear ANASW and delay EM4S entry by 30 us. */
    933            if ((EMU->EM4CTRL & _EMU_EM4CTRL_EM4STATE_MASK) == EMU_EM4CTRL_EM4STATE_EM4S) {
    934              if ((EMU->PWRCTRL & _EMU_PWRCTRL_ANASW_MASK) == EMU_PWRCTRL_ANASW_DVDD) {
    935                BUS_RegMaskedClear(&EMU->PWRCTRL, _EMU_PWRCTRL_ANASW_MASK);
    936                /* Switch to 1 MHz HFRCO. This delays enough to meet the 30 us requirement
    937                 * before entering EM4. */
    938                uint32_t freqCal = (DEVINFO->HFRCOCAL0 & ~_CMU_HFRCOCTRL_CLKDIV_MASK)
    939                                   | CMU_HFRCOCTRL_CLKDIV_DIV4;
    940                while ((CMU->SYNCBUSY & CMU_SYNCBUSY_HFRCOBSY) != 0UL) {
    941                }
    942                CMU->HFRCOCTRL = freqCal;
    943                CMU->OSCENCMD = CMU_OSCENCMD_HFRCOEN;
    944                while ((CMU->STATUS & CMU_STATUS_HFRCORDY) == 0U) {
    945                }
    946                CMU->HFCLKSEL = CMU_HFCLKSEL_HF_HFRCO;
    947                __NOP();
    948              }
    949            }
    950          #endif
    951          
    952            for (i = 0; i < 4; i++) {
   \       0x18   0x2004             MOVS     R0,#+4
    953          #if defined(_EMU_EM4CTRL_EM4ENTRY_SHIFT)
    954              EMU->EM4CTRL = em4seq2;
   \                     ??EMU_EnterEM4_0: (+1)
   \       0x1A   0x60CA             STR      R2,[R1, #+12]
    955              EMU->EM4CTRL = em4seq3;
   \       0x1C   0x60CB             STR      R3,[R1, #+12]
    956            }
   \       0x1E   0x1E40             SUBS     R0,R0,#+1
   \       0x20   0xD1FB             BNE.N    ??EMU_EnterEM4_0
    957            EMU->EM4CTRL = em4seq2;
   \       0x22   0x60CA             STR      R2,[R1, #+12]
    958          #else
    959              EMU->CTRL = em4seq2;
    960              EMU->CTRL = em4seq3;
    961            }
    962            EMU->CTRL = em4seq2;
    963          #endif
    964          }
   \       0x24   0x4770             BX       LR               ;; return
    965          
    966          #if defined(_EMU_EM4CTRL_MASK)
    967          /***************************************************************************//**
    968           * @brief
    969           *   Enter energy mode 4 hibernate (EM4H).
    970           *
    971           * @note
    972           *   Retention of clocks and GPIO in EM4 can be configured using
    973           *   @ref EMU_EM4Init before calling this function.
    974           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    975          void EMU_EnterEM4H(void)
    976          {
    977          #if defined(_EMU_EM4CTRL_EM4STATE_MASK)
    978            BUS_RegBitWrite(&EMU->EM4CTRL, _EMU_EM4CTRL_EM4STATE_SHIFT, 1);
    979          #endif
    980            EMU_EnterEM4();
   \                     EMU_EnterEM4H: (+1)
   \        0x0   0x....             B.N      EMU_EnterEM4
    981          }
    982          
    983          /***************************************************************************//**
    984           * @brief
    985           *   Enter energy mode 4 shutoff (EM4S).
    986           *
    987           * @note
    988           *   Retention of clocks and GPIO in EM4 can be configured using
    989           *   @ref EMU_EM4Init before calling this function.
    990           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    991          void EMU_EnterEM4S(void)
    992          {
    993          #if defined(_EMU_EM4CTRL_EM4STATE_MASK)
    994            BUS_RegBitWrite(&EMU->EM4CTRL, _EMU_EM4CTRL_EM4STATE_SHIFT, 0);
    995          #endif
    996            EMU_EnterEM4();
   \                     EMU_EnterEM4S: (+1)
   \        0x0   0x....             B.N      EMU_EnterEM4
    997          }
    998          #endif
    999          
   1000          /***************************************************************************//**
   1001           * @brief
   1002           *   Power down memory block.
   1003           *
   1004           * @param[in] blocks
   1005           *   Specifies a logical OR of bits indicating memory blocks to power down.
   1006           *   Bit 0 selects block 1, bit 1 selects block 2, and so on. Memory block 0 cannot
   1007           *   be disabled. See the reference manual for available
   1008           *   memory blocks for a device.
   1009           *
   1010           * @note
   1011           *   Only a POR reset can power up the specified memory block(s) after power down.
   1012           *
   1013           * @deprecated
   1014           *   This function is deprecated, use @ref EMU_RamPowerDown() instead which
   1015           *   maps a user provided memory range into RAM blocks to power down.
   1016           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1017          void EMU_MemPwrDown(uint32_t blocks)
   1018          {
   1019          #if defined(_EMU_MEMCTRL_MASK)
   1020            EMU->MEMCTRL = blocks & _EMU_MEMCTRL_MASK;
   1021          #elif defined(_EMU_RAM0CTRL_MASK)
   1022            EMU->RAM0CTRL = blocks & _EMU_RAM0CTRL_MASK;
   1023          #else
   1024            (void)blocks;
   1025          #endif
   1026          }
   \                     EMU_MemPwrDown: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1027          
   1028          /***************************************************************************//**
   1029           * @brief
   1030           *   Power down RAM memory blocks.
   1031           *
   1032           * @details
   1033           *   This function will power down all the RAM blocks that are within a given
   1034           *   range. The RAM block layout is different between device families, so this
   1035           *   function can be used in a generic way to power down a RAM memory region
   1036           *   which is known to be unused.
   1037           *
   1038           *   This function will only power down blocks which are completely enclosed
   1039           *   by the memory range given by [start, end).
   1040           *
   1041           *   This is an example to power down all RAM blocks except the first
   1042           *   one. The first RAM block is special in that it cannot be powered down
   1043           *   by the hardware. The size of the first RAM block is device-specific.
   1044           *   See the reference manual to find the RAM block sizes.
   1045           *
   1046           * @code
   1047           *   EMU_RamPowerDown(SRAM_BASE, SRAM_BASE + SRAM_SIZE);
   1048           * @endcode
   1049           *
   1050           * @note
   1051           *   Only a reset can power up the specified memory block(s) after power down
   1052           *   on a series 0 device.
   1053           *
   1054           * @param[in] start
   1055           *   The start address of the RAM region to power down. This address is
   1056           *   inclusive.
   1057           *
   1058           * @param[in] end
   1059           *   The end address of the RAM region to power down. This address is
   1060           *   exclusive. If this parameter is 0, all RAM blocks contained in the
   1061           *   region from start to the upper RAM address will be powered down.
   1062           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1063          void EMU_RamPowerDown(uint32_t start, uint32_t end)
   1064          {
   \                     EMU_RamPowerDown: (+1)
   \        0x0   0xB520             PUSH     {R5,LR}
   1065            uint32_t mask = 0;
   \        0x2   0x2200             MOVS     R2,#+0
   1066          
   1067            if (end == 0U) {
   \        0x4   0xB111             CBZ.N    R1,??EMU_RamPowerDown_0
   1068              end = SRAM_BASE + SRAM_SIZE;
   1069            }
   1070          
   1071            // Check to see if something in RAM0 can be powered down.
   1072            if (end > RAM0_END) {
   \        0x6   0x....             LDR.N    R3,??DataTable5_2  ;; 0x20018000
   \        0x8   0x4299             CMP      R1,R3
   \        0xA   0xD30D             BCC.N    ??EMU_RamPowerDown_1
   1073          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_84) // EFM32xG12 and EFR32xG12
   1074              // Block 0 is 16 kB and cannot be powered off.
   1075              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x20004000UL) << 0; // Block 1, 16 kB
   1076              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x20008000UL) << 1; // Block 2, 16 kB
   1077              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x2000C000UL) << 2; // Block 3, 16 kB
   1078              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x20010000UL) << 3; // Block 4, 64 kB
   1079          #elif defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80) // EFM32xG1 and EFR32xG1
   1080              // Block 0 is 4 kB and cannot be powered off.
   1081              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x20001000UL) << 0; // Block 1, 4 kB
   1082              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x20002000UL) << 1; // Block 2, 8 kB
   1083              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x20004000UL) << 2; // Block 3, 8 kB
   1084              mask |= ADDRESS_NOT_IN_BLOCK(start, 0x20006000UL) << 3; // Block 4, 7 kB
   1085          #elif defined(RAM0_BLOCKS)
   1086              // These platforms have equally-sized RAM blocks.
   1087              for (unsigned i = 1; i < RAM0_BLOCKS; i++) {
   \                     ??EMU_RamPowerDown_0: (+1)
   \        0xC   0x2101             MOVS     R1,#+1
   1088                mask |= ADDRESS_NOT_IN_BLOCK(start, RAM_MEM_BASE + (i * RAM0_BLOCK_SIZE)) << (i - 1U);
   \                     ??EMU_RamPowerDown_2: (+1)
   \        0xE   0x038B             LSLS     R3,R1,#+14
   \       0x10   0xF103 0x5300      ADD      R3,R3,#+536870912
   \       0x14   0x4283             CMP      R3,R0
   \       0x16   0x419B             SBCS     R3,R3,R3
   \       0x18   0x43DB             MVNS     R3,R3
   \       0x1A   0x0FDB             LSRS     R3,R3,#+31
   \       0x1C   0x1E4D             SUBS     R5,R1,#+1
   \       0x1E   0x40AB             LSLS     R3,R3,R5
   \       0x20   0x431A             ORRS     R2,R3,R2
   1089              }
   \       0x22   0x1C49             ADDS     R1,R1,#+1
   \       0x24   0x2906             CMP      R1,#+6
   \       0x26   0xD3F2             BCC.N    ??EMU_RamPowerDown_2
   1090          #endif
   1091            }
   1092          
   1093            // Power down the selected blocks.
   1094          #if defined(_EMU_MEMCTRL_MASK)
   1095            EMU->MEMCTRL = EMU->MEMCTRL   | mask;
   1096          #elif defined(_EMU_RAM0CTRL_MASK)
   1097            EMU->RAM0CTRL = EMU->RAM0CTRL | mask;
   1098          #elif defined(_SILICON_LABS_32B_SERIES_2)
   1099          #if defined(CMU_CLKEN0_SYSCFG)
   1100            CMU->CLKEN0_SET = CMU_CLKEN0_SYSCFG;
   1101          #endif
   1102          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
   1103            SYSCFG->DMEM0RETNCTRL = SYSCFG->DMEM0RETNCTRL | (mask << 1);
   1104          #else
   1105            SYSCFG->DMEM0RETNCTRL = SYSCFG->DMEM0RETNCTRL | mask;
   \                     ??EMU_RamPowerDown_1: (+1)
   \       0x28   0x....             LDR.N    R0,??DataTable5_3  ;; 0x4007c208
   \       0x2A   0x6801             LDR      R1,[R0, #+0]
   \       0x2C   0x430A             ORRS     R2,R2,R1
   \       0x2E   0x6002             STR      R2,[R0, #+0]
   1106          #endif
   1107          #else
   1108            // These devices are unable to power down RAM blocks.
   1109            (void) mask;
   1110            (void) start;
   1111          #endif
   1112          
   1113          #if defined(RAM1_MEM_END)
   1114            mask = 0;
   1115            if (end > RAM1_MEM_END) {
   1116              for (unsigned i = 0; i < RAM1_BLOCKS; i++) {
   1117                mask |= ADDRESS_NOT_IN_BLOCK(start, RAM1_MEM_BASE + (i * RAM1_BLOCK_SIZE)) << i;
   1118              }
   1119            }
   1120            EMU->RAM1CTRL |= mask;
   1121          #endif
   1122          
   1123          #if defined(RAM2_MEM_END)
   1124            mask = 0;
   1125            if (end > RAM2_MEM_END) {
   1126              for (unsigned i = 0; i < RAM2_BLOCKS; i++) {
   1127                mask |= ADDRESS_NOT_IN_BLOCK(start, RAM2_MEM_BASE + (i * RAM2_BLOCK_SIZE)) << i;
   1128              }
   1129            }
   1130            EMU->RAM2CTRL |= mask;
   1131          #endif
   1132          }
   \       0x30   0xBD20             POP      {R5,PC}          ;; return
   1133          
   1134          /***************************************************************************//**
   1135           * @brief
   1136           *   Power up all available RAM memory blocks.
   1137           *
   1138           * @details
   1139           *   This function will power up all the RAM blocks on a device, this means
   1140           *   that the RAM blocks are retained in EM2/EM3. Note that this functionality
   1141           *   is not supported on Series 0 devices. Only a reset will power up the RAM
   1142           *   blocks on a series 0 device.
   1143           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1144          void EMU_RamPowerUp(void)
   1145          {
   1146          #if defined(_EMU_RAM0CTRL_MASK)
   1147            EMU->RAM0CTRL = 0x0UL;
   1148          #endif
   1149          #if defined(_EMU_RAM1CTRL_MASK)
   1150            EMU->RAM1CTRL = 0x0UL;
   1151          #endif
   1152          #if defined(_EMU_RAM2CTRL_MASK)
   1153            EMU->RAM2CTRL = 0x0UL;
   1154          #endif
   1155          #if defined(_SYSCFG_DMEM0RETNCTRL_MASK)
   1156          #if defined(CMU_CLKEN0_SYSCFG)
   1157            CMU->CLKEN0_SET = CMU_CLKEN0_SYSCFG;
   1158          #endif
   1159            SYSCFG->DMEM0RETNCTRL = 0x0UL;
   \                     EMU_RamPowerUp: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x....             LDR.N    R1,??DataTable5_3  ;; 0x4007c208
   \        0x4   0x6008             STR      R0,[R1, #+0]
   1160          #endif
   1161          }
   \        0x6   0x4770             BX       LR               ;; return
   1162          
   1163          #if defined(_EMU_EM23PERNORETAINCTRL_MASK)
   1164          /***************************************************************************//**
   1165           * @brief
   1166           *   Set EM2 3 peripheral retention control.
   1167           *
   1168           * @param[in] periMask
   1169           *  A peripheral select mask. Use | operator to select multiple peripherals, for example
   1170           *  @ref emuPeripheralRetention_LEUART0 | @ref emuPeripheralRetention_VDAC0.
   1171           * @param[in] enable
   1172           *  Peripheral retention enable (true) or disable (false).
   1173           *
   1174           *
   1175           * @note
   1176           *   Only peripheral retention disable is currently supported. Peripherals are
   1177           *   enabled by default and can only be disabled.
   1178           ******************************************************************************/
   1179          void EMU_PeripheralRetention(EMU_PeripheralRetention_TypeDef periMask, bool enable)
   1180          {
   1181            EFM_ASSERT(!enable);
   1182            EMU->EM23PERNORETAINCTRL = (uint32_t)periMask
   1183                                       & (uint32_t)emuPeripheralRetention_ALL;
   1184          }
   1185          #endif
   1186          
   1187          /***************************************************************************//**
   1188           * @brief
   1189           *   Update EMU module with CMU oscillator selection/enable status.
   1190           *
   1191           * @deprecated
   1192           *   Oscillator status is saved in @ref EMU_EnterEM2() and @ref EMU_EnterEM3().
   1193           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1194          void EMU_UpdateOscConfig(void)
   1195          {
   1196            emState(emState_Save);
   1197          }
   \                     EMU_UpdateOscConfig: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1198          
   1199          #if defined(EMU_VSCALE_PRESENT)
   1200          /***************************************************************************//**
   1201           * @brief
   1202           *   Voltage scale in EM0 and 1 by clock frequency.
   1203           *
   1204           * @param[in] clockFrequency
   1205           *   Use CMSIS HF clock if 0 or override to custom clock. Providing a
   1206           *   custom clock frequency is required if using a non-standard HFXO
   1207           *   frequency.
   1208           * @param[in] wait
   1209           *   Wait for scaling to complete.
   1210           *
   1211           * @note
   1212           *   This function is primarily needed by the @ref CMU module.
   1213           ******************************************************************************/
   1214          void EMU_VScaleEM01ByClock(uint32_t clockFrequency, bool wait)
   1215          {
   1216            uint32_t hfSrcClockFrequency;
   1217            uint32_t hfPresc = 1U + ((CMU->HFPRESC & _CMU_HFPRESC_PRESC_MASK)
   1218                                     >> _CMU_HFPRESC_PRESC_SHIFT);
   1219          
   1220            /* VSCALE frequency is HFSRCCLK. */
   1221            if (clockFrequency == 0U) {
   1222              hfSrcClockFrequency = SystemHFClockGet() * hfPresc;
   1223            } else {
   1224              hfSrcClockFrequency = clockFrequency;
   1225            }
   1226          
   1227            /* Apply EM0 and 1 voltage scaling command. */
   1228            if (vScaleEM01Config.vScaleEM01LowPowerVoltageEnable
   1229                && (hfSrcClockFrequency < CMU_VSCALEEM01_LOWPOWER_VOLTAGE_CLOCK_MAX)) {
   1230              EMU_VScaleEM01(emuVScaleEM01_LowPower, wait);
   1231            } else {
   1232              EMU_VScaleEM01(emuVScaleEM01_HighPerformance, wait);
   1233            }
   1234          }
   1235          #endif
   1236          
   1237          #if defined(EMU_VSCALE_PRESENT)
   1238          /***************************************************************************//**
   1239           * @brief
   1240           *   Force voltage scaling in EM0 and 1 to a specific voltage level.
   1241           *
   1242           * @param[in] voltage
   1243           *   Target VSCALE voltage level.
   1244           * @param[in] wait
   1245           *   Wait for scaling to complete.
   1246           *
   1247           * @note
   1248           *   This function is useful for upscaling before programming Flash from @ref MSC
   1249           *   and downscaling after programming is done. Flash programming is only supported
   1250           *   at @ref emuVScaleEM01_HighPerformance.
   1251           *
   1252           * @note
   1253           *  This function ignores @ref vScaleEM01LowPowerVoltageEnable set from @ref
   1254           *  EMU_EM01Init().
   1255           ******************************************************************************/
   1256          void EMU_VScaleEM01(EMU_VScaleEM01_TypeDef voltage, bool wait)
   1257          {
   1258            uint32_t hfSrcClockFrequency;
   1259            uint32_t hfPresc = 1U + ((CMU->HFPRESC & _CMU_HFPRESC_PRESC_MASK)
   1260                                     >> _CMU_HFPRESC_PRESC_SHIFT);
   1261            uint32_t hfFreq = SystemHFClockGet();
   1262            EMU_VScaleEM01_TypeDef current = EMU_VScaleGet();
   1263          
   1264            if (current == voltage) {
   1265              /* Voltage is already at the correct level. */
   1266              return;
   1267            }
   1268          
   1269            hfSrcClockFrequency = hfFreq * hfPresc;
   1270          
   1271            if (voltage == emuVScaleEM01_LowPower) {
   1272              EFM_ASSERT(hfSrcClockFrequency <= CMU_VSCALEEM01_LOWPOWER_VOLTAGE_CLOCK_MAX);
   1273              /* Update wait states before scaling down voltage. */
   1274              CMU_UpdateWaitStates(hfFreq, (int)emuVScaleEM01_LowPower);
   1275            }
   1276          
   1277            EMU->CMD = vScaleEM01Cmd(voltage);
   1278          
   1279            if (wait) {
   1280              EMU_VScaleWait();
   1281            }
   1282          
   1283            if (voltage == emuVScaleEM01_HighPerformance) {
   1284              /* Update wait states after scaling up voltage. */
   1285              CMU_UpdateWaitStates(hfFreq, (int)emuVScaleEM01_HighPerformance);
   1286            }
   1287          }
   1288          #endif
   1289          
   1290          #if defined(EMU_VSCALE_PRESENT)
   1291          /***************************************************************************//**
   1292           * @brief
   1293           *   Update the EMU module with Energy Mode 0 and 1 configuration.
   1294           *
   1295           * @param[in] em01Init
   1296           *    Energy Mode 0 and 1 configuration structure.
   1297           ******************************************************************************/
   1298          void EMU_EM01Init(const EMU_EM01Init_TypeDef *em01Init)
   1299          {
   1300            vScaleEM01Config.vScaleEM01LowPowerVoltageEnable =
   1301              em01Init->vScaleEM01LowPowerVoltageEnable;
   1302            EMU_VScaleEM01ByClock(0, true);
   1303          }
   1304          #endif
   1305          
   1306          /***************************************************************************//**
   1307           * @brief
   1308           *   Update the EMU module with Energy Mode 2 and 3 configuration.
   1309           *
   1310           * @param[in] em23Init
   1311           *    Energy Mode 2 and 3 configuration structure.
   1312           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1313          void EMU_EM23Init(const EMU_EM23Init_TypeDef *em23Init)
   1314          {
   1315          #if defined(_EMU_CTRL_EMVREG_MASK)
   1316            EMU->CTRL = em23Init->em23VregFullEn ? (EMU->CTRL | EMU_CTRL_EMVREG)
   1317                        : (EMU->CTRL & ~EMU_CTRL_EMVREG);
   1318          #elif defined(_EMU_CTRL_EM23VREG_MASK)
   1319            EMU->CTRL = em23Init->em23VregFullEn ? (EMU->CTRL | EMU_CTRL_EM23VREG)
   1320                        : (EMU->CTRL & ~EMU_CTRL_EM23VREG);
   1321          #else
   1322            (void)em23Init;
   1323          #endif
   1324          
   1325          #if defined(_EMU_CTRL_EM23VSCALE_MASK)
   1326            EMU->CTRL = (EMU->CTRL & ~_EMU_CTRL_EM23VSCALE_MASK)
   1327                        | ((uint32_t)em23Init->vScaleEM23Voltage << _EMU_CTRL_EM23VSCALE_SHIFT);
   1328            if (em23Init->vScaleEM23Voltage == emuVScaleEM23_LowPower) {
   1329              /* Voltage scaling is not compatible with HFXO auto start and select. */
   1330              EFM_ASSERT((CMU->HFXOCTRL & CMU_HFXOCTRL_AUTOSTARTSELEM0EM1) == 0U);
   1331            }
   1332          #endif
   1333          }
   \                     EMU_EM23Init: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1334          
   1335          #if defined(_EMU_EM4CONF_MASK) || defined(_EMU_EM4CTRL_MASK)
   1336          /***************************************************************************//**
   1337           * @brief
   1338           *   Update the EMU module with Energy Mode 4 configuration.
   1339           *
   1340           * @param[in] em4Init
   1341           *    Energy Mode 4 configuration structure.
   1342           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1343          void EMU_EM4Init(const EMU_EM4Init_TypeDef *em4Init)
   1344          {
   1345          #if defined(_EMU_EM4CONF_MASK)
   1346            /* Initialization for platforms with EMU->EM4CONF register. */
   1347            uint32_t em4conf = EMU->EM4CONF;
   1348          
   1349            /* Clear fields that will be reconfigured. */
   1350            em4conf &= ~(_EMU_EM4CONF_LOCKCONF_MASK
   1351                         | _EMU_EM4CONF_OSC_MASK
   1352                         | _EMU_EM4CONF_BURTCWU_MASK
   1353                         | _EMU_EM4CONF_VREGEN_MASK
   1354                         | _EMU_EM4CONF_BUBODRSTDIS_MASK);
   1355          
   1356            /* Configure new settings. */
   1357            em4conf |= (em4Init->lockConfig << _EMU_EM4CONF_LOCKCONF_SHIFT)
   1358                       | (em4Init->osc)
   1359                       | (em4Init->buRtcWakeup << _EMU_EM4CONF_BURTCWU_SHIFT)
   1360                       | (em4Init->vreg << _EMU_EM4CONF_VREGEN_SHIFT)
   1361                       | (em4Init->buBodRstDis << _EMU_EM4CONF_BUBODRSTDIS_SHIFT);
   1362          
   1363            /* Apply configuration. Note that lock can be set after this stage. */
   1364            EMU->EM4CONF = em4conf;
   1365          
   1366          #elif defined(_EMU_EM4CTRL_EM4STATE_MASK)
   1367            /* Initialization for platforms with EMU->EM4CTRL register and EM4H and EM4S. */
   1368          
   1369            uint32_t em4ctrl = EMU->EM4CTRL;
   1370          
   1371            em4ctrl &= ~(_EMU_EM4CTRL_RETAINLFXO_MASK
   1372                         | _EMU_EM4CTRL_RETAINLFRCO_MASK
   1373                         | _EMU_EM4CTRL_RETAINULFRCO_MASK
   1374                         | _EMU_EM4CTRL_EM4STATE_MASK
   1375                         | _EMU_EM4CTRL_EM4IORETMODE_MASK);
   1376          
   1377            em4ctrl |= (em4Init->retainLfxo     ? EMU_EM4CTRL_RETAINLFXO : 0U)
   1378                       | (em4Init->retainLfrco  ? EMU_EM4CTRL_RETAINLFRCO : 0U)
   1379                       | (em4Init->retainUlfrco ? EMU_EM4CTRL_RETAINULFRCO : 0U)
   1380                       | (em4Init->em4State == emuEM4Hibernate
   1381                          ? EMU_EM4CTRL_EM4STATE_EM4H : 0U)
   1382                       | ((uint32_t)em4Init->pinRetentionMode);
   1383          
   1384            EMU->EM4CTRL = em4ctrl;
   1385          #elif defined(_EMU_EM4CTRL_MASK)
   1386            EMU->EM4CTRL = (EMU->EM4CTRL & ~_EMU_EM4CTRL_EM4IORETMODE_MASK)
   1387                           | (uint32_t)em4Init->pinRetentionMode;
   \                     EMU_EM4Init: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable5_4  ;; 0x4000406c
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0x7900             LDRB     R0,[R0, #+4]
   \        0x6   0xF022 0x0230      BIC      R2,R2,#0x30
   \        0xA   0x4302             ORRS     R2,R0,R2
   \        0xC   0x600A             STR      R2,[R1, #+0]
   1388          #endif
   1389          
   1390          #if defined(_EMU_CTRL_EM4HVSCALE_MASK)
   1391            EMU->CTRL = (EMU->CTRL & ~_EMU_CTRL_EM4HVSCALE_MASK)
   1392                        | ((uint32_t)em4Init->vScaleEM4HVoltage << _EMU_CTRL_EM4HVSCALE_SHIFT);
   1393          #endif
   1394          }
   \        0xE   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0xE000'ED10        DC32     0xe000ed10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x4000'4060        DC32     0x40004060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0x2001'8000        DC32     0x20018000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \        0x0   0x4007'C208        DC32     0x4007c208

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \        0x0   0x4000'406C        DC32     0x4000406c
   1395          #endif
   1396          
   1397          #if defined(BU_PRESENT) && defined(_SILICON_LABS_32B_SERIES_0)
   1398          /***************************************************************************//**
   1399           * @brief
   1400           *   Configure Backup Power Domain settings.
   1401           *
   1402           * @param[in] bupdInit
   1403           *   Backup power domain initialization structure.
   1404           ******************************************************************************/
   1405          void EMU_BUPDInit(const EMU_BUPDInit_TypeDef *bupdInit)
   1406          {
   1407            uint32_t reg;
   1408          
   1409            /* Set the power connection configuration. */
   1410            reg = EMU->PWRCONF & ~(_EMU_PWRCONF_PWRRES_MASK
   1411                                   | _EMU_PWRCONF_VOUTSTRONG_MASK
   1412                                   | _EMU_PWRCONF_VOUTMED_MASK
   1413                                   | _EMU_PWRCONF_VOUTWEAK_MASK);
   1414          
   1415            reg |= bupdInit->resistor
   1416                   | (bupdInit->voutStrong << _EMU_PWRCONF_VOUTSTRONG_SHIFT)
   1417                   | (bupdInit->voutMed    << _EMU_PWRCONF_VOUTMED_SHIFT)
   1418                   | (bupdInit->voutWeak   << _EMU_PWRCONF_VOUTWEAK_SHIFT);
   1419          
   1420            EMU->PWRCONF = reg;
   1421          
   1422            /* Set the backup domain inactive mode configuration. */
   1423            reg = EMU->BUINACT & ~(_EMU_BUINACT_PWRCON_MASK);
   1424            reg |= (bupdInit->inactivePower);
   1425            EMU->BUINACT = reg;
   1426          
   1427            /* Set the backup domain active mode configuration. */
   1428            reg = EMU->BUACT & ~(_EMU_BUACT_PWRCON_MASK);
   1429            reg |= (bupdInit->activePower);
   1430            EMU->BUACT = reg;
   1431          
   1432            /* Set the power control configuration */
   1433            reg = EMU->BUCTRL & ~(_EMU_BUCTRL_PROBE_MASK
   1434                                  | _EMU_BUCTRL_BODCAL_MASK
   1435                                  | _EMU_BUCTRL_STATEN_MASK
   1436                                  | _EMU_BUCTRL_EN_MASK);
   1437          
   1438            /* Note the use of ->enable to enable BUPD. Use BU_VIN pin input and
   1439               release reset. */
   1440            reg |= bupdInit->probe
   1441                   | (bupdInit->bodCal          << _EMU_BUCTRL_BODCAL_SHIFT)
   1442                   | (bupdInit->statusPinEnable << _EMU_BUCTRL_STATEN_SHIFT)
   1443                   | (bupdInit->enable          << _EMU_BUCTRL_EN_SHIFT);
   1444          
   1445            /* Enable configuration. */
   1446            EMU->BUCTRL = reg;
   1447          
   1448            /* If enable is true, enable BU_VIN input power pin. If not, disable it.  */
   1449            EMU_BUPinEnable(bupdInit->enable);
   1450          
   1451            /* If enable is true, release BU reset. If not, keep reset asserted. */
   1452            BUS_RegBitWrite(&(RMU->CTRL), _RMU_CTRL_BURSTEN_SHIFT, !bupdInit->enable);
   1453          }
   1454          
   1455          /***************************************************************************//**
   1456           * @brief
   1457           *   Configure the Backup Power Domain BOD Threshold value.
   1458           * @note
   1459           *   These values are precalibrated.
   1460           * @param[in] mode Active or Inactive mode
   1461           * @param[in] value
   1462           ******************************************************************************/
   1463          void EMU_BUThresholdSet(EMU_BODMode_TypeDef mode, uint32_t value)
   1464          {
   1465            EFM_ASSERT(value < 8);
   1466            EFM_ASSERT(value <= (_EMU_BUACT_BUEXTHRES_MASK >> _EMU_BUACT_BUEXTHRES_SHIFT));
   1467          
   1468            switch (mode) {
   1469              case emuBODMode_Active:
   1470                EMU->BUACT = (EMU->BUACT & ~_EMU_BUACT_BUEXTHRES_MASK)
   1471                             | (value << _EMU_BUACT_BUEXTHRES_SHIFT);
   1472                break;
   1473              case emuBODMode_Inactive:
   1474                EMU->BUINACT = (EMU->BUINACT & ~_EMU_BUINACT_BUENTHRES_MASK)
   1475                               | (value << _EMU_BUINACT_BUENTHRES_SHIFT);
   1476                break;
   1477            }
   1478          }
   1479          
   1480          /***************************************************************************//**
   1481           * @brief
   1482           *  Configure the Backup Power Domain BOD Threshold Range.
   1483           * @note
   1484           *  These values are precalibrated.
   1485           * @param[in] mode Active or Inactive mode
   1486           * @param[in] value
   1487           ******************************************************************************/
   1488          void EMU_BUThresRangeSet(EMU_BODMode_TypeDef mode, uint32_t value)
   1489          {
   1490            EFM_ASSERT(value < 4);
   1491            EFM_ASSERT(value <= (_EMU_BUACT_BUEXRANGE_MASK >> _EMU_BUACT_BUEXRANGE_SHIFT));
   1492          
   1493            switch (mode) {
   1494              case emuBODMode_Active:
   1495                EMU->BUACT = (EMU->BUACT & ~_EMU_BUACT_BUEXRANGE_MASK)
   1496                             | (value << _EMU_BUACT_BUEXRANGE_SHIFT);
   1497                break;
   1498              case emuBODMode_Inactive:
   1499                EMU->BUINACT = (EMU->BUINACT & ~_EMU_BUINACT_BUENRANGE_MASK)
   1500                               | (value << _EMU_BUINACT_BUENRANGE_SHIFT);
   1501                break;
   1502            }
   1503          }
   1504          #endif
   1505          
   1506          #if defined(BU_PRESENT) && defined(_SILICON_LABS_32B_SERIES_1)
   1507          /***************************************************************************//**
   1508           * @brief
   1509           *   Configure Backup Power Domain settings.
   1510           *
   1511           * @param[in] buInit
   1512           *   Backup power domain initialization structure.
   1513           ******************************************************************************/
   1514          void EMU_BUInit(const EMU_BUInit_TypeDef *buInit)
   1515          {
   1516            uint32_t reg = 0;
   1517          
   1518            /* Set the backup power configuration. */
   1519            reg |= (buInit->disMaxComp << _EMU_BUCTRL_DISMAXCOMP_SHIFT);
   1520            reg |= (uint32_t)(buInit->inactivePwrCon);
   1521            reg |= (uint32_t)(buInit->activePwrCon);
   1522            reg |= (uint32_t)(buInit->pwrRes);
   1523            reg |= (uint32_t)(buInit->voutRes);
   1524            reg |= (buInit->buVinProbeEn << _EMU_BUCTRL_BUVINPROBEEN_SHIFT);
   1525            reg |= (buInit->staEn << _EMU_BUCTRL_STATEN_SHIFT);
   1526            reg |= (buInit->enable << _EMU_BUCTRL_EN_SHIFT);
   1527            EMU->BUCTRL = reg;
   1528          }
   1529          #endif
   1530          
   1531          #if defined(_EMU_BUCTRL_DISMAXCOMP_MASK)
   1532          void EMU_BUDisMaxCompSet(bool disableMainBuComparator)
   1533          {
   1534            uint32_t reg;
   1535          
   1536            reg = EMU->BUCTRL & ~(_EMU_BUCTRL_DISMAXCOMP_MASK);
   1537            reg |= (disableMainBuComparator << _EMU_BUCTRL_DISMAXCOMP_SHIFT);
   1538            EMU->BUCTRL = reg;
   1539          }
   1540          #endif
   1541          
   1542          #if defined(_EMU_BUCTRL_BUINACTPWRCON_MASK)
   1543          void EMU_BUBuInactPwrConSet(EMU_BUBuInactPwrCon_TypeDef inactPwrCon)
   1544          {
   1545            uint32_t reg;
   1546          
   1547            reg = EMU->BUCTRL & ~(_EMU_BUCTRL_BUINACTPWRCON_MASK);
   1548            reg |= (uint32_t)(inactPwrCon);
   1549            EMU->BUCTRL = reg;
   1550          }
   1551          #endif
   1552          
   1553          #if defined(_EMU_BUCTRL_BUACTPWRCON_MASK)
   1554          void EMU_BUBuActPwrConSet(EMU_BUBuActPwrCon_TypeDef actPwrCon)
   1555          {
   1556            uint32_t reg;
   1557          
   1558            reg = EMU->BUCTRL & ~(_EMU_BUCTRL_BUACTPWRCON_MASK);
   1559            reg |= (uint32_t)(actPwrCon);
   1560            EMU->BUCTRL = reg;
   1561          }
   1562          #endif
   1563          
   1564          #if defined(_EMU_BUCTRL_PWRRES_MASK)
   1565          void EMU_BUPwrResSet(EMU_BUPwrRes_TypeDef pwrRes)
   1566          {
   1567            uint32_t reg;
   1568          
   1569            reg = EMU->BUCTRL & ~(_EMU_BUCTRL_PWRRES_MASK);
   1570            reg |= (uint32_t)(pwrRes);
   1571            EMU->BUCTRL = reg;
   1572          }
   1573          #endif
   1574          
   1575          #if defined(_EMU_BUCTRL_VOUTRES_MASK)
   1576          void EMU_BUVoutResSet(EMU_BUVoutRes_TypeDef resistorSel)
   1577          {
   1578            uint32_t reg;
   1579          
   1580            reg = EMU->BUCTRL & ~(_EMU_BUCTRL_VOUTRES_MASK);
   1581            reg |= (uint32_t)(resistorSel);
   1582            EMU->BUCTRL = reg;
   1583          }
   1584          #endif
   1585          
   1586          #if defined(_EMU_BUCTRL_BUVINPROBEEN_MASK)
   1587          void EMU_BUBuVinProbeEnSet(bool enable)
   1588          {
   1589            uint32_t reg;
   1590          
   1591            reg = EMU->BUCTRL & ~(_EMU_BUCTRL_BUVINPROBEEN_MASK);
   1592            reg |= (enable << _EMU_BUCTRL_BUVINPROBEEN_SHIFT);
   1593            EMU->BUCTRL = reg;
   1594          }
   1595          #endif
   1596          
   1597          #if defined(_EMU_BUCTRL_STATEN_MASK)
   1598          void EMU_BUStatEnSet(bool enable)
   1599          {
   1600            uint32_t reg;
   1601          
   1602            reg = EMU->BUCTRL & ~(_EMU_BUCTRL_STATEN_MASK);
   1603            reg |= (enable << _EMU_BUCTRL_STATEN_SHIFT);
   1604            EMU->BUCTRL = reg;
   1605          }
   1606          #endif
   1607          
   1608          #if defined(_EMU_BUCTRL_EN_MASK)
   1609          void EMU_BUEnableSet(bool enable)
   1610          {
   1611            uint32_t reg;
   1612          
   1613            reg = EMU->BUCTRL & ~(_EMU_BUCTRL_EN_MASK);
   1614            reg |= (enable << _EMU_BUCTRL_EN_SHIFT);
   1615            EMU->BUCTRL = reg;
   1616          }
   1617          #endif
   1618          
   1619          /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
   1620          #if defined(_EMU_DCDCCTRL_MASK)
   1621          /* Translate fields with different names across platform generations to common names. */
   1622          #if defined(_EMU_DCDCMISCCTRL_LPCMPBIAS_MASK)
   1623          #define _GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_MASK      _EMU_DCDCMISCCTRL_LPCMPBIAS_MASK
   1624          #define _GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_SHIFT     _EMU_DCDCMISCCTRL_LPCMPBIAS_SHIFT
   1625          #elif defined(_EMU_DCDCMISCCTRL_LPCMPBIASEM234H_MASK)
   1626          #define _GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_MASK      _EMU_DCDCMISCCTRL_LPCMPBIASEM234H_MASK
   1627          #define _GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_SHIFT     _EMU_DCDCMISCCTRL_LPCMPBIASEM234H_SHIFT
   1628          #endif
   1629          #if defined(_EMU_DCDCLPCTRL_LPCMPHYSSEL_MASK)
   1630          #define _GENERIC_DCDCLPCTRL_LPCMPHYSSELEM234H_MASK      _EMU_DCDCLPCTRL_LPCMPHYSSEL_MASK
   1631          #define _GENERIC_DCDCLPCTRL_LPCMPHYSSELEM234H_SHIFT     _EMU_DCDCLPCTRL_LPCMPHYSSEL_SHIFT
   1632          #elif defined(_EMU_DCDCLPCTRL_LPCMPHYSSELEM234H_MASK)
   1633          #define _GENERIC_DCDCLPCTRL_LPCMPHYSSELEM234H_MASK      _EMU_DCDCLPCTRL_LPCMPHYSSELEM234H_MASK
   1634          #define _GENERIC_DCDCLPCTRL_LPCMPHYSSELEM234H_SHIFT     _EMU_DCDCLPCTRL_LPCMPHYSSELEM234H_SHIFT
   1635          #endif
   1636          
   1637          /* Internal DCDC trim modes. */
   1638          typedef enum {
   1639            dcdcTrimMode_EM234H_LP = 0,
   1640          #if defined(_EMU_DCDCLPEM01CFG_LPCMPBIASEM01_MASK)
   1641            dcdcTrimMode_EM01_LP,
   1642          #endif
   1643            dcdcTrimMode_LN,
   1644          } dcdcTrimMode_TypeDef;
   1645          
   1646          /***************************************************************************//**
   1647           * @brief
   1648           *   Load DCDC calibration constants from the DI page. A constant means that calibration
   1649           *   data that does not change depending on other configuration parameters.
   1650           *
   1651           * @return
   1652           *   False if calibration registers are locked.
   1653           ******************************************************************************/
   1654          static bool dcdcConstCalibrationLoad(void)
   1655          {
   1656          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
   1657            uint32_t val;
   1658            volatile uint32_t *reg;
   1659          
   1660            /* DI calibration data in Flash. */
   1661            volatile uint32_t* const diCal_EMU_DCDCLNFREQCTRL =  (volatile uint32_t *)(0x0FE08038);
   1662            volatile uint32_t* const diCal_EMU_DCDCLNVCTRL =     (volatile uint32_t *)(0x0FE08040);
   1663            volatile uint32_t* const diCal_EMU_DCDCLPCTRL =      (volatile uint32_t *)(0x0FE08048);
   1664            volatile uint32_t* const diCal_EMU_DCDCLPVCTRL =     (volatile uint32_t *)(0x0FE08050);
   1665            volatile uint32_t* const diCal_EMU_DCDCTRIM0 =       (volatile uint32_t *)(0x0FE08058);
   1666            volatile uint32_t* const diCal_EMU_DCDCTRIM1 =       (volatile uint32_t *)(0x0FE08060);
   1667          
   1668            if (DEVINFO->DCDCLPVCTRL0 != UINT_MAX) {
   1669              val = *(diCal_EMU_DCDCLNFREQCTRL + 1);
   1670              reg = (volatile uint32_t *)*diCal_EMU_DCDCLNFREQCTRL;
   1671              *reg = val;
   1672          
   1673              val = *(diCal_EMU_DCDCLNVCTRL + 1);
   1674              reg = (volatile uint32_t *)*diCal_EMU_DCDCLNVCTRL;
   1675              *reg = val;
   1676          
   1677              val = *(diCal_EMU_DCDCLPCTRL + 1);
   1678              reg = (volatile uint32_t *)*diCal_EMU_DCDCLPCTRL;
   1679              *reg = val;
   1680          
   1681              val = *(diCal_EMU_DCDCLPVCTRL + 1);
   1682              reg = (volatile uint32_t *)*diCal_EMU_DCDCLPVCTRL;
   1683              *reg = val;
   1684          
   1685              val = *(diCal_EMU_DCDCTRIM0 + 1);
   1686              reg = (volatile uint32_t *)*diCal_EMU_DCDCTRIM0;
   1687              *reg = val;
   1688          
   1689              val = *(diCal_EMU_DCDCTRIM1 + 1);
   1690              reg = (volatile uint32_t *)*diCal_EMU_DCDCTRIM1;
   1691              *reg = val;
   1692          
   1693              return true;
   1694            }
   1695            EFM_ASSERT(false);
   1696            /* Return when assertions are disabled. */
   1697            return false;
   1698          
   1699          #else
   1700            return true;
   1701          #endif
   1702          }
   1703          
   1704          /***************************************************************************//**
   1705           * @brief
   1706           *   Set recommended and validated current optimization and timing settings.
   1707           *
   1708           ******************************************************************************/
   1709          static void dcdcValidatedConfigSet(void)
   1710          {
   1711          /* Disable LP mode hysteresis in the state machine control. */
   1712          #define EMU_DCDCMISCCTRL_LPCMPHYSDIS (0x1UL << 1)
   1713          /* Comparator threshold on the high side. */
   1714          #define EMU_DCDCMISCCTRL_LPCMPHYSHI  (0x1UL << 2)
   1715          #define EMU_DCDCSMCTRL  (*(volatile uint32_t *)(EMU_BASE + 0x44))
   1716          
   1717            uint32_t lnForceCcm;
   1718          
   1719          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
   1720            uint32_t dcdcTiming;
   1721            SYSTEM_ChipRevision_TypeDef rev;
   1722          #endif
   1723          
   1724            /* Enable duty cycling of the bias. */
   1725            EMU->DCDCLPCTRL |= EMU_DCDCLPCTRL_LPVREFDUTYEN;
   1726          
   1727            /* Set low-noise RCO for LNFORCECCM configuration.
   1728             * LNFORCECCM is default 1 for EFR32
   1729             * LNFORCECCM is default 0 for EFM32
   1730             */
   1731            lnForceCcm = BUS_RegBitRead(&EMU->DCDCMISCCTRL, _EMU_DCDCMISCCTRL_LNFORCECCM_SHIFT);
   1732            if (lnForceCcm != 0U) {
   1733              /* 7 MHz is recommended for LNFORCECCM = 1. */
   1734              EMU_DCDCLnRcoBandSet(emuDcdcLnRcoBand_7MHz);
   1735            } else {
   1736              /* 3 MHz is recommended for LNFORCECCM = 0. */
   1737              EMU_DCDCLnRcoBandSet(emuDcdcLnRcoBand_3MHz);
   1738            }
   1739          
   1740          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
   1741            EMU->DCDCTIMING &= ~_EMU_DCDCTIMING_DUTYSCALE_MASK;
   1742            EMU->DCDCMISCCTRL |= EMU_DCDCMISCCTRL_LPCMPHYSDIS
   1743                                 | EMU_DCDCMISCCTRL_LPCMPHYSHI;
   1744          
   1745            SYSTEM_ChipRevisionGet(&rev);
   1746            if ((rev.major == 1)
   1747                && (rev.minor < 3)
   1748                && (errataFixDcdcHsState == errataFixDcdcHsInit)) {
   1749              /* LPCMPWAITDIS = 1 */
   1750              EMU_DCDCSMCTRL |= 1;
   1751          
   1752              dcdcTiming = EMU->DCDCTIMING;
   1753              dcdcTiming &= ~(_EMU_DCDCTIMING_LPINITWAIT_MASK
   1754                              | _EMU_DCDCTIMING_LNWAIT_MASK
   1755                              | _EMU_DCDCTIMING_BYPWAIT_MASK);
   1756          
   1757              dcdcTiming |= ((180 << _EMU_DCDCTIMING_LPINITWAIT_SHIFT)
   1758                             | (12 << _EMU_DCDCTIMING_LNWAIT_SHIFT)
   1759                             | (180 << _EMU_DCDCTIMING_BYPWAIT_SHIFT));
   1760              EMU->DCDCTIMING = dcdcTiming;
   1761          
   1762              errataFixDcdcHsState = errataFixDcdcHsTrimSet;
   1763            }
   1764          #endif
   1765          }
   1766          
   1767          /***************************************************************************//**
   1768           * @brief
   1769           *   Compute current limiters:
   1770           *     LNCLIMILIMSEL: LN current limiter threshold
   1771           *     LPCLIMILIMSEL: LP current limiter threshold
   1772           *     DCDCZDETCTRL:  zero detector limiter threshold
   1773           ******************************************************************************/
   1774          static void currentLimitersUpdate(void)
   1775          {
   1776            uint32_t lncLimSel;
   1777            uint32_t zdetLimSel;
   1778            uint32_t pFetCnt;
   1779            uint16_t maxReverseCurrent_mA;
   1780          
   1781            /* 80 mA as recommended peak in Application Note AN0948.
   1782               The peak current is the average current plus 50% of the current ripple.
   1783               Hence, a 14 mA average current is recommended in LP mode. Since LP PFETCNT is also
   1784               a constant, lpcLimImSel = 1. The following calculation is provided
   1785               for documentation only. */
   1786            const uint32_t lpcLim = (((14 + 40) + ((14 + 40) / 2))
   1787                                     / (5 * (DCDC_LP_PFET_CNT + 1)))
   1788                                    - 1;
   1789            const uint32_t lpcLimSel = lpcLim << _EMU_DCDCMISCCTRL_LPCLIMILIMSEL_SHIFT;
   1790          
   1791            /* Get enabled PFETs. */
   1792            pFetCnt = (EMU->DCDCMISCCTRL & _EMU_DCDCMISCCTRL_PFETCNT_MASK)
   1793                      >> _EMU_DCDCMISCCTRL_PFETCNT_SHIFT;
   1794          
   1795            /* Compute the LN current limiter threshold from the nominal user input current and
   1796               LN PFETCNT as described in the register description for
   1797               EMU_DCDCMISCCTRL_LNCLIMILIMSEL. */
   1798            lncLimSel = ((((uint32_t)dcdcMaxCurrent_mA + 40U)
   1799                          + (((uint32_t)dcdcMaxCurrent_mA + 40U) / 2U))
   1800                         / (5U * (pFetCnt + 1U)))
   1801                        - 1U;
   1802          
   1803            /* Saturate the register field value. */
   1804            lncLimSel = SL_MIN(lncLimSel,
   1805                               _EMU_DCDCMISCCTRL_LNCLIMILIMSEL_MASK
   1806                               >> _EMU_DCDCMISCCTRL_LNCLIMILIMSEL_SHIFT);
   1807          
   1808            lncLimSel <<= _EMU_DCDCMISCCTRL_LNCLIMILIMSEL_SHIFT;
   1809          
   1810            /* Check for overflow. */
   1811            EFM_ASSERT((lncLimSel & ~_EMU_DCDCMISCCTRL_LNCLIMILIMSEL_MASK) == 0x0U);
   1812            EFM_ASSERT((lpcLimSel & ~_EMU_DCDCMISCCTRL_LPCLIMILIMSEL_MASK) == 0x0U);
   1813          
   1814            EMU->DCDCMISCCTRL = (EMU->DCDCMISCCTRL & ~(_EMU_DCDCMISCCTRL_LNCLIMILIMSEL_MASK
   1815                                                       | _EMU_DCDCMISCCTRL_LPCLIMILIMSEL_MASK))
   1816                                | (lncLimSel | lpcLimSel);
   1817          
   1818            /* Compute the reverse current limit threshold for the zero detector from the user input
   1819               maximum reverse current and LN PFETCNT as described in the register description
   1820               for EMU_DCDCZDETCTRL_ZDETILIMSEL. */
   1821            if (dcdcReverseCurrentControl >= 0) {
   1822              /* If dcdcReverseCurrentControl < 0, EMU_DCDCZDETCTRL_ZDETILIMSEL is "don't care". */
   1823              maxReverseCurrent_mA = (uint16_t)dcdcReverseCurrentControl;
   1824          
   1825              zdetLimSel = ((((uint32_t)maxReverseCurrent_mA + 40U)
   1826                             + (((uint32_t)maxReverseCurrent_mA + 40U) / 2U))
   1827                            / ((2U * (pFetCnt + 1U)) + ((pFetCnt + 1U) / 2U)));
   1828              /* Saturate the register field value. */
   1829              zdetLimSel = SL_MIN(zdetLimSel,
   1830                                  _EMU_DCDCZDETCTRL_ZDETILIMSEL_MASK
   1831                                  >> _EMU_DCDCZDETCTRL_ZDETILIMSEL_SHIFT);
   1832          
   1833              zdetLimSel <<= _EMU_DCDCZDETCTRL_ZDETILIMSEL_SHIFT;
   1834          
   1835              /* Check for overflow. */
   1836              EFM_ASSERT((zdetLimSel & ~_EMU_DCDCZDETCTRL_ZDETILIMSEL_MASK) == 0x0U);
   1837          
   1838              EMU->DCDCZDETCTRL = (EMU->DCDCZDETCTRL & ~_EMU_DCDCZDETCTRL_ZDETILIMSEL_MASK)
   1839                                  | zdetLimSel;
   1840            }
   1841          }
   1842          
   1843          /***************************************************************************//**
   1844           * @brief
   1845           *   Set static variables that hold the user set maximum peak current
   1846           *   and reverse current. Update limiters.
   1847           *
   1848           * @param[in] maxCurrent_mA
   1849           *   Set the maximum peak current that the DCDC can draw from the power source.
   1850           * @param[in] reverseCurrentControl
   1851           *   Reverse the current control as defined by
   1852           *   @ref EMU_DcdcLnReverseCurrentControl_TypeDef. Positive values have unit mA.
   1853           ******************************************************************************/
   1854          static void userCurrentLimitsSet(uint32_t maxCurrent_mA,
   1855                                           EMU_DcdcLnReverseCurrentControl_TypeDef reverseCurrentControl)
   1856          {
   1857            dcdcMaxCurrent_mA = (uint16_t)maxCurrent_mA;
   1858            dcdcReverseCurrentControl = reverseCurrentControl;
   1859          }
   1860          
   1861          /***************************************************************************//**
   1862           * @brief
   1863           *   Set DCDC low noise compensator control register.
   1864           *
   1865           * @param[in] comp
   1866           *   Low-noise mode compensator trim setpoint.
   1867           ******************************************************************************/
   1868          static void compCtrlSet(EMU_DcdcLnCompCtrl_TypeDef comp)
   1869          {
   1870            switch (comp) {
   1871              case emuDcdcLnCompCtrl_1u0F:
   1872                EMU->DCDCLNCOMPCTRL = 0x57204077UL;
   1873                break;
   1874          
   1875              case emuDcdcLnCompCtrl_4u7F:
   1876                EMU->DCDCLNCOMPCTRL = 0xB7102137UL;
   1877                break;
   1878          
   1879              default:
   1880                EFM_ASSERT(false);
   1881                break;
   1882            }
   1883          }
   1884          
   1885          /***************************************************************************//**
   1886           * @brief
   1887           *   Load EMU_DCDCLPCTRL_LPCMPHYSSEL depending on LP bias, LP feedback
   1888           *   attenuation, and DEVINFOREV.
   1889           *
   1890           * @param[in] lpAttenuation
   1891           *   LP feedback attenuation.
   1892           * @param[in] lpCmpBias
   1893           *   lpCmpBias selection.
   1894           * @param[in] trimMode
   1895           *   DCDC trim mode.
   1896           ******************************************************************************/
   1897          static bool lpCmpHystCalibrationLoad(bool lpAttenuation,
   1898                                               uint8_t lpCmpBias,
   1899                                               dcdcTrimMode_TypeDef trimMode)
   1900          {
   1901            uint32_t lpcmpHystSel;
   1902          #if !defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
   1903            (void)lpAttenuation;
   1904          #endif
   1905          
   1906            /* Get calibration data revision. */
   1907          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
   1908            uint8_t devinfoRev = SYSTEM_GetDevinfoRev();
   1909          
   1910            /* Load LPATT indexed calibration data. */
   1911            if (devinfoRev < 4) {
   1912              lpcmpHystSel = DEVINFO->DCDCLPCMPHYSSEL0;
   1913          
   1914              if (lpAttenuation) {
   1915                lpcmpHystSel = (lpcmpHystSel & _DEVINFO_DCDCLPCMPHYSSEL0_LPCMPHYSSELLPATT1_MASK)
   1916                               >> _DEVINFO_DCDCLPCMPHYSSEL0_LPCMPHYSSELLPATT1_SHIFT;
   1917              } else {
   1918                lpcmpHystSel = (lpcmpHystSel & _DEVINFO_DCDCLPCMPHYSSEL0_LPCMPHYSSELLPATT0_MASK)
   1919                               >> _DEVINFO_DCDCLPCMPHYSSEL0_LPCMPHYSSELLPATT0_SHIFT;
   1920              }
   1921            } else
   1922          #endif
   1923            {
   1924              /* devinfoRev >= 4: load LPCMPBIAS indexed calibration data. */
   1925              lpcmpHystSel = DEVINFO->DCDCLPCMPHYSSEL1;
   1926              switch (lpCmpBias) {
   1927                case 0:
   1928                  lpcmpHystSel = (lpcmpHystSel & _DEVINFO_DCDCLPCMPHYSSEL1_LPCMPHYSSELLPCMPBIAS0_MASK)
   1929                                 >> _DEVINFO_DCDCLPCMPHYSSEL1_LPCMPHYSSELLPCMPBIAS0_SHIFT;
   1930                  break;
   1931          
   1932                case 1:
   1933                  lpcmpHystSel = (lpcmpHystSel & _DEVINFO_DCDCLPCMPHYSSEL1_LPCMPHYSSELLPCMPBIAS1_MASK)
   1934                                 >> _DEVINFO_DCDCLPCMPHYSSEL1_LPCMPHYSSELLPCMPBIAS1_SHIFT;
   1935                  break;
   1936          
   1937                case 2:
   1938                  lpcmpHystSel = (lpcmpHystSel & _DEVINFO_DCDCLPCMPHYSSEL1_LPCMPHYSSELLPCMPBIAS2_MASK)
   1939                                 >> _DEVINFO_DCDCLPCMPHYSSEL1_LPCMPHYSSELLPCMPBIAS2_SHIFT;
   1940                  break;
   1941          
   1942                case 3:
   1943                  lpcmpHystSel = (lpcmpHystSel & _DEVINFO_DCDCLPCMPHYSSEL1_LPCMPHYSSELLPCMPBIAS3_MASK)
   1944                                 >> _DEVINFO_DCDCLPCMPHYSSEL1_LPCMPHYSSELLPCMPBIAS3_SHIFT;
   1945                  break;
   1946          
   1947                default:
   1948                  EFM_ASSERT(false);
   1949                  /* Return when assertions are disabled. */
   1950                  return false;
   1951              }
   1952            }
   1953          
   1954            /* Set trims. */
   1955            if (trimMode == dcdcTrimMode_EM234H_LP) {
   1956              /* Make sure the sel value is within the field range. */
   1957              lpcmpHystSel <<= _GENERIC_DCDCLPCTRL_LPCMPHYSSELEM234H_SHIFT;
   1958              if ((lpcmpHystSel & ~_GENERIC_DCDCLPCTRL_LPCMPHYSSELEM234H_MASK) != 0U) {
   1959                EFM_ASSERT(false);
   1960                /* Return when assertions are disabled. */
   1961                return false;
   1962              }
   1963              EMU->DCDCLPCTRL = (EMU->DCDCLPCTRL & ~_GENERIC_DCDCLPCTRL_LPCMPHYSSELEM234H_MASK) | lpcmpHystSel;
   1964            }
   1965          
   1966          #if defined(_EMU_DCDCLPEM01CFG_LPCMPHYSSELEM01_MASK)
   1967            if (trimMode == dcdcTrimMode_EM01_LP) {
   1968              /* Make sure the sel value is within the field range. */
   1969              lpcmpHystSel <<= _EMU_DCDCLPEM01CFG_LPCMPHYSSELEM01_SHIFT;
   1970              if ((lpcmpHystSel & ~_EMU_DCDCLPEM01CFG_LPCMPHYSSELEM01_MASK) != 0U) {
   1971                EFM_ASSERT(false);
   1972                /* Return when assertions are disabled. */
   1973                return false;
   1974              }
   1975              EMU->DCDCLPEM01CFG = (EMU->DCDCLPEM01CFG & ~_EMU_DCDCLPEM01CFG_LPCMPHYSSELEM01_MASK) | lpcmpHystSel;
   1976            }
   1977          #endif
   1978          
   1979            return true;
   1980          }
   1981          
   1982          /***************************************************************************//**
   1983           * @brief
   1984           *   Load LPVREF low and high from DEVINFO.
   1985           *
   1986           * @param[out] vrefL
   1987           *   LPVREF low from DEVINFO.
   1988           * @param[out] vrefH
   1989           *   LPVREF high from DEVINFO.
   1990           * @param[in] lpAttenuation
   1991           *   LP feedback attenuation.
   1992           * @param[in] lpcmpBias
   1993           *   lpcmpBias to look up in DEVINFO.
   1994           ******************************************************************************/
   1995          static void lpGetDevinfoVrefLowHigh(uint32_t *vrefL,
   1996                                              uint32_t *vrefH,
   1997                                              bool lpAttenuation,
   1998                                              uint8_t lpcmpBias)
   1999          {
   2000            uint32_t vrefLow = 0;
   2001            uint32_t vrefHigh = 0;
   2002          
   2003            /* Find VREF high and low in DEVINFO indexed by LPCMPBIAS (lpcmpBias)
   2004               and LPATT (lpAttenuation) */
   2005            uint32_t switchVal = ((uint32_t)lpcmpBias << 8) | (lpAttenuation ? 1U : 0U);
   2006            switch (switchVal) {
   2007              case ((0 << 8) | 1):
   2008                vrefLow  = DEVINFO->DCDCLPVCTRL2;
   2009                vrefHigh = (vrefLow & _DEVINFO_DCDCLPVCTRL2_3V0LPATT1LPCMPBIAS0_MASK)
   2010                           >> _DEVINFO_DCDCLPVCTRL2_3V0LPATT1LPCMPBIAS0_SHIFT;
   2011                vrefLow  = (vrefLow & _DEVINFO_DCDCLPVCTRL2_1V8LPATT1LPCMPBIAS0_MASK)
   2012                           >> _DEVINFO_DCDCLPVCTRL2_1V8LPATT1LPCMPBIAS0_SHIFT;
   2013                break;
   2014          
   2015              case ((1 << 8) | 1):
   2016                vrefLow  = DEVINFO->DCDCLPVCTRL2;
   2017                vrefHigh = (vrefLow & _DEVINFO_DCDCLPVCTRL2_3V0LPATT1LPCMPBIAS1_MASK)
   2018                           >> _DEVINFO_DCDCLPVCTRL2_3V0LPATT1LPCMPBIAS1_SHIFT;
   2019                vrefLow  = (vrefLow & _DEVINFO_DCDCLPVCTRL2_1V8LPATT1LPCMPBIAS1_MASK)
   2020                           >> _DEVINFO_DCDCLPVCTRL2_1V8LPATT1LPCMPBIAS1_SHIFT;
   2021                break;
   2022          
   2023              case ((2 << 8) | 1):
   2024                vrefLow  = DEVINFO->DCDCLPVCTRL3;
   2025                vrefHigh = (vrefLow & _DEVINFO_DCDCLPVCTRL3_3V0LPATT1LPCMPBIAS2_MASK)
   2026                           >> _DEVINFO_DCDCLPVCTRL3_3V0LPATT1LPCMPBIAS2_SHIFT;
   2027                vrefLow  = (vrefLow & _DEVINFO_DCDCLPVCTRL3_1V8LPATT1LPCMPBIAS2_MASK)
   2028                           >> _DEVINFO_DCDCLPVCTRL3_1V8LPATT1LPCMPBIAS2_SHIFT;
   2029                break;
   2030          
   2031              case ((3 << 8) | 1):
   2032                vrefLow  = DEVINFO->DCDCLPVCTRL3;
   2033                vrefHigh = (vrefLow & _DEVINFO_DCDCLPVCTRL3_3V0LPATT1LPCMPBIAS3_MASK)
   2034                           >> _DEVINFO_DCDCLPVCTRL3_3V0LPATT1LPCMPBIAS3_SHIFT;
   2035                vrefLow  = (vrefLow & _DEVINFO_DCDCLPVCTRL3_1V8LPATT1LPCMPBIAS3_MASK)
   2036                           >> _DEVINFO_DCDCLPVCTRL3_1V8LPATT1LPCMPBIAS3_SHIFT;
   2037                break;
   2038          
   2039              case ((0 << 8) | 0):
   2040                vrefLow  = DEVINFO->DCDCLPVCTRL0;
   2041                vrefHigh = (vrefLow & _DEVINFO_DCDCLPVCTRL0_1V8LPATT0LPCMPBIAS0_MASK)
   2042                           >> _DEVINFO_DCDCLPVCTRL0_1V8LPATT0LPCMPBIAS0_SHIFT;
   2043                vrefLow  = (vrefLow & _DEVINFO_DCDCLPVCTRL0_1V2LPATT0LPCMPBIAS0_MASK)
   2044                           >> _DEVINFO_DCDCLPVCTRL0_1V2LPATT0LPCMPBIAS0_SHIFT;
   2045                break;
   2046          
   2047              case ((1 << 8) | 0):
   2048                vrefLow  = DEVINFO->DCDCLPVCTRL0;
   2049                vrefHigh = (vrefLow & _DEVINFO_DCDCLPVCTRL0_1V8LPATT0LPCMPBIAS1_MASK)
   2050                           >> _DEVINFO_DCDCLPVCTRL0_1V8LPATT0LPCMPBIAS1_SHIFT;
   2051                vrefLow  = (vrefLow & _DEVINFO_DCDCLPVCTRL0_1V2LPATT0LPCMPBIAS1_MASK)
   2052                           >> _DEVINFO_DCDCLPVCTRL0_1V2LPATT0LPCMPBIAS1_SHIFT;
   2053                break;
   2054          
   2055              case ((2 << 8) | 0):
   2056                vrefLow  = DEVINFO->DCDCLPVCTRL1;
   2057                vrefHigh = (vrefLow & _DEVINFO_DCDCLPVCTRL1_1V8LPATT0LPCMPBIAS2_MASK)
   2058                           >> _DEVINFO_DCDCLPVCTRL1_1V8LPATT0LPCMPBIAS2_SHIFT;
   2059                vrefLow  = (vrefLow & _DEVINFO_DCDCLPVCTRL1_1V2LPATT0LPCMPBIAS2_MASK)
   2060                           >> _DEVINFO_DCDCLPVCTRL1_1V2LPATT0LPCMPBIAS2_SHIFT;
   2061                break;
   2062          
   2063              case ((3 << 8) | 0):
   2064                vrefLow  = DEVINFO->DCDCLPVCTRL1;
   2065                vrefHigh = (vrefLow & _DEVINFO_DCDCLPVCTRL1_1V8LPATT0LPCMPBIAS3_MASK)
   2066                           >> _DEVINFO_DCDCLPVCTRL1_1V8LPATT0LPCMPBIAS3_SHIFT;
   2067                vrefLow  = (vrefLow & _DEVINFO_DCDCLPVCTRL1_1V2LPATT0LPCMPBIAS3_MASK)
   2068                           >> _DEVINFO_DCDCLPVCTRL1_1V2LPATT0LPCMPBIAS3_SHIFT;
   2069                break;
   2070          
   2071              default:
   2072                EFM_ASSERT(false);
   2073                break;
   2074            }
   2075            *vrefL = vrefLow;
   2076            *vrefH = vrefHigh;
   2077          }
   2078          
   2079          /***************************************************************************//**
   2080           * @brief
   2081           *   Set DCDC regulator operating mode.
   2082           *
   2083           * @param[in] dcdcMode
   2084           *   DCDC mode.
   2085           ******************************************************************************/
   2086          void EMU_DCDCModeSet(EMU_DcdcMode_TypeDef dcdcMode)
   2087          {
   2088            bool dcdcLocked;
   2089            uint32_t currentDcdcMode;
   2090          
   2091            dcdcLocked = (EMU->PWRLOCK == EMU_PWRLOCK_LOCKKEY_LOCKED);
   2092            EMU_PowerUnlock();
   2093          
   2094            /* Wait for any previous write sync to complete and read DCDC mode. */
   2095            while ((EMU->DCDCSYNC & EMU_DCDCSYNC_DCDCCTRLBUSY) != 0U) {
   2096            }
   2097            currentDcdcMode = (EMU->DCDCCTRL & _EMU_DCDCCTRL_DCDCMODE_MASK);
   2098          
   2099            /* Enable bypass current limiter when not in bypass mode to prevent
   2100               excessive current between VREGVDD and DVDD supplies when reentering bypass mode.  */
   2101            if (currentDcdcMode != EMU_DCDCCTRL_DCDCMODE_BYPASS) {
   2102              BUS_RegBitWrite(&EMU->DCDCCLIMCTRL, _EMU_DCDCCLIMCTRL_BYPLIMEN_SHIFT, 1);
   2103            }
   2104          
   2105            if ((EMU_DcdcMode_TypeDef)currentDcdcMode == dcdcMode) {
   2106              /* Mode already set. If already in bypass, make sure the bypass current limiter
   2107                 is disabled. */
   2108              if (dcdcMode == emuDcdcMode_Bypass) {
   2109                BUS_RegBitWrite(&EMU->DCDCCLIMCTRL, _EMU_DCDCCLIMCTRL_BYPLIMEN_SHIFT, 0);
   2110              }
   2111              return;
   2112            }
   2113          
   2114          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
   2115          
   2116            /* Fix for errata DCDC_E203. */
   2117            if ((currentDcdcMode == EMU_DCDCCTRL_DCDCMODE_BYPASS)
   2118                && (dcdcMode == emuDcdcMode_LowNoise)) {
   2119              errataFixDcdcHsState = errataFixDcdcHsBypassLn;
   2120            }
   2121          
   2122          #else
   2123          
   2124            /* Fix for errata DCDC_E204. */
   2125            if (((currentDcdcMode == EMU_DCDCCTRL_DCDCMODE_OFF) || (currentDcdcMode == EMU_DCDCCTRL_DCDCMODE_BYPASS))
   2126                && ((dcdcMode == emuDcdcMode_LowPower) || (dcdcMode == emuDcdcMode_LowNoise))) {
   2127              /* Always start in LOWNOISE. Switch to LOWPOWER mode once LOWNOISE startup is complete. */
   2128              EMU_IntClear(EMU_IFC_DCDCLNRUNNING);
   2129              while ((EMU->DCDCSYNC & EMU_DCDCSYNC_DCDCCTRLBUSY) != 0U) {
   2130              }
   2131              EMU->DCDCCTRL = (EMU->DCDCCTRL & ~_EMU_DCDCCTRL_DCDCMODE_MASK) | EMU_DCDCCTRL_DCDCMODE_LOWNOISE;
   2132              while ((EMU_IntGet() & EMU_IF_DCDCLNRUNNING) == 0U) {
   2133              }
   2134            }
   2135          #endif
   2136          
   2137            /* Set user-requested mode. */
   2138            while ((EMU->DCDCSYNC & EMU_DCDCSYNC_DCDCCTRLBUSY) != 0UL) {
   2139            }
   2140            EMU->DCDCCTRL = (EMU->DCDCCTRL & ~_EMU_DCDCCTRL_DCDCMODE_MASK)
   2141                            | (uint32_t)dcdcMode;
   2142          
   2143            /* Disable bypass current limiter after bypass mode is entered.
   2144               Enable the limiter if any other mode is entered. */
   2145            while ((EMU->DCDCSYNC & EMU_DCDCSYNC_DCDCCTRLBUSY) != 0U) {
   2146            }
   2147            BUS_RegBitWrite(&EMU->DCDCCLIMCTRL,
   2148                            _EMU_DCDCCLIMCTRL_BYPLIMEN_SHIFT,
   2149                            dcdcMode == emuDcdcMode_Bypass ? 0U : 1U);
   2150          
   2151            if (dcdcLocked) {
   2152              EMU_PowerLock();
   2153            }
   2154          }
   2155          
   2156          /***************************************************************************//**
   2157           * @brief
   2158           *   Set DCDC LN regulator conduction mode.
   2159           *
   2160           * @param[in] conductionMode
   2161           *   DCDC LN conduction mode.
   2162           * @param[in] rcoDefaultSet
   2163           *   The default DCDC RCO band for the conductionMode will be used if true.
   2164           *   Otherwise, the current RCO configuration is used.
   2165           ******************************************************************************/
   2166          void EMU_DCDCConductionModeSet(EMU_DcdcConductionMode_TypeDef conductionMode,
   2167                                         bool rcoDefaultSet)
   2168          {
   2169            EMU_DcdcMode_TypeDef currentDcdcMode
   2170              = (EMU_DcdcMode_TypeDef)((uint32_t)
   2171                                       (EMU->DCDCCTRL & _EMU_DCDCCTRL_DCDCMODE_MASK));
   2172            EMU_DcdcLnRcoBand_TypeDef rcoBand
   2173              = (EMU_DcdcLnRcoBand_TypeDef)((uint32_t)
   2174                                            ((EMU->DCDCLNFREQCTRL
   2175                                              & _EMU_DCDCLNFREQCTRL_RCOBAND_MASK)
   2176                                             >> _EMU_DCDCLNFREQCTRL_RCOBAND_SHIFT));
   2177          
   2178            /* Set bypass mode and wait for bypass mode to settle before
   2179               EMU_DCDCMISCCTRL_LNFORCECCM is set. Restore current DCDC mode. */
   2180            EMU_IntClear(EMU_IFC_DCDCINBYPASS);
   2181            EMU_DCDCModeSet(emuDcdcMode_Bypass);
   2182            while ((EMU->DCDCSYNC & EMU_DCDCSYNC_DCDCCTRLBUSY) != 0U) {
   2183            }
   2184            while ((EMU_IntGet() & EMU_IF_DCDCINBYPASS) == 0U) {
   2185            }
   2186            if (conductionMode == emuDcdcConductionMode_DiscontinuousLN) {
   2187              EMU->DCDCMISCCTRL &= ~EMU_DCDCMISCCTRL_LNFORCECCM;
   2188              if (rcoDefaultSet) {
   2189                EMU_DCDCLnRcoBandSet(emuDcdcLnRcoBand_3MHz);
   2190              } else {
   2191                /* emuDcdcConductionMode_DiscontinuousLN supports up to 4MHz LN RCO. */
   2192                EFM_ASSERT(rcoBand <= emuDcdcLnRcoBand_4MHz);
   2193              }
   2194            } else {
   2195              EMU->DCDCMISCCTRL |= EMU_DCDCMISCCTRL_LNFORCECCM;
   2196              if (rcoDefaultSet) {
   2197                EMU_DCDCLnRcoBandSet(emuDcdcLnRcoBand_7MHz);
   2198              }
   2199            }
   2200            EMU_DCDCModeSet(currentDcdcMode);
   2201            /* Update slice configuration as it depends on conduction mode and RCO band.*/
   2202            EMU_DCDCOptimizeSlice(dcdcEm01LoadCurrent_mA);
   2203          }
   2204          
   2205          /***************************************************************************//**
   2206           * @brief
   2207           *   Configure the DCDC regulator.
   2208           *
   2209           * @note
   2210           * Do not call this function if the power circuit is configured for NODCDC as
   2211           * described in the Power Configurations section of the Reference Manual.
   2212           * Instead, call @ref EMU_DCDCPowerOff().
   2213           *
   2214           * @param[in] dcdcInit
   2215           *  The DCDC initialization structure.
   2216           *
   2217           * @return
   2218           *   True if initialization parameters are valid.
   2219           ******************************************************************************/
   2220          bool EMU_DCDCInit(const EMU_DCDCInit_TypeDef *dcdcInit)
   2221          {
   2222            uint32_t lpCmpBiasSelEM234H;
   2223          
   2224          #if defined(_EMU_PWRCFG_MASK)
   2225            /* Set the external power configuration. This enables writing to the other
   2226               DCDC registers. */
   2227            EMU->PWRCFG = EMU_PWRCFG_PWRCFG_DCDCTODVDD;
   2228          
   2229            /* EMU->PWRCFG is write-once and POR reset only. Check that
   2230               the desired power configuration was set. */
   2231            if ((EMU->PWRCFG & _EMU_PWRCFG_PWRCFG_MASK) != EMU_PWRCFG_PWRCFG_DCDCTODVDD) {
   2232              /* If this assert triggers unexpectedly, power cycle the
   2233                 kit to reset the power configuration. */
   2234              EFM_ASSERT(false);
   2235              /* Return when assertions are disabled. */
   2236              return false;
   2237            }
   2238          #endif
   2239          
   2240            /* Load DCDC calibration data from the DI page. */
   2241            (void)dcdcConstCalibrationLoad();
   2242          
   2243            /* Check current parameters */
   2244            EFM_ASSERT(dcdcInit->maxCurrent_mA <= 200U);
   2245            EFM_ASSERT(dcdcInit->em01LoadCurrent_mA <= dcdcInit->maxCurrent_mA);
   2246            EFM_ASSERT(dcdcInit->reverseCurrentControl <= 200);
   2247          
   2248            if (dcdcInit->dcdcMode == emuDcdcMode_LowNoise) {
   2249              /* DCDC low-noise supports max 200 mA. */
   2250              EFM_ASSERT(dcdcInit->em01LoadCurrent_mA <= 200U);
   2251            }
   2252          #if (_SILICON_LABS_GECKO_INTERNAL_SDID != 80)
   2253            else if (dcdcInit->dcdcMode == emuDcdcMode_LowPower) {
   2254              /* Up to 10 mA is supported for EM01-LP mode. */
   2255              EFM_ASSERT(dcdcInit->em01LoadCurrent_mA <= 10U);
   2256            }
   2257          #endif
   2258            else {
   2259              /* No need to check the EM01 load limit. */
   2260            }
   2261          
   2262            /* EM2/3/4 current above 10 mA is not supported. */
   2263            EFM_ASSERT(dcdcInit->em234LoadCurrent_uA <= 10000U);
   2264          
   2265            if (dcdcInit->em234LoadCurrent_uA < 75U) {
   2266              lpCmpBiasSelEM234H  = 0;
   2267            } else if (dcdcInit->em234LoadCurrent_uA < 500U) {
   2268              lpCmpBiasSelEM234H  = 1U << _GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_SHIFT;
   2269            } else if (dcdcInit->em234LoadCurrent_uA < 2500U) {
   2270              lpCmpBiasSelEM234H  = 2U << _GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_SHIFT;
   2271            } else {
   2272              lpCmpBiasSelEM234H  = 3U << _GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_SHIFT;
   2273            }
   2274          
   2275            /* ==== THESE NEXT STEPS ARE STRONGLY ORDER DEPENDENT ==== */
   2276          
   2277            /* Set DCDC low-power mode comparator bias selection. */
   2278          
   2279            /* 1. Set DCDC low-power mode comparator bias selection and forced CCM.
   2280                  => Updates DCDCMISCCTRL_LNFORCECCM */
   2281            EMU->DCDCMISCCTRL = (EMU->DCDCMISCCTRL & ~(_GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_MASK
   2282                                                       | _EMU_DCDCMISCCTRL_LNFORCECCM_MASK))
   2283                                | ((uint32_t)lpCmpBiasSelEM234H
   2284                                   | (dcdcInit->reverseCurrentControl >= 0
   2285                                      ? EMU_DCDCMISCCTRL_LNFORCECCM : 0U));
   2286          #if defined(_EMU_DCDCLPEM01CFG_LPCMPBIASEM01_MASK)
   2287            /* Only 10 mA EM01-LP current is supported. */
   2288            EMU->DCDCLPEM01CFG = (EMU->DCDCLPEM01CFG & ~_EMU_DCDCLPEM01CFG_LPCMPBIASEM01_MASK)
   2289                                 | EMU_DCDCLPEM01CFG_LPCMPBIASEM01_BIAS3;
   2290          #endif
   2291          
   2292            /* 2. Set recommended and validated current optimization settings.
   2293                  <= Depends on LNFORCECCM
   2294                  => Updates DCDCLNFREQCTRL_RCOBAND */
   2295            dcdcValidatedConfigSet();
   2296          
   2297            /* 3. Updated static currents and limits user data.
   2298                  Limiters are updated in @ref EMU_DCDCOptimizeSlice(). */
   2299            userCurrentLimitsSet(dcdcInit->maxCurrent_mA,
   2300                                 dcdcInit->reverseCurrentControl);
   2301            dcdcEm01LoadCurrent_mA = dcdcInit->em01LoadCurrent_mA;
   2302          
   2303            /* 4. Optimize LN slice based on the given user input load current.
   2304                  <= Depends on DCDCMISCCTRL_LNFORCECCM and DCDCLNFREQCTRL_RCOBAND
   2305                  <= Depends on dcdcInit->maxCurrent_mA and dcdcInit->reverseCurrentControl
   2306                  => Updates DCDCMISCCTRL_P/NFETCNT
   2307                  => Updates DCDCMISCCTRL_LNCLIMILIMSEL and DCDCMISCCTRL_LPCLIMILIMSEL
   2308                  => Updates DCDCZDETCTRL_ZDETILIMSEL */
   2309            EMU_DCDCOptimizeSlice(dcdcInit->em01LoadCurrent_mA);
   2310          
   2311            /* ======================================================= */
   2312          
   2313            /* Set DCDC low noise mode compensator control register. */
   2314            compCtrlSet(dcdcInit->dcdcLnCompCtrl);
   2315          
   2316            /* Set DCDC output voltage. */
   2317            if (!EMU_DCDCOutputVoltageSet(dcdcInit->mVout, true, true)) {
   2318              EFM_ASSERT(false);
   2319              /* Return when assertions are disabled. */
   2320              return false;
   2321            }
   2322          
   2323          #if (_SILICON_LABS_GECKO_INTERNAL_SDID == 80)
   2324            /* Select analog peripheral power supply. This must be done before
   2325               DCDC mode is set for all EFM32xG1 and EFR32xG1 devices. */
   2326            BUS_RegBitWrite(&EMU->PWRCTRL,
   2327                            _EMU_PWRCTRL_ANASW_SHIFT,
   2328                            dcdcInit->anaPeripheralPower ? 1 : 0);
   2329          #endif
   2330          
   2331          #if defined(_EMU_PWRCTRL_REGPWRSEL_MASK)
   2332            /* Select DVDD as input to the digital regulator. The switch to DVDD will take
   2333               effect once the DCDC output is stable. */
   2334            EMU->PWRCTRL |= EMU_PWRCTRL_REGPWRSEL_DVDD;
   2335          #endif
   2336          
   2337            /* Set EM0 DCDC operating mode. Output voltage set in
   2338               @ref EMU_DCDCOutputVoltageSet() above takes effect if mode
   2339               is changed from bypass/off mode. */
   2340            EMU_DCDCModeSet(dcdcInit->dcdcMode);
   2341          
   2342          #if (_SILICON_LABS_GECKO_INTERNAL_SDID != 80)
   2343            /* Select the analog peripheral power supply. This must be done after
   2344               DCDC mode is set for all devices other than EFM32xG1 and EFR32xG1. */
   2345            BUS_RegBitWrite(&EMU->PWRCTRL,
   2346                            _EMU_PWRCTRL_ANASW_SHIFT,
   2347                            dcdcInit->anaPeripheralPower
   2348                            == emuDcdcAnaPeripheralPower_DCDC ? 1U : 0U);
   2349          #endif
   2350          
   2351            return true;
   2352          }
   2353          
   2354          /***************************************************************************//**
   2355           * @brief
   2356           *   Set the DCDC output voltage.
   2357           *
   2358           * @param[in] mV
   2359           *   Target DCDC output voltage in mV.
   2360           *
   2361           * @return
   2362           *   True if the mV parameter is valid.
   2363           ******************************************************************************/
   2364          bool EMU_DCDCOutputVoltageSet(uint32_t mV,
   2365                                        bool setLpVoltage,
   2366                                        bool setLnVoltage)
   2367          {
   2368          #if defined(_DEVINFO_DCDCLNVCTRL0_3V0LNATT1_MASK)
   2369          
   2370          #define DCDC_TRIM_MODES ((uint8_t)dcdcTrimMode_LN + 1)
   2371            bool validOutVoltage;
   2372            bool attenuationSet;
   2373            uint32_t mVlow = 0;
   2374            uint32_t mVhigh = 0;
   2375            uint32_t mVdiff;
   2376            uint32_t vrefVal[DCDC_TRIM_MODES] = { 0 };
   2377            uint32_t vrefLow[DCDC_TRIM_MODES] = { 0 };
   2378            uint32_t vrefHigh[DCDC_TRIM_MODES] = { 0 };
   2379            uint8_t lpcmpBias[DCDC_TRIM_MODES] = { 0 };
   2380          
   2381            /* Check that the set voltage is within valid range.
   2382               Voltages are obtained from the data sheet. */
   2383            validOutVoltage = (mV >= PWRCFG_DCDCTODVDD_VMIN)
   2384                              && (mV <= PWRCFG_DCDCTODVDD_VMAX);
   2385          
   2386            if (!validOutVoltage) {
   2387              EFM_ASSERT(false);
   2388              /* Return when assertions are disabled. */
   2389              return false;
   2390            }
   2391          
   2392            /* Set attenuation to use and low/high range. */
   2393            attenuationSet = mV > 1800U;
   2394            if (attenuationSet) {
   2395              mVlow = 1800;
   2396              mVhigh = 3000;
   2397              mVdiff = mVhigh - mVlow;
   2398            } else {
   2399              mVlow = 1200;
   2400              mVhigh = 1800;
   2401              mVdiff = mVhigh - mVlow;
   2402            }
   2403          
   2404            /* Get 2-point calibration data from DEVINFO. */
   2405          
   2406            /* LN mode */
   2407            if (attenuationSet) {
   2408              vrefLow[dcdcTrimMode_LN]  = DEVINFO->DCDCLNVCTRL0;
   2409              vrefHigh[dcdcTrimMode_LN] = (vrefLow[dcdcTrimMode_LN] & _DEVINFO_DCDCLNVCTRL0_3V0LNATT1_MASK)
   2410                                          >> _DEVINFO_DCDCLNVCTRL0_3V0LNATT1_SHIFT;
   2411              vrefLow[dcdcTrimMode_LN]  = (vrefLow[dcdcTrimMode_LN] & _DEVINFO_DCDCLNVCTRL0_1V8LNATT1_MASK)
   2412                                          >> _DEVINFO_DCDCLNVCTRL0_1V8LNATT1_SHIFT;
   2413            } else {
   2414              vrefLow[dcdcTrimMode_LN]  = DEVINFO->DCDCLNVCTRL0;
   2415              vrefHigh[dcdcTrimMode_LN] = (vrefLow[dcdcTrimMode_LN] & _DEVINFO_DCDCLNVCTRL0_1V8LNATT0_MASK)
   2416                                          >> _DEVINFO_DCDCLNVCTRL0_1V8LNATT0_SHIFT;
   2417              vrefLow[dcdcTrimMode_LN]  = (vrefLow[dcdcTrimMode_LN] & _DEVINFO_DCDCLNVCTRL0_1V2LNATT0_MASK)
   2418                                          >> _DEVINFO_DCDCLNVCTRL0_1V2LNATT0_SHIFT;
   2419            }
   2420          
   2421            /* LP EM234H mode */
   2422            lpcmpBias[dcdcTrimMode_EM234H_LP] = (uint8_t)
   2423                                                ((EMU->DCDCMISCCTRL & _GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_MASK)
   2424                                                 >> _GENERIC_DCDCMISCCTRL_LPCMPBIASEM234H_SHIFT);
   2425            lpGetDevinfoVrefLowHigh(&vrefLow[dcdcTrimMode_EM234H_LP],
   2426                                    &vrefHigh[dcdcTrimMode_EM234H_LP],
   2427                                    attenuationSet,
   2428                                    lpcmpBias[dcdcTrimMode_EM234H_LP]);
   2429          
   2430          #if defined(_EMU_DCDCLPEM01CFG_LPCMPBIASEM01_MASK)
   2431            /* LP EM01 mode */
   2432            lpcmpBias[dcdcTrimMode_EM01_LP] = (uint8_t)
   2433                                              ((EMU->DCDCLPEM01CFG & _EMU_DCDCLPEM01CFG_LPCMPBIASEM01_MASK)
   2434                                               >> _EMU_DCDCLPEM01CFG_LPCMPBIASEM01_SHIFT);
   2435            lpGetDevinfoVrefLowHigh(&vrefLow[dcdcTrimMode_EM01_LP],
   2436                                    &vrefHigh[dcdcTrimMode_EM01_LP],
   2437                                    attenuationSet,
   2438                                    lpcmpBias[dcdcTrimMode_EM01_LP]);
   2439          #endif
   2440          
   2441            /* Calculate output voltage trims. */
   2442            vrefVal[dcdcTrimMode_LN]         = ((mV - mVlow) * (vrefHigh[dcdcTrimMode_LN] - vrefLow[dcdcTrimMode_LN]))
   2443                                               / mVdiff;
   2444            vrefVal[dcdcTrimMode_LN]        += vrefLow[dcdcTrimMode_LN];
   2445          
   2446            vrefVal[dcdcTrimMode_EM234H_LP]  = ((mV - mVlow) * (vrefHigh[dcdcTrimMode_EM234H_LP] - vrefLow[dcdcTrimMode_EM234H_LP]))
   2447                                               / mVdiff;
   2448            vrefVal[dcdcTrimMode_EM234H_LP] += vrefLow[dcdcTrimMode_EM234H_LP];
   2449          
   2450          #if defined(_EMU_DCDCLPEM01CFG_LPCMPBIASEM01_MASK)
   2451            vrefVal[dcdcTrimMode_EM01_LP]    = ((mV - mVlow) * (vrefHigh[dcdcTrimMode_EM01_LP] - vrefLow[dcdcTrimMode_EM01_LP]))
   2452                                               / mVdiff;
   2453            vrefVal[dcdcTrimMode_EM01_LP]   += vrefLow[dcdcTrimMode_EM01_LP];
   2454          #endif
   2455          
   2456            /* Range checks */
   2457            if ((vrefVal[dcdcTrimMode_LN] > vrefHigh[dcdcTrimMode_LN])
   2458                || (vrefVal[dcdcTrimMode_LN] < vrefLow[dcdcTrimMode_LN])
   2459          #if defined(_EMU_DCDCLPEM01CFG_LPCMPBIASEM01_MASK)
   2460                || (vrefVal[dcdcTrimMode_EM01_LP] > vrefHigh[dcdcTrimMode_EM01_LP])
   2461                || (vrefVal[dcdcTrimMode_EM01_LP] < vrefLow[dcdcTrimMode_EM01_LP])
   2462          #endif
   2463                || (vrefVal[dcdcTrimMode_EM234H_LP] > vrefHigh[dcdcTrimMode_EM234H_LP])
   2464                || (vrefVal[dcdcTrimMode_EM234H_LP] < vrefLow[dcdcTrimMode_EM234H_LP])) {
   2465              EFM_ASSERT(false);
   2466              /* Return when assertions are disabled. */
   2467              return false;
   2468            }
   2469          
   2470            /* Update output voltage tuning for LN and LP modes. */
   2471            if (setLnVoltage) {
   2472              EMU->DCDCLNVCTRL = (EMU->DCDCLNVCTRL & ~(_EMU_DCDCLNVCTRL_LNVREF_MASK | _EMU_DCDCLNVCTRL_LNATT_MASK))
   2473                                 | (vrefVal[dcdcTrimMode_LN] << _EMU_DCDCLNVCTRL_LNVREF_SHIFT)
   2474                                 | (attenuationSet ? EMU_DCDCLNVCTRL_LNATT : 0U);
   2475            }
   2476          
   2477            if (setLpVoltage) {
   2478              /* Load LP EM234H comparator hysteresis calibration. */
   2479              if (!(lpCmpHystCalibrationLoad(attenuationSet, lpcmpBias[dcdcTrimMode_EM234H_LP], dcdcTrimMode_EM234H_LP))) {
   2480                EFM_ASSERT(false);
   2481                /* Return when assertions are disabled. */
   2482                return false;
   2483              }
   2484          
   2485          #if defined(_EMU_DCDCLPEM01CFG_LPCMPBIASEM01_MASK)
   2486              /* Load LP EM234H comparator hysteresis calibration. */
   2487              if (!(lpCmpHystCalibrationLoad(attenuationSet, lpcmpBias[dcdcTrimMode_EM01_LP], dcdcTrimMode_EM01_LP))) {
   2488                EFM_ASSERT(false);
   2489                /* Return when assertions are disabled. */
   2490                return false;
   2491              }
   2492          
   2493              /* LP VREF is that maximum of trims for EM01 and EM234H. */
   2494              vrefVal[dcdcTrimMode_EM234H_LP] = SL_MAX(vrefVal[dcdcTrimMode_EM234H_LP], vrefVal[dcdcTrimMode_EM01_LP]);
   2495          #endif
   2496          
   2497              /* Don't exceed the maximum available code as specified in the reference manual for EMU_DCDCLPVCTRL. */
   2498              vrefVal[dcdcTrimMode_EM234H_LP] = SL_MIN(vrefVal[dcdcTrimMode_EM234H_LP], 0xE7U);
   2499              EMU->DCDCLPVCTRL = (EMU->DCDCLPVCTRL & ~(_EMU_DCDCLPVCTRL_LPVREF_MASK | _EMU_DCDCLPVCTRL_LPATT_MASK))
   2500                                 | (vrefVal[dcdcTrimMode_EM234H_LP] << _EMU_DCDCLPVCTRL_LPVREF_SHIFT)
   2501                                 | (attenuationSet ? EMU_DCDCLPVCTRL_LPATT : 0U);
   2502            }
   2503          #endif
   2504            return true;
   2505          }
   2506          
   2507          /***************************************************************************//**
   2508           * @brief
   2509           *   Optimize the DCDC slice count based on the estimated average load current
   2510           *   in EM0.
   2511           *
   2512           * @param[in] em0LoadCurrent_mA
   2513           *   Estimated average EM0 load current in mA.
   2514           ******************************************************************************/
   2515          void EMU_DCDCOptimizeSlice(uint32_t em0LoadCurrentmA)
   2516          {
   2517            uint32_t sliceCount = 0;
   2518            uint32_t rcoBand = (EMU->DCDCLNFREQCTRL & _EMU_DCDCLNFREQCTRL_RCOBAND_MASK)
   2519                               >> _EMU_DCDCLNFREQCTRL_RCOBAND_SHIFT;
   2520          
   2521            /* Set the recommended slice count. */
   2522            if (((EMU->DCDCMISCCTRL & _EMU_DCDCMISCCTRL_LNFORCECCM_MASK) != 0U)
   2523                && (rcoBand >= (uint32_t)emuDcdcLnRcoBand_5MHz)) {
   2524              if (em0LoadCurrentmA < 20U) {
   2525                sliceCount = 4;
   2526              } else if ((em0LoadCurrentmA >= 20U) && (em0LoadCurrentmA < 40U)) {
   2527                sliceCount = 8;
   2528              } else {
   2529                sliceCount = 16;
   2530              }
   2531            } else if (((EMU->DCDCMISCCTRL & _EMU_DCDCMISCCTRL_LNFORCECCM_MASK) == 0U)
   2532                       && (rcoBand <= (uint32_t)emuDcdcLnRcoBand_4MHz)) {
   2533              if (em0LoadCurrentmA < 10U) {
   2534                sliceCount = 4;
   2535              } else if ((em0LoadCurrentmA >= 10U) && (em0LoadCurrentmA < 20U)) {
   2536                sliceCount = 8;
   2537              } else {
   2538                sliceCount = 16;
   2539              }
   2540            } else if (((EMU->DCDCMISCCTRL & _EMU_DCDCMISCCTRL_LNFORCECCM_MASK) != 0U)
   2541                       && (rcoBand <= (uint32_t)emuDcdcLnRcoBand_4MHz)) {
   2542              if (em0LoadCurrentmA < 40U) {
   2543                sliceCount = 8;
   2544              } else {
   2545                sliceCount = 16;
   2546              }
   2547            } else {
   2548              /* This configuration is not recommended. @ref EMU_DCDCInit() applies a recommended
   2549                 configuration. */
   2550              EFM_ASSERT(false);
   2551            }
   2552          
   2553            /* The selected slices are PSLICESEL + 1. */
   2554            sliceCount--;
   2555          
   2556            /* Apply slice count to both N and P slice. */
   2557            sliceCount = (sliceCount << _EMU_DCDCMISCCTRL_PFETCNT_SHIFT
   2558                          | sliceCount << _EMU_DCDCMISCCTRL_NFETCNT_SHIFT);
   2559            EMU->DCDCMISCCTRL = (EMU->DCDCMISCCTRL & ~(_EMU_DCDCMISCCTRL_PFETCNT_MASK
   2560                                                       | _EMU_DCDCMISCCTRL_NFETCNT_MASK))
   2561                                | sliceCount;
   2562          
   2563            /* Update the current limiters. */
   2564            currentLimitersUpdate();
   2565          }
   2566          
   2567          /***************************************************************************//**
   2568           * @brief
   2569           *   Set DCDC Low-noise RCO band.
   2570           *
   2571           * @param[in] band
   2572           *   RCO band to set.
   2573           ******************************************************************************/
   2574          void EMU_DCDCLnRcoBandSet(EMU_DcdcLnRcoBand_TypeDef band)
   2575          {
   2576            uint32_t forcedCcm;
   2577            forcedCcm = BUS_RegBitRead(&EMU->DCDCMISCCTRL, _EMU_DCDCMISCCTRL_LNFORCECCM_SHIFT);
   2578          
   2579            /* DCM mode supports up to 4 MHz LN RCO. */
   2580            EFM_ASSERT(((forcedCcm == 0U) && band <= emuDcdcLnRcoBand_4MHz)
   2581                       || (forcedCcm != 0U));
   2582          
   2583            EMU->DCDCLNFREQCTRL = (EMU->DCDCLNFREQCTRL & ~_EMU_DCDCLNFREQCTRL_RCOBAND_MASK)
   2584                                  | ((uint32_t)band << _EMU_DCDCLNFREQCTRL_RCOBAND_SHIFT);
   2585          
   2586            /* Update slice configuration as this depends on the RCO band. */
   2587            EMU_DCDCOptimizeSlice(dcdcEm01LoadCurrent_mA);
   2588          }
   2589          
   2590          /***************************************************************************//**
   2591           * @brief
   2592           *   Power off the DCDC regulator.
   2593           *
   2594           * @details
   2595           *   This function powers off the DCDC controller. This function should only be
   2596           *   used if the external power circuit is wired for no DCDC. If the external power
   2597           *   circuit is wired for DCDC usage, use @ref EMU_DCDCInit() and set the
   2598           *   DCDC in bypass mode to disable DCDC.
   2599           *
   2600           * @return
   2601           *   Return false if the DCDC could not be disabled.
   2602           ******************************************************************************/
   2603          bool EMU_DCDCPowerOff(void)
   2604          {
   2605            bool dcdcModeSet;
   2606          
   2607          #if defined(_EMU_PWRCFG_MASK)
   2608            /* Set DCDCTODVDD only to enable write access to EMU->DCDCCTRL. */
   2609            EMU->PWRCFG = EMU_PWRCFG_PWRCFG_DCDCTODVDD;
   2610          #endif
   2611          
   2612            /* Select DVDD as input to the digital regulator. */
   2613          #if defined(EMU_PWRCTRL_IMMEDIATEPWRSWITCH)
   2614            EMU->PWRCTRL |= EMU_PWRCTRL_REGPWRSEL_DVDD | EMU_PWRCTRL_IMMEDIATEPWRSWITCH;
   2615          #elif defined(EMU_PWRCTRL_REGPWRSEL_DVDD)
   2616            EMU->PWRCTRL |= EMU_PWRCTRL_REGPWRSEL_DVDD;
   2617          #endif
   2618          
   2619            /* Set DCDC to OFF and disable LP in EM2/3/4. Verify that the required
   2620               mode could be set. */
   2621            while ((EMU->DCDCSYNC & EMU_DCDCSYNC_DCDCCTRLBUSY) != 0U) {
   2622            }
   2623            EMU->DCDCCTRL = EMU_DCDCCTRL_DCDCMODE_OFF;
   2624          
   2625            dcdcModeSet = (EMU->DCDCCTRL == EMU_DCDCCTRL_DCDCMODE_OFF);
   2626            EFM_ASSERT(dcdcModeSet);
   2627          
   2628            return dcdcModeSet;
   2629          }
   2630          #endif
   2631          
   2632          #if defined(_DCDC_CTRL_MASK)
   2633          /***************************************************************************//**
   2634           * @brief
   2635           *   Configure the DCDC regulator.
   2636           *
   2637           * @param[in] dcdcInit
   2638           *  The DCDC initialization structure.
   2639           *
   2640           * @return
   2641           *   True if initialization parameters are valid.
   2642           ******************************************************************************/
   2643          bool EMU_DCDCInit(const EMU_DCDCInit_TypeDef *dcdcInit)
   2644          {
   2645            bool dcdcLocked;
   2646          
   2647            CMU->CLKEN0_SET = CMU_CLKEN0_DCDC;
   2648            DCDC->EN_SET    = DCDC_EN_EN;
   2649            dcdcLocked      = DCDC->LOCKSTATUS == DCDC_LOCKSTATUS_LOCK;
   2650            EMU_DCDCUnlock();
   2651          
   2652            EMU->PFMBYPCTRL = ((uint32_t)dcdcInit->cmpThreshold << _EMU_PFMBYPCTRL_THRESSEL_SHIFT)
   2653                              | EMU_PFMBYPCTRL_VREGINCMPEN;
   2654            DCDC->CTRL = (DCDC->CTRL & ~(_DCDC_CTRL_IPKTMAXCTRL_MASK
   2655                                         | _DCDC_CTRL_DCMONLYEN_MASK))
   2656                         | ((uint32_t)dcdcInit->tonMax << _DCDC_CTRL_IPKTMAXCTRL_SHIFT)
   2657                         | ((uint32_t)(dcdcInit->dcmOnlyEn ? 1U : 0U) << _DCDC_CTRL_DCMONLYEN_SHIFT);
   2658            DCDC->EM01CTRL0 = ((uint32_t)dcdcInit->driveSpeedEM01 << _DCDC_EM01CTRL0_DRVSPEED_SHIFT)
   2659                              | ((uint32_t)dcdcInit->peakCurrentEM01 << _DCDC_EM01CTRL0_IPKVAL_SHIFT);
   2660            DCDC->EM23CTRL0 = ((uint32_t)dcdcInit->driveSpeedEM23 << _DCDC_EM23CTRL0_DRVSPEED_SHIFT)
   2661                              | ((uint32_t)dcdcInit->peakCurrentEM23 << _DCDC_EM23CTRL0_IPKVAL_SHIFT);
   2662          
   2663            EMU_DCDCModeSet(dcdcInit->mode);
   2664          
   2665            if (dcdcLocked) {
   2666              EMU_DCDCLock();
   2667            }
   2668          
   2669            return true;
   2670          }
   2671          
   2672          /***************************************************************************//**
   2673           * @brief
   2674           *   Set DCDC regulator operating mode.
   2675           *
   2676           * @param[in] dcdcMode
   2677           *   DCDC mode.
   2678           ******************************************************************************/
   2679          void EMU_DCDCModeSet(EMU_DcdcMode_TypeDef dcdcMode)
   2680          {
   2681            bool dcdcLocked;
   2682          
   2683            DCDC->EN_SET = DCDC_EN_EN;
   2684            dcdcLocked = DCDC->LOCKSTATUS == DCDC_LOCKSTATUS_LOCK;
   2685            EMU_DCDCUnlock();
   2686          
   2687            if (dcdcMode == emuDcdcMode_Bypass) {
   2688              DCDC->CTRL_CLR = DCDC_CTRL_MODE;
   2689              while ((DCDC->STATUS & DCDC_STATUS_BYPSW) == 0U) {
   2690                /* Wait for BYPASS switch enable. */
   2691              }
   2692              DCDC->EN_CLR = DCDC_EN_EN;
   2693            } else {
   2694              while ((DCDC->STATUS & DCDC_STATUS_VREGIN) != 0U) {
   2695                /* Wait for VREGIN voltage to rise above threshold. */
   2696              }
   2697              DCDC->IF_CLR = DCDC_IF_REGULATION;
   2698              DCDC->CTRL_SET = DCDC_CTRL_MODE;
   2699              while ((DCDC->IF & DCDC_IF_REGULATION) == 0U) {
   2700                /* Wait for DCDC to complete it's startup. */
   2701              }
   2702            }
   2703          
   2704            if (dcdcLocked) {
   2705              EMU_DCDCLock();
   2706            }
   2707          }
   2708          
   2709          /***************************************************************************//**
   2710           * @brief
   2711           *   Power off the DCDC regulator.
   2712           *
   2713           * @return
   2714           *   Returns true.
   2715           ******************************************************************************/
   2716          bool EMU_DCDCPowerOff(void)
   2717          {
   2718            EMU_DCDCModeSet(emuDcdcMode_Bypass);
   2719            return true;
   2720          }
   2721          #endif
   2722          
   2723          /** @endcond */
   2724          
   2725          #if defined(EMU_STATUS_VMONRDY)
   2726          /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
   2727          
   2728          /***************************************************************************//**
   2729           * @brief
   2730           *   Get the calibrated threshold value.
   2731           *
   2732           * @details
   2733           *   All VMON channels have two calibration fields in the DI page that
   2734           *   describes the threshold at 1.86 V and 2.98 V. This function will convert
   2735           *   the uncalibrated input voltage threshold in millivolts into a calibrated
   2736           *   threshold.
   2737           *
   2738           * @param[in] channel
   2739           *   A VMON channel.
   2740           *
   2741           * @param[in] threshold
   2742           *   A desired threshold in millivolts.
   2743           *
   2744           * @return
   2745           *   A calibrated threshold value to use. The first digit of the return value is placed
   2746           *   in the "fine" register fields while the next digits are placed in the
   2747           *   "coarse" register fields.
   2748           ******************************************************************************/
   2749          static uint32_t vmonCalibratedThreshold(EMU_VmonChannel_TypeDef channel,
   2750                                                  int threshold)
   2751          {
   2752            uint32_t tLow = 0;
   2753            uint32_t tHigh = 0;
   2754            uint32_t calReg;
   2755          
   2756            /* Get calibration values for 1.86 V and 2.98 V */
   2757            switch (channel) {
   2758              case emuVmonChannel_AVDD:
   2759                calReg = DEVINFO->VMONCAL0;
   2760                tLow = (10U * ((calReg & _DEVINFO_VMONCAL0_AVDD1V86THRESCOARSE_MASK)
   2761                               >> _DEVINFO_VMONCAL0_AVDD1V86THRESCOARSE_SHIFT))
   2762                       + ((calReg & _DEVINFO_VMONCAL0_AVDD1V86THRESFINE_MASK)
   2763                          >> _DEVINFO_VMONCAL0_AVDD1V86THRESFINE_SHIFT);
   2764                tHigh = (10U * ((calReg & _DEVINFO_VMONCAL0_AVDD2V98THRESCOARSE_MASK)
   2765                                >> _DEVINFO_VMONCAL0_AVDD2V98THRESCOARSE_SHIFT))
   2766                        + ((calReg & _DEVINFO_VMONCAL0_AVDD2V98THRESFINE_MASK)
   2767                           >> _DEVINFO_VMONCAL0_AVDD2V98THRESFINE_SHIFT);
   2768                break;
   2769              case emuVmonChannel_ALTAVDD:
   2770                calReg = DEVINFO->VMONCAL0;
   2771                tLow = (10U * ((calReg & _DEVINFO_VMONCAL0_ALTAVDD1V86THRESCOARSE_MASK)
   2772                               >> _DEVINFO_VMONCAL0_ALTAVDD1V86THRESCOARSE_SHIFT))
   2773                       + ((calReg & _DEVINFO_VMONCAL0_ALTAVDD1V86THRESFINE_MASK)
   2774                          >> _DEVINFO_VMONCAL0_ALTAVDD1V86THRESFINE_SHIFT);
   2775                tHigh = (10U * ((calReg & _DEVINFO_VMONCAL0_ALTAVDD2V98THRESCOARSE_MASK)
   2776                                >> _DEVINFO_VMONCAL0_ALTAVDD2V98THRESCOARSE_SHIFT))
   2777                        + ((calReg & _DEVINFO_VMONCAL0_ALTAVDD2V98THRESFINE_MASK)
   2778                           >> _DEVINFO_VMONCAL0_ALTAVDD2V98THRESFINE_SHIFT);
   2779                break;
   2780              case emuVmonChannel_DVDD:
   2781                calReg = DEVINFO->VMONCAL1;
   2782                tLow = (10U * ((calReg & _DEVINFO_VMONCAL1_DVDD1V86THRESCOARSE_MASK)
   2783                               >> _DEVINFO_VMONCAL1_DVDD1V86THRESCOARSE_SHIFT))
   2784                       + ((calReg & _DEVINFO_VMONCAL1_DVDD1V86THRESFINE_MASK)
   2785                          >> _DEVINFO_VMONCAL1_DVDD1V86THRESFINE_SHIFT);
   2786                tHigh = (10U * ((calReg & _DEVINFO_VMONCAL1_DVDD2V98THRESCOARSE_MASK)
   2787                                >> _DEVINFO_VMONCAL1_DVDD2V98THRESCOARSE_SHIFT))
   2788                        + ((calReg & _DEVINFO_VMONCAL1_DVDD2V98THRESFINE_MASK)
   2789                           >> _DEVINFO_VMONCAL1_DVDD2V98THRESFINE_SHIFT);
   2790                break;
   2791              case emuVmonChannel_IOVDD0:
   2792                calReg = DEVINFO->VMONCAL1;
   2793                tLow = (10U * ((calReg & _DEVINFO_VMONCAL1_IO01V86THRESCOARSE_MASK)
   2794                               >> _DEVINFO_VMONCAL1_IO01V86THRESCOARSE_SHIFT))
   2795                       + ((calReg & _DEVINFO_VMONCAL1_IO01V86THRESFINE_MASK)
   2796                          >> _DEVINFO_VMONCAL1_IO01V86THRESFINE_SHIFT);
   2797                tHigh = (10U * ((calReg & _DEVINFO_VMONCAL1_IO02V98THRESCOARSE_MASK)
   2798                                >> _DEVINFO_VMONCAL1_IO02V98THRESCOARSE_SHIFT))
   2799                        + ((calReg & _DEVINFO_VMONCAL1_IO02V98THRESFINE_MASK)
   2800                           >> _DEVINFO_VMONCAL1_IO02V98THRESFINE_SHIFT);
   2801                break;
   2802          #if defined(_EMU_VMONIO1CTRL_EN_MASK)
   2803              case emuVmonChannel_IOVDD1:
   2804                calReg = DEVINFO->VMONCAL2;
   2805                tLow = (10U * ((calReg & _DEVINFO_VMONCAL2_IO11V86THRESCOARSE_MASK)
   2806                               >> _DEVINFO_VMONCAL2_IO11V86THRESCOARSE_SHIFT))
   2807                       + ((calReg & _DEVINFO_VMONCAL2_IO11V86THRESFINE_MASK)
   2808                          >> _DEVINFO_VMONCAL2_IO11V86THRESFINE_SHIFT);
   2809                tHigh = (10U * ((calReg & _DEVINFO_VMONCAL2_IO12V98THRESCOARSE_MASK)
   2810                                >> _DEVINFO_VMONCAL2_IO12V98THRESCOARSE_SHIFT))
   2811                        + ((calReg & _DEVINFO_VMONCAL2_IO12V98THRESFINE_MASK)
   2812                           >> _DEVINFO_VMONCAL2_IO12V98THRESFINE_SHIFT);
   2813                break;
   2814          #endif
   2815          #if defined(_EMU_VMONBUVDDCTRL_EN_MASK)
   2816              case emuVmonChannel_BUVDD:
   2817                calReg = DEVINFO->VMONCAL2;
   2818                tLow = (10U * ((calReg & _DEVINFO_VMONCAL2_BUVDD1V86THRESCOARSE_MASK)
   2819                               >> _DEVINFO_VMONCAL2_BUVDD1V86THRESCOARSE_SHIFT))
   2820                       + ((calReg & _DEVINFO_VMONCAL2_BUVDD1V86THRESFINE_MASK)
   2821                          >> _DEVINFO_VMONCAL2_BUVDD1V86THRESFINE_SHIFT);
   2822                tHigh = (10U * ((calReg & _DEVINFO_VMONCAL2_BUVDD2V98THRESCOARSE_MASK)
   2823                                >> _DEVINFO_VMONCAL2_BUVDD2V98THRESCOARSE_SHIFT))
   2824                        + ((calReg & _DEVINFO_VMONCAL2_BUVDD2V98THRESFINE_MASK)
   2825                           >> _DEVINFO_VMONCAL2_BUVDD2V98THRESFINE_SHIFT);
   2826                break;
   2827          #endif
   2828              default:
   2829                EFM_ASSERT(false);
   2830                break;
   2831            }
   2832          
   2833            if (tLow < tHigh) {
   2834              /* Calculate threshold.
   2835               *
   2836               * Note that volt is used in the reference manual. However, the results
   2837               * should be in millivolts. The precision of Va and Vb are increased in the
   2838               * calculation instead of using floating points.
   2839               */
   2840              uint32_t va = (1120U * 100U) / (tHigh - tLow);
   2841              uint32_t vb = (1860U * 100U) - (va * tLow);
   2842              // If (tHigh - tLow) is large, Va could be zero. Caught by CSTAT.
   2843              if (va != 0) {
   2844                /* Round the threshold to the nearest integer value. */
   2845                return (((uint32_t)threshold * 100U) - vb + (va / 2U)) / va;
   2846              }
   2847            }
   2848          
   2849            /* Uncalibrated device guard. */
   2850            return (uint32_t)threshold;
   2851          }
   2852          
   2853          /** @endcond */
   2854          
   2855          /***************************************************************************//**
   2856           * @brief
   2857           *   Initialize a VMON channel.
   2858           *
   2859           * @details
   2860           *   Initialize a VMON channel without hysteresis. If the channel supports
   2861           *   separate rise and fall triggers, both thresholds will be set to the same
   2862           *   value. The threshold will be converted to a register field value based
   2863           *   on calibration values from the DI page.
   2864           *
   2865           * @param[in] vmonInit
   2866           *   The VMON initialization structure.
   2867           ******************************************************************************/
   2868          void EMU_VmonInit(const EMU_VmonInit_TypeDef *vmonInit)
   2869          {
   2870            uint32_t thresholdCoarse, thresholdFine;
   2871            uint32_t threshold;
   2872          
   2873            EFM_ASSERT((vmonInit->threshold >= 1620) && (vmonInit->threshold <= 3400));
   2874          
   2875            threshold = vmonCalibratedThreshold(vmonInit->channel, vmonInit->threshold);
   2876            thresholdFine = threshold % 10U;
   2877            thresholdCoarse = threshold / 10U;
   2878          
   2879            /* Saturate the threshold to maximum values. */
   2880            if (thresholdCoarse > 0xFU) {
   2881              thresholdCoarse = 0xF;
   2882              thresholdFine = 9;
   2883            }
   2884          
   2885            switch (vmonInit->channel) {
   2886              case emuVmonChannel_AVDD:
   2887                EMU->VMONAVDDCTRL = (thresholdCoarse << _EMU_VMONAVDDCTRL_RISETHRESCOARSE_SHIFT)
   2888                                    | (thresholdFine << _EMU_VMONAVDDCTRL_RISETHRESFINE_SHIFT)
   2889                                    | (thresholdCoarse << _EMU_VMONAVDDCTRL_FALLTHRESCOARSE_SHIFT)
   2890                                    | (thresholdFine << _EMU_VMONAVDDCTRL_FALLTHRESFINE_SHIFT)
   2891                                    | (vmonInit->riseWakeup ? EMU_VMONAVDDCTRL_RISEWU : 0U)
   2892                                    | (vmonInit->fallWakeup ? EMU_VMONAVDDCTRL_FALLWU : 0U)
   2893                                    | (vmonInit->enable     ? EMU_VMONAVDDCTRL_EN     : 0U);
   2894                break;
   2895              case emuVmonChannel_ALTAVDD:
   2896                EMU->VMONALTAVDDCTRL = (thresholdCoarse << _EMU_VMONALTAVDDCTRL_THRESCOARSE_SHIFT)
   2897                                       | (thresholdFine << _EMU_VMONALTAVDDCTRL_THRESFINE_SHIFT)
   2898                                       | (vmonInit->riseWakeup ? EMU_VMONALTAVDDCTRL_RISEWU : 0U)
   2899                                       | (vmonInit->fallWakeup ? EMU_VMONALTAVDDCTRL_FALLWU : 0U)
   2900                                       | (vmonInit->enable     ? EMU_VMONALTAVDDCTRL_EN     : 0U);
   2901                break;
   2902              case emuVmonChannel_DVDD:
   2903                EMU->VMONDVDDCTRL = (thresholdCoarse << _EMU_VMONDVDDCTRL_THRESCOARSE_SHIFT)
   2904                                    | (thresholdFine << _EMU_VMONDVDDCTRL_THRESFINE_SHIFT)
   2905                                    | (vmonInit->riseWakeup ? EMU_VMONDVDDCTRL_RISEWU : 0U)
   2906                                    | (vmonInit->fallWakeup ? EMU_VMONDVDDCTRL_FALLWU : 0U)
   2907                                    | (vmonInit->enable     ? EMU_VMONDVDDCTRL_EN     : 0U);
   2908                break;
   2909              case emuVmonChannel_IOVDD0:
   2910                EMU->VMONIO0CTRL = (thresholdCoarse << _EMU_VMONIO0CTRL_THRESCOARSE_SHIFT)
   2911                                   | (thresholdFine << _EMU_VMONIO0CTRL_THRESFINE_SHIFT)
   2912                                   | (vmonInit->retDisable ? EMU_VMONIO0CTRL_RETDIS : 0U)
   2913                                   | (vmonInit->riseWakeup ? EMU_VMONIO0CTRL_RISEWU : 0U)
   2914                                   | (vmonInit->fallWakeup ? EMU_VMONIO0CTRL_FALLWU : 0U)
   2915                                   | (vmonInit->enable     ? EMU_VMONIO0CTRL_EN     : 0U);
   2916                break;
   2917          #if defined(_EMU_VMONIO1CTRL_EN_MASK)
   2918              case emuVmonChannel_IOVDD1:
   2919                EMU->VMONIO1CTRL = (thresholdCoarse << _EMU_VMONIO1CTRL_THRESCOARSE_SHIFT)
   2920                                   | (thresholdFine << _EMU_VMONIO1CTRL_THRESFINE_SHIFT)
   2921                                   | (vmonInit->retDisable ? EMU_VMONIO1CTRL_RETDIS : 0U)
   2922                                   | (vmonInit->riseWakeup ? EMU_VMONIO1CTRL_RISEWU : 0U)
   2923                                   | (vmonInit->fallWakeup ? EMU_VMONIO1CTRL_FALLWU : 0U)
   2924                                   | (vmonInit->enable     ? EMU_VMONIO1CTRL_EN     : 0U);
   2925                break;
   2926          #endif
   2927          #if defined(_EMU_VMONBUVDDCTRL_EN_MASK)
   2928              case emuVmonChannel_BUVDD:
   2929                EMU->VMONBUVDDCTRL = (thresholdCoarse << _EMU_VMONBUVDDCTRL_THRESCOARSE_SHIFT)
   2930                                     | (thresholdFine << _EMU_VMONBUVDDCTRL_THRESFINE_SHIFT)
   2931                                     | (vmonInit->riseWakeup ? EMU_VMONBUVDDCTRL_RISEWU : 0U)
   2932                                     | (vmonInit->fallWakeup ? EMU_VMONBUVDDCTRL_FALLWU : 0U)
   2933                                     | (vmonInit->enable     ? EMU_VMONBUVDDCTRL_EN     : 0U);
   2934                break;
   2935          #endif
   2936              default:
   2937                EFM_ASSERT(false);
   2938                return;
   2939            }
   2940          }
   2941          
   2942          /***************************************************************************//**
   2943           * @brief
   2944           *   Initialize a VMON channel with hysteresis (separate rise and fall triggers).
   2945           *
   2946           * @details
   2947           *   Initialize a VMON channel which supports hysteresis. The AVDD channel is
   2948           *   the only channel to support separate rise and fall triggers. The rise and
   2949           *   fall thresholds will be converted to a register field value based on the
   2950           *   calibration values from the DI page.
   2951           *
   2952           * @param[in] vmonInit
   2953           *   The VMON hysteresis initialization structure.
   2954           ******************************************************************************/
   2955          void EMU_VmonHystInit(const EMU_VmonHystInit_TypeDef *vmonInit)
   2956          {
   2957            uint32_t riseThreshold;
   2958            uint32_t fallThreshold;
   2959          
   2960            /* VMON supports voltages between 1620 mV and 3400 mV (inclusive). */
   2961            EFM_ASSERT((vmonInit->riseThreshold >= 1620) && (vmonInit->riseThreshold <= 3400));
   2962            EFM_ASSERT((vmonInit->fallThreshold >= 1620) && (vmonInit->fallThreshold <= 3400));
   2963            /* The fall threshold has to be lower than rise threshold. */
   2964            EFM_ASSERT(vmonInit->fallThreshold <= vmonInit->riseThreshold);
   2965          
   2966            riseThreshold = vmonCalibratedThreshold(vmonInit->channel, vmonInit->riseThreshold);
   2967            fallThreshold = vmonCalibratedThreshold(vmonInit->channel, vmonInit->fallThreshold);
   2968          
   2969            switch (vmonInit->channel) {
   2970              case emuVmonChannel_AVDD:
   2971                EMU->VMONAVDDCTRL = ((riseThreshold / 10U) << _EMU_VMONAVDDCTRL_RISETHRESCOARSE_SHIFT)
   2972                                    | ((riseThreshold % 10U) << _EMU_VMONAVDDCTRL_RISETHRESFINE_SHIFT)
   2973                                    | ((fallThreshold / 10U) << _EMU_VMONAVDDCTRL_FALLTHRESCOARSE_SHIFT)
   2974                                    | ((fallThreshold % 10U) << _EMU_VMONAVDDCTRL_FALLTHRESFINE_SHIFT)
   2975                                    | (vmonInit->riseWakeup ? EMU_VMONAVDDCTRL_RISEWU : 0U)
   2976                                    | (vmonInit->fallWakeup ? EMU_VMONAVDDCTRL_FALLWU : 0U)
   2977                                    | (vmonInit->enable     ? EMU_VMONAVDDCTRL_EN     : 0U);
   2978                break;
   2979              default:
   2980                EFM_ASSERT(false);
   2981                return;
   2982            }
   2983          }
   2984          
   2985          /***************************************************************************//**
   2986           * @brief
   2987           *   Enable or disable a VMON channel.
   2988           *
   2989           * @param[in] channel
   2990           *   A VMON channel to enable/disable.
   2991           *
   2992           * @param[in] enable
   2993           *   Indicates whether to enable or disable.
   2994           ******************************************************************************/
   2995          void EMU_VmonEnable(EMU_VmonChannel_TypeDef channel, bool enable)
   2996          {
   2997            uint32_t volatile * reg;
   2998            uint32_t bit;
   2999          
   3000            switch (channel) {
   3001              case emuVmonChannel_AVDD:
   3002                reg = &(EMU->VMONAVDDCTRL);
   3003                bit = _EMU_VMONAVDDCTRL_EN_SHIFT;
   3004                break;
   3005              case emuVmonChannel_ALTAVDD:
   3006                reg = &(EMU->VMONALTAVDDCTRL);
   3007                bit = _EMU_VMONALTAVDDCTRL_EN_SHIFT;
   3008                break;
   3009              case emuVmonChannel_DVDD:
   3010                reg = &(EMU->VMONDVDDCTRL);
   3011                bit = _EMU_VMONDVDDCTRL_EN_SHIFT;
   3012                break;
   3013              case emuVmonChannel_IOVDD0:
   3014                reg = &(EMU->VMONIO0CTRL);
   3015                bit = _EMU_VMONIO0CTRL_EN_SHIFT;
   3016                break;
   3017          #if defined(_EMU_VMONIO1CTRL_EN_MASK)
   3018              case emuVmonChannel_IOVDD1:
   3019                reg = &(EMU->VMONIO1CTRL);
   3020                bit = _EMU_VMONIO1CTRL_EN_SHIFT;
   3021                break;
   3022          #endif
   3023          #if defined(_EMU_VMONBUVDDCTRL_EN_MASK)
   3024              case emuVmonChannel_BUVDD:
   3025                reg = &(EMU->VMONBUVDDCTRL);
   3026                bit = _EMU_VMONBUVDDCTRL_EN_SHIFT;
   3027                break;
   3028          #endif
   3029              default:
   3030                EFM_ASSERT(false);
   3031                return;
   3032            }
   3033          
   3034            BUS_RegBitWrite(reg, bit, (uint32_t)enable);
   3035          }
   3036          
   3037          /***************************************************************************//**
   3038           * @brief
   3039           *   Get the status of a voltage monitor channel.
   3040           *
   3041           * @param[in] channel
   3042           *   A VMON channel to get the status for.
   3043           *
   3044           * @return
   3045           *   A status of the selected VMON channel. True if the channel is triggered.
   3046           ******************************************************************************/
   3047          bool EMU_VmonChannelStatusGet(EMU_VmonChannel_TypeDef channel)
   3048          {
   3049            uint32_t bit;
   3050            switch (channel) {
   3051              case emuVmonChannel_AVDD:
   3052                bit = _EMU_STATUS_VMONAVDD_SHIFT;
   3053                break;
   3054              case emuVmonChannel_ALTAVDD:
   3055                bit = _EMU_STATUS_VMONALTAVDD_SHIFT;
   3056                break;
   3057              case emuVmonChannel_DVDD:
   3058                bit = _EMU_STATUS_VMONDVDD_SHIFT;
   3059                break;
   3060              case emuVmonChannel_IOVDD0:
   3061                bit = _EMU_STATUS_VMONIO0_SHIFT;
   3062                break;
   3063          #if defined(_EMU_VMONIO1CTRL_EN_MASK)
   3064              case emuVmonChannel_IOVDD1:
   3065                bit = _EMU_STATUS_VMONIO1_SHIFT;
   3066                break;
   3067          #endif
   3068          #if defined(_EMU_VMONBUVDDCTRL_EN_MASK)
   3069              case emuVmonChannel_BUVDD:
   3070                bit = _EMU_STATUS_VMONBUVDD_SHIFT;
   3071                break;
   3072          #endif
   3073              default:
   3074                bit = 0;
   3075                EFM_ASSERT(false);
   3076                break;
   3077            }
   3078          
   3079            return BUS_RegBitRead(&EMU->STATUS, bit) != 0U;
   3080          }
   3081          #endif /* EMU_STATUS_VMONRDY */
   3082          
   3083          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_80)
   3084          /***************************************************************************//**
   3085           * @brief
   3086           *   Adjust the bias refresh rate.
   3087           *
   3088           * @details
   3089           *   This function is only meant to be used under high-temperature operation on
   3090           *   EFR32xG1 and EFM32xG1 devices. Adjusting the bias mode will
   3091           *   increase the typical current consumption. See application note 1027
   3092           *   and errata documents for more details.
   3093           *
   3094           * @param [in] mode
   3095           *   The new bias refresh rate.
   3096           ******************************************************************************/
   3097          void EMU_SetBiasMode(EMU_BiasMode_TypeDef mode)
   3098          {
   3099          #define EMU_TESTLOCK         (*(volatile uint32_t *) (EMU_BASE + 0x190))
   3100          #define EMU_BIASCONF         (*(volatile uint32_t *) (EMU_BASE + 0x164))
   3101          #define EMU_BIASTESTCTRL     (*(volatile uint32_t *) (EMU_BASE + 0x19C))
   3102          #define CMU_ULFRCOCTRL       (*(volatile uint32_t *) (CMU_BASE + 0x03C))
   3103          
   3104            uint32_t freq = 0x2u;
   3105            bool emuTestLocked = false;
   3106          
   3107            if (mode == emuBiasMode_1KHz) {
   3108              freq = 0x0u;
   3109            }
   3110          
   3111            if (EMU_TESTLOCK == 0x1u) {
   3112              emuTestLocked = true;
   3113              EMU_TESTLOCK = 0xADE8u;
   3114            }
   3115          
   3116            if (mode == emuBiasMode_Continuous) {
   3117              EMU_BIASCONF &= ~0x74u;
   3118            } else {
   3119              EMU_BIASCONF |= 0x74u;
   3120            }
   3121          
   3122            EMU_BIASTESTCTRL |= 0x8u;
   3123            CMU_ULFRCOCTRL    = (CMU_ULFRCOCTRL & ~0xC00u)
   3124                                | ((freq & 0x3u) << 10u);
   3125            EMU_BIASTESTCTRL &= ~0x8u;
   3126          
   3127            if (emuTestLocked) {
   3128              EMU_TESTLOCK = 0u;
   3129            }
   3130          }
   3131          #endif
   3132          
   3133          /** @} (end addtogroup EMU) */
   3134          /** @} (end addtogroup emlib) */
   3135          #endif /* __EM_EMU_H */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   EMU_EM23Init
       0   EMU_EM23PostsleepHook
       0   EMU_EM23PresleepHook
       0   EMU_EM4Init
       8   EMU_EnterEM2
         8   -> EMU_EM23PostsleepHook
         8   -> EMU_EM23PresleepHook
         0   -> SystemCoreClockUpdate
       8   EMU_EnterEM3
         8   -> EMU_EM23PostsleepHook
         8   -> EMU_EM23PresleepHook
         0   -> SystemCoreClockUpdate
       0   EMU_EnterEM4
       0   EMU_EnterEM4H
         0   -> EMU_EnterEM4
       0   EMU_EnterEM4S
         0   -> EMU_EnterEM4
       0   EMU_MemPwrDown
       8   EMU_RamPowerDown
       0   EMU_RamPowerUp
       0   EMU_Restore
       0   EMU_Save
       0   EMU_UpdateOscConfig
       0   SystemCoreClockUpdate
         0   -> SystemHCLKGet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       6  ?Subroutine0
      16  ?Subroutine1
       2  EMU_EM23Init
       2  EMU_EM23PostsleepHook
       2  EMU_EM23PresleepHook
      16  EMU_EM4Init
      18  EMU_EnterEM2
      18  EMU_EnterEM3
      38  EMU_EnterEM4
       2  EMU_EnterEM4H
       2  EMU_EnterEM4S
       2  EMU_MemPwrDown
      50  EMU_RamPowerDown
       8  EMU_RamPowerUp
       2  EMU_Restore
       2  EMU_Save
       2  EMU_UpdateOscConfig
       4  SystemCoreClockUpdate

 
 212 bytes in section .text
 
 208 bytes of CODE memory (+ 4 bytes shared)

Errors: none
Warnings: none
