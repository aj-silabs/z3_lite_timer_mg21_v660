###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:37
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\sl_crypto\src\crypto_ecp.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW1D07.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\sl_crypto\src\crypto_ecp.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"crypto_ecp.c\"" -D PSSTORE_SIZE=0 -D
#        LONGTOKEN_SIZE=0 -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\sl_crypto\src\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\crypto_ecp.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\crypto_ecp.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\sl_crypto\src\crypto_ecp.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Elliptic curves over GF(p): CRYPTO hw acceleration functions
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: APACHE-2.0
     10           *
     11           * This software is subject to an open source license and is distributed by
     12           * Silicon Laboratories Inc. pursuant to the terms of the Apache License,
     13           * Version 2.0 available at https://www.apache.org/licenses/LICENSE-2.0.
     14           * Such terms and conditions may be further supplemented by the Silicon Labs
     15           * Master Software License Agreement (MSLA) available at www.silabs.com and its
     16           * sections applicable to open source software.
     17           *
     18           ******************************************************************************/
     19          
     20          /*
     21           * This file includes alternative plugin implementations of various
     22           * functions in ecp.c using the CRYPTO hardware accelerator incorporated
     23           * in MCU devices from Silicon Laboratories.
     24           */
     25           
     26          /*
     27           * References:
     28           *
     29           * SEC1 http://www.secg.org/index.php?action=secg,docs_secg
     30           * GECC = Guide to Elliptic Curve Cryptography - Hankerson, Menezes, Vanstone
     31           * FIPS 186-3 http://csrc.nist.gov/publications/fips/fips186-3/fips_186-3.pdf
     32           * RFC 4492 for the related TLS structures and constants
     33           *
     34           * [Curve25519] http://cr.yp.to/ecdh/curve25519-20060209.pdf
     35           *
     36           * [2] CORON, Jean-S'ebastien. Resistance against differential power analysis
     37           *     for elliptic curve cryptosystems. In : Cryptographic Hardware and
     38           *     Embedded Systems. Springer Berlin Heidelberg, 1999. p. 292-302.
     39           *     <http://link.springer.com/chapter/10.1007/3-540-48059-5_25>
     40           *
     41           * [3] HEDABOU, Mustapha, PINEL, Pierre, et B'EN'ETEAU, Lucien. A comb method to
     42           *     render ECC resistant against Side Channel Attacks. IACR Cryptology
     43           *     ePrint Archive, 2004, vol. 2004, p. 342.
     44           *     <http://eprint.iacr.org/2004/342.pdf>
     45           */
     46          
     47          #include "mbedtls/ecp.h"
     48          #include "mbedtls/ecp_internal.h"
     49          
     50          #include "em_device.h"
     51          
     52          #if defined( CRYPTO_PRESENT )
     53          #if defined( MBEDTLS_ECP_C )
     54          #if defined( MBEDTLS_ECP_INTERNAL_ALT )
     55          
     56          #include "mbedtls/platform.h"
     57          #include "em_crypto.h"
     58          #include "em_core.h"
     59          #include "crypto_management.h"
     60          
     61          #include <stdbool.h>
     62          #include <string.h>
     63          
     64          /** ECC big integer type. */
     65          #define ECC_BIGINT_SIZE_IN_BITS        (256)
     66          #define ECC_BIGINT_SIZE_IN_BYTES       (ECC_BIGINT_SIZE_IN_BITS/8)
     67          #define ECC_BIGINT_SIZE_IN_32BIT_WORDS (ECC_BIGINT_SIZE_IN_BYTES/sizeof(uint32_t))
     68          #define EC_BIGINT_COPY(X, Y) memcpy((X), (Y), sizeof(ecc_bigint_t));
     69          typedef uint32_t ecc_bigint_t[ECC_BIGINT_SIZE_IN_32BIT_WORDS];
     70          
     71          #define SLCL_ECP_CHK(f) do { if( ( ret = (f) ) != 0 ) goto cleanup; } while( 0 )
     72          
     73          #if defined(MBEDTLS_ECP_NORMALIZE_JAC_MANY_ALT) || defined(MBEDTLS_ECP_NORMALIZE_JAC_ALT)
     74          #define MPI_TO_BIGINT(bigint, mpi) mpitobigint((bigint), (mpi));
     75          
     76          /***************************************************************************//**
     77           * @brief
     78           *   Convert an mpi number representation to a 32bit word array used by crypto.
     79           ******************************************************************************/
     80          __STATIC_INLINE void mpitobigint( ecc_bigint_t bigint, const mbedtls_mpi* mpi )
     81          {
     82              uint32_t* bi = bigint;
     83          
     84              if ( mpi->n < ECC_BIGINT_SIZE_IN_32BIT_WORDS )
     85              {
     86                  memcpy(bigint, mpi->p, mpi->n * sizeof(uint32_t));
     87                  memset(&bi[mpi->n], 0, ECC_BIGINT_SIZE_IN_BYTES - ( mpi->n * sizeof(uint32_t) ));
     88              }
     89              else
     90              {
     91                  /* mpi has more room than bigint, so only store up to sizeof(bigint) */
     92                  memcpy(bigint, mpi->p, ECC_BIGINT_SIZE_IN_BYTES);
     93              }
     94          }
     95          
     96          /***************************************************************************//**
     97           * @brief
     98           *   Returns true if the value of the DDATA0 register is equal to zero.
     99           ******************************************************************************/
    100          __STATIC_INLINE bool crypto_ddata0_is_zero(CRYPTO_TypeDef* crypto,
    101                                                     uint32_t*       status_reg)
    102          {
    103              CORE_DECLARE_IRQ_STATE;
    104              CORE_ENTER_CRITICAL();
    105              CRYPTO_EXECUTE_3(crypto,
    106                               CRYPTO_CMD_INSTR_CCLR,
    107                               CRYPTO_CMD_INSTR_DEC,  /* Decrement by one which will set
    108                                                         carry bit if DDATA0 is zero. */
    109                               CRYPTO_CMD_INSTR_INC   /* Increment in order to restore
    110                                                         original value. */
    111                               );
    112          
    113              *status_reg = crypto->DSTATUS;
    114              CORE_EXIT_CRITICAL();
    115          
    116              return (*status_reg & CRYPTO_DSTATUS_CARRY) == CRYPTO_DSTATUS_CARRY;
    117          }
    118          
    119          /***************************************************************************//**
    120           * @brief
    121           *   Modular division using CRYPTO hardware acceleration.
    122           *
    123           * @details
    124           *   This function computes R = X/Y mod(N) using CRYPTO hardware acceleration.
    125           *   The implementation is not a direct replacement plugin, i.e. alternative
    126           *   implementation, of an existing mbedtls function. This function is used
    127           *   internally in other CRYPTO plugin functions indirectly replacing
    128           *   mbedtls_mpi_inv_mod.
    129           *
    130           *  @param[in]  X        Dividend of modular division operation
    131           *  @param[in]  Y        Divisor of  modular division operation
    132           *  @param[in]  N        Modulus
    133           *  @param[out] R        The destination of the result
    134           *
    135           * @return N/A
    136           ******************************************************************************/
    137          static void crypto_mpi_div_mod(CRYPTO_TypeDef *crypto,
    138                                          ecc_bigint_t   X,
    139                                          ecc_bigint_t   Y,
    140                                          ecc_bigint_t   N,
    141                                          ecc_bigint_t   R)
    142          {
    143              uint32_t            D[9];
    144              uint32_t            status_reg;
    145              uint8_t             rdata;
    146              uint8_t             lsb_C;
    147              uint8_t             lsb_D;
    148              uint8_t             lsb_U;
    149              int                 t;
    150              int                 k;
    151              CORE_DECLARE_IRQ_STATE;
    152          
    153              /************** Initialize and organize data in crypto module **************/
    154          
    155              /*
    156              ** Register usage:
    157              **
    158              ** DDATA0 - holds temporary results and loads 260 bit variables in/out
    159              ** DDATA1 - variable referred to as 'C' in the following algorithm
    160              ** DDATA2 - variable referred to as 'U' in the following algorithm
    161              ** DDATA3 - variable referred to as 'D' in the following algorithm
    162              ** DDATA4 - variable referred to as 'W' in the following algorithm
    163              */
    164          
    165              EC_BIGINT_COPY(D, N);             /* D will hold the modulus (n) initially */
    166              D[8]=0;                           /* Set MSWord of D to 0. */
    167          
    168              CORE_ENTER_CRITICAL();
    169              CRYPTO_DDataWrite(&crypto->DDATA1, Y);  /* Set C to Y (divisor) initially */
    170              CRYPTO_DDataWrite(&crypto->DDATA2, X);  /* Set U to X (dividend)initially */
    171              CRYPTO_DDataWrite(&crypto->DDATA3, N);  /* Set D to modulus p initially   */
    172              CORE_EXIT_CRITICAL();
    173          
    174              CRYPTO_EXECUTE_3(crypto,
    175                               CRYPTO_CMD_INSTR_CLR,            /* DDATA0 = 0 */
    176                               CRYPTO_CMD_INSTR_DDATA0TODDATA4, /* Set W to zero initially*/
    177                               CRYPTO_CMD_INSTR_DDATA1TODDATA0);/* DDATA0 = C initially */
    178          
    179              t     = 0;
    180              k     = 1;
    181          
    182              /******************* Run main loop while 'C' is non-zero ********************/
    183          
    184              /* while (C != 1024'd0)  */
    185              while ( !crypto_ddata0_is_zero(crypto, &status_reg) )
    186              {
    187          
    188                  lsb_C = (status_reg & _CRYPTO_DSTATUS_DDATA0LSBS_MASK) >> _CRYPTO_DSTATUS_DDATA0LSBS_SHIFT;
    189                  if ((lsb_C & 0x1) == 0)
    190                  {
    191                      CRYPTO_EXECUTE_3(crypto,
    192                                       CRYPTO_CMD_INSTR_SELDDATA1DDATA1,
    193                                       CRYPTO_CMD_INSTR_SHRA,
    194                                       CRYPTO_CMD_INSTR_DDATA0TODDATA1
    195                                       );
    196                      t = t-1;
    197                  }
    198                  else
    199                  {
    200                      if (t<0)
    201                      {
    202                          CRYPTO_EXECUTE_6(crypto,
    203                                           CRYPTO_CMD_INSTR_DDATA2TODDATA0,
    204                                           CRYPTO_CMD_INSTR_DDATA4TODDATA2,
    205                                           CRYPTO_CMD_INSTR_DDATA0TODDATA4,
    206                                           CRYPTO_CMD_INSTR_DDATA1TODDATA0,
    207                                           CRYPTO_CMD_INSTR_DDATA3TODDATA1,
    208                                           CRYPTO_CMD_INSTR_DDATA0TODDATA3);
    209                          CORE_ENTER_CRITICAL();
    210                          CRYPTO_DDATA0_260_BITS_READ(crypto, D);
    211                          CORE_EXIT_CRITICAL();
    212                          t = -t;
    213                      }
    214          
    215                      k = 1;
    216          
    217                      CRYPTO_EXECUTE_2(crypto,
    218                                       CRYPTO_CMD_INSTR_SELDDATA1DDATA3,
    219                                       CRYPTO_CMD_INSTR_ADD);
    220          
    221                      rdata = CRYPTO_DData0_4LSBitsRead(crypto);
    222          
    223                      if((rdata & 0x3) != 0x0)
    224                        k = -1;
    225                      else
    226                        t = t-1;
    227          
    228                      /*  R1 = C >> 1  */
    229                      crypto->CMD = CRYPTO_CMD_INSTR_DDATA1TODDATA0; /* to get the lsb of C */
    230          
    231                      lsb_C = CRYPTO_DData0_4LSBitsRead(crypto);
    232                      CRYPTO_EXECUTE_4(crypto,
    233                                       CRYPTO_CMD_INSTR_SELDDATA1DDATA1,
    234                                       CRYPTO_CMD_INSTR_SHRA,
    235                                       CRYPTO_CMD_INSTR_DDATA0TODDATA1,
    236                                       CRYPTO_CMD_INSTR_DDATA3TODDATA0); /* to get the lsb of D(R3) */
    237          
    238                      /*  R3 = D >> 1  */
    239                      lsb_D = CRYPTO_DData0_4LSBitsRead(crypto);
    240          
    241                      CRYPTO_EXECUTE_2(crypto,
    242                                       CRYPTO_CMD_INSTR_SELDDATA3DDATA3,
    243                                       CRYPTO_CMD_INSTR_SHRA);
    244          
    245                      if(k == 1)
    246                      {
    247                          if (((lsb_C & 0x1)==0x1) && ((lsb_D & 0x1)==0x1))
    248                          {
    249                              CRYPTO_EXECUTE_7(crypto,
    250                                               /*  C = R1+R3+1  */
    251                                               CRYPTO_CMD_INSTR_SELDDATA0DDATA1,
    252                                               CRYPTO_CMD_INSTR_CSET,
    253                                               CRYPTO_CMD_INSTR_ADDC,
    254                                               CRYPTO_CMD_INSTR_DDATA0TODDATA1,
    255                                               /*  U = mod(R2+R4,n)  */
    256                                               CRYPTO_CMD_INSTR_SELDDATA2DDATA4,
    257                                               CRYPTO_CMD_INSTR_MADD,
    258                                               CRYPTO_CMD_INSTR_DDATA0TODDATA2
    259                                               );
    260                          }
    261                          else
    262                          {
    263                              CRYPTO_EXECUTE_6(crypto,
    264                                               /*  C = R1+R3  */
    265                                               CRYPTO_CMD_INSTR_SELDDATA0DDATA1,
    266                                               CRYPTO_CMD_INSTR_ADD,
    267                                               CRYPTO_CMD_INSTR_DDATA0TODDATA1,
    268                                               /*  U = mod(R2+R4,n)  */
    269                                               CRYPTO_CMD_INSTR_SELDDATA2DDATA4,
    270                                               CRYPTO_CMD_INSTR_MADD,
    271                                               CRYPTO_CMD_INSTR_DDATA0TODDATA2
    272                                               );
    273                          }
    274                      }
    275                      else
    276                      {
    277                          if (k == -1)
    278                          {
    279                              if (((lsb_C & 0x1)==0x0) && ((lsb_D & 0x1)==0x1))
    280                              {
    281                                  CRYPTO_EXECUTE_8(crypto,
    282                                                   /*  C = R1-R3-1  */
    283                                                   CRYPTO_CMD_INSTR_DDATA0TODDATA3,
    284                                                   CRYPTO_CMD_INSTR_SELDDATA1DDATA3,
    285                                                   CRYPTO_CMD_INSTR_CSET,
    286                                                   CRYPTO_CMD_INSTR_SUBC,
    287                                                   CRYPTO_CMD_INSTR_DDATA0TODDATA1,
    288                                                   /*  U = mod(R2-R4,p)  */
    289                                                   CRYPTO_CMD_INSTR_SELDDATA2DDATA4,
    290                                                   CRYPTO_CMD_INSTR_MSUB,
    291                                                   CRYPTO_CMD_INSTR_DDATA0TODDATA2
    292                                                   );
    293                              }
    294                              else
    295                              {
    296                                  CRYPTO_EXECUTE_7(crypto,
    297                                                   /*  C = R1+R3  */
    298                                                   CRYPTO_CMD_INSTR_DDATA0TODDATA3,
    299                                                   CRYPTO_CMD_INSTR_SELDDATA1DDATA3,
    300                                                   CRYPTO_CMD_INSTR_SUB,
    301                                                   CRYPTO_CMD_INSTR_DDATA0TODDATA1,
    302                                                   /*  U = mod(R2-R4,p)  */
    303                                                   CRYPTO_CMD_INSTR_SELDDATA2DDATA4,
    304                                                   CRYPTO_CMD_INSTR_MSUB,
    305                                                   CRYPTO_CMD_INSTR_DDATA0TODDATA2
    306                                                   );
    307                              }
    308          
    309                              CRYPTO_DDATA0_260_BITS_WRITE(crypto, D);
    310                              crypto->CMD = CRYPTO_CMD_INSTR_DDATA0TODDATA3;
    311          
    312                          } /* if (k == -1) */
    313                      }
    314                  } /* else: !if((C[31:0] & 0x1) == 0x0) */
    315          
    316                  crypto->CMD = CRYPTO_CMD_INSTR_DDATA2TODDATA0;
    317          
    318                  lsb_U = CRYPTO_DData0_4LSBitsRead(crypto);
    319          
    320                  /* if ((U[31:0] & 0x1) == 0x1) */
    321                  if((lsb_U & 0x1) == 0x1)
    322                  {
    323                      CRYPTO_EXECUTE_3( crypto,
    324                                        CRYPTO_CMD_INSTR_SELDDATA2DDATA2,
    325                                        CRYPTO_CMD_INSTR_SHRA,
    326                                        CRYPTO_CMD_INSTR_DDATA0TODDATA2);
    327          
    328                      CORE_ENTER_CRITICAL();
    329                      CRYPTO_DDataWrite(&crypto->DDATA0, N);
    330                      CORE_EXIT_CRITICAL();
    331          
    332                      CRYPTO_EXECUTE_6( crypto,
    333                                        CRYPTO_CMD_INSTR_SELDDATA0DDATA0,
    334                                        CRYPTO_CMD_INSTR_SHR,
    335                                        CRYPTO_CMD_INSTR_SELDDATA0DDATA2,
    336                                        CRYPTO_CMD_INSTR_CSET,
    337                                        CRYPTO_CMD_INSTR_ADDC,
    338                                        CRYPTO_CMD_INSTR_DDATA0TODDATA2);
    339                  }
    340                  else
    341                  {
    342                      CRYPTO_EXECUTE_3(crypto,
    343                                       CRYPTO_CMD_INSTR_SELDDATA2DDATA2,
    344                                       CRYPTO_CMD_INSTR_SHRA,
    345                                       CRYPTO_CMD_INSTR_DDATA0TODDATA2);
    346                  }
    347          
    348                  /* DDATA0 = C */
    349                  crypto->CMD = CRYPTO_CMD_INSTR_DDATA1TODDATA0;
    350          
    351              } /* End of main loop:  while (C != 0)  */
    352          
    353              /* if (D == 1): */
    354              /* Decrement D by 1 and test if zero. */
    355              CRYPTO_EXECUTE_2(crypto,
    356                               CRYPTO_CMD_INSTR_DDATA3TODDATA0,
    357                               CRYPTO_CMD_INSTR_DEC);
    358          
    359              if (crypto_ddata0_is_zero(crypto, &status_reg))
    360              {
    361                  CORE_ENTER_CRITICAL();
    362                  CRYPTO_DDataRead(&crypto->DDATA4, R);
    363                  CORE_EXIT_CRITICAL();
    364              }
    365              else
    366              {
    367                  CORE_ENTER_CRITICAL();
    368                  CRYPTO_DDataWrite(&crypto->DDATA0, N);
    369                  CORE_EXIT_CRITICAL();
    370          
    371                  CRYPTO_EXECUTE_2(crypto,
    372                                   CRYPTO_CMD_INSTR_SELDDATA0DDATA4,
    373                                   CRYPTO_CMD_INSTR_SUB
    374                                   );
    375          
    376                  CORE_ENTER_CRITICAL();
    377                  CRYPTO_DDataRead(&crypto->DDATA0, R);
    378                  CORE_EXIT_CRITICAL();
    379              }
    380              return;
    381          } /* crypto_mpi_div_mod  */
    382          #endif /* MBEDTLS_ECP_NORMALIZE_JAC_MANY_ALT || MBEDTLS_ECP_NORMALIZE_JAC_ALT */
    383          
    384          /***************************************************************************//**
    385           * @brief
    386           *   Enable CRYPTO by setting up control registers for given ecc curve.
    387           ******************************************************************************/
    388          static int ecp_crypto_device_init( CRYPTO_TypeDef *device, const mbedtls_ecp_group *grp)
    389          {
    390              int             ret = 0;
    391          
    392              /* Setup CRYPTO registers for ECC operation */
    393              device->CTRL     = 0;
    394              device->SEQCTRL  = CRYPTO_SEQCTRL_BLOCKSIZE_32BYTES | 32;
    395              device->SEQCTRLB = 0;
    396          
    397              switch( grp->id )
    398              {
    399          #if defined(MBEDTLS_ECP_DP_SECP192R1_ENABLED)
    400                  case MBEDTLS_ECP_DP_SECP192R1:
    401                      CRYPTO_ModulusSet( device, cryptoModulusEccP192 );
    402                      CRYPTO_MulOperandWidthSet( device, cryptoMulOperandModulusBits );
    403                      CRYPTO_ResultWidthSet( device, cryptoResult256Bits );
    404                  break;
    405          #endif /* MBEDTLS_ECP_DP_SECP192R1_ENABLED */
    406          
    407          #if defined(MBEDTLS_ECP_DP_SECP224R1_ENABLED)
    408                  case MBEDTLS_ECP_DP_SECP224R1:
    409                      CRYPTO_ModulusSet( device, cryptoModulusEccP224 );
    410                      CRYPTO_MulOperandWidthSet( device, cryptoMulOperandModulusBits );
    411                      CRYPTO_ResultWidthSet( device, cryptoResult256Bits );
    412                  break;
    413          #endif /* MBEDTLS_ECP_DP_SECP224R1_ENABLED */
    414          
    415          #if defined(MBEDTLS_ECP_DP_SECP256R1_ENABLED)
    416                  case MBEDTLS_ECP_DP_SECP256R1:
    417                      CRYPTO_ModulusSet( device, cryptoModulusEccP256 );
    418                      CRYPTO_MulOperandWidthSet( device, cryptoMulOperandModulusBits );
    419                      CRYPTO_ResultWidthSet( device, cryptoResult260Bits );
    420                  break;
    421          #endif /* MBEDTLS_ECP_DP_SECP256R1_ENABLED */
    422          
    423                  default:
    424                      ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
    425                  break;
    426              }
    427          
    428              return( ret );
    429          }
    430          
    431          /***************************************************************************//**
    432           * @brief
    433           *   Write 256 bits of data to a DDATAX register in the CRYPTO module.
    434           *
    435           * @details
    436           *   Write 256 bits of data into a DDATAX (Double Data) register in the crypto
    437           *   module.
    438           *
    439           *  @param[in]  ddataReg   Data register identifier
    440           *  @param[in]  val        Value of the data to write to the DDATA register.
    441           ******************************************************************************/
    442          __STATIC_INLINE void ecp_crypto_ddata_write(CRYPTO_DDataReg_TypeDef  ddataReg,
    443                                                      const mbedtls_mpi*       mpi)
    444          {
    445            uint32_t volatile* regPtr = (volatile uint32_t *) ddataReg;
    446            uint32_t* pVal = mpi->p;
    447            register uint32_t v0;
    448            register uint32_t v1;
    449            register uint32_t v2;
    450            register uint32_t v3;
    451            int      i;
    452          
    453            if (mpi->n <4)
    454            {
    455              /* Non optimal write of data. */
    456              for (i=0; i<(int)mpi->n; i++)
    457                *regPtr = *pVal++;
    458              for (; i<8; i++)
    459                *regPtr = 0;
    460            }
    461            else
    462            {
    463              if (mpi->n < 8)
    464              {
    465                /* Optimal write of first 4 words. */
    466                v0 = *pVal++;
    467                v1 = *pVal++;
    468                v2 = *pVal++;
    469                v3 = *pVal++;
    470                *regPtr = v0;
    471                *regPtr = v1;
    472                *regPtr = v2;
    473                *regPtr = v3;
    474          
    475                /* Non optimal write of remaining words */
    476                for (i=4; i<(int)mpi->n; i++)
    477                  *regPtr = *pVal++;
    478                for (; i<8; i++)
    479                  *regPtr = 0;
    480              }
    481              else
    482              {
    483                /* Optimal write of all data. */
    484                v0 = *pVal++;
    485                v1 = *pVal++;
    486                v2 = *pVal++;
    487                v3 = *pVal++;
    488                *regPtr = v0;
    489                *regPtr = v1;
    490                *regPtr = v2;
    491                *regPtr = v3;
    492          
    493                v0 = *pVal++;
    494                v1 = *pVal++;
    495                v2 = *pVal++;
    496                v3 = *pVal++;
    497                *regPtr = v0;
    498                *regPtr = v1;
    499                *regPtr = v2;
    500                *regPtr = v3;
    501              }
    502            }
    503          }
    504          
    505          /***************************************************************************//**
    506           * @brief
    507           *   Read 256 bits of data from a DDATAX register in the CRYPTO module.
    508           *
    509           * @details
    510           *   Read 256 bits of data from a DDATAX (Double Data) register in the crypto
    511           *   module.
    512           *
    513           *  @param[in]  ddataReg   Data register identifier
    514           *  @param[out] val        Location where to store the value in memory.
    515           ******************************************************************************/
    516          
    517          __STATIC_INLINE int ecp_crypto_ddata_read(CRYPTO_DDataReg_TypeDef  ddataReg,
    518                                                    mbedtls_mpi*             mpi)
    519          {
    520            CRYPTO_DData_TypeDef  ddata;
    521            uint32_t              val32;
    522            int                   i;
    523            int                   used;
    524            int                   ret = 0;
    525            CORE_DECLARE_IRQ_STATE;
    526          
    527            if (mpi->n == 8)
    528            {
    529              CORE_ENTER_CRITICAL();
    530              CRYPTO_DDataRead(ddataReg, mpi->p);
    531              CORE_EXIT_CRITICAL();
    532            }
    533            else
    534            {
    535              if (mpi->n > 8)
    536              {
    537                CORE_ENTER_CRITICAL();
    538                CRYPTO_DDataRead(ddataReg, mpi->p);
    539                CORE_EXIT_CRITICAL();
    540                memset(&mpi->p[8], 0, sizeof(uint32_t)*(mpi->n-8));
    541              }
    542              else
    543              {
    544                uint32_t volatile* regPtr = (volatile uint32_t*) ddataReg;
    545                used = 0;
    546                for (i=0; i<8; i++)
    547                {
    548                  ddata[i] = val32 = *regPtr;
    549                  if (val32)
    550                    used = i+1;
    551                }
    552                if (used > (int)mpi->n)
    553                {
    554                  SLCL_ECP_CHK( mbedtls_mpi_grow(mpi, used) );
    555                  memcpy(mpi->p, ddata, used*sizeof(uint32_t));
    556                  mpi->s = 1;
    557                }
    558                else
    559                {
    560                  memcpy(mpi->p, ddata, mpi->n*sizeof(uint32_t));
    561                }
    562              }
    563            }
    564           cleanup:
    565            return( ret );
    566          }
    567          
    568          /**
    569           * \brief           Indicate if the Elliptic Curve Point module extension can
    570           *                  handle the group.
    571           *
    572           * \param grp       The pointer to the elliptic curve group that will be the
    573           *                  basis of the cryptographic computations.
    574           *
    575           * \return          Non-zero if successful.
    576           */
    577          unsigned char mbedtls_internal_ecp_grp_capable( const mbedtls_ecp_group *grp )
    578          {
    579              switch( grp->id )
    580              {
    581          #if defined(MBEDTLS_ECP_DP_SECP192R1_ENABLED)
    582                  case MBEDTLS_ECP_DP_SECP192R1:
    583                      return( true );
    584          #endif /* MBEDTLS_ECP_DP_SECP192R1_ENABLED */
    585          
    586          #if defined(MBEDTLS_ECP_DP_SECP224R1_ENABLED)
    587                  case MBEDTLS_ECP_DP_SECP224R1:
    588                      return( true );
    589          #endif /* MBEDTLS_ECP_DP_SECP224R1_ENABLED */
    590          
    591          #if defined(MBEDTLS_ECP_DP_SECP256R1_ENABLED)
    592                  case MBEDTLS_ECP_DP_SECP256R1:
    593                      return( true );
    594          #endif /* MBEDTLS_ECP_DP_SECP256R1_ENABLED */
    595          
    596                  default:
    597                      return( false );
    598              }
    599          }
    600          
    601          /**
    602           * \brief           Initialise the Elliptic Curve Point module extension.
    603           *
    604           *                  If mbedtls_internal_ecp_grp_capable returns true for a
    605           *                  group, this function has to be able to initialise the
    606           *                  module for it.
    607           *
    608           *                  This module can be a driver to a crypto hardware
    609           *                  accelerator, for which this could be an initialise function.
    610           *
    611           * \param grp       The pointer to the group the module needs to be
    612           *                  initialised for.
    613           *
    614           * \return          0 if successful.
    615           */
    616          int mbedtls_internal_ecp_init( const mbedtls_ecp_group *grp )
    617          {
    618              /* Crypto operations are atomic, so no need to setup any context here */
    619              (void) grp;
    620              return 0;
    621          }
    622          
    623          /**
    624           * \brief           Frees and deallocates the Elliptic Curve Point module
    625           *                  extension.
    626           *
    627           * \param grp       The pointer to the group the module was initialised for.
    628           */
    629          void mbedtls_internal_ecp_free( const mbedtls_ecp_group *grp )
    630          {
    631              /* Crypto operations are atomic, so no need to free any context here */
    632              (void) grp;
    633          }
    634          
    635          #if defined(MBEDTLS_ECP_RANDOMIZE_JAC_ALT)
    636          /**
    637           * \brief           Randomize jacobian coordinates:
    638           *                  (X, Y, Z) -> (l^2 X, l^3 Y, l Z) for random l.
    639           *
    640           * \param grp       Pointer to the group representing the curve.
    641           *
    642           * \param pt        The point on the curve to be randomised, given with Jacobian
    643           *                  coordinates.
    644           *
    645           * \param f_rng     A function pointer to the random number generator.
    646           *
    647           * \param p_rng     A pointer to the random number generator state.
    648           *
    649           * \return          0 if successful.
    650           */
    651          int mbedtls_internal_ecp_randomize_jac( const mbedtls_ecp_group *grp,
    652                                                  mbedtls_ecp_point *pt,
    653                                                  int (*f_rng)(void *, unsigned char *, size_t),
    654                                                  void *p_rng )
    655          {
    656              int ret;
    657              ecc_bigint_t l;
    658              CORE_DECLARE_IRQ_STATE;
    659              CRYPTO_TypeDef *crypto;
    660          
    661              /* Strategy:
    662               *  1) Generate l such that 1 < l < p
    663               *  2) Z = l (R1) * Z (R4)
    664               *  3) ll (R1) = l (R4) * l
    665               *  4) X = ll (R1) * X (R2)
    666               *  5) lll (R1) = ll (R1) * l (R4)
    667               *  6) Y = lll (R1) * Y (R3)
    668               */
    669          
    670              /* Acquire entropy before grabbing crypto, since the entropy function might use crypto */
    671              /* Generate l such that 1 < l < p */
    672              ret = f_rng(p_rng, (unsigned char *)l, sizeof(l));
    673              if ( ret != 0 ) {
    674                  return( ret );
    675              }
    676          
    677              crypto = crypto_management_acquire();
    678              ecp_crypto_device_init(crypto, grp);
    679          
    680              CORE_ENTER_CRITICAL();
    681              CRYPTO_DDataWrite(&crypto->DDATA1, l);
    682              ecp_crypto_ddata_write(&crypto->DDATA2, &pt->X);
    683              ecp_crypto_ddata_write(&crypto->DDATA3, &pt->Y);
    684              ecp_crypto_ddata_write(&crypto->DDATA4, &pt->Z);
    685              CORE_EXIT_CRITICAL();
    686          
    687              /* Z = l * Z */
    688              CRYPTO_EXECUTE_2 (  crypto,
    689                                  CRYPTO_CMD_INSTR_SELDDATA1DDATA4,
    690                                  CRYPTO_CMD_INSTR_MMUL );
    691              CRYPTO_InstructionSequenceWait(crypto);
    692          
    693              MBEDTLS_MPI_CHK( ecp_crypto_ddata_read(&crypto->DDATA0, &pt->Z) );
    694          
    695              /* X = l^2 * X */
    696              CRYPTO_EXECUTE_6 (  crypto,
    697                                  CRYPTO_CMD_INSTR_DDATA1TODDATA4,
    698                                  CRYPTO_CMD_INSTR_SELDDATA1DDATA4,
    699                                  CRYPTO_CMD_INSTR_MMUL,
    700                                  CRYPTO_CMD_INSTR_DDATA0TODDATA1,
    701                                  CRYPTO_CMD_INSTR_SELDDATA1DDATA2,
    702                                  CRYPTO_CMD_INSTR_MMUL );
    703              CRYPTO_InstructionSequenceWait(crypto);
    704          
    705              MBEDTLS_MPI_CHK( ecp_crypto_ddata_read(&crypto->DDATA0, &pt->X) );
    706          
    707              /* Y = l^3 * Y */
    708              CRYPTO_EXECUTE_5 (  crypto,
    709                                  CRYPTO_CMD_INSTR_SELDDATA1DDATA4,
    710                                  CRYPTO_CMD_INSTR_MMUL,
    711                                  CRYPTO_CMD_INSTR_DDATA0TODDATA1,
    712                                  CRYPTO_CMD_INSTR_SELDDATA1DDATA3,
    713                                  CRYPTO_CMD_INSTR_MMUL );
    714              CRYPTO_InstructionSequenceWait(crypto);
    715          
    716              MBEDTLS_MPI_CHK( ecp_crypto_ddata_read(&crypto->DDATA0, &pt->Y) );
    717          
    718          cleanup:
    719              crypto_management_release( crypto );
    720              return( ret );
    721          }
    722          #endif /* MBEDTLS_ECP_RANDOMIZE_JAC_ALT */
    723          
    724          #if defined(MBEDTLS_ECP_ADD_MIXED_ALT)
    725          /**
    726           * \brief           Addition: R = P + Q, mixed affine-Jacobian coordinates.
    727           *
    728           *                  The coordinates of Q must be normalized (= affine),
    729           *                  but those of P don't need to. R is not normalized.
    730           *
    731           *                  This function is used only as a subrutine of
    732           *                  ecp_mul_comb().
    733           *
    734           *                  Special cases: (1) P or Q is zero, (2) R is zero,
    735           *                      (3) P == Q.
    736           *                  None of these cases can happen as intermediate step in
    737           *                  ecp_mul_comb():
    738           *                      - at each step, P, Q and R are multiples of the base
    739           *                      point, the factor being less than its order, so none of
    740           *                      them is zero;
    741           *                      - Q is an odd multiple of the base point, P an even
    742           *                      multiple, due to the choice of precomputed points in the
    743           *                      modified comb method.
    744           *                  So branches for these cases do not leak secret information.
    745           *
    746           *                  We accept Q->Z being unset (saving memory in tables) as
    747           *                  meaning 1.
    748           *
    749           *                  Cost in field operations if done by [5] 3.22:
    750           *                      1A := 8M + 3S
    751           *
    752           * \param grp       Pointer to the group representing the curve.
    753           *
    754           * \param R         Pointer to a point structure to hold the result.
    755           *
    756           * \param P         Pointer to the first summand, given with Jacobian
    757           *                  coordinates
    758           *
    759           * \param Q         Pointer to the second summand, given with affine
    760           *                  coordinates.
    761           *
    762           * \return          0 if successful.
    763           */
    764          int mbedtls_internal_ecp_add_mixed( const mbedtls_ecp_group *grp,
    765                                              mbedtls_ecp_point *R,
    766                                              const mbedtls_ecp_point *P,
    767                                              const mbedtls_ecp_point *Q )
    768          {
    769              int             ret;
    770              CORE_DECLARE_IRQ_STATE;
    771              CRYPTO_TypeDef *crypto = crypto_management_acquire();
    772          
    773              ecp_crypto_device_init(crypto, grp);
    774          
    775              /*
    776                STEP 1:
    777          
    778                Goals:
    779                A = Qx*Pz^2
    780                B = Qy*Pz^3
    781          
    782                Write Operations:
    783          
    784                R0 = Pz
    785                R0 = Qx
    786                R0 = Qy
    787          
    788                Instructions to be executed:
    789          
    790                1. R0 = DMA = Pz
    791                2. R1 = R0 = Pz
    792                3. R2 = R0 = Pz
    793                4. Select R1, R2
    794                5. R0 = R1 * R2 = Pz^2
    795                6. R1 = R0 = Pz^2
    796          
    797                7.  R0 = DMA = Qx
    798                8.  R3 = R0 = Qx
    799                9.  Select R1, R3
    800                10. R0 = R1 * R3 = Qx * Pz^2
    801                11. R3 = R0 = Qx * Pz^2
    802          
    803                12. Select R1, R2
    804                13. R0 = R1 * R2 = Pz^3
    805                14. R1 = R0 = Pz^3
    806          
    807                15. R0 = DMA = Qy
    808                16. R4 = R0 = Qx
    809                17. Select R1, R4
    810                18. R0 = R1 * R4 = Qy * Pz^3
    811                19. Select R0, R1  (for MSUB in step 2)
    812          
    813                Output State:
    814                R0   = B
    815                R1   = FREE
    816                R2   = FREE
    817                R3   = A
    818                R4   = Pz
    819          
    820                STEP 1:
    821              */
    822              CORE_ENTER_CRITICAL();
    823              ecp_crypto_ddata_write(&crypto->DDATA0, &P->Z);
    824              CORE_EXIT_CRITICAL();
    825          
    826              CRYPTO_EXECUTE_5(crypto,
    827                                CRYPTO_CMD_INSTR_DDATA0TODDATA1,
    828                                CRYPTO_CMD_INSTR_DDATA0TODDATA4,
    829                                CRYPTO_CMD_INSTR_SELDDATA1DDATA4,
    830                                CRYPTO_CMD_INSTR_MMUL,
    831                                CRYPTO_CMD_INSTR_DDATA0TODDATA1);
    832              CRYPTO_InstructionSequenceWait(crypto);
    833          
    834              CORE_ENTER_CRITICAL();
    835              ecp_crypto_ddata_write(&crypto->DDATA0, &Q->X);
    836              CORE_EXIT_CRITICAL();
    837          
    838              CRYPTO_EXECUTE_4 (crypto,
    839                                CRYPTO_CMD_INSTR_DDATA0TODDATA3,
    840                                CRYPTO_CMD_INSTR_SELDDATA1DDATA3,
    841                                CRYPTO_CMD_INSTR_MMUL,
    842                                CRYPTO_CMD_INSTR_DDATA0TODDATA3);
    843              CRYPTO_InstructionSequenceWait(crypto);
    844              CRYPTO_EXECUTE_3 (crypto,
    845                                CRYPTO_CMD_INSTR_SELDDATA1DDATA4,
    846                                CRYPTO_CMD_INSTR_MMUL,
    847                                CRYPTO_CMD_INSTR_DDATA0TODDATA1);
    848              CRYPTO_InstructionSequenceWait(crypto);
    849          
    850              CORE_ENTER_CRITICAL();
    851              ecp_crypto_ddata_write(&crypto->DDATA0, &Q->Y);
    852              CORE_EXIT_CRITICAL();
    853          
    854              CRYPTO_EXECUTE_3 (crypto,
    855                                CRYPTO_CMD_INSTR_DDATA0TODDATA2,
    856                                CRYPTO_CMD_INSTR_SELDDATA1DDATA2,
    857                                CRYPTO_CMD_INSTR_MMUL
    858                                );
    859              CRYPTO_InstructionSequenceWait(crypto);
    860          
    861              /*
    862                STEP 2:
    863          
    864                Goals:
    865                C  = A - Px
    866                D  = B - Py
    867                R->Z = Pz * C
    868          
    869                Write Operations:
    870          
    871                R1 = Py
    872                R0 = Px (via DMA)
    873          
    874                Input State:
    875                R0   = B
    876                R1   = Py
    877                R2   = FREE
    878                R3   = A
    879                R4   = Pz
    880          
    881                Instructions to be executed:
    882          
    883                0. Select R0, R1
    884                1. R0 = R0 - R1 = B - Py = D
    885                2. R2 = R0 = D
    886                3. R1 = R3 = A
    887                4. R0 = DMA = Px
    888                5. R3 = R0 = Px
    889                6. Select R1, R3
    890                7. R0 = R1 - R3 = A - Px = C
    891                8. R1 = R0 = C
    892                9. Select R1, R4
    893                10. R0 = R1 * R4 = Pz * C = R->Z
    894          
    895                Read Operations:
    896          
    897                R->Z = R0 = Pz * C
    898          
    899                Output State:
    900                R0   = FREE
    901                R1   = C
    902                R2   = D
    903                R3   = Px
    904                R4   = FREE
    905          
    906                STEP 2:
    907              */
    908          
    909              CORE_ENTER_CRITICAL();
    910              ecp_crypto_ddata_write(&crypto->DDATA1, &P->Y);
    911              CORE_EXIT_CRITICAL();
    912          
    913              CRYPTO_EXECUTE_3 (crypto,
    914                                CRYPTO_CMD_INSTR_SELDDATA0DDATA1,
    915                                CRYPTO_CMD_INSTR_MSUB,
    916                                CRYPTO_CMD_INSTR_DDATA0TODDATA2); /* R2 = D */
    917              CRYPTO_InstructionSequenceWait(crypto);
    918          
    919              CORE_ENTER_CRITICAL();
    920              ecp_crypto_ddata_write(&crypto->DDATA0, &P->X);
    921              CORE_EXIT_CRITICAL();
    922          
    923              CRYPTO_EXECUTE_7 (crypto,
    924                                CRYPTO_CMD_INSTR_DDATA3TODDATA1,
    925                                CRYPTO_CMD_INSTR_DDATA0TODDATA3,
    926                                CRYPTO_CMD_INSTR_SELDDATA1DDATA3,
    927                                CRYPTO_CMD_INSTR_MSUB,
    928                                CRYPTO_CMD_INSTR_DDATA0TODDATA1,  /* R1 = C */
    929          
    930                                CRYPTO_CMD_INSTR_SELDDATA1DDATA4,
    931                                CRYPTO_CMD_INSTR_MMUL
    932                                );
    933              CRYPTO_InstructionSequenceWait(crypto);
    934          
    935              ret = ecp_crypto_ddata_read(&crypto->DDATA0, &R->Z);
    936          
    937              if (ret != 0) goto cleanup;
    938          
    939              /*
    940                STEP 3:
    941          
    942                Goals:
    943                X1C2  = Px * C^2
    944                C3    = C^3
    945                D2    = D^2
    946          
    947                Input State:
    948                R0   = FREE
    949                R1   = C
    950                R2   = D
    951                R3   = Px
    952                R4   = FREE
    953          
    954                Instructions to be executed:
    955          
    956                1. R4 = R1 = C
    957                2. Select R1, R4
    958                3. R0 = R1 * R4 = C^2
    959                4. R1 = R0 = C^2
    960                5. R0 = R1 * R4 = C^3
    961                6. R4 = R0 = C^3
    962                7. Select R1, R3
    963                8. R0 = R1 * R3 = Px * C^2
    964                9. R3 = R0 = Px * C^2
    965                10. R1 = R2 = D
    966                11. Select R1, R1
    967                12. R0 = R1 * R1 = D^2
    968                13. Select R0, R4
    969                14. R0 = R0 - R4 = D2 - C3
    970          
    971                Output state:
    972          
    973                R0 = D2 - C3
    974                R1 = FREE
    975                R2 = D
    976                R3 = X1C2 = Px * C^2
    977                R4 = C3   = C^3
    978          
    979                STEP 3:
    980              */
    981              CRYPTO_EXECUTE_3 (crypto,
    982                                CRYPTO_CMD_INSTR_DDATA1TODDATA4,
    983                                CRYPTO_CMD_INSTR_SELDDATA1DDATA4,
    984                                CRYPTO_CMD_INSTR_MMUL);
    985              CRYPTO_InstructionSequenceWait(crypto);
    986          
    987              CRYPTO_EXECUTE_3 (crypto,
    988                                CRYPTO_CMD_INSTR_DDATA0TODDATA1,
    989                                CRYPTO_CMD_INSTR_MMUL,
    990                                CRYPTO_CMD_INSTR_DDATA0TODDATA4);
    991              CRYPTO_InstructionSequenceWait(crypto);
    992          
    993              CRYPTO_EXECUTE_3 (crypto,
    994                                CRYPTO_CMD_INSTR_SELDDATA1DDATA3,
    995                                CRYPTO_CMD_INSTR_MMUL,
    996                                CRYPTO_CMD_INSTR_DDATA0TODDATA3);
    997              CRYPTO_InstructionSequenceWait(crypto);
    998          
    999              CRYPTO_EXECUTE_5 (crypto,
   1000                                CRYPTO_CMD_INSTR_DDATA2TODDATA1,
   1001                                CRYPTO_CMD_INSTR_SELDDATA1DDATA2,
   1002                                CRYPTO_CMD_INSTR_MMUL,
   1003                                CRYPTO_CMD_INSTR_SELDDATA0DDATA4,
   1004                                CRYPTO_CMD_INSTR_MSUB
   1005                                );
   1006              CRYPTO_InstructionSequenceWait(crypto);
   1007          
   1008              /*
   1009                STEP 3:
   1010          
   1011                Goals:
   1012                R->X   = D2 - (C3 + 2 * X1C2) = D2 - C3 - X1C2- X1C2
   1013                Y1C3 = Py * C3
   1014                R->Y = D * (X1C2 - R->X) - Y1C3
   1015          
   1016                Write Operations:
   1017                R1 = Py
   1018          
   1019                Input State:
   1020                R0 = D2 - C3
   1021                R1 = FREE
   1022                R2 = D
   1023                R3 = X1C2
   1024                R4 = C3
   1025          
   1026                Instructions to be executed:
   1027          
   1028                1.  Select R0, R3
   1029                2.  R0 = R0 - R3 = D2 - C3 - X1C2
   1030                3.  R0 = R0 - R3 = D2 - C3 - X1C2 - X1C2 = R->X
   1031                4.  DMA = R0 = R->X
   1032                5.  R1 = R0 = R->X
   1033          
   1034                6.  Select R3, R1
   1035                7.  R0 = R3 - R1 = X1C2 - R->X
   1036                8.  R1 = R0 = X1C2 - R->X
   1037                9.  Select R1, R2
   1038                10. R0 = R1 * R2 = D *(X1C2 - R->X)
   1039                11. R2 = R0
   1040          
   1041                12. R0 = DMA = Py
   1042                13. R1 = R0 = Py
   1043                14. Select R1, R4
   1044                15. R0 = R1 * R4 = Py * C3 = Y1C3
   1045                16. R4 = R0 = Y1C3
   1046          
   1047                17. Select R2, R4
   1048                18. R0 = R2 - R4
   1049          
   1050                Read Operations:
   1051          
   1052                R->X = R2 = D2 - (C3 + 2 * X1C2)
   1053                R->Y = R0 = D * (X1C2 - R->X) - Y1C3
   1054          
   1055                STEP 4:
   1056              */
   1057          
   1058              CRYPTO_EXECUTE_3 (crypto,
   1059                                CRYPTO_CMD_INSTR_SELDDATA0DDATA3,
   1060                                CRYPTO_CMD_INSTR_MSUB,
   1061                                CRYPTO_CMD_INSTR_MSUB);
   1062              CRYPTO_InstructionSequenceWait(crypto);
   1063          
   1064              ret = ecp_crypto_ddata_read(&crypto->DDATA0, &R->X);
   1065              if ( ret != 0 ) goto cleanup;
   1066          
   1067              CRYPTO_EXECUTE_7 (crypto,
   1068                                CRYPTO_CMD_INSTR_DDATA0TODDATA1,
   1069          
   1070                                CRYPTO_CMD_INSTR_SELDDATA3DDATA1,
   1071                                CRYPTO_CMD_INSTR_MSUB,
   1072                                CRYPTO_CMD_INSTR_DDATA0TODDATA1,
   1073                                CRYPTO_CMD_INSTR_SELDDATA1DDATA2,
   1074                                CRYPTO_CMD_INSTR_MMUL,
   1075                                CRYPTO_CMD_INSTR_DDATA0TODDATA2);
   1076              CRYPTO_InstructionSequenceWait(crypto);
   1077          
   1078              CORE_ENTER_CRITICAL();
   1079              ecp_crypto_ddata_write(&crypto->DDATA0, &P->Y);
   1080              CORE_EXIT_CRITICAL();
   1081          
   1082              CRYPTO_EXECUTE_6 (crypto,
   1083                                CRYPTO_CMD_INSTR_DDATA0TODDATA1,
   1084                                CRYPTO_CMD_INSTR_SELDDATA1DDATA4,
   1085                                CRYPTO_CMD_INSTR_MMUL,
   1086                                CRYPTO_CMD_INSTR_DDATA0TODDATA4,
   1087          
   1088                                CRYPTO_CMD_INSTR_SELDDATA2DDATA4,
   1089                                CRYPTO_CMD_INSTR_MSUB
   1090                                );
   1091              CRYPTO_InstructionSequenceWait(crypto);
   1092          
   1093              ret = ecp_crypto_ddata_read(&crypto->DDATA0, &R->Y);
   1094              if ( ret != 0 ) goto cleanup;
   1095          
   1096           cleanup:
   1097              crypto_management_release( crypto );
   1098              return ( ret );
   1099          }
   1100          #endif /* MBEDTLS_ECP_ADD_MIXED_ALT */
   1101          
   1102          /**
   1103           * \brief           Point doubling R = 2 P, Jacobian coordinates.
   1104           *
   1105           *                  Cost:   1D := 3M + 4S    (A ==  0)
   1106           *                          4M + 4S          (A == -3)
   1107           *                          3M + 6S + 1a     otherwise
   1108           *                  when the implementation is based on the "dbl-1998-cmo-2"
   1109           *                  doubling formulas in [8] and standard optimizations are
   1110           *                  applied when curve parameter A is one of { 0, -3 }.
   1111           *
   1112           * \param grp       Pointer to the group representing the curve.
   1113           *
   1114           * \param R         Pointer to a point structure to hold the result.
   1115           *
   1116           * \param P         Pointer to the point that has to be doubled, given with
   1117           *                  Jacobian coordinates.
   1118           *
   1119           * \return          0 if successful.
   1120           */
   1121          #if defined(MBEDTLS_ECP_DOUBLE_JAC_ALT)
   1122          int mbedtls_internal_ecp_double_jac( const mbedtls_ecp_group *grp,
   1123                                               mbedtls_ecp_point *R,
   1124                                               const mbedtls_ecp_point *P )
   1125          {
   1126              int             ret;
   1127              CORE_DECLARE_IRQ_STATE;
   1128              CRYPTO_TypeDef *crypto = crypto_management_acquire();
   1129          
   1130              ecp_crypto_device_init(crypto, grp);
   1131          
   1132              ecc_bigint_t _2YY;
   1133              /*
   1134                STEP 1:
   1135          
   1136                Goals:
   1137                ZZ   = Z^2
   1138                R->Z = 2 * Y * Z
   1139                YY   = Y^2
   1140                4YY  = 4 * Y^2
   1141          
   1142                Write Operations:
   1143          
   1144                R2 = Y
   1145                R3 = Z
   1146          
   1147                Instructions to be executed:
   1148          
   1149                1.  R0 = DMA = Z
   1150                2.  R1 = R0 = Z
   1151                3.  R2 = R0 = Z
   1152                4.  Select R1, R2
   1153                5.  R0 = R1 * R2 = Z^2 = ZZ
   1154                6.  R3 = R0 = ZZ
   1155          
   1156                7.  R0 = DMA = Y
   1157                8.  R2 = R0 = Y
   1158                9.  R0 = R1 * R2 = Y * Z
   1159                10. Select R0, R0
   1160                11. R0 = R0 + R0 = 2 * Y * Z = R->Z
   1161          
   1162                12. DMA = R0 = R->Z
   1163          
   1164                13. R1 = R2 = Y
   1165                14. Select R1, R2
   1166                15. R0 = R1 * R2 = Y^2 = YY
   1167                16.  Select R0, R0
   1168                17.  R0 = R0 + R0 = 2YY
   1169          
   1170                Read Operations:
   1171          
   1172                R->Z = R0 = 2 * Y * Z
   1173                2YY  = R0
   1174          
   1175                Output State:
   1176                R0 = 2YY
   1177                R1 = FREE
   1178                R2 = FREE
   1179                R3 = ZZ
   1180                R4 = FREE
   1181          
   1182                STEP 1:
   1183              */
   1184              CORE_ENTER_CRITICAL();
   1185              ecp_crypto_ddata_write(&crypto->DDATA0, &P->Z);
   1186              CORE_EXIT_CRITICAL();
   1187          
   1188              CRYPTO_EXECUTE_5 (crypto,
   1189                                CRYPTO_CMD_INSTR_DDATA0TODDATA1,
   1190                                CRYPTO_CMD_INSTR_DDATA0TODDATA2,
   1191                                CRYPTO_CMD_INSTR_SELDDATA1DDATA2,
   1192                                CRYPTO_CMD_INSTR_MMUL,
   1193                                CRYPTO_CMD_INSTR_DDATA0TODDATA3);
   1194              CRYPTO_InstructionSequenceWait(crypto);
   1195          
   1196              CORE_ENTER_CRITICAL();
   1197              ecp_crypto_ddata_write(&crypto->DDATA0, &P->Y);
   1198              CORE_EXIT_CRITICAL();
   1199          
   1200              CRYPTO_EXECUTE_4 (crypto,
   1201                                CRYPTO_CMD_INSTR_DDATA0TODDATA2,
   1202                                CRYPTO_CMD_INSTR_MMUL,
   1203                                CRYPTO_CMD_INSTR_SELDDATA0DDATA0,
   1204                                CRYPTO_CMD_INSTR_MADD);
   1205              CRYPTO_InstructionSequenceWait(crypto);
   1206          
   1207              ret = ecp_crypto_ddata_read(&crypto->DDATA0, &R->Z);
   1208              if ( ret != 0 ) goto cleanup;
   1209          
   1210              CRYPTO_EXECUTE_5 (crypto,
   1211                                CRYPTO_CMD_INSTR_DDATA2TODDATA1,
   1212                                CRYPTO_CMD_INSTR_SELDDATA1DDATA2,
   1213                                CRYPTO_CMD_INSTR_MMUL,
   1214                                CRYPTO_CMD_INSTR_SELDDATA0DDATA0,
   1215                                CRYPTO_CMD_INSTR_MADD
   1216                                );
   1217              CRYPTO_InstructionSequenceWait(crypto);
   1218          
   1219              CORE_ENTER_CRITICAL();
   1220              ecp_crypto_ddata_write(&crypto->DDATA4, &P->X);
   1221              CRYPTO_DDataRead(&crypto->DDATA0, _2YY);
   1222              CORE_EXIT_CRITICAL();
   1223          
   1224              /*
   1225                STEP 2:
   1226          
   1227                Goals:
   1228                A   = 4YY * X
   1229                C   = 3(X - ZZ)(X + ZZ)
   1230          
   1231                Write Operations:
   1232          
   1233                R4 = X
   1234          
   1235                Input State:
   1236                R0 = 2YY
   1237                R1 = FREE
   1238                R2 = FREE
   1239                R3 = ZZ
   1240                R4 = X
   1241          
   1242                Instructions to be executed:
   1243          
   1244                1.  R0 = R0 + R0 = 4YY
   1245                2.  R1 = R0 = 4YY
   1246                3.  Select R1, R4
   1247                4.  R0 = R1 * R4 = 4YY * X = A
   1248                5.  R2 = R0 = A
   1249                6.  Select R4, R3
   1250                7.  R0 = R4 + R3 = X + ZZ
   1251                8.  R1 = R0 = X + ZZ
   1252                9.  R0 = R4 - R3 = X - ZZ
   1253                0.  R2 = R0 = X - ZZ
   1254                11. Select R1, R2
   1255                12. R0 = R1 * R2 = (X + ZZ)(X - ZZ)
   1256                13. R1 = R0 = (X + ZZ)(X - ZZ)
   1257                14. Select R0, R1
   1258                15. R0 = R0 + R1 = 2(X + ZZ)(X - ZZ)
   1259                16. R0 = R0 + R1 = 3(X + ZZ)(X - ZZ) = C
   1260                17. R1 = R0 = C
   1261          
   1262                Output State:
   1263                R0 = FREE
   1264                R1 = C
   1265                R2 = A
   1266                R3 = FREE
   1267                R4 = FREE
   1268          
   1269                STEP 2:
   1270              */
   1271              CRYPTO_EXECUTE_11(crypto,
   1272                                CRYPTO_CMD_INSTR_SELDDATA0DDATA0,
   1273                                CRYPTO_CMD_INSTR_MADD,
   1274                                CRYPTO_CMD_INSTR_DDATA0TODDATA1,
   1275                                CRYPTO_CMD_INSTR_SELDDATA1DDATA4,
   1276                                CRYPTO_CMD_INSTR_MMUL,
   1277                                CRYPTO_CMD_INSTR_DDATA0TODDATA2,
   1278                                CRYPTO_CMD_INSTR_SELDDATA4DDATA3,
   1279                                CRYPTO_CMD_INSTR_MADD,
   1280                                CRYPTO_CMD_INSTR_DDATA0TODDATA1,
   1281                                CRYPTO_CMD_INSTR_MSUB,
   1282                                CRYPTO_CMD_INSTR_DDATA0TODDATA4);
   1283              CRYPTO_InstructionSequenceWait(crypto);
   1284              CRYPTO_EXECUTE_7 (crypto,
   1285                                CRYPTO_CMD_INSTR_SELDDATA1DDATA4,
   1286                                CRYPTO_CMD_INSTR_MMUL,
   1287                                CRYPTO_CMD_INSTR_DDATA0TODDATA1,
   1288                                CRYPTO_CMD_INSTR_SELDDATA0DDATA1,
   1289                                CRYPTO_CMD_INSTR_MADD,
   1290                                CRYPTO_CMD_INSTR_MADD,
   1291                                CRYPTO_CMD_INSTR_DDATA0TODDATA1
   1292                                );
   1293              CRYPTO_InstructionSequenceWait(crypto);
   1294              /*
   1295                STEP 3:
   1296          
   1297                Goals:
   1298                R->X = C^2 - 2A
   1299                D = C(A - R->X)
   1300          
   1301                Input State:
   1302                R0 = FREE
   1303                R1 = C
   1304                R2 = A
   1305                R3 = FREE
   1306                R4 = FREE
   1307          
   1308                Instructions to be executed:
   1309          
   1310                1.  R4 = R1 = C
   1311                2.  Select R1, R4
   1312                3.  R0 = R1 * R4 = C^2
   1313                4.  Select R0, R2
   1314                5.  R0 = R0 - R2 = C^2 - 2A = R->X
   1315                6.  R4 = R0 = R->X
   1316                7.  Select R3, R4
   1317                8.  R0 = R3 - R4 = A - R->X
   1318                9.  R2 = R0 = A - R->X
   1319                10  Select R1, R2
   1320                11. R0 = R1 * R2 = C(A - R->X) = D
   1321          
   1322                Read Operations:
   1323          
   1324                R->X = R4 = C^2 - 2A
   1325          
   1326                Output State:
   1327                R0   = FREE
   1328                R1   = FREE
   1329                R2   = FREE
   1330                R3   = D
   1331                R4   = FREE
   1332          
   1333                STEP 3:
   1334              */
   1335          
   1336              CRYPTO_EXECUTE_8 (crypto,
   1337                                CRYPTO_CMD_INSTR_SELDDATA2DDATA2,
   1338                                CRYPTO_CMD_INSTR_MADD,
   1339                                CRYPTO_CMD_INSTR_DDATA0TODDATA4,
   1340          
   1341                                CRYPTO_CMD_INSTR_DDATA1TODDATA3,
   1342                                CRYPTO_CMD_INSTR_SELDDATA1DDATA3,
   1343                                CRYPTO_CMD_INSTR_MMUL,
   1344          
   1345                                CRYPTO_CMD_INSTR_SELDDATA0DDATA4,
   1346                                CRYPTO_CMD_INSTR_MSUB);
   1347              CRYPTO_InstructionSequenceWait(crypto);
   1348          
   1349              ret = ecp_crypto_ddata_read(&crypto->DDATA0, &R->X);
   1350              if ( ret != 0 ) goto cleanup;
   1351          
   1352              CRYPTO_EXECUTE_7 (crypto,
   1353                                CRYPTO_CMD_INSTR_DDATA0TODDATA4,
   1354          
   1355                                CRYPTO_CMD_INSTR_SELDDATA2DDATA4,
   1356                                CRYPTO_CMD_INSTR_MSUB,
   1357                                CRYPTO_CMD_INSTR_DDATA0TODDATA2,
   1358                                CRYPTO_CMD_INSTR_SELDDATA1DDATA2,
   1359                                CRYPTO_CMD_INSTR_MMUL,
   1360                                CRYPTO_CMD_INSTR_DDATA0TODDATA3
   1361                                );
   1362              CRYPTO_InstructionSequenceWait(crypto);
   1363          
   1364          
   1365              /*
   1366                STEP 4:
   1367          
   1368                Goals:
   1369                B    = 8 * Y^4
   1370                R->Y = D - B
   1371          
   1372                Write Operations:
   1373          
   1374                R1 = YY
   1375          
   1376                Input State:
   1377                R0   = FREE
   1378                R1   = YY
   1379                R2   = FREE
   1380                R3   = D
   1381                R4   = FREE
   1382          
   1383                Instructions to be executed:
   1384          
   1385                2. R0 = DMA0
   1386                3. R1 = R0 = Y^2
   1387                4. R2 = R0 = Y^2
   1388                5. Select R1, R2
   1389                6. R0 = R1 * R2 = Y^4
   1390                7. Select R0, R0
   1391                8. R0 = R0 + R0 = 2 * Y^4
   1392                9. R0 = R0 + R0 = 4 * Y^4
   1393                10. R0 = R0 + R0 = 8 * Y^4
   1394                11. R2 = R0
   1395                12. Select R3, R2
   1396                13. R0 = R3 - R2 = D - B = R->Y
   1397          
   1398                Read Operations:
   1399          
   1400                R->Y = R0 = D - B
   1401          
   1402                STEP 4:
   1403              */
   1404              CORE_ENTER_CRITICAL();
   1405              CRYPTO_DDataWrite(&crypto->DDATA0, _2YY);
   1406              CORE_EXIT_CRITICAL();
   1407          
   1408              CRYPTO_EXECUTE_9 (crypto,
   1409                                CRYPTO_CMD_INSTR_DDATA0TODDATA1,
   1410                                CRYPTO_CMD_INSTR_DDATA0TODDATA2,
   1411                                CRYPTO_CMD_INSTR_SELDDATA1DDATA2,
   1412                                CRYPTO_CMD_INSTR_MMUL,
   1413          
   1414                                CRYPTO_CMD_INSTR_SELDDATA0DDATA0,
   1415                                CRYPTO_CMD_INSTR_MADD,
   1416                                CRYPTO_CMD_INSTR_DDATA0TODDATA2,
   1417          
   1418                                CRYPTO_CMD_INSTR_SELDDATA3DDATA2,
   1419                                CRYPTO_CMD_INSTR_MSUB
   1420                                );
   1421              CRYPTO_InstructionSequenceWait(crypto);
   1422          
   1423              ret = ecp_crypto_ddata_read(&crypto->DDATA0, &R->Y);
   1424              if ( ret != 0 ) goto cleanup;
   1425          
   1426           cleanup:
   1427              crypto_management_release( crypto );
   1428          
   1429              return ( ret );
   1430          }
   1431          #endif /* MBEDTLS_ECP_DOUBLE_JAC_ALT */
   1432          
   1433          /**
   1434           * \brief           Normalize jacobian coordinates of an array of (pointers to)
   1435           *                  points.
   1436           *
   1437           *                  Using Montgomery's trick to perform only one inversion mod P
   1438           *                  the cost is:
   1439           *                      1N(t) := 1I + (6t - 3)M + 1S
   1440           *                  (See for example Algorithm 10.3.4. in [9])
   1441           *
   1442           *                  This function is used only as a subrutine of
   1443           *                  ecp_mul_comb().
   1444           *
   1445           *                  Warning: fails (returning an error) if one of the points is
   1446           *                  zero!
   1447           *                  This should never happen, see choice of w in ecp_mul_comb().
   1448           *
   1449           * \param grp       Pointer to the group representing the curve.
   1450           *
   1451           * \param T         Array of pointers to the points to normalise.
   1452           *
   1453           * \param t_len     Number of elements in the array.
   1454           *
   1455           * \return          0 if successful,
   1456           *                      an error if one of the points is zero.
   1457           */
   1458          #if defined(MBEDTLS_ECP_NORMALIZE_JAC_MANY_ALT)
   1459          int mbedtls_internal_ecp_normalize_jac_many( const mbedtls_ecp_group *grp,
   1460                                                       mbedtls_ecp_point *T[],
   1461                                                       size_t t_len )
   1462          {
   1463              int ret = 0;
   1464              size_t i;
   1465              ecc_bigint_t*   cc;
   1466              ecc_bigint_t    uu;
   1467              ecc_bigint_t    one;
   1468              ecc_bigint_t    modulus;
   1469              CORE_DECLARE_IRQ_STATE;
   1470          
   1471              if( t_len < 2 )
   1472                  return( mbedtls_internal_ecp_normalize_jac( grp, *T ) );
   1473          
   1474              if( ( cc = mbedtls_calloc( t_len, sizeof( ecc_bigint_t ) ) ) == NULL )
   1475                  return( MBEDTLS_ERR_ECP_ALLOC_FAILED );
   1476          
   1477              /*
   1478               * c[i] = Z_0 * ... * Z_i
   1479               */
   1480              MPI_TO_BIGINT( cc[0], &T[0]->Z );
   1481          
   1482              CRYPTO_TypeDef *crypto = crypto_management_acquire();
   1483              ecp_crypto_device_init(crypto, grp);
   1484          
   1485              for( i = 1; i < t_len; i++ )
   1486              {
   1487                  CORE_ENTER_CRITICAL();
   1488                  ecp_crypto_ddata_write( &crypto->DDATA1, &T[i]->Z );
   1489                  CRYPTO_DDataWrite( &crypto->DDATA2, cc[i-1] );
   1490                  CORE_EXIT_CRITICAL();
   1491          
   1492                  CRYPTO_EXECUTE_2(crypto,
   1493                                   CRYPTO_CMD_INSTR_SELDDATA1DDATA2,
   1494                                   CRYPTO_CMD_INSTR_MMUL);
   1495                  CRYPTO_InstructionSequenceWait(crypto);
   1496          
   1497                  CORE_ENTER_CRITICAL();
   1498                  CRYPTO_DDataRead( &crypto->DDATA0, cc[i] );
   1499                  CORE_EXIT_CRITICAL();
   1500              }
   1501          
   1502              memset(one, 0, sizeof(one));
   1503              one[0]=1;
   1504              MPI_TO_BIGINT( modulus, &grp->P );
   1505          
   1506              /*
   1507               * u = 1 / (Z_0 * ... * Z_n) mod P
   1508               */
   1509              crypto_mpi_div_mod(crypto, one, cc[t_len-1], modulus, uu);
   1510          
   1511              for( i = t_len - 1; ; i-- )
   1512              {
   1513                  /*
   1514                   * Zi = 1 / Z_i mod p
   1515                   * u = 1 / (Z_0 * ... * Z_i) mod P
   1516                   */
   1517                  if( i == 0 )
   1518                  {
   1519                      /* Z_inv (DDATA2) = uu */
   1520                      CORE_ENTER_CRITICAL();
   1521                      CRYPTO_DDataWrite(&crypto->DDATA2, uu);
   1522                      CORE_EXIT_CRITICAL();
   1523                  }
   1524                  else
   1525                  {
   1526                      /* Z_inv (DDATA1) = uu x cc[i-1] modulo p */
   1527                      /* uu = uu x T[i]->Z modulo p */
   1528                      CORE_ENTER_CRITICAL();
   1529                      CRYPTO_DDataWrite(&crypto->DDATA1, uu);
   1530                      CRYPTO_DDataWrite(&crypto->DDATA2, cc[i-1]);
   1531                      ecp_crypto_ddata_write( &crypto->DDATA3, &T[i]->Z );
   1532                      CORE_EXIT_CRITICAL();
   1533          
   1534                      CRYPTO_EXECUTE_3(crypto,
   1535                                       CRYPTO_CMD_INSTR_SELDDATA1DDATA2,
   1536                                       CRYPTO_CMD_INSTR_MMUL,
   1537                                       CRYPTO_CMD_INSTR_DDATA0TODDATA2); /* Z_inv (DDATA2) */
   1538                      CRYPTO_InstructionSequenceWait(crypto);
   1539                      CRYPTO_EXECUTE_2(crypto,
   1540                                       CRYPTO_CMD_INSTR_SELDDATA1DDATA3,
   1541                                       CRYPTO_CMD_INSTR_MMUL);
   1542                      CRYPTO_InstructionSequenceWait(crypto);
   1543          
   1544                      CORE_ENTER_CRITICAL();
   1545                      CRYPTO_DDataRead(&crypto->DDATA0, uu);
   1546                      CORE_EXIT_CRITICAL();
   1547                  }
   1548          
   1549                  /*
   1550                   * proceed as in normalize()
   1551                   */
   1552                  CORE_ENTER_CRITICAL();
   1553                  ecp_crypto_ddata_write(&crypto->DDATA3, &T[i]->X);
   1554                  ecp_crypto_ddata_write(&crypto->DDATA4, &T[i]->Y);
   1555                  CORE_EXIT_CRITICAL();
   1556          
   1557                  /* Z_inv  already in DDATA2 */
   1558                  CRYPTO_EXECUTE_3 (crypto,
   1559                                    CRYPTO_CMD_INSTR_DDATA2TODDATA1,
   1560                                    CRYPTO_CMD_INSTR_SELDDATA1DDATA2,
   1561                                    CRYPTO_CMD_INSTR_MMUL);
   1562                  CRYPTO_InstructionSequenceWait(crypto);
   1563                  CRYPTO_EXECUTE_3 (crypto,
   1564                                    CRYPTO_CMD_INSTR_DDATA0TODDATA1,
   1565                                    CRYPTO_CMD_INSTR_SELDDATA1DDATA3,
   1566                                    CRYPTO_CMD_INSTR_MMUL);
   1567                  CRYPTO_InstructionSequenceWait(crypto);
   1568                  CRYPTO_EXECUTE_3 (crypto,
   1569                                    CRYPTO_CMD_INSTR_DDATA0TODDATA3,
   1570                                    CRYPTO_CMD_INSTR_SELDDATA1DDATA2,
   1571                                    CRYPTO_CMD_INSTR_MMUL);
   1572                  CRYPTO_InstructionSequenceWait(crypto);
   1573                  CRYPTO_EXECUTE_3 (crypto,
   1574                                    CRYPTO_CMD_INSTR_DDATA0TODDATA1,
   1575                                    CRYPTO_CMD_INSTR_SELDDATA1DDATA4,
   1576                                    CRYPTO_CMD_INSTR_MMUL);
   1577                  CRYPTO_InstructionSequenceWait(crypto);
   1578          
   1579                  ecp_crypto_ddata_read(&crypto->DDATA0, &T[i]->Y);
   1580                  ecp_crypto_ddata_read(&crypto->DDATA3, &T[i]->X);
   1581          
   1582                  /*
   1583                   * Post-precessing: reclaim some memory by shrinking coordinates
   1584                   * - not storing Z (always 1)
   1585                   * - shrinking other coordinates, but still keeping the same number of
   1586                   *   limbs as P, as otherwise it will too likely be regrown too fast.
   1587                   */
   1588                  SLCL_ECP_CHK( mbedtls_mpi_shrink( &T[i]->X, grp->P.n ) );
   1589                  SLCL_ECP_CHK( mbedtls_mpi_shrink( &T[i]->Y, grp->P.n ) );
   1590                  mbedtls_mpi_free( &T[i]->Z );
   1591          
   1592                  if( i == 0 )
   1593                      break;
   1594              }
   1595          
   1596           cleanup:
   1597              crypto_management_release( crypto );
   1598              mbedtls_free( cc );
   1599          
   1600              return( ret );
   1601          }
   1602          #endif /* MBEDTLS_ECP_NORMALIZE_JAC_MANY_ALT */
   1603          
   1604          /**
   1605           * \brief           Normalize jacobian coordinates so that Z == 0 || Z == 1.
   1606           *
   1607           *                  Cost in field operations if done by [5] 3.2.1:
   1608           *                      1N := 1I + 3M + 1S
   1609           *
   1610           * \param grp       Pointer to the group representing the curve.
   1611           *
   1612           * \param pt        pointer to the point to be normalised. This is an
   1613           *                  input/output parameter.
   1614           *
   1615           * \return          0 if successful.
   1616           */
   1617          #if defined(MBEDTLS_ECP_NORMALIZE_JAC_ALT)
   1618          int mbedtls_internal_ecp_normalize_jac( const mbedtls_ecp_group *grp,
   1619                                                  mbedtls_ecp_point *pt )
   1620          {
   1621              int             ret      = 0;
   1622              CORE_DECLARE_IRQ_STATE;
   1623              CRYPTO_TypeDef *crypto = crypto_management_acquire();
   1624          
   1625              ecp_crypto_device_init(crypto, grp);
   1626          
   1627              ecc_bigint_t    one;
   1628              ecc_bigint_t    Z;
   1629              ecc_bigint_t    modulus;
   1630              ecc_bigint_t    Z_inv;
   1631          
   1632              memset(one, 0, sizeof(one));
   1633              one[0]=1;
   1634          
   1635              MPI_TO_BIGINT( Z, &pt->Z );
   1636              MPI_TO_BIGINT( modulus, &grp->P );
   1637          
   1638              crypto_mpi_div_mod(crypto, one, Z, modulus, Z_inv);
   1639          
   1640              /*
   1641          
   1642              Goals:
   1643              R->X = P->X * Z_inv ^2
   1644              R->Y = P->Y * Z_inv ^3
   1645          
   1646              Write Operations:
   1647          
   1648              R1 = Z_inv
   1649              R3 = P->X
   1650              R4 = P->Y
   1651          
   1652              Instructions to be executed:
   1653          
   1654              1.  R2 = R1 = Z_inv
   1655              2.  Select R1, R2
   1656              3.  R0 = R1 * R2 = Z_inv^2
   1657              4.  R1 = R0 = Z_inv^2
   1658              5.  Select R1, R3
   1659              6.  R0 = R1 * R3 = P->X * Z_inv^2 = R->X
   1660              7.  R3 = R0
   1661              8.  Select R1, R2
   1662              9.  R0 = R1 * R2 = Z_inv^3
   1663              10. R1 = R0 = Z_inv^3
   1664              11. Select R1, R4
   1665              12. R0 = R1 * R4 = P->Y * Z_inv^3 = R->Y
   1666          
   1667              Read Operations:
   1668          
   1669              R->Y = R0 = P->Y * P->Z_inv^3
   1670              R->X = R3 = P->X * P->Z_inv^2
   1671          
   1672              */
   1673              CORE_ENTER_CRITICAL();
   1674              CRYPTO_DDataWrite(&crypto->DDATA1, Z_inv);
   1675              ecp_crypto_ddata_write(&crypto->DDATA3, &pt->X);
   1676              ecp_crypto_ddata_write(&crypto->DDATA4, &pt->Y);
   1677              CORE_EXIT_CRITICAL();
   1678          
   1679              CRYPTO_EXECUTE_3 (crypto,
   1680                                CRYPTO_CMD_INSTR_DDATA1TODDATA2,
   1681                                CRYPTO_CMD_INSTR_SELDDATA1DDATA2,
   1682                                CRYPTO_CMD_INSTR_MMUL);
   1683              CRYPTO_InstructionSequenceWait(crypto);
   1684              CRYPTO_EXECUTE_3 (crypto,
   1685                                CRYPTO_CMD_INSTR_DDATA0TODDATA1,
   1686                                CRYPTO_CMD_INSTR_SELDDATA1DDATA3,
   1687                                CRYPTO_CMD_INSTR_MMUL);
   1688              CRYPTO_InstructionSequenceWait(crypto);
   1689              CRYPTO_EXECUTE_3 (crypto,
   1690                                CRYPTO_CMD_INSTR_DDATA0TODDATA3,
   1691                                CRYPTO_CMD_INSTR_SELDDATA1DDATA2,
   1692                                CRYPTO_CMD_INSTR_MMUL);
   1693              CRYPTO_InstructionSequenceWait(crypto);
   1694              CRYPTO_EXECUTE_3 (crypto,
   1695                                CRYPTO_CMD_INSTR_DDATA0TODDATA1,
   1696                                CRYPTO_CMD_INSTR_SELDDATA1DDATA4,
   1697                                CRYPTO_CMD_INSTR_MMUL);
   1698              CRYPTO_InstructionSequenceWait(crypto);
   1699          
   1700              ecp_crypto_ddata_read(&crypto->DDATA0, &pt->Y);
   1701              ecp_crypto_ddata_read(&crypto->DDATA3, &pt->X);
   1702          
   1703              crypto_management_release( crypto );
   1704          
   1705              /*
   1706               * Z = 1
   1707               */
   1708              SLCL_ECP_CHK( mbedtls_mpi_lset( &pt->Z, 1 ) );
   1709          
   1710           cleanup:
   1711              return( ret );
   1712          }
   1713          #endif /* MBEDTLS_ECP_NORMALIZE_JAC_ALT */
   1714          
   1715          #endif /* #if defined( MBEDTLS_ECP_INTERNAL_ALT ) */
   1716          
   1717          #endif /* #if defined( MBEDTLS_ECP_C ) */
   1718          
   1719          #endif /* #if defined( CRYPTO_PRESENT ) */


 
 
 0 bytes of memory

Errors: none
Warnings: none
