###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:19:19
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\micro\cortexm3\efm32\mfg-token.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EWC1B7.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\micro\cortexm3\efm32\mfg-token.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"mfg-token.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0
#        -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\mfg-token.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\mfg-token.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\micro\cortexm3\efm32\mfg-token.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief EFM32 Cortex-M3 Manufacturing-Token system
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc. Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement. This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          #include PLATFORM_HEADER
     18          #include "include/error.h"
     19          #include "hal/micro/cortexm3/flash.h"
     20          #include "mfg-token.h"
     21          #include "hal/plugin/sim-eeprom/sim-eeprom.h"
     22          
     23          #define DEFINETOKENS
     24          #define TOKEN_MFG(name, creator, iscnt, isidx, type, arraysize, ...) \
     25            const uint16_t TOKEN_##name = TOKEN_##name##_ADDRESS;
     26          // Multiple inclusion of unguarded token-related header files is by design; suppress violation.
     27          //cstat !MISRAC2012-Dir-4.10
     28            #include "hal/micro/cortexm3/efm32/token-manufacturing.h"

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_EMBER_EUI_64
   \                     TOKEN_MFG_EMBER_EUI_64:
   \        0x0   0x11F0             DC16 4592

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_CUSTOM_EUI_64
   \                     TOKEN_MFG_CUSTOM_EUI_64:
   \        0x0   0x1002             DC16 4098

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_CUSTOM_VERSION
   \                     TOKEN_MFG_CUSTOM_VERSION:
   \        0x0   0x100C             DC16 4108

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_STRING
   \                     TOKEN_MFG_STRING:
   \        0x0   0x1010             DC16 4112

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_BOARD_NAME
   \                     TOKEN_MFG_BOARD_NAME:
   \        0x0   0x1020             DC16 4128

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_MANUF_ID
   \                     TOKEN_MFG_MANUF_ID:
   \        0x0   0x1030             DC16 4144

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_PHY_CONFIG
   \                     TOKEN_MFG_PHY_CONFIG:
   \        0x0   0x1034             DC16 4148

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_ASH_CONFIG
   \                     TOKEN_MFG_ASH_CONFIG:
   \        0x0   0x1038             DC16 4152

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_SYNTH_FREQ_OFFSET
   \                     TOKEN_MFG_SYNTH_FREQ_OFFSET:
   \        0x0   0x1060             DC16 4192

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_CCA_THRESHOLD
   \                     TOKEN_MFG_CCA_THRESHOLD:
   \        0x0   0x1064             DC16 4196

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_EZSP_STORAGE
   \                     TOKEN_MFG_EZSP_STORAGE:
   \        0x0   0x1068             DC16 4200

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_XO_TUNE
   \                     TOKEN_MFG_XO_TUNE:
   \        0x0   0x1070             DC16 4208

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_ZWAVE_COUNTRY_FREQ
   \                     TOKEN_MFG_ZWAVE_COUNTRY_FREQ:
   \        0x0   0x1074             DC16 4212

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_ZWAVE_HW_VERSION
   \                     TOKEN_MFG_ZWAVE_HW_VERSION:
   \        0x0   0x1078             DC16 4216

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_ZWAVE_PSEUDO_RANDOM_NUMBER
   \                     TOKEN_MFG_ZWAVE_PSEUDO_RANDOM_NUMBER:
   \        0x0   0x107C             DC16 4220

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_SERIAL_NUMBER
   \                     TOKEN_MFG_SERIAL_NUMBER:
   \        0x0   0x108C             DC16 4236

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_LFXO_TUNE
   \                     TOKEN_MFG_LFXO_TUNE:
   \        0x0   0x109C             DC16 4252

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_CTUNE
   \                     TOKEN_MFG_CTUNE:
   \        0x0   0x1100             DC16 4352

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_LOCKBITS_PLW
   \                     TOKEN_MFG_LOCKBITS_PLW:
   \        0x0   0x2000             DC16 8192

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_LOCKBITS_CLW0
   \                     TOKEN_MFG_LOCKBITS_CLW0:
   \        0x0   0x21E8             DC16 8680

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_LOCKBITS_MLW
   \                     TOKEN_MFG_LOCKBITS_MLW:
   \        0x0   0x21F4             DC16 8692

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_LOCKBITS_ULW
   \                     TOKEN_MFG_LOCKBITS_ULW:
   \        0x0   0x21F8             DC16 8696

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_LOCKBITS_DLW
   \                     TOKEN_MFG_LOCKBITS_DLW:
   \        0x0   0x21FC             DC16 8700

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_CBKE_DATA
   \                     TOKEN_MFG_CBKE_DATA:
   \        0x0   0x3204             DC16 12804

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_SECURITY_CONFIG
   \                     TOKEN_MFG_SECURITY_CONFIG:
   \        0x0   0x3260             DC16 12896

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_INSTALLATION_CODE
   \                     TOKEN_MFG_INSTALLATION_CODE:
   \        0x0   0x3270             DC16 12912

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_SECURE_BOOTLOADER_KEY
   \                     TOKEN_MFG_SECURE_BOOTLOADER_KEY:
   \        0x0   0x3286             DC16 12934

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_CBKE_283K1_DATA
   \                     TOKEN_MFG_CBKE_283K1_DATA:
   \        0x0   0x3298             DC16 12952

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_BOOTLOAD_AES_KEY
   \                     TOKEN_MFG_BOOTLOAD_AES_KEY:
   \        0x0   0x332C             DC16 13100

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_SIGNED_BOOTLOADER_KEY_X
   \                     TOKEN_MFG_SIGNED_BOOTLOADER_KEY_X:
   \        0x0   0x334C             DC16 13132

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_SIGNED_BOOTLOADER_KEY_Y
   \                     TOKEN_MFG_SIGNED_BOOTLOADER_KEY_Y:
   \        0x0   0x336C             DC16 13164

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_THREAD_JOIN_KEY
   \                     TOKEN_MFG_THREAD_JOIN_KEY:
   \        0x0   0x338C             DC16 13196

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_NVM3_CRYPTO_KEY
   \                     TOKEN_MFG_NVM3_CRYPTO_KEY:
   \        0x0   0x33B0             DC16 13232

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_ZW_PRK
   \                     TOKEN_MFG_ZW_PRK:
   \        0x0   0x33C0             DC16 13248

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_ZW_PUK
   \                     TOKEN_MFG_ZW_PUK:
   \        0x0   0x33E0             DC16 13280

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_ZW_QR_CODE
   \                     TOKEN_MFG_ZW_QR_CODE:
   \        0x0   0x3400             DC16 13312

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_ZW_INITIALIZED
   \                     TOKEN_MFG_ZW_INITIALIZED:
   \        0x0   0x345C             DC16 13404

   \                                 In section .rodata, align 2
   \   __absolute uint16_t const TOKEN_MFG_EUI_64
   \                     TOKEN_MFG_EUI_64:
   \        0x0   0xB634             DC16 46644
     29          #undef TOKEN_DEF
     30          #undef TOKEN_MFG
     31          #undef DEFINETOKENS
     32          
     33          #if defined(_SILICON_LABS_32B_SERIES_1)
     34            #define SILABS_DEVINFO_EUI64_LOW   (DEVINFO->UNIQUEL)
     35            #define SILABS_DEVINFO_EUI64_HIGH  (DEVINFO->UNIQUEH)
     36          #elif defined(_SILICON_LABS_32B_SERIES_2)
     37            #include "em_se.h"
     38            #define SILABS_DEVINFO_EUI64_LOW   (DEVINFO->EUI64L)
     39            #define SILABS_DEVINFO_EUI64_HIGH  (DEVINFO->EUI64H)
     40          // Unlike Series1 EFR devices, Series2 devices do not have an explicit
     41          // flash space for LockBits.  Series 2 uses the top page of main
     42          // flash to store LockBits.  This top page is set aside using a dedicated
     43          // byte array that the linker places at the top of flash.  The define
     44          // LOCKBITS_BASE is then used like all EFR devices to access the LockBits
     45          // memory.
     46          // In non-Series2 devices the LOCKBITS_IN_MAINFLASH section is not
     47          // defined so it is ignored by the linker and therefore the top page
     48          // of flash is free for all existing prior uses.

   \                                 In section LOCKBITS_IN_MAINFLASH, align 4, root
     49          VAR_AT_SEGMENT(NO_STRIPPING NO_INIT(uint8_t lockBitsInMainFlashSpace[FLASH_PAGE_SIZE]), __LOCKBITS_IN_MAINFLASH__);
   \                     lockBitsInMainFlashSpace:
   \        0x0                      DS8 8192
     50          #else
     51            #error Error: this micro is not yet supported by the manufacturing token code
     52          #endif
     53          

   \                                 In section .rodata, align 4
     54          static const uint8_t nullEui[] = { 0xFFU, 0xFFU, 0xFFU, 0xFFU, 0xFFU, 0xFFU, 0xFFU, 0xFFU };
   \                     nullEui:
   \        0x0   0xFF 0xFF          DC8 255, 255, 255, 255, 255, 255, 255, 255
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
     55          

   \                                 In section .text, align 2, keep-with-next
     56          static void getMfgTokenData(void *data,
     57                                      uint16_t token,
     58                                      uint8_t index,
     59                                      uint32_t len)
     60          {
   \                     getMfgTokenData: (+1)
   \        0x0   0xB5BC             PUSH     {R2-R5,R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x4610             MOV      R0,R2
     61            uint8_t *ram = (uint8_t*)data;
     62          
     63            //0x7F is a non-indexed token.  Remap to 0 for the address calculation
     64            index = (index == 0x7FU) ? 0U : index;
   \        0x6   0x287F             CMP      R0,#+127
     65          
     66            if (token == MFG_EUI_64_LOCATION) {
   \        0x8   0xF24B 0x6734      MOVW     R7,#+46644
   \        0xC   0x461A             MOV      R2,R3
   \        0xE   0xBF08             IT       EQ 
   \       0x10   0x2000             MOVEQ    R0,#+0
   \       0x12   0xF241 0x15F0      MOVW     R5,#+4592
   \       0x16   0x42B9             CMP      R1,R7
   \       0x18   0xD118             BNE.N    ??getMfgTokenData_0
     67              //There are two EUI64's stored in the flash, Ember and Custom.
     68              //MFG_EUI_64_LOCATION is the address used by the generic EUI64 token.
     69              //It is the low level routine's responbility to pick and return EUI64 from
     70              //either Ember or Custom.  Return the Custom EUI64 if it is not all FF's,
     71              //otherwise return the Ember EUI64.
     72              tokTypeMfgEui64 eui64;
     73              halCommonGetMfgToken(&eui64, TOKEN_MFG_CUSTOM_EUI_64);
   \       0x1A   0x2308             MOVS     R3,#+8
   \       0x1C   0x227F             MOVS     R2,#+127
   \       0x1E   0xF241 0x0102      MOVW     R1,#+4098
   \       0x22   0x4668             MOV      R0,SP
   \       0x24   0x....'....        BL       halInternalGetMfgTokenData
     74              if (MEMCOMPARE(eui64, nullEui, 8 /*EUI64_SIZE*/) == 0) {
   \       0x28   0x2208             MOVS     R2,#+8
   \       0x2A   0x....             LDR.N    R1,??DataTable2
   \       0x2C   0x4668             MOV      R0,SP
   \       0x2E   0x....'....        BL       halCommonMemCompare
   \       0x32   0xB928             CBNZ.N   R0,??getMfgTokenData_1
     75                halCommonGetMfgToken(&eui64, TOKEN_MFG_EMBER_EUI_64);
   \       0x34   0x2308             MOVS     R3,#+8
   \       0x36   0x227F             MOVS     R2,#+127
   \       0x38   0x4629             MOV      R1,R5
   \       0x3A   0x4668             MOV      R0,SP
   \       0x3C   0x....'....        BL       halInternalGetMfgTokenData
     76              }
     77              MEMCOPY(ram, eui64, 8 /*EUI64_SIZE*/);
   \                     ??getMfgTokenData_1: (+1)
   \       0x40   0x2208             MOVS     R2,#+8
   \       0x42   0x4669             MOV      R1,SP
   \       0x44   0x4620             MOV      R0,R4
   \       0x46   0x....'....        BL       halCommonMemMove
   \       0x4A   0xBDB3             POP      {R0,R1,R4,R5,R7,PC}
     78            } else if (token == MFG_EMBER_EUI_64_LOCATION) {
   \                     ??getMfgTokenData_0: (+1)
   \       0x4C   0x42A9             CMP      R1,R5
   \       0x4E   0xD117             BNE.N    ??getMfgTokenData_2
     79              uint32_t low = SILABS_DEVINFO_EUI64_LOW;
   \       0x50   0x....             LDR.N    R1,??DataTable2_1  ;; 0xfe08048
   \       0x52   0x6808             LDR      R0,[R1, #+0]
     80              uint32_t high = SILABS_DEVINFO_EUI64_HIGH;
   \       0x54   0x6849             LDR      R1,[R1, #+4]
     81              uint8_t i = 0U;
   \       0x56   0x2300             MOVS     R3,#+0
   \                     ??getMfgTokenData_3: (+1)
   \       0x58   0xB372             CBZ.N    R2,??getMfgTokenData_4
     82              while ((i < 4U) && (len > 0U)) {
     83                ram[i] = low & 0xFFU;
   \       0x5A   0xB2DD             UXTB     R5,R3
   \       0x5C   0x5560             STRB     R0,[R4, R5]
     84                low >>= 8;
     85                len--;
     86                i++;
   \       0x5E   0x1C5B             ADDS     R3,R3,#+1
   \       0x60   0x0A00             LSRS     R0,R0,#+8
   \       0x62   0x1E52             SUBS     R2,R2,#+1
     87              }
   \       0x64   0xB2DD             UXTB     R5,R3
   \       0x66   0x2D04             CMP      R5,#+4
   \       0x68   0xD3F6             BCC.N    ??getMfgTokenData_3
     88              while ((i < 8U) && (len > 0U)) {
   \                     ??getMfgTokenData_5: (+1)
   \       0x6A   0xB2D8             UXTB     R0,R3
   \       0x6C   0x2808             CMP      R0,#+8
   \       0x6E   0xD223             BCS.N    ??getMfgTokenData_4
   \       0x70   0x2A00             CMP      R2,#+0
   \       0x72   0xBF1F             ITTTT    NE 
   \       0x74   0x5421             STRBNE   R1,[R4, R0]
   \       0x76   0x0A09             LSRNE    R1,R1,#+8
   \       0x78   0x1E52             SUBNE    R2,R2,#+1
   \       0x7A   0x1C5B             ADDNE    R3,R3,#+1
     89                ram[i] = high & 0xFFU;
     90                high >>= 8;
     91                len--;
     92                i++;
   \       0x7C   0xD1F5             BNE.N    ??getMfgTokenData_5
   \       0x7E   0xBDB3             POP      {R0,R1,R4,R5,R7,PC}
     93              }
     94            } else if ((token & 0xF000) == (USERDATA_TOKENS & 0xF000)) {
   \                     ??getMfgTokenData_2: (+1)
   \       0x80   0x4350             MULS     R0,R0,R2
   \       0x82   0xF401 0x4570      AND      R5,R1,#0xF000
   \       0x86   0xF3C1 0x030B      UBFX     R3,R1,#+0,#+12
   \       0x8A   0xF5B5 0x5F80      CMP      R5,#+4096
   \       0x8E   0xD104             BNE.N    ??getMfgTokenData_6
     95              uint32_t realAddress = ((USERDATA_BASE + (token & 0x0FFF)) + (len * index));
     96              uint8_t *flash = (uint8_t *)realAddress;
     97          
     98              MEMCOPY(ram, flash, len);
   \       0x90   0x18C0             ADDS     R0,R0,R3
   \       0x92   0xB292             UXTH     R2,R2
   \       0x94   0xF100 0x617E      ADD      R1,R0,#+266338304
   \       0x98   0xE00B             B.N      ??getMfgTokenData_7
     99            } else if (((token & 0xF000) == (LOCKBITS_TOKENS & 0xF000))
    100                       || ((token & 0xF000) == (LOCKBITSDATA_TOKENS & 0xF000))) {
   \                     ??getMfgTokenData_6: (+1)
   \       0x9A   0xF5B5 0x5F00      CMP      R5,#+8192
   \       0x9E   0xBF1C             ITT      NE 
   \       0xA0   0xF401 0x4170      ANDNE    R1,R1,#0xF000
   \       0xA4   0xF5B1 0x5F40      CMPNE    R1,#+12288
   \       0xA8   0xD106             BNE.N    ??getMfgTokenData_4
    101              uint32_t realAddress = ((LOCKBITS_BASE + (token & 0x0FFF)) + (len * index));
    102              uint8_t *flash = (uint8_t *)realAddress;
    103          
    104              MEMCOPY(ram, flash, len);
   \       0xAA   0x....             LDR.N    R1,??DataTable2_2
   \       0xAC   0x185B             ADDS     R3,R3,R1
   \       0xAE   0xB292             UXTH     R2,R2
   \       0xB0   0x18C1             ADDS     R1,R0,R3
   \                     ??getMfgTokenData_7: (+1)
   \       0xB2   0x4620             MOV      R0,R4
   \       0xB4   0x....'....        BL       halCommonMemMove
    105            } else {
    106              // Sate MISRA
    107            }
    108          }
   \                     ??getMfgTokenData_4: (+1)
   \       0xB8   0xBDB3             POP      {R0,R1,R4,R5,R7,PC}  ;; return
    109          

   \                                 In section .text, align 2, keep-with-next
    110          void halInternalGetMfgTokenData(void *data,
    111                                          uint16_t token,
    112                                          uint8_t index,
    113                                          uint32_t len)
    114          {
   \                     halInternalGetMfgTokenData: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x4616             MOV      R6,R2
   \        0x6   0x001C             MOVS     R4,R3
    115            if (len == 0U) {
   \        0x8   0xD01A             BEQ.N    ??halInternalGetMfgTokenData_0
    116              return; // Nothing to do...
    117            }
    118            if (token == MFG_EUI_64_LOCATION) {
   \        0xA   0xF24B 0x6234      MOVW     R2,#+46644
   \        0xE   0x4291             CMP      R1,R2
   \       0x10   0xD110             BNE.N    ??halInternalGetMfgTokenData_1
    119              //There are two EUI64's stored in the flash, Ember and Custom.
    120              //MFG_EUI_64_LOCATION is the address used by the generic EUI64 token.
    121              //It is the low level routine's responbility to pick and return EUI64 from
    122              //either Ember or Custom.  Return the Custom EUI64 if it is not all FF's,
    123              //otherwise return the Ember EUI64.
    124              if (len > sizeof(nullEui)) {
   \       0x12   0x2C08             CMP      R4,#+8
    125                len = sizeof(nullEui);
    126              }
    127              getMfgTokenData(data, MFG_CUSTOM_EUI_64_LOCATION, 0x7FU, len);
   \       0x14   0xF241 0x0102      MOVW     R1,#+4098
   \       0x18   0xBF88             IT       HI 
   \       0x1A   0x2408             MOVHI    R4,#+8
   \       0x1C   0x4623             MOV      R3,R4
   \       0x1E   0x227F             MOVS     R2,#+127
   \       0x20   0x....'....        BL       getMfgTokenData
    128              if (MEMCOMPARE(data, nullEui, len) != 0) {
   \       0x24   0xB2A2             UXTH     R2,R4
   \       0x26   0x....             LDR.N    R1,??DataTable2
   \       0x28   0x4628             MOV      R0,R5
   \       0x2A   0x....'....        BL       halCommonMemCompare
   \       0x2E   0xB938             CBNZ.N   R0,??halInternalGetMfgTokenData_0
    129                return;
    130              }
    131              token = MFG_EMBER_EUI_64_LOCATION;
   \       0x30   0xF241 0x11F0      MOVW     R1,#+4592
    132            }
    133            getMfgTokenData(data, token, index, len);
   \                     ??halInternalGetMfgTokenData_1: (+1)
   \       0x34   0x4623             MOV      R3,R4
   \       0x36   0x4632             MOV      R2,R6
   \       0x38   0x4628             MOV      R0,R5
   \       0x3A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0x3E   0x....             B.N      getMfgTokenData
   \                     ??halInternalGetMfgTokenData_0: (+1)
   \       0x40   0xBD70             POP      {R4-R6,PC}       ;; return
    134          }
    135          

   \                                 In section .text, align 2, keep-with-next
    136          void halInternalSetMfgTokenData(uint16_t token, void *data, uint32_t len)
    137          {
   \                     halInternalSetMfgTokenData: (+1)
   \        0x0   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x4614             MOV      R4,R2
    138            EmberStatus flashStatus = EMBER_ERR_FATAL;
    139            uint32_t realAddress = 0;
   \        0x8   0x2600             MOVS     R6,#+0
   \        0xA   0x468B             MOV      R11,R1
    140            //Initializing to a high memory address adds protection by causing a
    141            //hardfault if accidentally used.
    142            uint8_t *flash = (uint8_t *)0xFFFFFFF0U;
   \        0xC   0xF06F 0x050F      MVN      R5,#+15
    143            uint32_t i;
    144            //The flash library requires the address and length to both
    145            //be multiples of 16bits.  Since this API is only valid for writing to
    146            //the UserPage or LockBits page, verify that the token+len falls within
    147            //acceptable addresses..
    148            assert((token & 1) != 1);
   \       0x10   0x....'....        LDR.W    R8,??DataTable2_3
   \       0x14   0xEA5F 0x72C9      LSLS     R2,R9,#+31
   \       0x18   0xD502             BPL.N    ??CrossCallReturnLabel_9
   \       0x1A   0x2194             MOVS     R1,#+148
   \       0x1C   0x....'....        BL       ?Subroutine0
    149            assert((len & 1) != 1);
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x20   0x07E0             LSLS     R0,R4,#+31
   \       0x22   0xD502             BPL.N    ??CrossCallReturnLabel_8
   \       0x24   0x2195             MOVS     R1,#+149
   \       0x26   0x....'....        BL       ?Subroutine0
    150          
    151            if ((token & 0xF000) == (USERDATA_TOKENS & 0xF000)) {
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x2A   0xF409 0x4170      AND      R1,R9,#0xF000
   \       0x2E   0xF3C9 0x000B      UBFX     R0,R9,#+0,#+12
   \       0x32   0xF5B1 0x5F80      CMP      R1,#+4096
   \       0x36   0xD109             BNE.N    ??halInternalSetMfgTokenData_0
    152              realAddress = ((USERDATA_BASE + (token & 0x0FFF)));
   \       0x38   0xF100 0x667E      ADD      R6,R0,#+266338304
    153              flash = (uint8_t *)realAddress;
    154              assert((realAddress >= USERDATA_BASE) && ((realAddress + len - 1) < (USERDATA_BASE + FLASH_PAGE_SIZE)));
   \       0x3C   0x19A0             ADDS     R0,R4,R6
   \       0x3E   0x1E40             SUBS     R0,R0,#+1
   \       0x40   0x....             LDR.N    R1,??DataTable2_4  ;; 0xfe02000
   \       0x42   0x4635             MOV      R5,R6
   \       0x44   0x4288             CMP      R0,R1
   \       0x46   0xD310             BCC.N    ??CrossCallReturnLabel_7
   \       0x48   0x219A             MOVS     R1,#+154
   \       0x4A   0xE00C             B.N      ??halInternalSetMfgTokenData_1
    155            } else if (((token & 0xF000) == (LOCKBITS_TOKENS & 0xF000))
    156                       || ((token & 0xF000) == (LOCKBITSDATA_TOKENS & 0xF000))) {
   \                     ??halInternalSetMfgTokenData_0: (+1)
   \       0x4C   0xF5B1 0x5F00      CMP      R1,#+8192
   \       0x50   0xBF1C             ITT      NE 
   \       0x52   0xF409 0x4270      ANDNE    R2,R9,#0xF000
   \       0x56   0xF5B2 0x5F40      CMPNE    R2,#+12288
   \       0x5A   0xD103             BNE.N    ??halInternalSetMfgTokenData_2
    157              realAddress = ((LOCKBITS_BASE + (token & 0x0FFF)));
   \       0x5C   0x....             LDR.N    R6,??DataTable2_2
   \       0x5E   0x1986             ADDS     R6,R0,R6
    158              flash = (uint8_t *)realAddress;
   \       0x60   0x4635             MOV      R5,R6
   \       0x62   0xE002             B.N      ??CrossCallReturnLabel_7
    159            } else {
    160              //in coming token parameter is an illegal address.
    161              assert(0);
   \                     ??halInternalSetMfgTokenData_2: (+1)
   \       0x64   0x21A1             MOVS     R1,#+161
   \                     ??halInternalSetMfgTokenData_1: (+1)
   \       0x66   0x....'....        BL       ?Subroutine0
    162            }
    163          
    164            //UserData and LockBits manufacturing tokens can only be written by on-chip
    165            //code if the token is currently unprogrammed.  Verify the entire token is
    166            //unwritten.  The flash library performs a similar check, but verifying here
    167            //ensures that the entire token is unprogrammed and will prevent partial
    168            //writes.
    169            //NOTE:  On chip code CANNOT erase LockBits Page.
    170            for (i = 0; i < len; i++) {
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x6A   0x2700             MOVS     R7,#+0
   \       0x6C   0xE006             B.N      ??halInternalSetMfgTokenData_3
    171              assert(flash[i] == 0xFF);
   \                     ??halInternalSetMfgTokenData_4: (+1)
   \       0x6E   0x5DE8             LDRB     R0,[R5, R7]
   \       0x70   0x28FF             CMP      R0,#+255
   \       0x72   0xD002             BEQ.N    ??CrossCallReturnLabel_6
   \       0x74   0x21AB             MOVS     R1,#+171
   \       0x76   0x....'....        BL       ?Subroutine0
    172            }
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x7A   0x1C7F             ADDS     R7,R7,#+1
   \                     ??halInternalSetMfgTokenData_3: (+1)
   \       0x7C   0x42A7             CMP      R7,R4
   \       0x7E   0xD3F6             BCC.N    ??halInternalSetMfgTokenData_4
    173          
    174            #if defined(_SILICON_LABS_32B_SERIES_2)
    175            uint32_t startWordToWrite, endWordToWrite, startWordAddress, endWordAddress;
    176            bool isStartWord = false;
   \       0x80   0x2000             MOVS     R0,#+0
    177            bool isEndWord = false;
   \       0x82   0x2500             MOVS     R5,#+0
    178          
    179            // if address is 2 byte aligned instead of 4, write two buffer bytes of 0xFFFF with
    180            // the first 2 bytes of data separately from the rest of data 2 bytes before
    181            // realAddress. There is buffer space built into the token map to account for these
    182            // extra two bytes at the beginning
    183            if ((realAddress & 3U) != 0U) {
   \       0x84   0xF016 0x0F03      TST      R6,#0x3
   \       0x88   0xD010             BEQ.N    ??halInternalSetMfgTokenData_5
    184              // address for start word at aligned address 2 bytes before realAddress,
    185              // realAddress shifts to aligned address 2 bytes later
    186              startWordAddress = realAddress - 2;
   \       0x8A   0x1EB7             SUBS     R7,R6,#+2
    187              realAddress += 2;
   \       0x8C   0x1CB6             ADDS     R6,R6,#+2
    188              assert((realAddress & 3U) == 0U);
   \       0x8E   0xF016 0x0F03      TST      R6,#0x3
   \       0x92   0xD002             BEQ.N    ??CrossCallReturnLabel_5
   \       0x94   0x21BC             MOVS     R1,#+188
   \       0x96   0x....'....        BL       ?Subroutine0
    189          
    190              // create word to write buffer bytes and first 2 bytes of token
    191              startWordToWrite = 0x0000FFFF | (*(uint16_t *)data << 16);
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x9A   0xF83B 0x0B02      LDRH     R0,[R11], #+2
   \       0x9E   0xF64F 0x71FF      MOVW     R1,#+65535
    192          
    193              // adjust data pointer and byte count
    194              data = (uint16_t *)data + 1;
    195              len -= 2;
   \       0xA2   0x1EA4             SUBS     R4,R4,#+2
   \       0xA4   0xEA41 0x4100      ORR      R1,R1,R0, LSL #+16
    196          
    197              isStartWord = true;
   \       0xA8   0x2001             MOVS     R0,#+1
   \       0xAA   0x9101             STR      R1,[SP, #+4]
    198            }
    199          
    200            // If data size is 2 byte aligned instead of 4, write the last 2 bytes of data and
    201            // two buffer bytes of 0xFFFF at the end of the token separately from the rest of
    202            // data. Buffer space is built into the mfg token map to account for the extra bytes
    203            if ((len & 3U) != 0) {
   \                     ??halInternalSetMfgTokenData_5: (+1)
   \       0xAC   0xF014 0x0F03      TST      R4,#0x3
   \       0xB0   0xD00B             BEQ.N    ??halInternalSetMfgTokenData_6
    204              // adjust to new length
    205              len -= 2;
   \       0xB2   0x1EA4             SUBS     R4,R4,#+2
    206          
    207              // address for end word at aligned address where the last two bytes of data would
    208              // be written
    209              endWordAddress = realAddress + len;
    210          
    211              // create word to write last 2 bytes of token and buffer bytes
    212              endWordToWrite = 0xFFFF0000 | *((uint16_t *)data + len / 2);
   \       0xB4   0x0861             LSRS     R1,R4,#+1
   \       0xB6   0xF83B 0x2011      LDRH     R2,[R11, R1, LSL #+1]
   \       0xBA   0xEB04 0x0A06      ADD      R10,R4,R6
    213          
    214              isEndWord = true;
   \       0xBE   0x2501             MOVS     R5,#+1
   \       0xC0   0xF042 0x427F      ORR      R2,R2,#0xFF000000
   \       0xC4   0xF442 0x027F      ORR      R2,R2,#0xFF0000
   \       0xC8   0x9200             STR      R2,[SP, #+0]
    215            }
    216          
    217            // if writing to USERDATA use secure element
    218            if ((token & 0xF000) == (USERDATA_TOKENS & 0xF000)) {
   \                     ??halInternalSetMfgTokenData_6: (+1)
   \       0xCA   0xF409 0x4170      AND      R1,R9,#0xF000
   \       0xCE   0xF5B1 0x5F80      CMP      R1,#+4096
   \       0xD2   0xD11F             BNE.N    ??halInternalSetMfgTokenData_7
    219              SE_Response_t seStatus = SE_RESPONSE_ABORT;
    220              uint32_t offset;
    221          
    222              // write first word if necessary
    223              if (isStartWord) {
   \       0xD4   0xB148             CBZ.N    R0,??CrossCallReturnLabel_4
    224                offset = startWordAddress & 0x0FFF;
    225                seStatus = SE_writeUserData(offset, (void *)&startWordToWrite, 4);
    226                assert(seStatus == SE_RESPONSE_OK);
   \       0xD6   0x2204             MOVS     R2,#+4
   \       0xD8   0xA901             ADD      R1,SP,#+4
   \       0xDA   0xF3C7 0x000B      UBFX     R0,R7,#+0,#+12
   \       0xDE   0x....'....        BL       SE_writeUserData
   \       0xE2   0xB110             CBZ.N    R0,??CrossCallReturnLabel_4
   \       0xE4   0x21E2             MOVS     R1,#+226
   \       0xE6   0x....'....        BL       ?Subroutine0
    227              }
    228          
    229              // write main area of token if necessary
    230              if (len > 0) {
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0xEA   0xB14C             CBZ.N    R4,??CrossCallReturnLabel_3
    231                offset = realAddress & 0x0FFF;
    232                seStatus = SE_writeUserData(offset, data, len);
    233                assert(seStatus == SE_RESPONSE_OK);
   \       0xEC   0x4622             MOV      R2,R4
   \       0xEE   0x4659             MOV      R1,R11
   \       0xF0   0xF3C6 0x000B      UBFX     R0,R6,#+0,#+12
   \       0xF4   0x....'....        BL       SE_writeUserData
   \       0xF8   0xB110             CBZ.N    R0,??CrossCallReturnLabel_3
   \       0xFA   0x21E9             MOVS     R1,#+233
   \       0xFC   0x....'....        BL       ?Subroutine0
    234              }
    235          
    236              // write last word if necessary
    237              if (isEndWord) {
   \                     ??CrossCallReturnLabel_3: (+1)
   \      0x100   0xB34D             CBZ.N    R5,??CrossCallReturnLabel_0
    238                offset = endWordAddress & 0x0FFF;
    239                seStatus = SE_writeUserData(offset, (void *)&endWordToWrite, 4);
    240                assert(seStatus == SE_RESPONSE_OK);
   \      0x102   0x2204             MOVS     R2,#+4
   \      0x104   0x4669             MOV      R1,SP
   \      0x106   0xF3CA 0x000B      UBFX     R0,R10,#+0,#+12
   \      0x10A   0x....'....        BL       SE_writeUserData
   \      0x10E   0xB310             CBZ.N    R0,??CrossCallReturnLabel_0
   \      0x110   0x21F0             MOVS     R1,#+240
   \      0x112   0xE01E             B.N      ??halInternalSetMfgTokenData_8
    241              }
    242            } else {
    243              // write first word if necessary
    244              if (isStartWord) {
   \                     ??halInternalSetMfgTokenData_7: (+1)
   \      0x114   0xB148             CBZ.N    R0,??CrossCallReturnLabel_2
    245                flashStatus = halInternalFlashWriteSeries2(startWordAddress, &startWordToWrite, 1);
                                     ^
Warning[Pe223]: function "halInternalFlashWriteSeries2" declared implicitly
    246                assert(flashStatus == EMBER_SUCCESS);
   \      0x116   0x2201             MOVS     R2,#+1
   \      0x118   0xA901             ADD      R1,SP,#+4
   \      0x11A   0x4638             MOV      R0,R7
   \      0x11C   0x....'....        BL       halInternalFlashWriteSeries2
   \      0x120   0xB2C0             UXTB     R0,R0
   \      0x122   0xB110             CBZ.N    R0,??CrossCallReturnLabel_2
   \      0x124   0x21F6             MOVS     R1,#+246
   \      0x126   0x....'....        BL       ?Subroutine0
    247              }
    248          
    249              //write main area of token if necessary
    250              if (len > 0) {
   \                     ??CrossCallReturnLabel_2: (+1)
   \      0x12A   0xB144             CBZ.N    R4,??CrossCallReturnLabel_1
    251                //Remember, the flash library's token support operates in 32bit quantities,
    252                //but halInternalFlashWrite converts those to 16 bit quantities and the
    253                //token system operates in 8bit quantities.  Hence the divide by 2.
    254                flashStatus = halInternalFlashWrite(realAddress, data, (len / 2));
    255                assert(flashStatus == EMBER_SUCCESS);
   \      0x12C   0x0862             LSRS     R2,R4,#+1
   \      0x12E   0x4659             MOV      R1,R11
   \      0x130   0x4630             MOV      R0,R6
   \      0x132   0x....'....        BL       halInternalFlashWrite
   \      0x136   0xB110             CBZ.N    R0,??CrossCallReturnLabel_1
   \      0x138   0x21FF             MOVS     R1,#+255
   \      0x13A   0x....'....        BL       ?Subroutine0
    256              }
    257          
    258              // write last word if necessary
    259              if (isEndWord) {
   \                     ??CrossCallReturnLabel_1: (+1)
   \      0x13E   0xB155             CBZ.N    R5,??CrossCallReturnLabel_0
    260                flashStatus = halInternalFlashWriteSeries2(endWordAddress, &endWordToWrite, 1);
                                     ^
Warning[Pe223]: function "halInternalFlashWriteSeries2" declared implicitly
    261                assert(flashStatus == EMBER_SUCCESS);
   \      0x140   0x2201             MOVS     R2,#+1
   \      0x142   0x4669             MOV      R1,SP
   \      0x144   0x4650             MOV      R0,R10
   \      0x146   0x....'....        BL       halInternalFlashWriteSeries2
   \      0x14A   0xB2C0             UXTB     R0,R0
   \      0x14C   0xB118             CBZ.N    R0,??CrossCallReturnLabel_0
   \      0x14E   0xF240 0x1105      MOVW     R1,#+261
    262              }
    263            }
   \                     ??halInternalSetMfgTokenData_8: (+1)
   \      0x152   0x....'....        BL       ?Subroutine0
    264            #elif defined(_SILICON_LABS_32B_SERIES_1)
    265            //Remember, the flash library's token support operates in 16bit quantities,
    266            //but the token system operates in 8bit quantities.  Hence the divide by 2.
    267            //NOTE: The actual flash for the EFM32 device prefer to work with 32b writes,
    268            //but 16b is possible and supported by the flash driver - primarily for the
    269            //purposes of the SimEE/Token system that likes to use 8b and 16b.
    270            // THIS LENGTH IS A 32 BIT LENGTH
    271            flashStatus = halInternalFlashWrite(realAddress, data, (len / 2));
    272            assert(flashStatus == EMBER_SUCCESS);
    273            #else
    274              #error Unknown device series
    275            #endif
    276          }
   \                     ??CrossCallReturnLabel_0: (+1)
   \      0x156   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x4640             MOV      R0,R8
   \        0x2   0x....'....        B.W      halInternalAssertFailed
    277          
    278          #ifndef EMBER_TEST

   \                                 In section .text, align 2, keep-with-next
    279          uint16_t getMfgTokenAddress(uint16_t creator)
    280          {
    281            uint16_t tokenAddress;
    282          
    283            #define DEFINETOKENS
    284            switch (creator) {
   \                     getMfgTokenAddress: (+1)
   \        0x0   0xF24B 0x6134      MOVW     R1,#+46644
   \        0x4   0x1A40             SUBS     R0,R0,R1
   \        0x6   0xF000 0x80E5      BEQ.W    ??getMfgTokenAddress_0
   \        0xA   0xF640 0x310F      MOVW     R1,#+2831
   \        0xE   0x1A40             SUBS     R0,R0,R1
   \       0x10   0xF000 0x8086      BEQ.W    ??getMfgTokenAddress_1
   \       0x14   0xF44F 0x7184      MOV      R1,#+264
   \       0x18   0x1A40             SUBS     R0,R0,R1
   \       0x1A   0xF000 0x80C0      BEQ.W    ??getMfgTokenAddress_2
   \       0x1E   0x1EC0             SUBS     R0,R0,#+3
   \       0x20   0xD075             BEQ.N    ??getMfgTokenAddress_3
   \       0x22   0x38F4             SUBS     R0,R0,#+244
   \       0x24   0xF000 0x80AC      BEQ.W    ??getMfgTokenAddress_4
   \       0x28   0x1E40             SUBS     R0,R0,#+1
   \       0x2A   0xF000 0x807F      BEQ.W    ??getMfgTokenAddress_5
   \       0x2E   0x1E80             SUBS     R0,R0,#+2
   \       0x30   0xF000 0x80B2      BEQ.W    ??getMfgTokenAddress_6
   \       0x34   0x380F             SUBS     R0,R0,#+15
   \       0x36   0xF000 0x8091      BEQ.W    ??getMfgTokenAddress_7
   \       0x3A   0x1E80             SUBS     R0,R0,#+2
   \       0x3C   0xD061             BEQ.N    ??getMfgTokenAddress_8
   \       0x3E   0x1E40             SUBS     R0,R0,#+1
   \       0x40   0xF000 0x8092      BEQ.W    ??getMfgTokenAddress_9
   \       0x44   0xF44F 0x7180      MOV      R1,#+256
   \       0x48   0x1A40             SUBS     R0,R0,R1
   \       0x4A   0xF000 0x8096      BEQ.W    ??getMfgTokenAddress_10
   \       0x4E   0xF240 0x41EC      MOVW     R1,#+1260
   \       0x52   0x1A40             SUBS     R0,R0,R1
   \       0x54   0xF000 0x809A      BEQ.W    ??getMfgTokenAddress_11
   \       0x58   0x1E40             SUBS     R0,R0,#+1
   \       0x5A   0xD05B             BEQ.N    ??getMfgTokenAddress_12
   \       0x5C   0xF240 0x1107      MOVW     R1,#+263
   \       0x60   0x1A40             SUBS     R0,R0,R1
   \       0x62   0xF000 0x80A5      BEQ.W    ??getMfgTokenAddress_13
   \       0x66   0xF240 0x2109      MOVW     R1,#+521
   \       0x6A   0x1A40             SUBS     R0,R0,R1
   \       0x6C   0xD073             BEQ.N    ??getMfgTokenAddress_14
   \       0x6E   0x38FF             SUBS     R0,R0,#+255
   \       0x70   0xD05F             BEQ.N    ??getMfgTokenAddress_15
   \       0x72   0x1F00             SUBS     R0,R0,#+4
   \       0x74   0xD07B             BEQ.N    ??getMfgTokenAddress_16
   \       0x76   0x38F4             SUBS     R0,R0,#+244
   \       0x78   0xF000 0x809D      BEQ.W    ??getMfgTokenAddress_17
   \       0x7C   0xF44F 0x71FC      MOV      R1,#+504
   \       0x80   0x1A40             SUBS     R0,R0,R1
   \       0x82   0xD04A             BEQ.N    ??getMfgTokenAddress_18
   \       0x84   0x3814             SUBS     R0,R0,#+20
   \       0x86   0xD06C             BEQ.N    ??getMfgTokenAddress_19
   \       0x88   0xF240 0x21EB      MOVW     R1,#+747
   \       0x8C   0x1A40             SUBS     R0,R0,R1
   \       0x8E   0xF000 0x8080      BEQ.W    ??getMfgTokenAddress_20
   \       0x92   0x1E40             SUBS     R0,R0,#+1
   \       0x94   0xD077             BEQ.N    ??getMfgTokenAddress_21
   \       0x96   0x1EC0             SUBS     R0,R0,#+3
   \       0x98   0xD045             BEQ.N    ??getMfgTokenAddress_22
   \       0x9A   0x3808             SUBS     R0,R0,#+8
   \       0x9C   0xD058             BEQ.N    ??getMfgTokenAddress_23
   \       0x9E   0x380A             SUBS     R0,R0,#+10
   \       0xA0   0xF000 0x8080      BEQ.W    ??getMfgTokenAddress_24
   \       0xA4   0x1E40             SUBS     R0,R0,#+1
   \       0xA6   0xF000 0x8080      BEQ.W    ??getMfgTokenAddress_25
   \       0xAA   0xF44F 0x71FF      MOV      R1,#+510
   \       0xAE   0x1A40             SUBS     R0,R0,R1
   \       0xB0   0xD060             BEQ.N    ??getMfgTokenAddress_26
   \       0xB2   0xF240 0x21FD      MOVW     R1,#+765
   \       0xB6   0x1A40             SUBS     R0,R0,R1
   \       0xB8   0xD03E             BEQ.N    ??getMfgTokenAddress_27
   \       0xBA   0xF240 0x11EF      MOVW     R1,#+495
   \       0xBE   0x1A40             SUBS     R0,R0,R1
   \       0xC0   0xD03D             BEQ.N    ??getMfgTokenAddress_28
   \       0xC2   0x1F40             SUBS     R0,R0,#+5
   \       0xC4   0xD03E             BEQ.N    ??getMfgTokenAddress_29
   \       0xC6   0x1E40             SUBS     R0,R0,#+1
   \       0xC8   0xF000 0x8081      BEQ.W    ??getMfgTokenAddress_30
   \       0xCC   0x1FC0             SUBS     R0,R0,#+7
   \       0xCE   0xD075             BEQ.N    ??getMfgTokenAddress_31
   \       0xD0   0x1E40             SUBS     R0,R0,#+1
   \       0xD2   0xD079             BEQ.N    ??getMfgTokenAddress_32
   \       0xD4   0x1E40             SUBS     R0,R0,#+1
   \       0xD6   0xD038             BEQ.N    ??getMfgTokenAddress_33
   \       0xD8   0x1EC0             SUBS     R0,R0,#+3
   \       0xDA   0xD072             BEQ.N    ??getMfgTokenAddress_34
   \       0xDC   0xF44F 0x610F      MOV      R1,#+2288
   \       0xE0   0x1A40             SUBS     R0,R0,R1
   \       0xE2   0xD00B             BEQ.N    ??getMfgTokenAddress_35
   \       0xE4   0xF44F 0x7100      MOV      R1,#+512
   \       0xE8   0x1A40             SUBS     R0,R0,R1
   \       0xEA   0xD004             BEQ.N    ??getMfgTokenAddress_36
   \       0xEC   0xF640 0x012E      MOVW     R1,#+2094
   \       0xF0   0x1A40             SUBS     R0,R0,R1
   \       0xF2   0xD009             BEQ.N    ??getMfgTokenAddress_37
   \       0xF4   0xE070             B.N      ??getMfgTokenAddress_38
    285              #define TOKEN_MFG TOKEN_DEF
    286              #define TOKEN_DEF(name, creator, iscnt, isidx, type, arraysize, ...) \
    287            case creator:                                                          \
    288              tokenAddress = TOKEN_##name;                                         \
    289              break;
    290              // Multiple inclusion of unguarded token-related header files is by design; suppress violation.
    291              //cstat !MISRAC2012-Dir-4.10
    292              #include "hal/micro/cortexm3/efm32/token-manufacturing.h"
   \                     ??getMfgTokenAddress_36: (+1)
   \       0xF6   0xF241 0x10F0      MOVW     R0,#+4592
   \       0xFA   0x4770             BX       LR
   \                     ??getMfgTokenAddress_35: (+1)
   \       0xFC   0xF241 0x0002      MOVW     R0,#+4098
   \      0x100   0x4770             BX       LR
   \                     ??getMfgTokenAddress_8: (+1)
   \      0x102   0xF241 0x000C      MOVW     R0,#+4108
   \      0x106   0x4770             BX       LR
   \                     ??getMfgTokenAddress_37: (+1)
   \      0x108   0xF241 0x0010      MOVW     R0,#+4112
   \      0x10C   0x4770             BX       LR
   \                     ??getMfgTokenAddress_3: (+1)
   \      0x10E   0xF44F 0x5081      MOV      R0,#+4128
   \      0x112   0x4770             BX       LR
   \                     ??getMfgTokenAddress_12: (+1)
   \      0x114   0xF241 0x0030      MOVW     R0,#+4144
   \      0x118   0x4770             BX       LR
   \                     ??getMfgTokenAddress_18: (+1)
   \      0x11A   0xF241 0x0034      MOVW     R0,#+4148
   \      0x11E   0x4770             BX       LR
   \                     ??getMfgTokenAddress_1: (+1)
   \      0x120   0xF241 0x0038      MOVW     R0,#+4152
   \      0x124   0x4770             BX       LR
   \                     ??getMfgTokenAddress_22: (+1)
   \      0x126   0xF44F 0x5083      MOV      R0,#+4192
   \      0x12A   0x4770             BX       LR
   \                     ??getMfgTokenAddress_5: (+1)
   \      0x12C   0xF241 0x0064      MOVW     R0,#+4196
   \      0x130   0x4770             BX       LR
   \                     ??getMfgTokenAddress_15: (+1)
   \      0x132   0xF241 0x0068      MOVW     R0,#+4200
   \      0x136   0x4770             BX       LR
   \                     ??getMfgTokenAddress_27: (+1)
   \      0x138   0xF241 0x0070      MOVW     R0,#+4208
   \      0x13C   0x4770             BX       LR
   \                     ??getMfgTokenAddress_28: (+1)
   \      0x13E   0xF241 0x0074      MOVW     R0,#+4212
   \      0x142   0x4770             BX       LR
   \                     ??getMfgTokenAddress_29: (+1)
   \      0x144   0xF241 0x0078      MOVW     R0,#+4216
   \      0x148   0x4770             BX       LR
   \                     ??getMfgTokenAddress_33: (+1)
   \      0x14A   0xF241 0x007C      MOVW     R0,#+4220
   \      0x14E   0x4770             BX       LR
   \                     ??getMfgTokenAddress_23: (+1)
   \      0x150   0xF241 0x008C      MOVW     R0,#+4236
   \      0x154   0x4770             BX       LR
   \                     ??getMfgTokenAddress_14: (+1)
   \      0x156   0xF241 0x009C      MOVW     R0,#+4252
   \      0x15A   0x4770             BX       LR
   \                     ??getMfgTokenAddress_7: (+1)
   \      0x15C   0xF44F 0x5088      MOV      R0,#+4352
   \      0x160   0x4770             BX       LR
   \                     ??getMfgTokenAddress_19: (+1)
   \      0x162   0xF44F 0x5000      MOV      R0,#+8192
   \      0x166   0x4770             BX       LR
   \                     ??getMfgTokenAddress_9: (+1)
   \      0x168   0xF242 0x10E8      MOVW     R0,#+8680
   \      0x16C   0x4770             BX       LR
   \                     ??getMfgTokenAddress_16: (+1)
   \      0x16E   0xF242 0x10F4      MOVW     R0,#+8692
   \      0x172   0x4770             BX       LR
   \                     ??getMfgTokenAddress_26: (+1)
   \      0x174   0xF242 0x10F8      MOVW     R0,#+8696
   \      0x178   0x4770             BX       LR
   \                     ??getMfgTokenAddress_10: (+1)
   \      0x17A   0xF242 0x10FC      MOVW     R0,#+8700
   \      0x17E   0x4770             BX       LR
   \                     ??getMfgTokenAddress_4: (+1)
   \      0x180   0xF243 0x2004      MOVW     R0,#+12804
   \      0x184   0x4770             BX       LR
   \                     ??getMfgTokenAddress_21: (+1)
   \      0x186   0xF243 0x2060      MOVW     R0,#+12896
   \      0x18A   0x4770             BX       LR
   \                     ??getMfgTokenAddress_11: (+1)
   \      0x18C   0xF243 0x2070      MOVW     R0,#+12912
   \      0x190   0x4770             BX       LR
   \                     ??getMfgTokenAddress_20: (+1)
   \      0x192   0xF243 0x2086      MOVW     R0,#+12934
   \      0x196   0x4770             BX       LR
   \                     ??getMfgTokenAddress_6: (+1)
   \      0x198   0xF243 0x2098      MOVW     R0,#+12952
   \      0x19C   0x4770             BX       LR
   \                     ??getMfgTokenAddress_2: (+1)
   \      0x19E   0xF243 0x302C      MOVW     R0,#+13100
   \      0x1A2   0x4770             BX       LR
   \                     ??getMfgTokenAddress_24: (+1)
   \      0x1A4   0xF243 0x304C      MOVW     R0,#+13132
   \      0x1A8   0x4770             BX       LR
   \                     ??getMfgTokenAddress_25: (+1)
   \      0x1AA   0xF243 0x306C      MOVW     R0,#+13164
   \      0x1AE   0x4770             BX       LR
   \                     ??getMfgTokenAddress_13: (+1)
   \      0x1B0   0xF243 0x308C      MOVW     R0,#+13196
   \      0x1B4   0x4770             BX       LR
   \                     ??getMfgTokenAddress_17: (+1)
   \      0x1B6   0xF243 0x30B0      MOVW     R0,#+13232
   \      0x1BA   0x4770             BX       LR
   \                     ??getMfgTokenAddress_31: (+1)
   \      0x1BC   0xF44F 0x504F      MOV      R0,#+13248
   \      0x1C0   0x4770             BX       LR
   \                     ??getMfgTokenAddress_34: (+1)
   \      0x1C2   0xF243 0x30E0      MOVW     R0,#+13280
   \      0x1C6   0x4770             BX       LR
   \                     ??getMfgTokenAddress_32: (+1)
   \      0x1C8   0xF44F 0x5050      MOV      R0,#+13312
   \      0x1CC   0x4770             BX       LR
   \                     ??getMfgTokenAddress_30: (+1)
   \      0x1CE   0xF243 0x405C      MOVW     R0,#+13404
   \      0x1D2   0x4770             BX       LR
   \                     ??getMfgTokenAddress_0: (+1)
   \      0x1D4   0x4608             MOV      R0,R1
   \      0x1D6   0x4770             BX       LR
    293              #undef TOKEN_MFG
    294              #undef TOKEN_DEF
    295              default:
    296                tokenAddress = INVALID_TOKEN_ADDRESS;
   \                     ??getMfgTokenAddress_38: (+1)
   \      0x1D8   0xF64F 0x70FF      MOVW     R0,#+65535
    297                break;
    298            }
    299            #undef DEFINETOKENS
    300            return tokenAddress;
   \      0x1DC   0x4770             BX       LR               ;; return
    301          }
    302          

   \                                 In section .text, align 2, keep-with-next
    303          uint8_t getMfgTokenSize(uint16_t creator)
    304          {
    305            uint8_t tokenSize;
    306          
    307            #define DEFINETOKENS
    308            switch (creator) {
   \                     getMfgTokenSize: (+1)
   \        0x0   0xF24B 0x6134      MOVW     R1,#+46644
   \        0x4   0x1A40             SUBS     R0,R0,R1
   \        0x6   0xD078             BEQ.N    ??getMfgTokenSize_0
   \        0x8   0xF640 0x310F      MOVW     R1,#+2831
   \        0xC   0x1A40             SUBS     R0,R0,R1
   \        0xE   0xD064             BEQ.N    ??getMfgTokenSize_1
   \       0x10   0xF44F 0x7184      MOV      R1,#+264
   \       0x14   0x1A40             SUBS     R0,R0,R1
   \       0x16   0xD068             BEQ.N    ??getMfgTokenSize_2
   \       0x18   0x1EC0             SUBS     R0,R0,#+3
   \       0x1A   0xD066             BEQ.N    ??getMfgTokenSize_2
   \       0x1C   0x38F4             SUBS     R0,R0,#+244
   \       0x1E   0xD05A             BEQ.N    ??getMfgTokenSize_3
   \       0x20   0x1E40             SUBS     R0,R0,#+1
   \       0x22   0xD05A             BEQ.N    ??getMfgTokenSize_1
   \       0x24   0x1E80             SUBS     R0,R0,#+2
   \       0x26   0xD05C             BEQ.N    ??getMfgTokenSize_4
   \       0x28   0x380F             SUBS     R0,R0,#+15
   \       0x2A   0xD056             BEQ.N    ??getMfgTokenSize_1
   \       0x2C   0x1E80             SUBS     R0,R0,#+2
   \       0x2E   0xD054             BEQ.N    ??getMfgTokenSize_1
   \       0x30   0x1E40             SUBS     R0,R0,#+1
   \       0x32   0xD04E             BEQ.N    ??getMfgTokenSize_5
   \       0x34   0xF44F 0x7180      MOV      R1,#+256
   \       0x38   0x1A40             SUBS     R0,R0,R1
   \       0x3A   0xD04A             BEQ.N    ??getMfgTokenSize_5
   \       0x3C   0xF240 0x41EC      MOVW     R1,#+1260
   \       0x40   0x1A40             SUBS     R0,R0,R1
   \       0x42   0xD04C             BEQ.N    ??getMfgTokenSize_6
   \       0x44   0x1E40             SUBS     R0,R0,#+1
   \       0x46   0xD048             BEQ.N    ??getMfgTokenSize_1
   \       0x48   0xF240 0x1107      MOVW     R1,#+263
   \       0x4C   0x1A40             SUBS     R0,R0,R1
   \       0x4E   0xD04A             BEQ.N    ??getMfgTokenSize_7
   \       0x50   0xF240 0x2109      MOVW     R1,#+521
   \       0x54   0x1A40             SUBS     R0,R0,R1
   \       0x56   0xD04E             BEQ.N    ??getMfgTokenSize_8
   \       0x58   0x38FF             SUBS     R0,R0,#+255
   \       0x5A   0xD04E             BEQ.N    ??getMfgTokenSize_0
   \       0x5C   0x1F00             SUBS     R0,R0,#+4
   \       0x5E   0xD038             BEQ.N    ??getMfgTokenSize_5
   \       0x60   0x38F4             SUBS     R0,R0,#+244
   \       0x62   0xD042             BEQ.N    ??getMfgTokenSize_2
   \       0x64   0xF44F 0x71FC      MOV      R1,#+504
   \       0x68   0x1A40             SUBS     R0,R0,R1
   \       0x6A   0xD036             BEQ.N    ??getMfgTokenSize_1
   \       0x6C   0x3814             SUBS     R0,R0,#+20
   \       0x6E   0xD03C             BEQ.N    ??getMfgTokenSize_2
   \       0x70   0xF240 0x21EB      MOVW     R1,#+747
   \       0x74   0x1A40             SUBS     R0,R0,R1
   \       0x76   0xD038             BEQ.N    ??getMfgTokenSize_2
   \       0x78   0x1E40             SUBS     R0,R0,#+1
   \       0x7A   0xD02E             BEQ.N    ??getMfgTokenSize_1
   \       0x7C   0x1EC0             SUBS     R0,R0,#+3
   \       0x7E   0xD02C             BEQ.N    ??getMfgTokenSize_1
   \       0x80   0x3808             SUBS     R0,R0,#+8
   \       0x82   0xD032             BEQ.N    ??getMfgTokenSize_2
   \       0x84   0x380A             SUBS     R0,R0,#+10
   \       0x86   0x2801             CMP      R0,#+1
   \       0x88   0xD931             BLS.N    ??getMfgTokenSize_9
   \       0x8A   0xF240 0x11FF      MOVW     R1,#+511
   \       0x8E   0x1A40             SUBS     R0,R0,R1
   \       0x90   0xD01F             BEQ.N    ??getMfgTokenSize_5
   \       0x92   0xF240 0x21FD      MOVW     R1,#+765
   \       0x96   0x1A40             SUBS     R0,R0,R1
   \       0x98   0xD01F             BEQ.N    ??getMfgTokenSize_1
   \       0x9A   0xF240 0x11EF      MOVW     R1,#+495
   \       0x9E   0x1A40             SUBS     R0,R0,R1
   \       0xA0   0xD029             BEQ.N    ??getMfgTokenSize_8
   \       0xA2   0x1F40             SUBS     R0,R0,#+5
   \       0xA4   0x2801             CMP      R0,#+1
   \       0xA6   0xD926             BLS.N    ??getMfgTokenSize_8
   \       0xA8   0x3808             SUBS     R0,R0,#+8
   \       0xAA   0xD020             BEQ.N    ??getMfgTokenSize_9
   \       0xAC   0x1E40             SUBS     R0,R0,#+1
   \       0xAE   0xD020             BEQ.N    ??getMfgTokenSize_10
   \       0xB0   0x1E40             SUBS     R0,R0,#+1
   \       0xB2   0xD01A             BEQ.N    ??getMfgTokenSize_2
   \       0xB4   0x1EC0             SUBS     R0,R0,#+3
   \       0xB6   0xD01A             BEQ.N    ??getMfgTokenSize_9
   \       0xB8   0xF44F 0x610F      MOV      R1,#+2288
   \       0xBC   0x1A40             SUBS     R0,R0,R1
   \       0xBE   0xD01C             BEQ.N    ??getMfgTokenSize_0
   \       0xC0   0xF44F 0x7100      MOV      R1,#+512
   \       0xC4   0x1A40             SUBS     R0,R0,R1
   \       0xC6   0xD018             BEQ.N    ??getMfgTokenSize_0
   \       0xC8   0xF640 0x012E      MOVW     R1,#+2094
   \       0xCC   0x1A40             SUBS     R0,R0,R1
   \       0xCE   0xD00C             BEQ.N    ??getMfgTokenSize_2
   \       0xD0   0xE015             B.N      ??getMfgTokenSize_11
    309              #define TOKEN_MFG TOKEN_DEF
    310              #define TOKEN_DEF(name, creator, iscnt, isidx, type, arraysize, ...) \
    311            case creator:                                                          \
    312              tokenSize = sizeof(type);                                            \
    313              break;
    314              // Multiple inclusion of unguarded token-related header files is by design; suppress violation.
    315              //cstat !MISRAC2012-Dir-4.10
    316              #include "hal/micro/cortexm3/efm32/token-manufacturing.h"
   \                     ??getMfgTokenSize_5: (+1)
   \       0xD2   0x2004             MOVS     R0,#+4
   \       0xD4   0x4770             BX       LR
   \                     ??getMfgTokenSize_3: (+1)
   \       0xD6   0x205C             MOVS     R0,#+92
   \       0xD8   0x4770             BX       LR
   \                     ??getMfgTokenSize_1: (+1)
   \       0xDA   0x2002             MOVS     R0,#+2
   \       0xDC   0x4770             BX       LR
   \                     ??getMfgTokenSize_6: (+1)
   \       0xDE   0x2014             MOVS     R0,#+20
   \       0xE0   0x4770             BX       LR
   \                     ??getMfgTokenSize_4: (+1)
   \       0xE2   0x2094             MOVS     R0,#+148
   \       0xE4   0x4770             BX       LR
   \                     ??getMfgTokenSize_7: (+1)
   \       0xE6   0x2022             MOVS     R0,#+34
   \       0xE8   0x4770             BX       LR
   \                     ??getMfgTokenSize_2: (+1)
   \       0xEA   0x2010             MOVS     R0,#+16
   \       0xEC   0x4770             BX       LR
   \                     ??getMfgTokenSize_9: (+1)
   \       0xEE   0x2020             MOVS     R0,#+32
   \       0xF0   0x4770             BX       LR
   \                     ??getMfgTokenSize_10: (+1)
   \       0xF2   0x205A             MOVS     R0,#+90
   \       0xF4   0x4770             BX       LR
   \                     ??getMfgTokenSize_8: (+1)
   \       0xF6   0x2001             MOVS     R0,#+1
   \       0xF8   0x4770             BX       LR
   \                     ??getMfgTokenSize_0: (+1)
   \       0xFA   0x2008             MOVS     R0,#+8
   \       0xFC   0x4770             BX       LR
    317              #undef TOKEN_MFG
    318              #undef TOKEN_DEF
    319              default:
    320                tokenSize = 0U;
   \                     ??getMfgTokenSize_11: (+1)
   \       0xFE   0x2000             MOVS     R0,#+0
    321                break;
    322            }
    323            #undef DEFINETOKENS
    324            return tokenSize;
   \      0x100   0x4770             BX       LR               ;; return
    325          }
    326          

   \                                 In section .text, align 2, keep-with-next
    327          uint8_t getMfgTokenArraySize(uint16_t creator)
    328          {
    329            uint8_t tokenArraySize;
    330          
    331            #define DEFINETOKENS
    332            switch (creator) {
   \                     getMfgTokenArraySize: (+1)
   \        0x0   0xF24B 0x6134      MOVW     R1,#+46644
   \        0x4   0x1A40             SUBS     R0,R0,R1
   \        0x6   0xD05F             BEQ.N    ??getMfgTokenArraySize_0
   \        0x8   0xF640 0x310F      MOVW     R1,#+2831
   \        0xC   0x1A40             SUBS     R0,R0,R1
   \        0xE   0xD059             BEQ.N    ??getMfgTokenArraySize_1
   \       0x10   0xF44F 0x7184      MOV      R1,#+264
   \       0x14   0x1A40             SUBS     R0,R0,R1
   \       0x16   0xD057             BEQ.N    ??getMfgTokenArraySize_0
   \       0x18   0x1EC0             SUBS     R0,R0,#+3
   \       0x1A   0xD055             BEQ.N    ??getMfgTokenArraySize_0
   \       0x1C   0x38F4             SUBS     R0,R0,#+244
   \       0x1E   0x2801             CMP      R0,#+1
   \       0x20   0xD952             BLS.N    ??getMfgTokenArraySize_0
   \       0x22   0x1EC0             SUBS     R0,R0,#+3
   \       0x24   0xD050             BEQ.N    ??getMfgTokenArraySize_0
   \       0x26   0x380F             SUBS     R0,R0,#+15
   \       0x28   0xD04E             BEQ.N    ??getMfgTokenArraySize_0
   \       0x2A   0x1E80             SUBS     R0,R0,#+2
   \       0x2C   0x2801             CMP      R0,#+1
   \       0x2E   0xD94B             BLS.N    ??getMfgTokenArraySize_0
   \       0x30   0xF240 0x1101      MOVW     R1,#+257
   \       0x34   0x1A40             SUBS     R0,R0,R1
   \       0x36   0xD047             BEQ.N    ??getMfgTokenArraySize_0
   \       0x38   0xF240 0x41EC      MOVW     R1,#+1260
   \       0x3C   0x1A40             SUBS     R0,R0,R1
   \       0x3E   0x2801             CMP      R0,#+1
   \       0x40   0xD942             BLS.N    ??getMfgTokenArraySize_0
   \       0x42   0xF44F 0x7184      MOV      R1,#+264
   \       0x46   0x1A40             SUBS     R0,R0,R1
   \       0x48   0xD03E             BEQ.N    ??getMfgTokenArraySize_0
   \       0x4A   0xF240 0x2109      MOVW     R1,#+521
   \       0x4E   0x1A40             SUBS     R0,R0,R1
   \       0x50   0xD03A             BEQ.N    ??getMfgTokenArraySize_0
   \       0x52   0x38FF             SUBS     R0,R0,#+255
   \       0x54   0xD038             BEQ.N    ??getMfgTokenArraySize_0
   \       0x56   0x1F00             SUBS     R0,R0,#+4
   \       0x58   0xD036             BEQ.N    ??getMfgTokenArraySize_0
   \       0x5A   0x38F4             SUBS     R0,R0,#+244
   \       0x5C   0xD034             BEQ.N    ??getMfgTokenArraySize_0
   \       0x5E   0xF44F 0x71FC      MOV      R1,#+504
   \       0x62   0x1A40             SUBS     R0,R0,R1
   \       0x64   0xD030             BEQ.N    ??getMfgTokenArraySize_0
   \       0x66   0x3814             SUBS     R0,R0,#+20
   \       0x68   0xD02E             BEQ.N    ??getMfgTokenArraySize_0
   \       0x6A   0xF240 0x21EB      MOVW     R1,#+747
   \       0x6E   0x1A40             SUBS     R0,R0,R1
   \       0x70   0x2801             CMP      R0,#+1
   \       0x72   0xD929             BLS.N    ??getMfgTokenArraySize_0
   \       0x74   0x1F00             SUBS     R0,R0,#+4
   \       0x76   0xD027             BEQ.N    ??getMfgTokenArraySize_0
   \       0x78   0x3808             SUBS     R0,R0,#+8
   \       0x7A   0xD025             BEQ.N    ??getMfgTokenArraySize_0
   \       0x7C   0x380A             SUBS     R0,R0,#+10
   \       0x7E   0x2801             CMP      R0,#+1
   \       0x80   0xD922             BLS.N    ??getMfgTokenArraySize_0
   \       0x82   0xF240 0x11FF      MOVW     R1,#+511
   \       0x86   0x1A40             SUBS     R0,R0,R1
   \       0x88   0xD01E             BEQ.N    ??getMfgTokenArraySize_0
   \       0x8A   0xF240 0x21FD      MOVW     R1,#+765
   \       0x8E   0x1A40             SUBS     R0,R0,R1
   \       0x90   0xD01A             BEQ.N    ??getMfgTokenArraySize_0
   \       0x92   0xF240 0x11EF      MOVW     R1,#+495
   \       0x96   0x1A40             SUBS     R0,R0,R1
   \       0x98   0xD016             BEQ.N    ??getMfgTokenArraySize_0
   \       0x9A   0x1F40             SUBS     R0,R0,#+5
   \       0x9C   0x2801             CMP      R0,#+1
   \       0x9E   0xBF84             ITT      HI 
   \       0xA0   0x3808             SUBHI    R0,R0,#+8
   \       0xA2   0x2802             CMPHI    R0,#+2
   \       0xA4   0xD910             BLS.N    ??getMfgTokenArraySize_0
   \       0xA6   0x1F40             SUBS     R0,R0,#+5
   \       0xA8   0xD00E             BEQ.N    ??getMfgTokenArraySize_0
   \       0xAA   0xF44F 0x610F      MOV      R1,#+2288
   \       0xAE   0x1A40             SUBS     R0,R0,R1
   \       0xB0   0xD00A             BEQ.N    ??getMfgTokenArraySize_0
   \       0xB2   0xF44F 0x7100      MOV      R1,#+512
   \       0xB6   0x1A40             SUBS     R0,R0,R1
   \       0xB8   0xD006             BEQ.N    ??getMfgTokenArraySize_0
   \       0xBA   0xF640 0x012E      MOVW     R1,#+2094
   \       0xBE   0x1A40             SUBS     R0,R0,R1
   \       0xC0   0xD002             BEQ.N    ??getMfgTokenArraySize_0
   \       0xC2   0xE003             B.N      ??getMfgTokenArraySize_2
    333              #define TOKEN_MFG TOKEN_DEF
    334              #define TOKEN_DEF(name, creator, iscnt, isidx, type, arraysize, ...) \
    335            case creator:                                                          \
    336              tokenArraySize = arraysize;                                          \
    337              break;
    338              // Multiple inclusion of unguarded token-related header files is by design; suppress violation.
    339              //cstat !MISRAC2012-Dir-4.10
    340              #include "hal/micro/cortexm3/efm32/token-manufacturing.h"
   \                     ??getMfgTokenArraySize_1: (+1)
   \       0xC4   0x2014             MOVS     R0,#+20
   \       0xC6   0x4770             BX       LR
   \                     ??getMfgTokenArraySize_0: (+1)
   \       0xC8   0x2001             MOVS     R0,#+1
   \       0xCA   0x4770             BX       LR
    341              #undef TOKEN_MFG
    342              #undef TOKEN_DEF
    343              default:
    344                tokenArraySize = 0U;
   \                     ??getMfgTokenArraySize_2: (+1)
   \       0xCC   0x2000             MOVS     R0,#+0
    345                break;
    346            }
    347            #undef DEFINETOKENS
    348            return tokenArraySize;
   \       0xCE   0x4770             BX       LR               ;; return
    349          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x....'....        DC32     nullEui

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0x0FE0'8048        DC32     0xfe08048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x....'....        DC32     lockBitsInMainFlashSpace

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0x0FE0'2000        DC32     0xfe02000

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x6D 0x66          DC8 "mfg-token.c"
   \              0x67 0x2D    
   \              0x74 0x6F    
   \              0x6B 0x65    
   \              0x6E 0x2E    
   \              0x63 0x00    
    350          #endif // EMBER_TEST

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   getMfgTokenAddress
       0   getMfgTokenArraySize
      24   getMfgTokenData
        24   -> halCommonMemCompare
        24   -> halCommonMemMove
        24   -> halInternalGetMfgTokenData
       0   getMfgTokenSize
      16   halInternalGetMfgTokenData
         0   -> getMfgTokenData
        16   -> getMfgTokenData
        16   -> halCommonMemCompare
      48   halInternalSetMfgTokenData
        48   -> SE_writeUserData
        48   -> halInternalAssertFailed
        48   -> halInternalFlashWrite
        48   -> halInternalFlashWriteSeries2


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       6  ?Subroutine0
      12  ?_0
       2  TOKEN_MFG_ASH_CONFIG
       2  TOKEN_MFG_BOARD_NAME
       2  TOKEN_MFG_BOOTLOAD_AES_KEY
       2  TOKEN_MFG_CBKE_283K1_DATA
       2  TOKEN_MFG_CBKE_DATA
       2  TOKEN_MFG_CCA_THRESHOLD
       2  TOKEN_MFG_CTUNE
       2  TOKEN_MFG_CUSTOM_EUI_64
       2  TOKEN_MFG_CUSTOM_VERSION
       2  TOKEN_MFG_EMBER_EUI_64
       2  TOKEN_MFG_EUI_64
       2  TOKEN_MFG_EZSP_STORAGE
       2  TOKEN_MFG_INSTALLATION_CODE
       2  TOKEN_MFG_LFXO_TUNE
       2  TOKEN_MFG_LOCKBITS_CLW0
       2  TOKEN_MFG_LOCKBITS_DLW
       2  TOKEN_MFG_LOCKBITS_MLW
       2  TOKEN_MFG_LOCKBITS_PLW
       2  TOKEN_MFG_LOCKBITS_ULW
       2  TOKEN_MFG_MANUF_ID
       2  TOKEN_MFG_NVM3_CRYPTO_KEY
       2  TOKEN_MFG_PHY_CONFIG
       2  TOKEN_MFG_SECURE_BOOTLOADER_KEY
       2  TOKEN_MFG_SECURITY_CONFIG
       2  TOKEN_MFG_SERIAL_NUMBER
       2  TOKEN_MFG_SIGNED_BOOTLOADER_KEY_X
       2  TOKEN_MFG_SIGNED_BOOTLOADER_KEY_Y
       2  TOKEN_MFG_STRING
       2  TOKEN_MFG_SYNTH_FREQ_OFFSET
       2  TOKEN_MFG_THREAD_JOIN_KEY
       2  TOKEN_MFG_XO_TUNE
       2  TOKEN_MFG_ZWAVE_COUNTRY_FREQ
       2  TOKEN_MFG_ZWAVE_HW_VERSION
       2  TOKEN_MFG_ZWAVE_PSEUDO_RANDOM_NUMBER
       2  TOKEN_MFG_ZW_INITIALIZED
       2  TOKEN_MFG_ZW_PRK
       2  TOKEN_MFG_ZW_PUK
       2  TOKEN_MFG_ZW_QR_CODE
     478  getMfgTokenAddress
     208  getMfgTokenArraySize
     186  getMfgTokenData
     258  getMfgTokenSize
      66  halInternalGetMfgTokenData
     346  halInternalSetMfgTokenData
    8192  lockBitsInMainFlashSpace
       8  nullEui

 
    96 bytes in section .rodata
 1 568 bytes in section .text
 8 192 bytes in section LOCKBITS_IN_MAINFLASH
 
 1 568 bytes of CODE  memory
    96 bytes of CONST memory
 8 192 bytes of DATA  memory

Errors: none
Warnings: 2
