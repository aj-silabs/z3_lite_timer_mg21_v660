###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:48
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\em_core.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW4644.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\em_core.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"em_core.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0
#        -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\em_core.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\em_core.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\em_core.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Core interrupt handling API
      4           * @version 5.8.0
      5           *******************************************************************************
      6           * # License
      7           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      8           *******************************************************************************
      9           *
     10           * SPDX-License-Identifier: Zlib
     11           *
     12           * The licensor of this software is Silicon Laboratories Inc.
     13           *
     14           * This software is provided 'as-is', without any express or implied
     15           * warranty. In no event will the authors be held liable for any damages
     16           * arising from the use of this software.
     17           *
     18           * Permission is granted to anyone to use this software for any purpose,
     19           * including commercial applications, and to alter it and redistribute it
     20           * freely, subject to the following restrictions:
     21           *
     22           * 1. The origin of this software must not be misrepresented; you must not
     23           *    claim that you wrote the original software. If you use this software
     24           *    in a product, an acknowledgment in the product documentation would be
     25           *    appreciated but is not required.
     26           * 2. Altered source versions must be plainly marked as such, and must not be
     27           *    misrepresented as being the original software.
     28           * 3. This notice may not be removed or altered from any source distribution.
     29           *
     30           ******************************************************************************/
     31          #include "em_core.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t __NVIC_GetPriority(IRQn_Type)
   \                     __NVIC_GetPriority: (+1)
   \        0x0   0x0001             MOVS     R1,R0
   \        0x2   0xD402             BMI.N    ??__NVIC_GetPriority_0
   \        0x4   0x....             LDR.N    R0,??DataTable10  ;; 0xe000e400
   \        0x6   0x5C40             LDRB     R0,[R0, R1]
   \        0x8   0xE005             B.N      ??__NVIC_GetPriority_1
   \                     ??__NVIC_GetPriority_0: (+1)
   \        0xA   0x....             LDR.N    R0,??DataTable10_1  ;; 0xe000ed18
   \        0xC   0xF001 0x010F      AND      R1,R1,#0xF
   \       0x10   0x4401             ADD      R1,R0,R1
   \       0x12   0xF811 0x0C04      LDRB     R0,[R1, #-4]
   \                     ??__NVIC_GetPriority_1: (+1)
   \       0x16   0x0900             LSRS     R0,R0,#+4
   \       0x18   0x4770             BX       LR               ;; return
     32          #include "em_assert.h"
     33          
     34          #if defined(EMLIB_USER_CONFIG)
     35          #include "emlib_config.h"
     36          #endif
     37          
     38          /***************************************************************************//**
     39           * @addtogroup emlib
     40           * @{
     41           ******************************************************************************/
     42          
     43          /* *INDENT-OFF* */
     44          /***************************************************************************//**
     45            @addtogroup CORE
     46            @brief Core interrupt handling API
     47          
     48            @li @ref core_intro
     49            @li @ref core_conf
     50            @li @ref core_macro_api
     51            @li @ref core_reimplementation
     52            @li @ref core_vector_tables
     53            @li @ref core_examples
     54            @li @ref core_porting
     55          
     56          @n @section core_intro Introduction
     57          
     58            CORE interrupt API provides a simple and safe means
     59            to disable and enable interrupts to protect sections of code.
     60          
     61            This is often referred to as "critical sections". This module provides
     62            support for three types of critical sections, each with different interrupt
     63            blocking capabilities.
     64          
     65            @li <b>CRITICAL</b> section: Inside a critical section, all interrupts are
     66                disabled (except for fault handlers). The PRIMASK register is always used for
     67                interrupt disable/enable.
     68            @li <b>ATOMIC</b> section: This type of section is configurable and the default
     69                method is to use PRIMASK. With BASEPRI configuration, interrupts with priority
     70                equal to or lower than a given configurable level are disabled. The interrupt
     71                disable priority level is defined at compile time. The BASEPRI register is not
     72                available for all architectures.
     73            @li <b>NVIC mask</b> section: Disable NVIC (external interrupts) on an
     74                individual manner.
     75          
     76            em_core also has an API for manipulating RAM-based interrupt vector tables.
     77          
     78          @n @section core_conf Compile-time Configuration
     79          
     80            The following @htmlonly #defines @endhtmlonly are used to configure em_core:
     81            @verbatim
     82            // The interrupt priority level used inside ATOMIC sections.
     83            #define CORE_ATOMIC_BASE_PRIORITY_LEVEL    3
     84          
     85            // A method used for interrupt disable/enable within ATOMIC sections.
     86            #define CORE_ATOMIC_METHOD                 CORE_ATOMIC_METHOD_PRIMASK
     87            @endverbatim
     88          
     89            If the default values do not support your needs, they can be overridden
     90            by supplying -D compiler flags on the compiler command line or by collecting
     91            all macro redefinitions in a file named @em emlib_config.h and then supplying
     92            -DEMLIB_USER_CONFIG on a compiler command line.
     93          
     94            @note The default emlib configuration for ATOMIC section interrupt disable
     95                  method is using PRIMASK, i.e., ATOMIC sections are implemented as
     96                  CRITICAL sections.
     97          
     98            @note Due to architectural limitations Cortex-M0+ devices do not support
     99                  ATOMIC type critical sections using the BASEPRI register. On M0+
    100                  devices ATOMIC section helper macros are available but they are
    101                  implemented as CRITICAL sections using PRIMASK register.
    102          
    103          @n @section core_macro_api Macro API
    104          
    105            The primary em_core API is the macro API. Macro API will map to correct
    106            CORE functions according to the selected @ref CORE_ATOMIC_METHOD and similar
    107            configurations (the full CORE API is of course also available).
    108            The most useful macros are as follows:
    109          
    110            @ref CORE_DECLARE_IRQ_STATE @n @ref CORE_ENTER_ATOMIC() @n
    111            @ref CORE_EXIT_ATOMIC()@n
    112            Used together to implement an ATOMIC section.
    113            @verbatim
    114            {
    115              CORE_DECLARE_IRQ_STATE;           // Storage for saving IRQ state prior to
    116                                                // atomic section entry.
    117          
    118              CORE_ENTER_ATOMIC();              // Enter atomic section.
    119          
    120              ...
    121              ... your code goes here ...
    122              ...
    123          
    124              CORE_EXIT_ATOMIC();               // Exit atomic section, IRQ state is restored.
    125            }
    126            @endverbatim
    127          
    128            @n @ref CORE_ATOMIC_SECTION(yourcode)@n
    129            A concatenation of all three macros above.
    130            @verbatim
    131            {
    132              CORE_ATOMIC_SECTION(
    133                ...
    134                ... your code goes here ...
    135                ...
    136              )
    137            }
    138            @endverbatim
    139          
    140            @n @ref CORE_DECLARE_IRQ_STATE @n @ref CORE_ENTER_CRITICAL() @n
    141            @ref CORE_EXIT_CRITICAL() @n @ref CORE_CRITICAL_SECTION(yourcode)@n
    142            These macros implement CRITICAL sections in a similar fashion as described
    143            above for ATOMIC sections.
    144          
    145            @n @ref CORE_DECLARE_NVIC_STATE @n @ref CORE_ENTER_NVIC() @n
    146            @ref CORE_EXIT_NVIC() @n @ref CORE_NVIC_SECTION(yourcode)@n
    147            These macros implement NVIC mask sections in a similar fashion as described
    148            above for ATOMIC sections. See @ref core_examples for an example.
    149          
    150            Refer to @em Macros or <em>Macro Definition Documentation</em> below for a
    151            full list of macros.
    152          
    153          @n @section core_reimplementation API reimplementation
    154          
    155            Most of the functions in the API are implemented as weak functions. This means
    156            that it is easy to reimplement when special needs arise. Shown below is a
    157            reimplementation of CRITICAL sections suitable if FreeRTOS OS is used:
    158            @verbatim
    159            CORE_irqState_t CORE_EnterCritical(void)
    160            {
    161              vPortEnterCritical();
    162              return 0;
    163            }
    164          
    165            void CORE_ExitCritical(CORE_irqState_t irqState)
    166            {
    167              (void)irqState;
    168              vPortExitCritical();
    169            }
    170            @endverbatim
    171            Also note that CORE_Enter/ExitCritical() are not implemented as inline
    172            functions. As a result, reimplementations will be possible even when original
    173            implementations are inside a linked library.
    174          
    175            Some RTOSes must be notified on interrupt handler entry and exit. Macros
    176            @ref CORE_INTERRUPT_ENTRY() and @ref CORE_INTERRUPT_EXIT() are suitable
    177            placeholders for inserting such code. Insert these macros in all your
    178            interrupt handlers and then override the default macro implementations.
    179            This is an example if uC/OS is used:
    180            @verbatim
    181            // In emlib_config.h:
    182          
    183            #define CORE_INTERRUPT_ENTRY()   OSIntEnter()
    184            #define CORE_INTERRUPT_EXIT()    OSIntExit()
    185            @endverbatim
    186          
    187          @n @section core_vector_tables Interrupt vector tables
    188          
    189            When using RAM based interrupt vector tables it is the user's responsibility
    190            to allocate the table space correctly. The tables must be aligned as specified
    191            in the CPU reference manual.
    192          
    193            @ref CORE_InitNvicVectorTable()@n
    194            Initialize a RAM based vector table by copying table entries from a source
    195            vector table to a target table. VTOR is set to the address of the target
    196            vector table.
    197          
    198            @n @ref CORE_GetNvicRamTableHandler() @n @ref CORE_SetNvicRamTableHandler()@n
    199            Use these functions to get or set the interrupt handler for a specific IRQn.
    200            They both use the interrupt vector table defined by the current
    201            VTOR register value.
    202          
    203          @n @section core_examples Examples
    204          
    205            Implement an NVIC critical section:
    206            @verbatim
    207            {
    208              CORE_DECLARE_NVIC_ZEROMASK(mask); // A zero initialized NVIC disable mask
    209          
    210              // Set mask bits for IRQs to block in the NVIC critical section.
    211              // In many cases, you can create the disable mask once upon application
    212              // startup and use the mask globally throughout the application lifetime.
    213              CORE_NvicMaskSetIRQ(LEUART0_IRQn, &mask);
    214              CORE_NvicMaskSetIRQ(VCMP_IRQn,    &mask);
    215          
    216              // Enter NVIC critical section with the disable mask
    217              CORE_NVIC_SECTION(&mask,
    218                ...
    219                ... your code goes here ...
    220                ...
    221              )
    222            }
    223            @endverbatim
    224          
    225          @n @section core_porting Porting from em_int
    226          
    227            Existing code using INT_Enable() and INT_Disable() must be ported to the
    228            em_core API. While em_int used, a global counter to store the interrupt state,
    229            em_core uses a local variable. Any usage of INT_Disable(), therefore, needs to
    230            be replaced with a declaration of the interrupt state variable before entering
    231            the critical section.
    232          
    233            Since the state variable is in local scope, the critical section exit
    234            needs to occur within the scope of the variable. If multiple nested critical
    235            sections are used, each needs to have its own state variable in its own scope.
    236          
    237            In many cases, completely disabling all interrupts using CRITICAL sections
    238            might be more heavy-handed than needed. When porting, consider whether other
    239            types of sections, such as ATOMIC or NVIC mask, can be used to only disable
    240            a subset of the interrupts.
    241          
    242            Replacing em_int calls with em_core function calls:
    243            @verbatim
    244            void func(void)
    245            {
    246              // INT_Disable();
    247              CORE_DECLARE_IRQ_STATE;
    248              CORE_ENTER_ATOMIC();
    249                .
    250                .
    251                .
    252              // INT_Enable();
    253              CORE_EXIT_ATOMIC();
    254            }
    255            @endverbatim
    256           * @{
    257           ******************************************************************************/
    258          /* *INDENT-ON* */
    259          
    260          /*******************************************************************************
    261           *******************************   DEFINES   ***********************************
    262           ******************************************************************************/
    263          
    264          #if !defined(CORE_ATOMIC_BASE_PRIORITY_LEVEL)
    265          /** The interrupt priority level disabled within ATOMIC regions. Interrupts
    266           *  with priority level equal to or lower than this definition will be disabled
    267           *  within ATOMIC regions. */
    268          #define CORE_ATOMIC_BASE_PRIORITY_LEVEL   3
    269          #endif
    270          
    271          #if !defined(CORE_ATOMIC_METHOD)
    272          /** Specify which method to use when implementing ATOMIC sections. You can
    273           *  select between BASEPRI or PRIMASK method.
    274           *  @note On Cortex-M0+ devices only PRIMASK can be used. */
    275          #define CORE_ATOMIC_METHOD    CORE_ATOMIC_METHOD_PRIMASK
    276          #endif
    277          
    278          #if !defined(CORE_INTERRUPT_ENTRY)
    279          // Some RTOSes must be notified on interrupt entry (and exit).
    280          // Use this macro at the start of all your interrupt handlers.
    281          // Reimplement the macro in emlib_config.h to suit the needs of your RTOS.
    282          /** Placeholder for optional interrupt handler entry code. This might be needed
    283           *  when working with an RTOS. */
    284          #define CORE_INTERRUPT_ENTRY()
    285          #endif
    286          
    287          #if !defined(CORE_INTERRUPT_EXIT)
    288          /** Placeholder for optional interrupt handler exit code. This might be needed
    289           *  when working with an RTOS. */
    290          #define CORE_INTERRUPT_EXIT()
    291          #endif
    292          
    293          // Compile time sanity check.
    294          #if (CORE_ATOMIC_METHOD != CORE_ATOMIC_METHOD_PRIMASK) \
    295            && (CORE_ATOMIC_METHOD != CORE_ATOMIC_METHOD_BASEPRI)
    296          #error "em_core: Undefined ATOMIC IRQ handling strategy."
    297          #endif
    298          
    299          /*******************************************************************************
    300           ******************************   FUNCTIONS   **********************************
    301           ******************************************************************************/
    302          
    303          /***************************************************************************//**
    304           * @brief
    305           *   Disable interrupts.
    306           *
    307           *   Disable all interrupts by setting PRIMASK.
    308           *   (Fault exception handlers will still be enabled).
    309           ******************************************************************************/

   \                                 In section .text, align 2
    310          SL_WEAK void CORE_CriticalDisableIrq(void)
    311          {
    312            __disable_irq();
   \                     CORE_CriticalDisableIrq: (+1)
   \        0x0   0xB672             CPSID    I
    313          }
   \        0x2   0x4770             BX       LR               ;; return
    314          
    315          /***************************************************************************//**
    316           * @brief
    317           *   Enable interrupts.
    318           *
    319           *   Enable interrupts by clearing PRIMASK.
    320           ******************************************************************************/

   \                                 In section .text, align 2
    321          SL_WEAK void CORE_CriticalEnableIrq(void)
    322          {
    323            __enable_irq();
   \                     CORE_CriticalEnableIrq: (+1)
   \        0x0   0xB662             CPSIE    I
    324          }
   \        0x2   0x4770             BX       LR               ;; return
    325          
    326          /***************************************************************************//**
    327           * @brief
    328           *   Enter a CRITICAL section.
    329           *
    330           *   When a CRITICAL section is entered, all interrupts (except fault handlers)
    331           *   are disabled.
    332           *
    333           * @return
    334           *   The value of PRIMASK register prior to the CRITICAL section entry.
    335           ******************************************************************************/

   \                                 In section .text, align 2
    336          SL_WEAK CORE_irqState_t CORE_EnterCritical(void)
    337          {
    338            CORE_irqState_t irqState = __get_PRIMASK();
   \                     CORE_EnterCritical: (+1)
   \        0x0   0xF3EF 0x8010      MRS      R0,PRIMASK
    339            __disable_irq();
   \        0x4   0xB672             CPSID    I
    340            return irqState;
   \        0x6   0x4770             BX       LR               ;; return
    341          }
    342          
    343          /***************************************************************************//**
    344           * @brief
    345           *   Exit a CRITICAL section.
    346           *
    347           * @param[in] irqState
    348           *   The interrupt priority blocking level to restore to PRIMASK when exiting
    349           *   the CRITICAL section. This value is usually the one returned by a prior
    350           *   call to @ref CORE_EnterCritical().
    351           ******************************************************************************/

   \                                 In section .text, align 2
    352          SL_WEAK void CORE_ExitCritical(CORE_irqState_t irqState)
    353          {
    354            if (irqState == 0U) {
   \                     CORE_ExitCritical: (+1)
   \        0x0   0xB900             CBNZ.N   R0,??CORE_ExitCritical_0
    355              __enable_irq();
   \        0x2   0xB662             CPSIE    I
    356            }
    357          }
   \                     ??CORE_ExitCritical_0: (+1)
   \        0x4   0x4770             BX       LR               ;; return
    358          
    359          /***************************************************************************//**
    360           * @brief
    361           *   Brief interrupt enable/disable sequence to allow handling of
    362           *   pending interrupts.
    363           *
    364           * @note
    365           *   Usually used within a CRITICAL section.
    366           ******************************************************************************/

   \                                 In section .text, align 2
    367          SL_WEAK void CORE_YieldCritical(void)
    368          {
    369            if ((__get_PRIMASK() & 1U) != 0U) {
   \                     CORE_YieldCritical: (+1)
   \        0x0   0xF3EF 0x8010      MRS      R0,PRIMASK
   \        0x4   0x07C0             LSLS     R0,R0,#+31
   \        0x6   0xD503             BPL.N    ??CORE_YieldCritical_0
    370              __enable_irq();
   \        0x8   0xB662             CPSIE    I
    371              __ISB();
   \        0xA   0xF3BF 0x8F6F      ISB      SY
    372              __disable_irq();
   \        0xE   0xB672             CPSID    I
    373            }
    374          }
   \                     ??CORE_YieldCritical_0: (+1)
   \       0x10   0x4770             BX       LR               ;; return
    375          
    376          /***************************************************************************//**
    377           * @brief
    378           *   Disable interrupts.
    379           *
    380           *   Disable interrupts with a priority lower or equal to
    381           *   @ref CORE_ATOMIC_BASE_PRIORITY_LEVEL. Sets core BASEPRI register
    382           *   to CORE_ATOMIC_BASE_PRIORITY_LEVEL.
    383           *
    384           * @note
    385           *   If @ref CORE_ATOMIC_METHOD is @ref CORE_ATOMIC_METHOD_PRIMASK, this
    386           *   function is identical to @ref CORE_CriticalDisableIrq().
    387           ******************************************************************************/

   \                                 In section .text, align 2
    388          SL_WEAK void CORE_AtomicDisableIrq(void)
    389          {
    390          #if (CORE_ATOMIC_METHOD == CORE_ATOMIC_METHOD_BASEPRI)
    391            __set_BASEPRI(CORE_ATOMIC_BASE_PRIORITY_LEVEL << (8 - __NVIC_PRIO_BITS));
   \                     CORE_AtomicDisableIrq: (+1)
   \        0x0   0x2030             MOVS     R0,#+48
   \        0x2   0xF380 0x8811      MSR      BASEPRI,R0
    392          #else
    393            __disable_irq();
    394          #endif // (CORE_ATOMIC_METHOD == CORE_ATOMIC_METHOD_BASEPRI)
    395          }
   \        0x6   0x4770             BX       LR               ;; return
    396          
    397          /***************************************************************************//**
    398           * @brief
    399           *   Enable interrupts.
    400           *
    401           *   Enable interrupts by setting core BASEPRI register to 0.
    402           *
    403           * @note
    404           *   If @ref CORE_ATOMIC_METHOD is @ref CORE_ATOMIC_METHOD_BASEPRI and PRIMASK
    405           *   is set (CPU is inside a CRITICAL section), interrupts will still be
    406           *   disabled after calling this function.
    407           *
    408           * @note
    409           *   If @ref CORE_ATOMIC_METHOD is @ref CORE_ATOMIC_METHOD_PRIMASK, this
    410           *   function is identical to @ref CORE_CriticalEnableIrq().
    411           ******************************************************************************/

   \                                 In section .text, align 2
    412          SL_WEAK void CORE_AtomicEnableIrq(void)
    413          {
    414          #if (CORE_ATOMIC_METHOD == CORE_ATOMIC_METHOD_BASEPRI)
    415            __set_BASEPRI(0);
   \                     CORE_AtomicEnableIrq: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0xF380 0x8811      MSR      BASEPRI,R0
    416          #else
    417            __enable_irq();
    418          #endif // (CORE_ATOMIC_METHOD == CORE_ATOMIC_METHOD_BASEPRI)
    419          }
   \        0x6   0x4770             BX       LR               ;; return
    420          
    421          /***************************************************************************//**
    422           * @brief
    423           *   Enter an ATOMIC section.
    424           *
    425           *   When an ATOMIC section is entered, interrupts with priority lower or equal
    426           *   to @ref CORE_ATOMIC_BASE_PRIORITY_LEVEL are disabled.
    427           *
    428           * @note
    429           *   If @ref CORE_ATOMIC_METHOD is @ref CORE_ATOMIC_METHOD_PRIMASK, this
    430           *   function is identical to @ref CORE_EnterCritical().
    431           *
    432           * @return
    433           *   The value of BASEPRI register prior to ATOMIC section entry.
    434           ******************************************************************************/

   \                                 In section .text, align 2
    435          SL_WEAK CORE_irqState_t CORE_EnterAtomic(void)
    436          {
    437          #if (CORE_ATOMIC_METHOD == CORE_ATOMIC_METHOD_BASEPRI)
    438            CORE_irqState_t irqState = __get_BASEPRI();
   \                     CORE_EnterAtomic: (+1)
   \        0x0   0xF3EF 0x8011      MRS      R0,BASEPRI
    439            __set_BASEPRI(CORE_ATOMIC_BASE_PRIORITY_LEVEL << (8 - __NVIC_PRIO_BITS));
   \        0x4   0x2130             MOVS     R1,#+48
   \        0x6   0xF381 0x8811      MSR      BASEPRI,R1
    440            return irqState;
   \        0xA   0x4770             BX       LR               ;; return
    441          #else
    442            CORE_irqState_t irqState = __get_PRIMASK();
    443            __disable_irq();
    444            return irqState;
    445          #endif // (CORE_ATOMIC_METHOD == CORE_ATOMIC_METHOD_BASEPRI)
    446          }
    447          
    448          /***************************************************************************//**
    449           * @brief
    450           *   Exit an ATOMIC section.
    451           *
    452           * @param[in] irqState
    453           *   The interrupt priority blocking level to restore to BASEPRI when exiting
    454           *   the ATOMIC section. This value is usually the one returned by a prior
    455           *   call to @ref CORE_EnterAtomic().
    456           *
    457           * @note
    458           *   If @ref CORE_ATOMIC_METHOD is set to @ref CORE_ATOMIC_METHOD_PRIMASK, this
    459           *   function is identical to @ref CORE_ExitCritical().
    460           ******************************************************************************/

   \                                 In section .text, align 2
    461          SL_WEAK void CORE_ExitAtomic(CORE_irqState_t irqState)
    462          {
    463          #if (CORE_ATOMIC_METHOD == CORE_ATOMIC_METHOD_BASEPRI)
    464            __set_BASEPRI(irqState);
   \                     CORE_ExitAtomic: (+1)
   \        0x0   0xF380 0x8811      MSR      BASEPRI,R0
    465          #else
    466            if (irqState == 0U) {
    467              __enable_irq();
    468            }
    469          #endif // (CORE_ATOMIC_METHOD == CORE_ATOMIC_METHOD_BASEPRI)
    470          }
   \        0x4   0x4770             BX       LR               ;; return
    471          
    472          /***************************************************************************//**
    473           * @brief
    474           *   Brief interrupt enable/disable sequence to allow handling of
    475           *   pending interrupts.
    476           *
    477           * @note
    478           *   Usully used within an ATOMIC section.
    479           *
    480           * @note
    481           *   If @ref CORE_ATOMIC_METHOD is @ref CORE_ATOMIC_METHOD_PRIMASK, this
    482           *   function is identical to @ref CORE_YieldCritical().
    483           ******************************************************************************/

   \                                 In section .text, align 2
    484          SL_WEAK void CORE_YieldAtomic(void)
    485          {
    486          #if (CORE_ATOMIC_METHOD == CORE_ATOMIC_METHOD_BASEPRI)
    487            CORE_irqState_t basepri = __get_BASEPRI();
   \                     CORE_YieldAtomic: (+1)
   \        0x0   0xF3EF 0x8011      MRS      R0,BASEPRI
    488            if (basepri >= (CORE_ATOMIC_BASE_PRIORITY_LEVEL << (8 - __NVIC_PRIO_BITS))) {
   \        0x4   0x2830             CMP      R0,#+48
   \        0x6   0xD306             BCC.N    ??CORE_YieldAtomic_0
    489              __set_BASEPRI(0);
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0xF381 0x8811      MSR      BASEPRI,R1
    490              __ISB();
   \        0xE   0xF3BF 0x8F6F      ISB      SY
    491              __set_BASEPRI(basepri);
   \       0x12   0xF380 0x8811      MSR      BASEPRI,R0
    492            }
    493          #else
    494            if ((__get_PRIMASK() & 1U) != 0U) {
    495              __enable_irq();
    496              __ISB();
    497              __disable_irq();
    498            }
    499          #endif // (CORE_ATOMIC_METHOD == CORE_ATOMIC_METHOD_BASEPRI)
    500          }
   \                     ??CORE_YieldAtomic_0: (+1)
   \       0x16   0x4770             BX       LR               ;; return
    501          
    502          /***************************************************************************//**
    503           * @brief
    504           *   Enter a NVIC mask section.
    505           *
    506           *   When a NVIC mask section is entered, specified NVIC interrupts
    507           *   are disabled.
    508           *
    509           * @param[out] nvicState
    510           *   Return NVIC interrupts enable mask prior to section entry.
    511           *
    512           * @param[in] disable
    513           *   A mask specifying which NVIC interrupts to disable within the section.
    514           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    515          void CORE_EnterNvicMask(CORE_nvicMask_t *nvicState,
    516                                  const CORE_nvicMask_t *disable)
    517          {
   \                     CORE_EnterNvicMask: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    518            CORE_CRITICAL_SECTION(
    519              *nvicState = *(CORE_nvicMask_t*)((uint32_t)&NVIC->ICER[0]);
    520              *(CORE_nvicMask_t*)((uint32_t)&NVIC->ICER[0]) = *disable;
    521              )
   \        0x6   0x....'....        BL       CORE_EnterCritical
   \        0xA   0x....             LDR.N    R1,??DataTable10_2  ;; 0xe000e180
   \        0xC   0xE9D1 0x2300      LDRD     R2,R3,[R1, #+0]
   \       0x10   0xE9C4 0x2300      STRD     R2,R3,[R4, #+0]
   \       0x14   0xE9D5 0x6700      LDRD     R6,R7,[R5, #+0]
   \       0x18   0xE9C1 0x6700      STRD     R6,R7,[R1, #+0]
   \       0x1C   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \       0x20   0x....'....        B.W      CORE_ExitCritical
    522          }
    523          
    524          /***************************************************************************//**
    525           * @brief
    526           *   Disable NVIC interrupts.
    527           *
    528           * @param[in] disable
    529           *   A mask specifying which NVIC interrupts to disable.
    530           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    531          void CORE_NvicDisableMask(const CORE_nvicMask_t *disable)
    532          {
   \                     CORE_NvicDisableMask: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    533            CORE_CRITICAL_SECTION(
    534              *(CORE_nvicMask_t*)((uint32_t)&NVIC->ICER[0]) = *disable;
    535              )
   \        0x4   0x....'....        BL       CORE_EnterCritical
   \        0x8   0xE9D4 0x2300      LDRD     R2,R3,[R4, #+0]
   \        0xC   0x....             LDR.N    R1,??DataTable10_2  ;; 0xe000e180
   \        0xE   0x....             B.N      ?Subroutine0
    536          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xE9C1 0x2300      STRD     R2,R3,[R1, #+0]
   \                     ??Subroutine0_0: (+1)
   \        0x4   0xE8BD 0x4010      POP      {R4,LR}
   \        0x8   0x....'....        B.W      CORE_ExitCritical
    537          
    538          /***************************************************************************//**
    539           * @brief
    540           *   Set current NVIC interrupt enable mask.
    541           *
    542           * @param[out] enable
    543           *   A mask specifying which NVIC interrupts are currently enabled.
    544           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    545          void CORE_NvicEnableMask(const CORE_nvicMask_t *enable)
    546          {
   \                     CORE_NvicEnableMask: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    547            CORE_CRITICAL_SECTION(
    548              *(CORE_nvicMask_t*)((uint32_t)&NVIC->ISER[0]) = *enable;
    549              )
   \        0x4   0x....'....        BL       CORE_EnterCritical
   \        0x8   0xE9D4 0x2300      LDRD     R2,R3,[R4, #+0]
   \        0xC   0x....             LDR.N    R1,??DataTable10_3  ;; 0xe000e100
   \        0xE                      REQUIRE ?Subroutine0
   \        0xE                      ;; // Fall through to label ?Subroutine0
    550          }
    551          
    552          /***************************************************************************//**
    553           * @brief
    554           *   Brief NVIC interrupt enable/disable sequence to allow handling of
    555           *   pending interrupts.
    556           *
    557           * @param[in] enable
    558           *   A mask specifying which NVIC interrupts to briefly enable.
    559           *
    560           * @note
    561           *   Usually used within an NVIC mask section.
    562           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    563          void CORE_YieldNvicMask(const CORE_nvicMask_t *enable)
    564          {
   \                     CORE_YieldNvicMask: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4607             MOV      R7,R0
    565            CORE_nvicMask_t nvicMask;
    566          
    567            // Get current NVIC enable mask.
    568            CORE_CRITICAL_SECTION(
    569              nvicMask = *(CORE_nvicMask_t*)((uint32_t)&NVIC->ISER[0]);
    570              )
   \        0x4   0x....'....        BL       CORE_EnterCritical
   \        0x8   0x....             LDR.N    R6,??DataTable10_3  ;; 0xe000e100
   \        0xA   0xE9D6 0x4500      LDRD     R4,R5,[R6, #+0]
   \        0xE   0x....'....        BL       CORE_ExitCritical
    571          
    572            // Make a mask with bits set for those interrupts that are currently
    573            // disabled but are set in the enable mask.
    574          #if (CORE_NVIC_REG_WORDS == 1)
    575            nvicMask.a[0] &= enable->a[0];
    576            nvicMask.a[0] = ~nvicMask.a[0] & enable->a[0];
    577          
    578            if (nvicMask.a[0] != 0) {
    579          #elif (CORE_NVIC_REG_WORDS == 2)
    580            nvicMask.a[0] &= enable->a[0];
   \       0x12   0x6838             LDR      R0,[R7, #+0]
    581            nvicMask.a[1] &= enable->a[1];
   \       0x14   0x687A             LDR      R2,[R7, #+4]
   \       0x16   0x4004             ANDS     R4,R0,R4
    582            nvicMask.a[0] = ~nvicMask.a[0] & enable->a[0];
   \       0x18   0xEA20 0x0404      BIC      R4,R0,R4
   \       0x1C   0xEA02 0x0105      AND      R1,R2,R5
    583            nvicMask.a[1] = ~nvicMask.a[1] & enable->a[1];
   \       0x20   0xEA22 0x0101      BIC      R1,R2,R1
    584          
    585            if ((nvicMask.a[0] != 0U) || (nvicMask.a[1] != 0U)) {
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0xBF08             IT       EQ 
   \       0x28   0x2900             CMPEQ    R1,#+0
   \       0x2A   0xD004             BEQ.N    ??CORE_YieldNvicMask_0
    586          #elif (CORE_NVIC_REG_WORDS == 3)
    587            nvicMask.a[0] &= enable->a[0];
    588            nvicMask.a[1] &= enable->a[1];
    589            nvicMask.a[2] &= enable->a[2];
    590            nvicMask.a[0] = ~nvicMask.a[0] & enable->a[0];
    591            nvicMask.a[1] = ~nvicMask.a[1] & enable->a[1];
    592            nvicMask.a[2] = ~nvicMask.a[2] & enable->a[2];
    593          
    594            if ((nvicMask.a[0] != 0) || (nvicMask.a[1] != 0) || (nvicMask.a[2] != 0)) {
    595          #endif
    596          
    597              // Enable previously disabled interrupts.
    598              *(CORE_nvicMask_t*)((uint32_t)&NVIC->ISER[0]) = nvicMask;
   \       0x2C   0xE9C6 0x4100      STRD     R4,R1,[R6, #+0]
    599          
    600              // Disable those interrupts again.
    601              *(CORE_nvicMask_t*)((uint32_t)&NVIC->ICER[0]) = nvicMask;
   \       0x30   0x....             LDR.N    R0,??DataTable10_2  ;; 0xe000e180
   \       0x32   0xE9C0 0x4100      STRD     R4,R1,[R0, #+0]
    602            }
    603          }
   \                     ??CORE_YieldNvicMask_0: (+1)
   \       0x36   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    604          
    605          /***************************************************************************//**
    606           * @brief
    607           *   Utility function to set an IRQn bit in a NVIC enable/disable mask.
    608           *
    609           * @param[in] irqN
    610           *   The @ref IRQn_Type enumerator for the interrupt.
    611           *
    612           * @param[in,out] mask
    613           *   The mask to set the interrupt bit in.
    614           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    615          void CORE_NvicMaskSetIRQ(IRQn_Type irqN, CORE_nvicMask_t *mask)
    616          {
   \                     CORE_NvicMaskSetIRQ: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    617            EFM_ASSERT(((int)irqN >= 0) && ((int)irqN < EXT_IRQ_COUNT));
    618            mask->a[(unsigned)irqN >> 5] |= 1UL << ((unsigned)irqN & 0x1FUL);
   \        0x2   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0x6   0x4318             ORRS     R0,R0,R3
   \        0x8   0x....             B.N      ?Subroutine1
    619          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
   \        0x4   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x0942             LSRS     R2,R0,#+5
   \        0x2   0xF851 0x3022      LDR      R3,[R1, R2, LSL #+2]
   \        0x6   0x2401             MOVS     R4,#+1
   \        0x8   0xF000 0x001F      AND      R0,R0,#0x1F
   \        0xC   0xFA04 0xF000      LSL      R0,R4,R0
   \       0x10   0x4770             BX       LR
    620          
    621          /***************************************************************************//**
    622           * @brief
    623           *   Utility function to clear an IRQn bit in a NVIC enable/disable mask.
    624           *
    625           * @param[in] irqN
    626           *   The @ref IRQn_Type enumerator for the interrupt.
    627           *
    628           * @param[in,out] mask
    629           *   The mask to clear the interrupt bit in.
    630           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    631          void CORE_NvicMaskClearIRQ(IRQn_Type irqN, CORE_nvicMask_t *mask)
    632          {
   \                     CORE_NvicMaskClearIRQ: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    633            EFM_ASSERT(((int)irqN >= 0) && ((int)irqN < EXT_IRQ_COUNT));
    634            mask->a[(unsigned)irqN >> 5] &= ~(1UL << ((unsigned)irqN & 0x1FUL));
   \        0x2   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0x6   0xEA23 0x0000      BIC      R0,R3,R0
   \        0xA                      REQUIRE ?Subroutine1
   \        0xA                      ;; // Fall through to label ?Subroutine1
    635          }
    636          
    637          /***************************************************************************//**
    638           * @brief
    639           *   Check whether the current CPU operation mode is handler mode.
    640           *
    641           * @return
    642           *   True if the CPU is in handler mode (currently executing an interrupt handler).
    643           *   @n False if the CPU is in thread mode.
    644           ******************************************************************************/

   \                                 In section .text, align 4
    645          SL_WEAK bool CORE_InIrqContext(void)
    646          {
    647            return (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) != 0U;
   \                     CORE_InIrqContext: (+1)
   \        0x0   0x4804             LDR.N    R0,??CORE_InIrqContext_0  ;; 0xe000ed04
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0xF3C1 0x0008      UBFX     R0,R1,#+0,#+9
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xBF18             IT       NE 
   \        0xC   0x2001             MOVNE    R0,#+1
   \        0xE   0xB2C0             UXTB     R0,R0
   \       0x10   0x4770             BX       LR               ;; return
   \       0x12   0xBF00             Nop      
   \                     ??CORE_InIrqContext_0:
   \       0x14   0xE000'ED04        DC32     0xe000ed04
    648          }
    649          
    650          /***************************************************************************//**
    651           * @brief
    652           *   Check if a specific interrupt is disabled or blocked.
    653           *
    654           * @param[in] irqN
    655           *   The @ref IRQn_Type enumerator for the interrupt to check.
    656           *
    657           * @return
    658           *   True if the interrupt is disabled or blocked.
    659           ******************************************************************************/

   \                                 In section .text, align 4
    660          SL_WEAK bool CORE_IrqIsBlocked(IRQn_Type irqN)
    661          {
   \                     CORE_IrqIsBlocked: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    662            uint32_t irqPri, activeIrq;
    663          
    664          #if (__CORTEX_M >= 3)
    665            uint32_t basepri;
    666          
    667            EFM_ASSERT((irqN >= MemoryManagement_IRQn)
    668                       && (irqN < (IRQn_Type)EXT_IRQ_COUNT));
    669          #else
    670            EFM_ASSERT((irqN >= SVCall_IRQn) && ((IRQn_Type)irqN < EXT_IRQ_COUNT));
    671          #endif
    672          
    673            if ((__get_PRIMASK() & 1U) != 0U) {
   \        0x4   0xF3EF 0x8010      MRS      R0,PRIMASK
   \        0x8   0x07C0             LSLS     R0,R0,#+31
   \        0xA   0xD419             BMI.N    ??CORE_IrqIsBlocked_1
    674              return true;                            // All IRQs are disabled.
    675            }
    676          
    677            if (CORE_NvicIRQDisabled(irqN)) {
   \        0xC   0x4620             MOV      R0,R4
   \        0xE   0x....'....        BL       CORE_NvicIRQDisabled
   \       0x12   0xB9A8             CBNZ.N   R0,??CORE_IrqIsBlocked_1
    678              return true;                            // The IRQ in question is disabled.
    679            }
    680          
    681            irqPri  = NVIC_GetPriority(irqN);
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x....'....        BL       __NVIC_GetPriority
   \       0x1A   0x4604             MOV      R4,R0
    682          #if (__CORTEX_M >= 3)
    683            basepri = __get_BASEPRI();
   \       0x1C   0xF3EF 0x8011      MRS      R0,BASEPRI
    684            if ((basepri != 0U)
    685                && (irqPri >= (basepri >> (8 - __NVIC_PRIO_BITS)))) {
   \       0x20   0xB110             CBZ.N    R0,??CORE_IrqIsBlocked_2
   \       0x22   0xEBB4 0x1F10      CMP      R4,R0, LSR #+4
   \       0x26   0xD20B             BCS.N    ??CORE_IrqIsBlocked_1
    686              return true;                            // The IRQ in question has too low
    687            }                                         // priority vs. BASEPRI.
    688          #endif
    689          
    690            // Check if already in an interrupt handler. If so, an interrupt with a
    691            // higher priority (lower priority value) can preempt.
    692            activeIrq = (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) >> SCB_ICSR_VECTACTIVE_Pos;
   \                     ??CORE_IrqIsBlocked_2: (+1)
   \       0x28   0x4807             LDR.N    R0,??CORE_IrqIsBlocked_0  ;; 0xe000ed04
   \       0x2A   0x6800             LDR      R0,[R0, #+0]
   \       0x2C   0xF3C0 0x0008      UBFX     R0,R0,#+0,#+9
   \       0x30   0x2800             CMP      R0,#+0
    693            if (activeIrq != 0U) {
   \       0x32   0xD007             BEQ.N    ??CORE_IrqIsBlocked_3
    694              if (irqPri >= NVIC_GetPriority((IRQn_Type)(activeIrq - 16U))) {
   \       0x34   0x3810             SUBS     R0,R0,#+16
   \       0x36   0xB240             SXTB     R0,R0
   \       0x38   0x....'....        BL       __NVIC_GetPriority
   \       0x3C   0x4284             CMP      R4,R0
   \       0x3E   0xD301             BCC.N    ??CORE_IrqIsBlocked_3
    695                return true;                          // The IRQ in question has too low
   \                     ??CORE_IrqIsBlocked_1: (+1)
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0xBD10             POP      {R4,PC}
    696              }                                       // priority vs. current active IRQ
    697            }
    698          
    699            return false;
   \                     ??CORE_IrqIsBlocked_3: (+1)
   \       0x44   0x2000             MOVS     R0,#+0
   \       0x46   0xBD10             POP      {R4,PC}          ;; return
   \                     ??CORE_IrqIsBlocked_0:
   \       0x48   0xE000'ED04        DC32     0xe000ed04
    700          }
    701          
    702          /***************************************************************************//**
    703           * @brief
    704           *   Check if interrupts are disabled.
    705           *
    706           * @return
    707           *   True if interrupts are disabled.
    708           ******************************************************************************/

   \                                 In section .text, align 2
    709          SL_WEAK bool CORE_IrqIsDisabled(void)
    710          {
    711          #if (CORE_ATOMIC_METHOD == CORE_ATOMIC_METHOD_PRIMASK)
    712            return (__get_PRIMASK() & 1U) == 1U;
    713          
    714          #elif (CORE_ATOMIC_METHOD == CORE_ATOMIC_METHOD_BASEPRI)
    715            return ((__get_PRIMASK() & 1U) == 1U)
    716                   || (__get_BASEPRI() >= (CORE_ATOMIC_BASE_PRIORITY_LEVEL
    717                                           << (8 - __NVIC_PRIO_BITS)));
   \                     CORE_IrqIsDisabled: (+1)
   \        0x0   0xF3EF 0x8010      MRS      R0,PRIMASK
   \        0x4   0x07C0             LSLS     R0,R0,#+31
   \        0x6   0xD406             BMI.N    ??CORE_IrqIsDisabled_0
   \        0x8   0xF3EF 0x8011      MRS      R0,BASEPRI
   \        0xC   0x2830             CMP      R0,#+48
   \        0xE   0x4180             SBCS     R0,R0,R0
   \       0x10   0x43C0             MVNS     R0,R0
   \       0x12   0x0FC0             LSRS     R0,R0,#+31
   \       0x14   0x4770             BX       LR
   \                     ??CORE_IrqIsDisabled_0: (+1)
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0x4770             BX       LR               ;; return
    718          #endif
    719          }
    720          
    721          /***************************************************************************//**
    722           * @brief
    723           *   Get the current NVIC enable mask state.
    724           *
    725           * @param[out] mask
    726           *   The current NVIC enable mask.
    727           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    728          void CORE_GetNvicEnabledMask(CORE_nvicMask_t *mask)
    729          {
   \                     CORE_GetNvicEnabledMask: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    730            CORE_CRITICAL_SECTION(
    731              *mask = *(CORE_nvicMask_t*)((uint32_t)&NVIC->ISER[0]);
    732              )
   \        0x4   0x....'....        BL       CORE_EnterCritical
   \        0x8   0x....             LDR.N    R1,??DataTable10_3  ;; 0xe000e100
   \        0xA   0xE9D1 0x2300      LDRD     R2,R3,[R1, #+0]
   \        0xE   0xE9C4 0x2300      STRD     R2,R3,[R4, #+0]
   \       0x12   0x....             B.N      ??Subroutine0_0
    733          }
    734          
    735          /***************************************************************************//**
    736           * @brief
    737           *   Get NVIC disable state for a given mask.
    738           *
    739           * @param[in] mask
    740           *   An NVIC mask to check.
    741           *
    742           * @return
    743           *   True if all NVIC interrupt mask bits are clear.
    744           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    745          bool CORE_GetNvicMaskDisableState(const CORE_nvicMask_t *mask)
    746          {
   \                     CORE_GetNvicMaskDisableState: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
    747            CORE_nvicMask_t nvicMask;
    748          
    749            CORE_CRITICAL_SECTION(
    750              nvicMask = *(CORE_nvicMask_t*)((uint32_t)&NVIC->ISER[0]);
    751              )
   \        0x4   0x....'....        BL       CORE_EnterCritical
   \        0x8   0x....             LDR.N    R1,??DataTable10_3  ;; 0xe000e100
   \        0xA   0xE9D1 0x4500      LDRD     R4,R5,[R1, #+0]
   \        0xE   0x....'....        BL       CORE_ExitCritical
    752          
    753          #if (CORE_NVIC_REG_WORDS == 1)
    754            return (mask->a[0] & nvicMask.a[0]) == 0U;
    755          
    756          #elif (CORE_NVIC_REG_WORDS == 2)
    757            return ((mask->a[0] & nvicMask.a[0]) == 0U)
    758                   && ((mask->a[1] & nvicMask.a[1]) == 0U);
   \       0x12   0x6830             LDR      R0,[R6, #+0]
   \       0x14   0x4220             TST      R0,R4
   \       0x16   0xD105             BNE.N    ??CORE_GetNvicMaskDisableState_0
   \       0x18   0x6871             LDR      R1,[R6, #+4]
   \       0x1A   0x4029             ANDS     R1,R5,R1
   \       0x1C   0x1E48             SUBS     R0,R1,#+1
   \       0x1E   0x4180             SBCS     R0,R0,R0
   \       0x20   0x0FC0             LSRS     R0,R0,#+31
   \       0x22   0xBD70             POP      {R4-R6,PC}
   \                     ??CORE_GetNvicMaskDisableState_0: (+1)
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xBD70             POP      {R4-R6,PC}       ;; return
    759          
    760          #elif (CORE_NVIC_REG_WORDS == 3)
    761            return ((mask->a[0] & nvicMask.a[0]) == 0U)
    762                   && ((mask->a[1] & nvicMask.a[1]) == 0U)
    763                   && ((mask->a[2] & nvicMask.a[2]) == 0U);
    764          #endif
    765          }
    766          
    767          /***************************************************************************//**
    768           * @brief
    769           *   Check if an NVIC interrupt is disabled.
    770           *
    771           * @param[in] irqN
    772           *   The @ref IRQn_Type enumerator for the interrupt to check.
    773           *
    774           * @return
    775           *   True if the interrupt is disabled.
    776           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    777          bool CORE_NvicIRQDisabled(IRQn_Type irqN)
    778          {
   \                     CORE_NvicIRQDisabled: (+1)
   \        0x0   0x4601             MOV      R1,R0
    779            CORE_nvicMask_t *mask;
    780          
    781            EFM_ASSERT(((int)irqN >= 0) && ((int)irqN < EXT_IRQ_COUNT));
    782            mask = (CORE_nvicMask_t*)((uint32_t)&NVIC->ISER[0]);
    783            return (mask->a[(unsigned)irqN >> 5U] & (1UL << ((unsigned)irqN & 0x1FUL)))
    784                   == 0UL;
   \        0x2   0x....             LDR.N    R0,??DataTable10_3  ;; 0xe000e100
   \        0x4   0x094A             LSRS     R2,R1,#+5
   \        0x6   0xF850 0x0022      LDR      R0,[R0, R2, LSL #+2]
   \        0xA   0xF001 0x011F      AND      R1,R1,#0x1F
   \        0xE   0x40C8             LSRS     R0,R0,R1
   \       0x10   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x14   0xF080 0x0001      EOR      R0,R0,#0x1
   \       0x18   0x4770             BX       LR               ;; return
    785          }
    786          
    787          /***************************************************************************//**
    788           * @brief
    789           *   Utility function to get the handler for a specific interrupt.
    790           *
    791           * @param[in] irqN
    792           *   The @ref IRQn_Type enumerator for the interrupt.
    793           *
    794           * @return
    795           *   The handler address.
    796           *
    797           * @note
    798           *   Uses the interrupt vector table defined by the current VTOR register value.
    799           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    800          void *CORE_GetNvicRamTableHandler(IRQn_Type irqN)
    801          {
    802            EFM_ASSERT(((int)irqN >= -16) && ((int)irqN < EXT_IRQ_COUNT));
    803            return (void*)((uint32_t*)(((uint32_t*)SCB->VTOR)[(int)irqN + 16]));
   \                     CORE_GetNvicRamTableHandler: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable10_4  ;; 0xe000ed08
   \        0x2   0x680A             LDR      R2,[R1, #+0]
   \        0x4   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \        0x8   0x6C00             LDR      R0,[R0, #+64]
   \        0xA   0x4770             BX       LR               ;; return
    804          }
    805          
    806          /***************************************************************************//**
    807           * @brief
    808           *   Utility function to set the handler for a specific interrupt.
    809           *
    810           * @param[in] irqN
    811           *   The @ref IRQn_Type enumerator for the interrupt.
    812           *
    813           * @param[in] handler
    814           *   The handler address.
    815           *
    816           * @note
    817           *   Uses the interrupt vector table defined by the current VTOR register value.
    818           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    819          void CORE_SetNvicRamTableHandler(IRQn_Type irqN, void *handler)
    820          {
    821            EFM_ASSERT(((int)irqN >= -16) && ((int)irqN < EXT_IRQ_COUNT));
    822            ((uint32_t*)SCB->VTOR)[(int)irqN + 16] = (uint32_t)((uint32_t*)handler);
   \                     CORE_SetNvicRamTableHandler: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable10_4  ;; 0xe000ed08
   \        0x2   0x6813             LDR      R3,[R2, #+0]
   \        0x4   0xEB03 0x0080      ADD      R0,R3,R0, LSL #+2
   \        0x8   0x6401             STR      R1,[R0, #+64]
    823          }
   \        0xA   0x4770             BX       LR               ;; return
    824          
    825          /***************************************************************************//**
    826           * @brief
    827           *   Initialize an interrupt vector table by copying table entries from a
    828           *   source to a target table.
    829           *
    830           * @note This function will set a new VTOR register value.
    831           *
    832           * @param[in] sourceTable
    833           *   The address of the source vector table.
    834           *
    835           * @param[in] sourceSize
    836           *   A number of entries in the source vector table.
    837           *
    838           * @param[in] targetTable
    839           *   The address of the target (new) vector table.
    840           *
    841           * @param[in] targetSize
    842           *   A number of entries in the target vector table.
    843           *
    844           * @param[in] defaultHandler
    845           *   An address of the interrupt handler used for target entries for which where there
    846           *   is no corresponding source entry (i.e., the target table is larger than the source
    847           *   table).
    848           *
    849           * @param[in] overwriteActive
    850           *   When true, a target table entry is always overwritten with the
    851           *   corresponding source entry. If false, a target table entry is only
    852           *   overwritten if it is zero. This makes it possible for an application
    853           *   to partly initialize a target table before passing it to this function.
    854           *
    855           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    856          void CORE_InitNvicVectorTable(uint32_t *sourceTable,
    857                                        uint32_t sourceSize,
    858                                        uint32_t *targetTable,
    859                                        uint32_t targetSize,
    860                                        void *defaultHandler,
    861                                        bool overwriteActive)
    862          {
   \                     CORE_InitNvicVectorTable: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0x9E05             LDR      R6,[SP, #+20]
   \        0x4   0x9D06             LDR      R5,[SP, #+24]
    863            uint32_t i;
    864          
    865            // ASSERT on non SRAM-based target table.
    866            EFM_ASSERT(((uint32_t)targetTable >= SRAM_BASE)
    867                       && ((uint32_t)targetTable < (SRAM_BASE + SRAM_SIZE)));
    868          
    869            // ASSERT if misaligned with respect to the VTOR register implementation.
    870          #if defined(SCB_VTOR_TBLBASE_Msk)
    871            EFM_ASSERT(((uint32_t)targetTable & ~(SCB_VTOR_TBLOFF_Msk
    872                                                  | SCB_VTOR_TBLBASE_Msk)) == 0U);
    873          #else
    874            EFM_ASSERT(((uint32_t)targetTable & ~SCB_VTOR_TBLOFF_Msk) == 0U);
    875          #endif
    876          
    877            // ASSERT if misaligned with respect to the vector table size.
    878            // The vector table address must be aligned at its size rounded up to nearest 2^n.
    879            EFM_ASSERT(((uint32_t)targetTable
    880                        & ((1UL << (32UL - __CLZ((targetSize * 4UL) - 1UL))) - 1UL))
    881                       == 0UL);
    882          
    883            for (i = 0; i < targetSize; i++) {
   \        0x6   0x2700             MOVS     R7,#+0
   \        0x8   0xE00D             B.N      ??CORE_InitNvicVectorTable_0
    884              if (overwriteActive) {                      // Overwrite target entries.
    885                if (i < sourceSize) {                     //   targetSize <= sourceSize
    886                  targetTable[i] = sourceTable[i];
    887                } else {                                  //   targetSize > sourceSize
    888                  targetTable[i] = (uint32_t)((uint32_t*)defaultHandler);
    889                }
    890              } else {                            // Overwrite target entries which are 0.
    891                if (i < sourceSize) {                     // targetSize <= sourceSize
    892                  if (targetTable[i] == 0U) {
    893                    targetTable[i] = sourceTable[i];
    894                  }
    895                } else {                                  // targetSize > sourceSize
    896                  if (targetTable[i] == 0U) {
   \                     ??CORE_InitNvicVectorTable_1: (+1)
   \        0xA   0xB95C             CBNZ.N   R4,??CORE_InitNvicVectorTable_2
    897                    targetTable[i] = (uint32_t)((uint32_t*)defaultHandler);
   \                     ??CORE_InitNvicVectorTable_3: (+1)
   \        0xC   0xF842 0x6027      STR      R6,[R2, R7, LSL #+2]
   \       0x10   0xE008             B.N      ??CORE_InitNvicVectorTable_2
    898                  }
    899                }
   \                     ??CORE_InitNvicVectorTable_4: (+1)
   \       0x12   0xF852 0x4027      LDR      R4,[R2, R7, LSL #+2]
   \       0x16   0x428F             CMP      R7,R1
   \       0x18   0xD2F7             BCS.N    ??CORE_InitNvicVectorTable_1
   \       0x1A   0xB91C             CBNZ.N   R4,??CORE_InitNvicVectorTable_2
   \                     ??CORE_InitNvicVectorTable_5: (+1)
   \       0x1C   0xF850 0x4027      LDR      R4,[R0, R7, LSL #+2]
   \       0x20   0xF842 0x4027      STR      R4,[R2, R7, LSL #+2]
    900              }
   \                     ??CORE_InitNvicVectorTable_2: (+1)
   \       0x24   0x1C7F             ADDS     R7,R7,#+1
   \                     ??CORE_InitNvicVectorTable_0: (+1)
   \       0x26   0x429F             CMP      R7,R3
   \       0x28   0xD204             BCS.N    ??CORE_InitNvicVectorTable_6
   \       0x2A   0x002C             MOVS     R4,R5
   \       0x2C   0xD0F1             BEQ.N    ??CORE_InitNvicVectorTable_4
   \       0x2E   0x428F             CMP      R7,R1
   \       0x30   0xD2EC             BCS.N    ??CORE_InitNvicVectorTable_3
   \       0x32   0xE7F3             B.N      ??CORE_InitNvicVectorTable_5
    901            }
    902            SCB->VTOR = (uint32_t)targetTable;
   \                     ??CORE_InitNvicVectorTable_6: (+1)
   \       0x34   0x....             LDR.N    R0,??DataTable10_4  ;; 0xe000ed08
   \       0x36   0x6002             STR      R2,[R0, #+0]
    903          }
   \       0x38   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \        0x0   0xE000'E400        DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \        0x0   0xE000'ED18        DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \        0x0   0xE000'E180        DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \        0x0   0xE000'E100        DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \        0x0   0xE000'ED08        DC32     0xe000ed08
    904          
    905          /** @} (end addtogroup CORE) */
    906          /** @} (end addtogroup emlib) */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CORE_AtomicDisableIrq
       0   CORE_AtomicEnableIrq
       0   CORE_CriticalDisableIrq
       0   CORE_CriticalEnableIrq
       0   CORE_EnterAtomic
       0   CORE_EnterCritical
      24   CORE_EnterNvicMask
        24   -> CORE_EnterCritical
         0   -> CORE_ExitCritical
       0   CORE_ExitAtomic
       0   CORE_ExitCritical
       8   CORE_GetNvicEnabledMask
         8   -> CORE_EnterCritical
         0   -> CORE_ExitCritical
      16   CORE_GetNvicMaskDisableState
        16   -> CORE_EnterCritical
        16   -> CORE_ExitCritical
       0   CORE_GetNvicRamTableHandler
       0   CORE_InIrqContext
      20   CORE_InitNvicVectorTable
       8   CORE_IrqIsBlocked
         8   -> CORE_NvicIRQDisabled
         8   -> __NVIC_GetPriority
       0   CORE_IrqIsDisabled
       8   CORE_NvicDisableMask
         8   -> CORE_EnterCritical
         0   -> CORE_ExitCritical
       8   CORE_NvicEnableMask
         8   -> CORE_EnterCritical
         0   -> CORE_ExitCritical
       0   CORE_NvicIRQDisabled
       8   CORE_NvicMaskClearIRQ
       8   CORE_NvicMaskSetIRQ
       0   CORE_SetNvicRamTableHandler
       0   CORE_YieldAtomic
       0   CORE_YieldCritical
      24   CORE_YieldNvicMask
        24   -> CORE_EnterCritical
        24   -> CORE_ExitCritical
       0   __NVIC_GetPriority


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
      12  ?Subroutine0
       6  ?Subroutine1
      18  ?Subroutine2
       8  CORE_AtomicDisableIrq
       8  CORE_AtomicEnableIrq
       4  CORE_CriticalDisableIrq
       4  CORE_CriticalEnableIrq
      12  CORE_EnterAtomic
       8  CORE_EnterCritical
      36  CORE_EnterNvicMask
       6  CORE_ExitAtomic
       6  CORE_ExitCritical
      20  CORE_GetNvicEnabledMask
      40  CORE_GetNvicMaskDisableState
      12  CORE_GetNvicRamTableHandler
      24  CORE_InIrqContext
      58  CORE_InitNvicVectorTable
      76  CORE_IrqIsBlocked
      26  CORE_IrqIsDisabled
      16  CORE_NvicDisableMask
      14  CORE_NvicEnableMask
      26  CORE_NvicIRQDisabled
      10  CORE_NvicMaskClearIRQ
      10  CORE_NvicMaskSetIRQ
      12  CORE_SetNvicRamTableHandler
      24  CORE_YieldAtomic
      18  CORE_YieldCritical
      56  CORE_YieldNvicMask
      26  __NVIC_GetPriority

 
 616 bytes in section .text
 
 392 bytes of CODE memory (+ 224 bytes shared)

Errors: none
Warnings: none
