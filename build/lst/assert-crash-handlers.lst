###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:11
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\micro\cortexm3\efm32\assert-crash-handlers.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EWB445.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\micro\cortexm3\efm32\assert-crash-handlers.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"assert-crash-handlers.c\"" -D PSSTORE_SIZE=0 -D
#        LONGTOKEN_SIZE=0 -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\assert-crash-handlers.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\assert-crash-handlers.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\base\hal\micro\cortexm3\efm32\assert-crash-handlers.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief EM3XX-specific Assert and Crash HAL functions
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc. Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement. This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          #include PLATFORM_HEADER
     18          #include "stack/include/ember.h"
     19          #include "hal/hal.h"
     20          #include "serial/com.h"
     21          #include "serial/serial.h"
     22          #include "hal/micro/cortexm3/diagnostic.h"
     23          #include "hal/micro/cortexm3/efm32/mpu.h"
     24          
     25          #ifdef RTOS
     26            #include "rtos/rtos.h"
     27            #define freeRTOS 1
     28          #else  // RTOS
     29            #define freeRTOS 0
     30          // extern uint32_t* xTaskGetCurrentTaskStackTop(void);
     31          // extern uint32_t* xTaskGetCurrentTaskStackBottom(void);
     32          #endif // RTOS
     33          
     34          #if !defined(WDOG0)
     35          #define WDOG0      WDOG
     36          #define WDOG0_IRQn WDOG_IRQn
     37          #endif
     38          
     39          //------------------------------------------------------------------------------
     40          // Preprocessor definitions
     41          
     42          // Reserved instruction executed after a failed assert to cause a usage fault
     43          #define ASSERT_USAGE_OPCODE 0xDE42U
     44          
     45          //------------------------------------------------------------------------------
     46          // Forward Declarations
     47          
     48          extern void emRadioSleep(void);
     49          
     50          //------------------------------------------------------------------------------
     51          // Functions
     52          
     53          // Cause a usage fault by executing a special UNDEFINED instruction.
     54          // The high byte (0xDE) is reserved to be undefined - the low byte (0x42)
     55          // is arbitrary and distiguishes a failed assert from other usage faults.
     56          // the fault handler with then decode this, grab the filename and linenumber
     57          // parameters from R0 and R1 and save the information for display after
     58          // a reset
     59          #if defined (__ICCARM__)
     60          #pragma diag_suppress=Og014

   \                                 In section .text, align 4, keep-with-next
     61          static void halInternalAssertFault(PGM_P filename, int linenumber)
     62          {
     63            asm ("DC16 0DE42h");
   \                     halInternalAssertFault: (+1)
   \        0x0   0xDE42             DC16 0DE42h
     64          }
   \        0x2   0x4770             BX       LR               ;; return
     65          #pragma diag_default=Og014
     66          #elif defined (__GNUC__)
     67          __attribute__((noinline))
     68          static void halInternalAssertFault(PGM_P filename, int linenumber)
     69          {
     70            asm (".short 0xDE42\n" : : "r" (filename), "r" (linenumber));
     71          }
     72          #endif
     73          

   \                                 In section .text, align 2, keep-with-next
     74          void halInternalAssertFailed(PGM_P filename, int linenumber)
     75          {
   \                     halInternalAssertFailed: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
     76           #ifndef PHY_PRO2PLUS
     77          #if !defined (_SILICON_LABS_32B_SERIES_2) // emRadioSleep
     78            emRadioSleep();
     79          #endif // !defined (_SILICON_LABS_32B_SERIES_2) // emRadioSleep
     80           #endif//PHY_PRO2PLUS
     81            halResetWatchdog();              // In case we're close to running out.
   \        0x6   0x....'....        BL       halInternalResetWatchDog
     82            INTERRUPTS_OFF();
   \        0xA   0x....'....        BL       CORE_AtomicDisableIrq
     83          
     84            #if DEBUG_LEVEL >= BASIC_DEBUG
     85            emberDebugAssert(filename, linenumber);
   \        0xE   0x4629             MOV      R1,R5
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x....'....        BL       emberDebugAssert
     86            #endif
     87          
     88            #if !defined(EMBER_ASSERT_OUTPUT_DISABLED)
     89            (void) emberSerialGuaranteedPrintf(EMBER_ASSERT_SERIAL_PORT,
     90                                               "\r\n[ASSERT:%p:%d]\r\n",
     91                                               filename,
     92                                               linenumber);
   \       0x16   0x462B             MOV      R3,R5
   \       0x18   0x4622             MOV      R2,R4
   \       0x1A   0x....             LDR.N    R1,??DataTable2
   \       0x1C   0x2001             MOVS     R0,#+1
   \       0x1E   0x....'....        BL       emberSerialGuaranteedPrintf
     93            #endif
     94          
     95            #if defined (__ICCARM__) || defined (__GNUC__)
     96            // We can use the special fault mechanism to preserve more assert
     97            // information for display after a crash
     98            halInternalAssertFault(filename, linenumber);
   \       0x22   0x4629             MOV      R1,R5
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \       0x2A   0x....             B.N      halInternalAssertFault
     99            #else
    100            // Other toolchains don't handle the inline assembly correctly, so
    101            // we just call the internal reset
    102            halResetInfo.crash.data.assertInfo.file = filename;
    103            halResetInfo.crash.data.assertInfo.line = linenumber;
    104            halInternalSysReset(RESET_CRASH_ASSERT);
    105            #endif
    106          }
    107          
    108          // Returns the bytes used in the main stack area.
    109          static uint32_t halInternalGetMainStackBytesUsed(uint32_t *p)
    110          {
    111            for (; p < (uint32_t *)_CSTACK_SEGMENT_END; p++) {
    112              if (*p != STACK_FILL_VALUE) {
    113                break;
    114              }
    115            }
    116            return (uint32_t)((uint8_t *)_CSTACK_SEGMENT_END - (uint8_t *)p);
    117          }
    118          
    119          // After the low-level fault handler (in faults.s79) has saved the processor
    120          // registers (R0-R12, LR and both MSP an PSP), it calls halInternalCrashHandler
    121          // to finish saving additional crash data. This function returns the reason for
    122          // the crash to the low-level fault handler that then calls
    123          // halInternalSystsemReset() to reset the processor.
    124          //
    125          // NOTE:
    126          // This function should not use more than 16 words on the stack to avoid
    127          // overwriting halResetInfo at the bottom of the stack segment.
    128          // The 16 words include this function's return address, plus any stack
    129          // used by functions called by this one. The stack size allowed is defined
    130          // by the symbol CRASH_STACK_SIZE in faults.s79.
    131          // As compiled by IAR V6.21.1, it now uses 8 words (1 for its return address,
    132          // 6 for registers pushed onto the stack and 1 for the return address of
    133          // halInternalGetMainStackBytesUsed().
    134          //

   \                                 In section .text, align 2, keep-with-next
    135          uint16_t halInternalCrashHandler(void)
    136          {
    137            uint32_t activeException;
    138            uint16_t reason = (uint16_t)RESET_FAULT_UNKNOWN;
    139            HalCrashInfoType *c = &halResetInfo.crash;
    140            uint8_t i, j;
    141            uint32_t *sp, *s, *sEnd, *stackBottom, *stackTop;
    142            uint32_t data;
    143          
    144            c->icsr.word = SCB->ICSR;
   \                     halInternalCrashHandler: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable2_1  ;; 0xe000ed04
   \        0x2   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0x....             LDR.N    R6,??DataTable2_2
   \        0xA   0xF44F 0x6820      MOV      R8,#+2560
   \        0xE   0x65B1             STR      R1,[R6, #+88]
    145            c->shcsr.word = SCB->SHCSR;
   \       0x10   0x6A02             LDR      R2,[R0, #+32]
    146          #if (__CORTEX_M >= 0x03)
    147            c->intActive.word[0] = NVIC->IABR[0];
   \       0x12   0x....             LDR.N    R1,??DataTable2_3  ;; 0xe000e300
   \       0x14   0x65F2             STR      R2,[R6, #+92]
   \       0x16   0x680B             LDR      R3,[R1, #+0]
   \       0x18   0x6633             STR      R3,[R6, #+96]
    148            c->intActive.word[1] = NVIC->IABR[1];
   \       0x1A   0x6849             LDR      R1,[R1, #+4]
   \       0x1C   0x6671             STR      R1,[R6, #+100]
    149          #else
    150            // No IABR on Cortex-M0+
    151            uint32_t icsr_reg = (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) >= 16 ? (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) : 0;
    152            if (icsr_reg > 0) {
    153              uint64_t activeVector = 1 << (icsr_reg - 16);
    154              c->intActive.word[0] = (uint32_t) (activeVector & 0xFFFFFFFF);
    155              c->intActive.word[1] = (activeVector >> 32) & 0xFFFFFFFF;
    156            }
    157          #endif
    158          
    159          #if (__CORTEX_M >= 0x03)
    160            c->cfsr.word = SCB->CFSR;
   \       0x1E   0x6A42             LDR      R2,[R0, #+36]
   \       0x20   0x66B2             STR      R2,[R6, #+104]
    161            c->hfsr.word = SCB->HFSR;
   \       0x22   0x6A81             LDR      R1,[R0, #+40]
   \       0x24   0x66F1             STR      R1,[R6, #+108]
    162            c->dfsr.word = SCB->DFSR;
   \       0x26   0x6AC2             LDR      R2,[R0, #+44]
   \       0x28   0x6732             STR      R2,[R6, #+112]
    163            c->faultAddress = SCB->MMFAR;
   \       0x2A   0x6B01             LDR      R1,[R0, #+48]
   \       0x2C   0x6771             STR      R1,[R6, #+116]
    164            c->afsr.word = SCB->AFSR;
   \       0x2E   0x6B80             LDR      R0,[R0, #+56]
    165          #endif
    166          
    167            // Examine B2 of the saved LR to know the stack in use when the fault occurred
    168            sp = (uint32_t *)(((c->LR & 4U) != 0U) ? c->processSP : c->mainSP);
   \       0x30   0xF896 0x1038      LDRB     R1,[R6, #+56]
   \       0x34   0x67B0             STR      R0,[R6, #+120]
   \       0x36   0x0748             LSLS     R0,R1,#+29
   \       0x38   0xBF4C             ITE      MI 
   \       0x3A   0x6C34             LDRMI    R4,[R6, #+64]
   \       0x3C   0x6BF4             LDRPL    R4,[R6, #+60]
    169            sEnd = sp; // Keep a copy around for walking the stack later
    170          
    171            // Get the bottom of the stack since we allow stack resizing
    172            c->mainStackBottom = (uint32_t)halInternalGetCStackBottom();
   \       0x3E   0x....'....        BL       halInternalGetCStackBottom
    173          
    174            // If we're running FreeRTOS and this is a process stack then add
    175            // extra diagnostic information
    176            if ((freeRTOS != 0) && ((c->LR & 4U) != 0U)) {
    177              // FreeRTOS doesn't provide the diagnostic functions we need
    178              // so for now just lie to get some diagnostics
    179              // stackBottom = (uint32_t*)xTaskGetCurrentTaskStackBottom();
    180              // stackTop = (uint32_t*)xTaskGetCurrentTaskStackTop();
    181              stackBottom = sp;
    182              stackTop = sp + 8;
    183              c->processSPUsed = stackTop - sp;
    184            } else {
    185              stackBottom = (uint32_t*)c->mainStackBottom;
    186              stackTop = (uint32_t*)_CSTACK_SEGMENT_END;
    187              c->processSPUsed = 0;   // process stack not in use
    188            }
    189          
    190            // If the stack pointer is valid, read and save the stacked PC and xPSR
    191            if ((sp >= stackBottom)
    192                && (sp <= (stackTop - 8))) {
   \       0x42   0x....'....        LDR.W    LR,??DataTable2_4
   \       0x46   0x2200             MOVS     R2,#+0
   \       0x48   0x4284             CMP      R4,R0
   \       0x4A   0x4601             MOV      R1,R0
   \       0x4C   0x6532             STR      R2,[R6, #+80]
   \       0x4E   0x46A1             MOV      R9,R4
   \       0x50   0xBF24             ITT      CS 
   \       0x52   0xF1AE 0x0720      SUBCS    R7,LR,#+32
   \       0x56   0x42A7             CMPCS    R7,R4
   \       0x58   0x6571             STR      R1,[R6, #+84]
   \       0x5A   0xF106 0x0290      ADD      R2,R6,#+144
   \       0x5E   0x....             LDR.N    R3,??DataTable2_5
   \       0x60   0x....'....        LDR.W    R12,??DataTable2_6
   \       0x64   0xD318             BCC.N    ??halInternalCrashHandler_0
    193              sp += 6; // Skip over R0,R1,R2,R3,R12,LR
    194              c->PC = *sp++;
   \       0x66   0x69A0             LDR      R0,[R4, #+24]
   \       0x68   0x6470             STR      R0,[R6, #+68]
    195              c->xPSR.word = *sp++;
   \       0x6A   0x69E4             LDR      R4,[R4, #+28]
   \       0x6C   0x64B4             STR      R4,[R6, #+72]
    196          
    197              // See if fault was due to a failed assert. This is indicated by
    198              // a usage fault caused by executing a reserved instruction.
    199              if ( c->icsr.bits.VECTACTIVE == USAGE_FAULT_VECTOR_INDEX
    200                   && ((uint16_t *)c->PC >= (uint16_t *)_TEXT_SEGMENT_BEGIN)
    201                   && ((uint16_t *)c->PC < (uint16_t *)_TEXT_SEGMENT_END)
    202                   && *(uint16_t *)(c->PC) == ASSERT_USAGE_OPCODE ) {
   \       0x6E   0x6DB5             LDR      R5,[R6, #+88]
   \       0x70   0xF3C5 0x0508      UBFX     R5,R5,#+0,#+9
   \       0x74   0x2D06             CMP      R5,#+6
   \       0x76   0xD113             BNE.N    ??halInternalCrashHandler_1
   \       0x78   0x4560             CMP      R0,R12
   \       0x7A   0xD311             BCC.N    ??halInternalCrashHandler_1
   \       0x7C   0x4298             CMP      R0,R3
   \       0x7E   0xD20F             BCS.N    ??halInternalCrashHandler_1
   \       0x80   0x8800             LDRH     R0,[R0, #+0]
   \       0x82   0xF64D 0x6442      MOVW     R4,#+56898
   \       0x86   0x42A0             CMP      R0,R4
   \       0x88   0xD10A             BNE.N    ??halInternalCrashHandler_1
    203                // Copy halInternalAssertFailed() arguments into data member specific
    204                // to asserts.
    205                c->data.assertInfo.file = (const char *)c->R0;
   \       0x8A   0x6870             LDR      R0,[R6, #+4]
    206                c->data.assertInfo.line = c->R1;
   \       0x8C   0x68B4             LDR      R4,[R6, #+8]
    207          #ifdef PUSH_REGS_BEFORE_ASSERT
    208                // Just before calling halInternalAssertFailed(), R0, R1, R2 and LR were
    209                // pushed onto the stack - copy these values into the crash data struct.
    210                c->R0 = *sp++;
    211                c->R1 = *sp++;
    212                c->R2 = *sp++;
    213                c->LR = *sp++;
    214          #endif
    215                reason = (uint16_t)RESET_CRASH_ASSERT;
   \       0x8E   0xF240 0x7801      MOVW     R8,#+1793
   \       0x92   0x6050             STR      R0,[R2, #+4]
   \       0x94   0x6094             STR      R4,[R2, #+8]
   \       0x96   0xE003             B.N      ??halInternalCrashHandler_1
    216              }
    217              // If a bad stack pointer, PC and xPSR to 0 to indicate they are not known.
    218            } else {
    219              c->PC = 0;
   \                     ??halInternalCrashHandler_0: (+1)
   \       0x98   0x2400             MOVS     R4,#+0
   \       0x9A   0x6474             STR      R4,[R6, #+68]
    220              c->xPSR.word = 0;
   \       0x9C   0x64B4             STR      R4,[R6, #+72]
    221              sEnd = stackBottom;
   \       0x9E   0x4681             MOV      R9,R0
    222            }
    223          
    224            // Fault handler has already started filling in halResetInfo{}
    225            // prior to calling this routine, so want to make sure _not_
    226            // to include halResetInfo in the stack assessment when crashing
    227            // to avoid a self-fulfilling prophesy of a full stack!  BugzId:13403
    228            uint32_t safeStackBottom = c->mainStackBottom;
    229            if (safeStackBottom < (uint32_t)(uint16_t *)_RESETINFO_SEGMENT_END) {
   \                     ??halInternalCrashHandler_1: (+1)
   \       0xA0   0x....             LDR.N    R0,??DataTable2_7
   \       0xA2   0x4281             CMP      R1,R0
   \       0xA4   0xBF38             IT       CC 
   \       0xA6   0x4601             MOVCC    R1,R0
    230              safeStackBottom = (uint32_t)(uint16_t *)_RESETINFO_SEGMENT_END;
    231            }
    232            c->mainSPUsed = halInternalGetMainStackBytesUsed((uint32_t*)safeStackBottom);
   \                     ??halInternalCrashHandler_2: (+1)
   \       0xA8   0x4608             MOV      R0,R1
   \       0xAA   0x4570             CMP      R0,LR
   \       0xAC   0xD26A             BCS.N    ??halInternalCrashHandler_3
   \       0xAE   0x680C             LDR      R4,[R1, #+0]
   \       0xB0   0xF1B4 0x3FCD      CMP      R4,#-842150451
   \       0xB4   0xBF08             IT       EQ 
   \       0xB6   0x1D09             ADDEQ    R1,R1,#+4
   \       0xB8   0xD0F6             BEQ.N    ??halInternalCrashHandler_2
   \       0xBA   0xE063             B.N      ??halInternalCrashHandler_3
    233          
    234            for (i = 0; i < NUM_RETURNS; i++) {
    235              c->returns[i] = 0;
    236            }
    237          
    238            // Search the stack downward for probable return addresses. A probable
    239            // return address is a value in the CODE segment that also has bit 0 set
    240            // (since we're in Thumb mode).
    241            i = 0U;
    242            s = stackTop;
    243            while (s > sEnd) {
    244              data = *(--s);
    245              if (((uint16_t *)data >= (uint16_t *)_TEXT_SEGMENT_BEGIN)
    246                  && ((uint16_t *)data < (uint16_t *)_TEXT_SEGMENT_END)
    247                  && ((data & 1U) != 0U)) {
    248                // Only record the first occurrence of a return - other copies could
    249                // have been in registers that then were pushed.
    250                for (j = 0; j < NUM_RETURNS; j++) {
    251                  if (c->returns[j] == data) {
    252                    break;
    253                  }
    254                }
    255                if (j != NUM_RETURNS) {
   \                     ??halInternalCrashHandler_4: (+1)
   \       0xBC   0x2C06             CMP      R4,#+6
   \       0xBE   0xD109             BNE.N    ??halInternalCrashHandler_5
    256                  continue;
    257                }
    258                // Save the return in the returns array managed as a circular buffer.
    259                // This keeps only the last NUM_RETURNS in the event that there are more.
    260                i = (i != 0U) ? i - 1U : NUM_RETURNS - 1U;
   \       0xC0   0xB2C4             UXTB     R4,R0
   \       0xC2   0x2C00             CMP      R4,#+0
    261                c->returns[i] = data;
   \       0xC4   0xF106 0x047C      ADD      R4,R6,#+124
   \       0xC8   0xBF0C             ITE      EQ 
   \       0xCA   0x2005             MOVEQ    R0,#+5
   \       0xCC   0x1E40             SUBNE    R0,R0,#+1
   \       0xCE   0xB2C5             UXTB     R5,R0
   \       0xD0   0xF844 0x1025      STR      R1,[R4, R5, LSL #+2]
   \                     ??halInternalCrashHandler_5: (+1)
   \       0xD4   0x45F1             CMP      R9,LR
   \       0xD6   0xD220             BCS.N    ??halInternalCrashHandler_6
   \       0xD8   0xF85E 0x1D04      LDR      R1,[LR, #-4]!
   \       0xDC   0x4561             CMP      R1,R12
   \       0xDE   0xD3F9             BCC.N    ??halInternalCrashHandler_5
   \       0xE0   0x4299             CMP      R1,R3
   \       0xE2   0xD2F7             BCS.N    ??halInternalCrashHandler_5
   \       0xE4   0x07CC             LSLS     R4,R1,#+31
   \       0xE6   0xD5F5             BPL.N    ??halInternalCrashHandler_5
   \       0xE8   0x2400             MOVS     R4,#+0
   \       0xEA   0xF106 0x057C      ADD      R5,R6,#+124
   \                     ??halInternalCrashHandler_7: (+1)
   \       0xEE   0xF855 0x7024      LDR      R7,[R5, R4, LSL #+2]
   \       0xF2   0x428F             CMP      R7,R1
   \       0xF4   0xD0E2             BEQ.N    ??halInternalCrashHandler_4
   \       0xF6   0x1C64             ADDS     R4,R4,#+1
   \       0xF8   0x2C06             CMP      R4,#+6
   \       0xFA   0xD3F8             BCC.N    ??halInternalCrashHandler_7
   \       0xFC   0xE7DE             B.N      ??halInternalCrashHandler_4
    262              }
    263            }
    264            // Shuffle the returns array so returns[0] has last probable return found.
    265            // If there were fewer than NUM_RETURNS, unused entries will contain zero.
    266            while ((i--) != 0U) {
    267              data = c->returns[0];
   \                     ??halInternalCrashHandler_8: (+1)
   \       0xFE   0x6FF1             LDR      R1,[R6, #+124]
    268              for (j = 0; j < NUM_RETURNS - 1U; j++ ) {
   \      0x100   0x2300             MOVS     R3,#+0
   \      0x102   0xF106 0x057C      ADD      R5,R6,#+124
    269                c->returns[j] = c->returns[j + 1U];
   \                     ??halInternalCrashHandler_9: (+1)
   \      0x106   0xEB06 0x0483      ADD      R4,R6,R3, LSL #+2
   \      0x10A   0xF8D4 0x4080      LDR      R4,[R4, #+128]
   \      0x10E   0xF845 0x4023      STR      R4,[R5, R3, LSL #+2]
    270              }
   \      0x112   0x1C5B             ADDS     R3,R3,#+1
   \      0x114   0x2B04             CMP      R3,#+4
   \      0x116   0xD9F6             BLS.N    ??halInternalCrashHandler_9
    271              c->returns[NUM_RETURNS - 1U] = data;
   \      0x118   0x6011             STR      R1,[R2, #+0]
    272            }
   \                     ??halInternalCrashHandler_6: (+1)
   \      0x11A   0x4601             MOV      R1,R0
   \      0x11C   0x1E48             SUBS     R0,R1,#+1
   \      0x11E   0xB2C9             UXTB     R1,R1
   \      0x120   0x2900             CMP      R1,#+0
   \      0x122   0xD1EC             BNE.N    ??halInternalCrashHandler_8
    273          
    274            // Read the highest priority active exception to get reason for fault
    275            activeException = c->icsr.bits.VECTACTIVE;
   \      0x124   0x6DB0             LDR      R0,[R6, #+88]
   \      0x126   0xF3C0 0x0008      UBFX     R0,R0,#+0,#+9
    276            switch (activeException) {
   \      0x12A   0x2803             CMP      R0,#+3
   \      0x12C   0xD010             BEQ.N    ??halInternalCrashHandler_10
   \      0x12E   0x2804             CMP      R0,#+4
   \      0x130   0xD011             BEQ.N    ??halInternalCrashHandler_11
   \      0x132   0x2805             CMP      R0,#+5
   \      0x134   0xD012             BEQ.N    ??halInternalCrashHandler_12
   \      0x136   0x2806             CMP      R0,#+6
   \      0x138   0xD013             BEQ.N    ??halInternalCrashHandler_13
   \      0x13A   0x280C             CMP      R0,#+12
   \      0x13C   0xD017             BEQ.N    ??halInternalCrashHandler_14
   \      0x13E   0x283B             CMP      R0,#+59
   \      0x140   0xD118             BNE.N    ??halInternalCrashHandler_15
    277              #if defined(WDOG_IF_WARN) && !defined(BOOTLOADER)
    278              case IRQ_TO_VECTOR_NUMBER(WDOG0_IRQn):
    279                if (WDOG0->IF & WDOG_IF_WARN) {
   \      0x142   0x....             LDR.N    R0,??DataTable2_8  ;; 0x4a018018
   \      0x144   0x6802             LDR      R2,[R0, #+0]
   \      0x146   0x0791             LSLS     R1,R2,#+30
   \      0x148   0xD519             BPL.N    ??halInternalCrashHandler_16
    280                  reason = RESET_WATCHDOG_CAUGHT;
   \      0x14A   0xF240 0x5802      MOVW     R8,#+1282
   \      0x14E   0xE016             B.N      ??halInternalCrashHandler_16
    281                }
    282                break;
    283              #endif
    284              case HARD_FAULT_VECTOR_INDEX:
    285                reason = (uint16_t)RESET_FAULT_HARD;
   \                     ??halInternalCrashHandler_10: (+1)
   \      0x150   0xF640 0x2801      MOVW     R8,#+2561
    286                break;
   \      0x154   0xE013             B.N      ??halInternalCrashHandler_16
    287              case MEMORY_FAULT_VECTOR_INDEX:
    288                reason = (uint16_t)RESET_FAULT_MEM;
   \                     ??halInternalCrashHandler_11: (+1)
   \      0x156   0xF640 0x2802      MOVW     R8,#+2562
    289                break;
   \      0x15A   0xE010             B.N      ??halInternalCrashHandler_16
    290              case BUS_FAULT_VECTOR_INDEX:
    291                reason = (uint16_t)RESET_FAULT_BUS;
   \                     ??halInternalCrashHandler_12: (+1)
   \      0x15C   0xF640 0x2803      MOVW     R8,#+2563
    292                break;
   \      0x160   0xE00D             B.N      ??halInternalCrashHandler_16
    293              case USAGE_FAULT_VECTOR_INDEX:
    294                // make sure we didn't already identify the usage fault as an assert
    295                if (reason == (uint16_t)RESET_FAULT_UNKNOWN) {
   \                     ??halInternalCrashHandler_13: (+1)
   \      0x162   0xF5B8 0x6F20      CMP      R8,#+2560
   \      0x166   0xD10A             BNE.N    ??halInternalCrashHandler_16
    296                  reason = (uint16_t)RESET_FAULT_USAGE;
   \      0x168   0xF640 0x2804      MOVW     R8,#+2564
   \      0x16C   0xE007             B.N      ??halInternalCrashHandler_16
    297                }
    298                break;
    299              case DEBUG_MONITOR_VECTOR_INDEX:
    300                reason = (uint16_t)RESET_FAULT_DBGMON;
   \                     ??halInternalCrashHandler_14: (+1)
   \      0x16E   0xF640 0x2805      MOVW     R8,#+2565
    301                break;
   \      0x172   0xE004             B.N      ??halInternalCrashHandler_16
    302              default:
    303                if ((activeException != 0U) && (activeException < VECTOR_TABLE_LENGTH)) {
   \                     ??halInternalCrashHandler_15: (+1)
   \      0x174   0xB118             CBZ.N    R0,??halInternalCrashHandler_16
   \      0x176   0x284D             CMP      R0,#+77
   \      0x178   0xBF38             IT       CC 
   \      0x17A   0xF640 0x2807      MOVWCC   R8,#+2567
    304                  reason = (uint16_t)RESET_FAULT_BADVECTOR;
    305                }
    306                break;
    307            }
    308            return reason;
   \                     ??halInternalCrashHandler_16: (+1)
   \      0x17E   0x4640             MOV      R0,R8
   \      0x180   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   \                     ??halInternalCrashHandler_3: (+1)
   \      0x184   0x....             LDR.N    R1,??DataTable2_9
   \      0x186   0x1A08             SUBS     R0,R1,R0
   \      0x188   0x64F0             STR      R0,[R6, #+76]
   \      0x18A   0x2000             MOVS     R0,#+0
   \      0x18C   0x2100             MOVS     R1,#+0
   \      0x18E   0xF106 0x047C      ADD      R4,R6,#+124
   \                     ??halInternalCrashHandler_17: (+1)
   \      0x192   0xB2C5             UXTB     R5,R0
   \      0x194   0x1C40             ADDS     R0,R0,#+1
   \      0x196   0xB2C7             UXTB     R7,R0
   \      0x198   0xF844 0x1025      STR      R1,[R4, R5, LSL #+2]
   \      0x19C   0x2F06             CMP      R7,#+6
   \      0x19E   0xD3F8             BCC.N    ??halInternalCrashHandler_17
   \      0x1A0   0x2000             MOVS     R0,#+0
   \      0x1A2   0xE797             B.N      ??halInternalCrashHandler_5
    309          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \        0x0   0xE000'ED04        DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \        0x0   0x....'....        DC32     halResetInfo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \        0x0   0xE000'E300        DC32     0xe000e300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \        0x0   0x....'....        DC32     SFE(CSTACK)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \        0x0   0x....'....        DC32     SFE(`.text`)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \        0x0   0x....'....        DC32     SFB(`.text`)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \        0x0   0x....'....        DC32     SFE(RESETINFO)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \        0x0   0x4A01'8018        DC32     0x4a018018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \        0x0   0x....'....        DC32     SFE(CSTACK)

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x0D 0x0A          DC8 "\015\012[ASSERT:%p:%d]\015\012"
   \              0x5B 0x41    
   \              0x53 0x53    
   \              0x45 0x52    
   \              0x54 0x3A    
   \              0x25 0x70    
   \              0x3A 0x25    
   \              0x64 0x5D    
   \              0x0D 0x0A    
   \              0x00         
   \       0x13   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   halInternalAssertFailed
        16   -> CORE_AtomicDisableIrq
        16   -> emberDebugAssert
        16   -> emberSerialGuaranteedPrintf
         0   -> halInternalAssertFault
        16   -> halInternalResetWatchDog
       0   halInternalAssertFault
      32   halInternalCrashHandler
        32   -> halInternalGetCStackBottom


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
      20  ?_0
      44  halInternalAssertFailed
       4  halInternalAssertFault
     420  halInternalCrashHandler

 
  20 bytes in section .rodata
 508 bytes in section .text
 
 508 bytes of CODE  memory
  20 bytes of CONST memory

Errors: none
Warnings: none
