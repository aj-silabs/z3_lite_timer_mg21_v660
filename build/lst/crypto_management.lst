###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:38
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\sl_crypto\src\crypto_management.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW1EFC.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\sl_crypto\src\crypto_management.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"crypto_management.c\"" -D PSSTORE_SIZE=0 -D
#        LONGTOKEN_SIZE=0 -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\sl_crypto\src\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\crypto_management.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\crypto_management.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\sl_crypto\src\crypto_management.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Silicon Labs CRYPTO device management interface.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * SPDX-License-Identifier: APACHE-2.0
     10           *
     11           * This software is subject to an open source license and is distributed by
     12           * Silicon Laboratories Inc. pursuant to the terms of the Apache License,
     13           * Version 2.0 available at https://www.apache.org/licenses/LICENSE-2.0.
     14           * Such terms and conditions may be further supplemented by the Silicon Labs
     15           * Master Software License Agreement (MSLA) available at www.silabs.com and its
     16           * sections applicable to open source software.
     17           *
     18           ******************************************************************************/
     19          
     20          #include "crypto_management.h"
     21          #include "em_core.h"
     22          #include "em_bus.h"
     23          
     24          #if defined( CRYPTO_PRESENT )
     25          
     26          #if defined( MBEDTLS_THREADING_C )
     27          #include "mbedtls/threading.h"
     28          static mbedtls_threading_mutex_t    crypto_locks[CRYPTO_COUNT];
     29          static volatile bool                crypto_locks_initialized = false;
     30          static unsigned int                 acquire_count = 0U;
     31          #endif /* MBEDTLS_THREADING_C */
     32          
     33          /* Conversion macro for compatibility with the 5.3.x release of the Gecko SDK */
     34          #if defined( MBEDTLS_CRYPTO_DEVICE_PREEMPTION )
     35          #warning "MBEDTLS_CRYPTO_DEVICE_PREEMPTION is deprecated, please define " \
     36                   "CRYPTO_DEVICE_PREEMPTION instead."
     37          #define CRYPTO_DEVICE_PREEMPTION
     38          #endif
     39          
     40          #if defined( CRYPTO_DEVICE_PREEMPTION )
     41          /** Preemptable context of CRYPTO hardware module. */
     42          typedef struct
     43          {
     44              uint32_t CTRL;          /*!< Control Register  */
     45              uint32_t WAC;           /*!< Wide Arithmetic Configuration  */
     46              uint32_t SEQCTRL;       /*!< Sequence Control  */
     47              uint32_t SEQCTRLB;      /*!< Sequence Control B  */
     48              uint32_t IEN;           /*!< Interrupt Enable Register  */
     49              uint32_t SEQ[5];        /*!< Instruction Sequence registers */
     50              CRYPTO_Data260_TypeDef DDATA[5]; /*!< DDATA registers. Covers all data
     51                                                  registers
     52                                                  of CRYPTO, including DATA(128 bit),
     53                                                  DDATA (256bit/260bit),
     54                                                  QDATA (512bit) registers. */
     55              uint32_t regmask;       /*!< Bitmask for which registers to save */
     56              uint32_t operands;      /*!< Saving the currently selected operands */
     57              bool carry;             /*!< Saving the status of the carry flag */
     58          } crypto_context_t;
     59          
     60          static crypto_context_t preemption_context;
     61          static bool             is_preempted = false;
     62          static CORE_DECLARE_IRQ_STATE;
     63          #endif /* CRYPTO_DEVICE_PREEMPTION */
     64          
     65          typedef enum
     66          {
     67          #if defined( CRYPTO0 )
     68              CRYPTO0_ID = 0,
     69          #elif defined( CRYPTO )
     70              CRYPTO_ID = 0,
     71          #endif
     72          #if defined( CRYPTO1 )
     73              CRYPTO1_ID = 1,
     74          #endif
     75          } crypto_instance_number_t;
     76          
     77          typedef struct {
     78              CRYPTO_TypeDef *device;
     79              uint32_t clockMask;
     80          } crypto_device_t;
     81          
     82          static const crypto_device_t crypto_devices[CRYPTO_COUNT] =
     83          {
     84          #if defined( CRYPTO0 )
     85              {
     86                  CRYPTO0,
     87                  _CMU_HFBUSCLKEN0_CRYPTO0_SHIFT
     88              },
     89          #elif defined( CRYPTO )
     90              {
     91                  CRYPTO,
     92                  _CMU_HFBUSCLKEN0_CRYPTO_SHIFT
     93              },
     94          #endif
     95          #if defined( CRYPTO1 )
     96              {
     97                  CRYPTO1,
     98                  _CMU_HFBUSCLKEN0_CRYPTO1_SHIFT
     99              },
    100          #endif
    101          };
    102          
    103          static inline int crypto_management_index_by_device( CRYPTO_TypeDef *device )
    104          {
    105          #if defined( CRYPTO0 )
    106              if ( device == CRYPTO0 ) { return 0; }
    107          #elif defined( CRYPTO )
    108              if ( device == CRYPTO ) { return 0; }
    109          #endif
    110          #if defined( CRYPTO1 )
    111              if ( device == CRYPTO1 ) { return 1; }
    112          #endif
    113              return -1;
    114          }
    115          
    116          /* Use bitband for clock enable/disable operations, such that they are atomic */
    117          #define CRYPTO_CLOCK_ENABLE(clk)  BUS_RegBitWrite(&(CMU->HFBUSCLKEN0), (clk), 1)
    118          #define CRYPTO_CLOCK_DISABLE(clk) BUS_RegBitWrite(&(CMU->HFBUSCLKEN0), (clk), 0)
    119          #define CRYPTO_CLOCK_ENABLED(clk) BUS_RegBitRead(&(CMU->HFBUSCLKEN0), (clk))
    120          
    121          /* Get ownership of an available crypto device */
    122          CRYPTO_TypeDef *crypto_management_acquire( void )
    123          {
    124              CRYPTO_TypeDef *device = NULL;
    125          
    126          #if defined( MBEDTLS_THREADING_C )
    127              unsigned int devno = 0;
    128          
    129              /* Initialize mutexes if that hasn't happened yet */
    130              CORE_DECLARE_IRQ_STATE;
    131          
    132              if ( !crypto_locks_initialized ) {
    133                  CORE_ENTER_CRITICAL();
    134                  if ( !crypto_locks_initialized ) {
    135                      for ( int i = 0; i < CRYPTO_COUNT; i++ ) {
    136                          mbedtls_mutex_init(&crypto_locks[i]);
    137                      }
    138                      crypto_locks_initialized = true;
    139                  }
    140                  CORE_EXIT_CRITICAL();
    141              }
    142          
    143          /* Wrapping this in SL_THREADING_ALT pending non-blocking mutex in official
    144           * threading API. */
    145          #if defined( SL_THREADING_ALT )
    146              /* Try to take an available crypto instance */
    147              for ( ; devno < CRYPTO_COUNT; devno++ ) {
    148                  if ( 0 == THREADING_TakeMutexNonBlocking(&crypto_locks[devno]) ) {
    149                      device = crypto_devices[devno].device;
    150                      break;
    151                  }
    152              }
    153          #endif /* SL_THREADING_ALT */
    154          
    155              /* If no device immediately available, do naieve round-robin */
    156              if ( device == NULL ) {
    157                  devno = acquire_count % CRYPTO_COUNT;
    158                  mbedtls_mutex_lock( &crypto_locks[devno] );
    159                  device = crypto_devices[devno].device;
    160              }
    161          
    162              /* Doing this outside of critical section is safe, since we own the lock
    163               * and are using bitband to poke the clock enable bit */
    164              CRYPTO_CLOCK_ENABLE( crypto_devices[devno].clockMask );
    165          
    166              acquire_count++;
    167          #else // !MBEDTLS_THREADING_C
    168              device = crypto_devices[0].device;
    169              CRYPTO_CLOCK_ENABLE( crypto_devices[0].clockMask );
    170          #endif // MBEDTLS_THREADING_C
    171          
    172              return device;
    173          }
    174          
    175          /* Get ownership of the default crypto device (CRYPTO0/CRYPTO) */
    176          CRYPTO_TypeDef *crypto_management_acquire_default( void )
    177          {
    178              CRYPTO_TypeDef *device = NULL;
    179          
    180          #if defined( MBEDTLS_THREADING_C )
    181              /* Initialize mutexes if that hasn't happened yet */
    182              CORE_DECLARE_IRQ_STATE;
    183          
    184              if ( !crypto_locks_initialized ) {
    185                  CORE_ENTER_CRITICAL();
    186                  if ( !crypto_locks_initialized ) {
    187                      for ( int i = 0; i < CRYPTO_COUNT; i++ ) {
    188                          mbedtls_mutex_init(&crypto_locks[i]);
    189                      }
    190                      crypto_locks_initialized = true;
    191                  }
    192                  CORE_EXIT_CRITICAL();
    193              }
    194          
    195              mbedtls_mutex_lock( &crypto_locks[0] );
    196              device = crypto_devices[0].device;
    197          
    198              /* Doing this outside of critical section is safe, since we own the lock
    199               * and are using bitband to poke the clock enable bit */
    200              CRYPTO_CLOCK_ENABLE( crypto_devices[0].clockMask );
    201          #else // !MBEDTLS_THREADING_C
    202              device = crypto_devices[0].device;
    203              CRYPTO_CLOCK_ENABLE( crypto_devices[0].clockMask );
    204          #endif // MBEDTLS_THREADING_C
    205          
    206              return device;
    207          }
    208          
    209          /* Release ownership of an available crypto device */
    210          void crypto_management_release( CRYPTO_TypeDef *device )
    211          {
    212              int devno = crypto_management_index_by_device( device );
    213              if ( devno < 0 ) {
    214                  return;
    215              }
    216          
    217              /* Doing this outside of critical section is safe, since we still own the lock
    218               * and are using bitband to poke the clock enable bit */
    219              CRYPTO_CLOCK_DISABLE( crypto_devices[devno].clockMask );
    220          
    221          #if defined ( MBEDTLS_THREADING_C )
    222              mbedtls_mutex_unlock( &crypto_locks[devno] );
    223          #endif
    224          }
    225          
    226          /* Acquire a device with preemption. NOT thread-safe! */
    227          CRYPTO_TypeDef *crypto_management_acquire_preemption( uint32_t regmask )
    228          {
    229          #if defined( CRYPTO_DEVICE_PREEMPTION )
    230              CRYPTO_TypeDef *device = NULL;
    231              /* Turn off interrupts */
    232              CORE_ENTER_CRITICAL();
    233          
    234              /* Check if there is an unused CRYPTO instance */
    235              for ( int i = 0; i < CRYPTO_COUNT; i++ ) {
    236                  if ( !CRYPTO_CLOCK_ENABLED( crypto_devices[i].clockMask ) ) {
    237                      /* Found an unused device */
    238                      CRYPTO_CLOCK_ENABLE( crypto_devices[i].clockMask );
    239                      device = crypto_devices[i].device;
    240                      break;
    241                  }
    242              }
    243          
    244              /* If there is no unused instance, preempt the last one */
    245              if ( device == NULL ) {
    246                  is_preempted = true;
    247                  device = crypto_devices[CRYPTO_COUNT - 1].device;
    248          
    249                  /* In case this instance is still working on anything */
    250                  CRYPTO_InstructionSequenceWait(device);
    251          
    252                  /* Store operational context */
    253                  preemption_context.regmask  = regmask;
    254                  preemption_context.WAC      = device->WAC;
    255                  preemption_context.CTRL     = device->CTRL;
    256                  preemption_context.SEQCTRL  = device->SEQCTRL;
    257                  preemption_context.SEQCTRLB = device->SEQCTRLB;
    258                  preemption_context.IEN      = device->IEN;
    259                  preemption_context.operands = device->CSTATUS;
    260                  preemption_context.carry    = (device->DSTATUS & CRYPTO_DSTATUS_CARRY) != 0;
    261          
    262                  if ( (preemption_context.WAC & _CRYPTO_WAC_RESULTWIDTH_MASK) == CRYPTO_WAC_RESULTWIDTH_260BIT)
    263                  {
    264                      CRYPTO_DData0Read260(device, preemption_context.DDATA[0]); /* Always save DDATA0 because it'll get clobbered in 260-bit mode*/
    265          
    266                      if ( (regmask & CRYPTO_MANAGEMENT_SAVE_DDATA1) != 0 ) {
    267                          device->CMD = CRYPTO_CMD_INSTR_DDATA1TODDATA0; /* Move DDATA1 to DDATA0
    268                                                                            in order to read. */
    269                          CRYPTO_DData0Read260(device, preemption_context.DDATA[1]);
    270                      }
    271                      if ( (regmask & CRYPTO_MANAGEMENT_SAVE_DDATA2) != 0 ) {
    272                          device->CMD = CRYPTO_CMD_INSTR_DDATA2TODDATA0; /* Move DDATA2 to DDATA0
    273                                                                            in order to read. */
    274                          CRYPTO_DData0Read260(device, preemption_context.DDATA[2]);
    275                      }
    276                      if ( (regmask & CRYPTO_MANAGEMENT_SAVE_DDATA3) != 0 ) {
    277                          device->CMD = CRYPTO_CMD_INSTR_DDATA3TODDATA0; /* Move DDATA3 to DDATA0
    278                                                                            in order to read. */
    279                          CRYPTO_DData0Read260(device, preemption_context.DDATA[3]);
    280                      }
    281                      if ( (regmask & CRYPTO_MANAGEMENT_SAVE_DDATA4) != 0 ) {
    282                          device->CMD = CRYPTO_CMD_INSTR_DDATA4TODDATA0; /* Move DDATA4 to DDATA0
    283                                                                            in order to read. */
    284                          CRYPTO_DData0Read260(device, preemption_context.DDATA[4]);
    285                      }
    286                  }
    287                  else
    288                  {
    289                      if ( (regmask & CRYPTO_MANAGEMENT_SAVE_DDATA0) != 0 )
    290                          CRYPTO_DDataRead(&device->DDATA0, preemption_context.DDATA[0]);
    291                      if ( (regmask & CRYPTO_MANAGEMENT_SAVE_DDATA1) != 0 )
    292                          CRYPTO_DDataRead(&device->DDATA1, preemption_context.DDATA[1]);
    293                      if ( (regmask & CRYPTO_MANAGEMENT_SAVE_DDATA2) != 0 )
    294                          CRYPTO_DDataRead(&device->DDATA2, preemption_context.DDATA[2]);
    295                      if ( (regmask & CRYPTO_MANAGEMENT_SAVE_DDATA3) != 0 )
    296                          CRYPTO_DDataRead(&device->DDATA3, preemption_context.DDATA[3]);
    297                      if ( (regmask & CRYPTO_MANAGEMENT_SAVE_DDATA4) != 0 )
    298                          CRYPTO_DDataRead(&device->DDATA4, preemption_context.DDATA[4]);
    299                  }
    300          
    301                  /* Search for possible EXEC commands and replace with END. */
    302                  for ( size_t j = 0; j < (regmask & 0x7U)*sizeof(uint32_t); j++ ) {
    303                      if ( (j & 0x03) == 0 ) {
    304                          preemption_context.SEQ[j / sizeof(uint32_t)] = *((&device->SEQ0) + (j / sizeof(uint32_t)));
    305                      }
    306                      if ( ((uint8_t*)preemption_context.SEQ)[j] == CRYPTO_CMD_INSTR_EXEC ) {
    307                          ((uint8_t*)preemption_context.SEQ)[j] = CRYPTO_CMD_INSTR_END;
    308                      }
    309                  }
    310              }
    311          
    312              return device;
    313          #else /* CRYPTO_DEVICE_PREEMPTION */
    314              (void) regmask;
    315              return crypto_management_acquire();
    316          #endif /* CRYPTO_DEVICE_PREEMPTION */
    317          }
    318          
    319          /* Release a device from preemption */
    320          void crypto_management_release_preemption( CRYPTO_TypeDef *device )
    321          {
    322              if ( crypto_management_index_by_device( device ) < 0 ) {
    323                  return;
    324              }
    325          #if defined( CRYPTO_DEVICE_PREEMPTION )
    326          
    327              if ( is_preempted ) {
    328                  /* If we preempted something, put their context back */
    329                  device->WAC      = preemption_context.WAC;
    330                  device->CTRL     = preemption_context.CTRL;
    331                  device->SEQCTRL  = preemption_context.SEQCTRL;
    332                  device->SEQCTRLB = preemption_context.SEQCTRLB;
    333                  device->IEN      = preemption_context.IEN;
    334          
    335                  if ( (preemption_context.WAC & _CRYPTO_WAC_RESULTWIDTH_MASK) == CRYPTO_WAC_RESULTWIDTH_260BIT)
    336                  {
    337                      /* Start by writing the DDATA1 value to DDATA0 and move to DDATA1. */
    338                      if ( (preemption_context.regmask & CRYPTO_MANAGEMENT_SAVE_DDATA1) != 0 ) {
    339                          CRYPTO_DData0Write260(device, preemption_context.DDATA[1]);
    340                          device->CMD = CRYPTO_CMD_INSTR_DDATA0TODDATA1;
    341                      }
    342          
    343                      /* Write the DDATA2 value to DDATA0 and move to DDATA2. */
    344                      if ( (preemption_context.regmask & CRYPTO_MANAGEMENT_SAVE_DDATA2) != 0 ) {
    345                          CRYPTO_DData0Write260(device, preemption_context.DDATA[2]);
    346                          device->CMD = CRYPTO_CMD_INSTR_DDATA0TODDATA2;
    347                      }
    348          
    349                      /* Write the DDATA3 value to DDATA0 and move to DDATA3. */
    350                      if ( (preemption_context.regmask & CRYPTO_MANAGEMENT_SAVE_DDATA3) != 0 ) {
    351                          CRYPTO_DData0Write260(device, preemption_context.DDATA[3]);
    352                          device->CMD = CRYPTO_CMD_INSTR_DDATA0TODDATA3;
    353                      }
    354          
    355                      /* Write the DDATA4 value to DDATA0 and move to DDATA4. */
    356                      if ( (preemption_context.regmask & CRYPTO_MANAGEMENT_SAVE_DDATA4) != 0 ) {
    357                          CRYPTO_DData0Write260(device, preemption_context.DDATA[4]);
    358                          device->CMD = CRYPTO_CMD_INSTR_DDATA0TODDATA4;
    359                      }
    360          
    361                      /* Finally write DDATA0 */
    362                      CRYPTO_DData0Write260(device, preemption_context.DDATA[0]);
    363                  }
    364                  else
    365                  {
    366                      if ( (preemption_context.regmask & CRYPTO_MANAGEMENT_SAVE_DDATA0) != 0 )
    367                          CRYPTO_DDataWrite(&device->DDATA0, preemption_context.DDATA[0]);
    368                      if ( (preemption_context.regmask & CRYPTO_MANAGEMENT_SAVE_DDATA1) != 0 )
    369                          CRYPTO_DDataWrite(&device->DDATA1, preemption_context.DDATA[1]);
    370                      if ( (preemption_context.regmask & CRYPTO_MANAGEMENT_SAVE_DDATA2) != 0 )
    371                          CRYPTO_DDataWrite(&device->DDATA2, preemption_context.DDATA[2]);
    372                      if ( (preemption_context.regmask & CRYPTO_MANAGEMENT_SAVE_DDATA3) != 0 )
    373                          CRYPTO_DDataWrite(&device->DDATA3, preemption_context.DDATA[3]);
    374                      if ( (preemption_context.regmask & CRYPTO_MANAGEMENT_SAVE_DDATA4) != 0 )
    375                          CRYPTO_DDataWrite(&device->DDATA4, preemption_context.DDATA[4]);
    376                  }
    377          
    378                  if (preemption_context.carry) {
    379                      device->CMD = CRYPTO_CMD_INSTR_CSET;
    380                  } else {
    381                      device->CMD = CRYPTO_CMD_INSTR_CCLR;
    382                  }
    383          
    384                  device->CMD = (preemption_context.operands & 0x7U) |
    385                                (((preemption_context.operands >> 8) & 0x7U) << 3) |
    386                                0xC0;
    387          
    388                  for (size_t i = 0; i < (preemption_context.regmask & 0x7U); i++ ) {
    389                      *((&device->SEQ0) + i) = preemption_context.SEQ[i];
    390                  }
    391          
    392                  is_preempted = false;
    393              } else {
    394                  /* If we didn't preempt anything, turn crypto clock back off */
    395                  CRYPTO_CLOCK_DISABLE( crypto_devices[crypto_management_index_by_device( device )].clockMask );
    396              }
    397          
    398              /* Turn interrupts back on */
    399              CORE_EXIT_CRITICAL();
    400          #else /* CRYPTO_DEVICE_PREEMPTION */
    401              crypto_management_release(device);
    402          #endif /* CRYPTO_DEVICE_PREEMPTION */
    403          }
    404          
    405          #endif /* CRYPTO_PRESENT */


 
 
 0 bytes of memory

Errors: none
Warnings: none
