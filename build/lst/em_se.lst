###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:53
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\em_se.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW5999.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\em_se.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"em_se.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0 -D
#        LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D EMBER_AF_USE_HWCONF
#        -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\em_se.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\em_se.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\em_se.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Secure Element API
      4           * @version 5.8.0
      5           *******************************************************************************
      6           * # License
      7           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      8           *******************************************************************************
      9           *
     10           * SPDX-License-Identifier: Zlib
     11           *
     12           * The licensor of this software is Silicon Laboratories Inc.
     13           *
     14           * This software is provided 'as-is', without any express or implied
     15           * warranty. In no event will the authors be held liable for any damages
     16           * arising from the use of this software.
     17           *
     18           * Permission is granted to anyone to use this software for any purpose,
     19           * including commercial applications, and to alter it and redistribute it
     20           * freely, subject to the following restrictions:
     21           *
     22           * 1. The origin of this software must not be misrepresented; you must not
     23           *    claim that you wrote the original software. If you use this software
     24           *    in a product, an acknowledgment in the product documentation would be
     25           *    appreciated but is not required.
     26           * 2. Altered source versions must be plainly marked as such, and must not be
     27           *    misrepresented as being the original software.
     28           * 3. This notice may not be removed or altered from any source distribution.
     29           *
     30           ******************************************************************************/
     31          #include "em_device.h"
     32          
     33          #if defined(SEMAILBOX_PRESENT) || defined(CRYPTOACC_PRESENT)
     34          
     35          #include "em_se.h"
     36          #include "em_assert.h"
     37          
     38          /***************************************************************************//**
     39           * @addtogroup emlib
     40           * @{
     41           ******************************************************************************/
     42          
     43          /***************************************************************************//**
     44           * @addtogroup SE
     45           * @{
     46           ******************************************************************************/
     47          
     48          /*******************************************************************************
     49           ******************************   DEFINES    ***********************************
     50           ******************************************************************************/
     51          
     52          #if defined(SEMAILBOX_PRESENT)
     53          
     54          /* OTP initialization structure defines. */
     55          #define SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ENABLE (1 << 16)
     56          #define SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_VERIFY_CERTIFICATE (1 << 17)
     57          #define SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ANTI_ROLLBACK (1 << 18)
     58          
     59          #elif defined(CRYPTOACC_PRESENT)
     60          
     61          /* Size of Root Code Mailbox instance.
     62             There are two instances, input and output. */
     63          #define ROOT_MAILBOX_SIZE  (512UL)
     64          
     65          /* Base addresses of the Root Code Input and Output Mailbox data structures.
     66             (Must be stored in a RAM area which is not used by the root code)
     67             We use the upper 1KB of FRC RAM for the root code mailboxes. */
     68          #define ROOT_MAILBOX_OUTPUT_BASE (RDMEM_FRCRAM_S_MEM_END + 1 - ROOT_MAILBOX_SIZE)
     69          #define ROOT_MAILBOX_INPUT_BASE  (ROOT_MAILBOX_OUTPUT_BASE - ROOT_MAILBOX_SIZE)
     70          
     71          /* Position of parameter number field in Root Code Input Mailbox LENGTH field.*/
     72          #define ROOT_MB_LENGTH_PARAM_NUM_SHIFT (24)
     73          
     74          /* Done flag indicating that the Root Code Mailbox handler has completed
     75             processing the mailbox command. */
     76          #define ROOT_MB_DONE  (1 << 23)
     77          
     78          /* Root Code Configuration Status bits mask */
     79          #define ROOT_MB_OUTPUT_STATUS_CONFIG_BITS_MASK  (0xFFFF)
     80          
     81          #endif // #if defined(SEMAILBOX_PRESENT)
     82          
     83          /*******************************************************************************
     84           ******************************   TYPEDEFS   ***********************************
     85           ******************************************************************************/
     86          #if defined(CRYPTOACC_PRESENT)
     87          
     88          // Root Code Input Mailbox structure
     89          typedef struct {
     90            volatile uint32_t magic;
     91            volatile uint32_t command;
     92            volatile uint32_t length;
     93            volatile uint32_t data[0];
     94          } root_InputMailbox_t;
     95          
     96          // Root Code Output Mailbox structure
     97          typedef struct {
     98            volatile uint32_t magic;
     99            volatile uint32_t version;
    100            volatile uint32_t status;
    101            volatile uint32_t command;
    102            volatile uint32_t length;
    103            volatile uint32_t data[0];
    104          } root_OutputMailbox_t;
    105          
    106          #endif // #if defined(CRYPTOACC_PRESENT)
    107          
    108          /*******************************************************************************
    109           **************************   GLOBAL FUNCTIONS   *******************************
    110           ******************************************************************************/
    111          
    112          /***************************************************************************//**
    113           * @brief
    114           *   Add input data to a command
    115           *
    116           * @details
    117           *   This function adds a buffer of input data to the given SE command structure
    118           *   The buffer gets appended by reference at the end of the list of already
    119           *   added buffers.
    120           *
    121           * @note
    122           *   Note that this function does not copy either the data buffer or the buffer
    123           *   structure, so make sure to keep the data object in scope until the command
    124           *   has been executed by the secure element.
    125           *
    126           * @param[in]  command
    127           *   Pointer to an SE command structure.
    128           *
    129           * @param[in]  data
    130           *   Pointer to a data transfer structure.
    131           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    132          void SE_addDataInput(SE_Command_t *command, SE_DataTransfer_t *data)
    133          {
    134            if (command->data_in == NULL) {
   \                     SE_addDataInput: (+1)
   \        0x0   0x6842             LDR      R2,[R0, #+4]
   \        0x2   0xB912             CBNZ.N   R2,??SE_addDataInput_0
    135              command->data_in = data;
   \        0x4   0x6041             STR      R1,[R0, #+4]
   \        0x6   0x4770             BX       LR
    136            } else {
    137              SE_DataTransfer_t *next = command->data_in;
    138              while (next->next != (void*)SE_DATATRANSFER_STOP) {
    139                next = (SE_DataTransfer_t*)next->next;
   \                     ??SE_addDataInput_1: (+1)
   \        0x8   0x6852             LDR      R2,[R2, #+4]
    140              }
   \                     ??SE_addDataInput_0: (+1)
   \        0xA   0x6850             LDR      R0,[R2, #+4]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD1FB             BNE.N    ??SE_addDataInput_1
    141              next->next = data;
   \       0x10   0x6051             STR      R1,[R2, #+4]
    142            }
    143          }
   \       0x12   0x4770             BX       LR               ;; return
    144          
    145          /***************************************************************************//**
    146           * @brief
    147           *   Add output data to a command
    148           *
    149           * @details
    150           *   This function adds a buffer of output data to the given command structure
    151           *   The buffer gets appended by reference at the end of the list of already
    152           *   added buffers.
    153           *
    154           * @note
    155           *   Note that this function does not copy either the data buffer or the buffer
    156           *   structure, so make sure to keep the data object in scope until the command
    157           *   has been executed by the secure element.
    158           *
    159           * @param[in]  command
    160           *   Pointer to an SE command structure.
    161           *
    162           * @param[in]  data
    163           *   Pointer to a data transfer structure.
    164           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    165          void SE_addDataOutput(SE_Command_t *command,
    166                                SE_DataTransfer_t *data)
    167          {
    168            if (command->data_out == NULL) {
   \                     SE_addDataOutput: (+1)
   \        0x0   0x6882             LDR      R2,[R0, #+8]
   \        0x2   0xB912             CBNZ.N   R2,??SE_addDataOutput_0
    169              command->data_out = data;
   \        0x4   0x6081             STR      R1,[R0, #+8]
   \        0x6   0x4770             BX       LR
    170            } else {
    171              SE_DataTransfer_t *next = command->data_out;
    172              while (next->next != (void*)SE_DATATRANSFER_STOP) {
    173                next = (SE_DataTransfer_t*)next->next;
   \                     ??SE_addDataOutput_1: (+1)
   \        0x8   0x6852             LDR      R2,[R2, #+4]
    174              }
   \                     ??SE_addDataOutput_0: (+1)
   \        0xA   0x6850             LDR      R0,[R2, #+4]
   \        0xC   0x2801             CMP      R0,#+1
   \        0xE   0xD1FB             BNE.N    ??SE_addDataOutput_1
    175              next->next = data;
   \       0x10   0x6051             STR      R1,[R2, #+4]
    176            }
    177          }
   \       0x12   0x4770             BX       LR               ;; return
    178          
    179          /***************************************************************************//**
    180           * @brief
    181           *   Add a parameter to a command
    182           *
    183           * @details
    184           *   This function adds a parameter word to the passed command.
    185           *
    186           * @note
    187           *   Make sure to not exceed @ref SE_MAX_PARAMETERS.
    188           *
    189           * @param[in]  command
    190           *   Pointer to a filled-out SE command structure.
    191           * @param[in]  parameter
    192           *   Parameter to add.
    193           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    194          void SE_addParameter(SE_Command_t *command, uint32_t parameter)
    195          {
    196            if (command->num_parameters >= SE_MAX_PARAMETERS) {
   \                     SE_addParameter: (+1)
   \        0x0   0x69C2             LDR      R2,[R0, #+28]
   \        0x2   0x2A04             CMP      R2,#+4
   \        0x4   0xD205             BCS.N    ??SE_addParameter_0
    197              EFM_ASSERT(command->num_parameters < SE_MAX_PARAMETERS);
    198              return;
    199            }
    200          
    201            command->parameters[command->num_parameters] = parameter;
   \        0x6   0xEB00 0x0282      ADD      R2,R0,R2, LSL #+2
   \        0xA   0x60D1             STR      R1,[R2, #+12]
    202            command->num_parameters += 1;
   \        0xC   0x69C1             LDR      R1,[R0, #+28]
   \        0xE   0x1C49             ADDS     R1,R1,#+1
   \       0x10   0x61C1             STR      R1,[R0, #+28]
    203          }
   \                     ??SE_addParameter_0: (+1)
   \       0x12   0x4770             BX       LR               ;; return
    204          
    205          /***************************************************************************//**
    206           * @brief
    207           *   Execute the passed command
    208           *
    209           * @details
    210           *   This function starts the execution of the passed command by the secure
    211           *   element. When started, wait for the RXINT interrupt flag, or call
    212           *   @ref SE_waitCommandCompletion to busy-wait. After completion, you have to
    213           *   call @ref SE_readCommandResponse to get the command's execution status.
    214           *
    215           * @param[in]  command
    216           *   Pointer to a filled-out SE command structure.
    217           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    218          void SE_executeCommand(SE_Command_t *command)
    219          {
   \                     SE_executeCommand: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    220            // Don't overflow our struct
    221            if (command->num_parameters > SE_MAX_PARAMETERS) {
   \        0x2   0x69C1             LDR      R1,[R0, #+28]
   \        0x4   0x2904             CMP      R1,#+4
   \        0x6   0xD909             BLS.N    ??SE_executeCommand_0
    222              EFM_ASSERT(command->num_parameters <= SE_MAX_PARAMETERS);
    223              return;
   \        0x8   0xBD10             POP      {R4,PC}
    224            }
    225          
    226          #if defined(SEMAILBOX_PRESENT)
    227          
    228            // Wait for room available in the mailbox
    229            while (!(SEMAILBOX_HOST->TX_STATUS & SEMAILBOX_TX_STATUS_TXINT)) ;
    230          
    231            // Write header to start transaction
    232            SEMAILBOX_HOST->TX_HEADER = sizeof(uint32_t) * (4 + command->num_parameters);
    233          
    234            // Write command into FIFO
    235            SEMAILBOX_HOST->FIFO[0].DATA = command->command;
    236          
    237            // Write DMA descriptors into FIFO
    238            SEMAILBOX_HOST->FIFO[0].DATA = (uint32_t)command->data_in;
    239            SEMAILBOX_HOST->FIFO[0].DATA = (uint32_t)command->data_out;
    240          
    241            // Write applicable parameters into FIFO
    242            for (size_t i = 0; i < command->num_parameters; i++) {
    243              SEMAILBOX_HOST->FIFO[0].DATA = command->parameters[i];
   \                     ??SE_executeCommand_1: (+1)
   \        0xA   0xEB00 0x0382      ADD      R3,R0,R2, LSL #+2
   \        0xE   0x68DC             LDR      R4,[R3, #+12]
    244            }
   \       0x10   0x1C52             ADDS     R2,R2,#+1
   \       0x12   0x600C             STR      R4,[R1, #+0]
   \                     ??SE_executeCommand_2: (+1)
   \       0x14   0x69C3             LDR      R3,[R0, #+28]
   \       0x16   0x429A             CMP      R2,R3
   \       0x18   0xD3F7             BCC.N    ??SE_executeCommand_1
    245          
    246          #elif defined(CRYPTOACC_PRESENT)
    247          
    248            // Setup pointer to the Root Code Mailbox Input data structure
    249            // (must be stored in a RAM area which is not used by the root code)
    250            root_InputMailbox_t *rootInMb = (root_InputMailbox_t*)ROOT_MAILBOX_INPUT_BASE;
    251            uint32_t *mbData;
    252            unsigned int mbDataLen, inDataLen, i;
    253            SE_DataTransfer_t *inDataDesc;
    254            uint32_t *inData;
    255            uint32_t checksum;
    256          
    257            // Set base of Mailbox Input data structure in SYSCFG register in order
    258            // for Root Code to find it.
    259            SYSCFG->ROOTDATA0 = ROOT_MAILBOX_INPUT_BASE;
    260          
    261            // Set base of Mailbox Output data structure in SYSCFG register in order
    262            // for Root Code to know where to write output data.
    263            // Write command into FIFO
    264            SYSCFG->ROOTDATA1 = ROOT_MAILBOX_OUTPUT_BASE;
    265          
    266            rootInMb->magic   = SE_RESPONSE_MAILBOX_VALID;
    267            rootInMb->command = command->command;
    268          
    269            // Write applicable parameters into Mailbox DATA array
    270            mbData = (uint32_t*) rootInMb->data;
    271            for (mbDataLen = 0; mbDataLen < command->num_parameters; mbDataLen++) {
    272              mbData[mbDataLen] = command->parameters[mbDataLen];
    273            }
    274          
    275            // Write input data into Mailbox DATA array
    276            for (inDataDesc = command->data_in, inDataLen = 0; inDataDesc;
    277                 inDataDesc = (SE_DataTransfer_t*) inDataDesc->next) {
    278              inData = (uint32_t*) inDataDesc->data;
    279              for (i = 0; i < inDataDesc->length; i++, inDataLen++) {
    280                // Make sure we do not overflow the input mailbox.
    281                EFM_ASSERT(mbDataLen < ROOT_MAILBOX_SIZE);
    282                mbData[mbDataLen++] = inData[i];
    283              }
    284            }
    285          
    286            // Write number of parameters and data words to 'length' field of mailbox.
    287            rootInMb->length =
    288              inDataLen | (command->num_parameters << ROOT_MB_LENGTH_PARAM_NUM_SHIFT);
    289          
    290            // Calculate checksum using bitwise XOR over the all words in the mailbox
    291            // data structure, minus the CHECKSUM word (32bit = 4bytes ) at the end.
    292            checksum = rootInMb->magic;
    293            checksum ^= rootInMb->command;
    294            checksum ^= rootInMb->length;
    295            for (i = 0; i < mbDataLen; i++) {
    296              checksum ^= mbData[i];
    297            }
    298          
    299            // Finally, write the calculated checksum to mailbox checksum field
    300            mbData[mbDataLen] = checksum;
    301          
    302            __NVIC_SystemReset();
    303          
    304          #endif // #if defined(SEMAILBOX_PRESENT)
    305          
    306            return;
   \       0x1A   0xBD10             POP      {R4,PC}          ;; return
   \                     ??SE_executeCommand_0: (+1)
   \       0x1C   0xF04F 0x4198      MOV      R1,#+1275068416
   \       0x20   0x6C0A             LDR      R2,[R1, #+64]
   \       0x22   0x02D3             LSLS     R3,R2,#+11
   \       0x24   0xD5FA             BPL.N    ??SE_executeCommand_0
   \       0x26   0x69C2             LDR      R2,[R0, #+28]
   \       0x28   0x1D12             ADDS     R2,R2,#+4
   \       0x2A   0x0092             LSLS     R2,R2,#+2
   \       0x2C   0x650A             STR      R2,[R1, #+80]
   \       0x2E   0x6802             LDR      R2,[R0, #+0]
   \       0x30   0x600A             STR      R2,[R1, #+0]
   \       0x32   0x6843             LDR      R3,[R0, #+4]
   \       0x34   0x600B             STR      R3,[R1, #+0]
   \       0x36   0x6882             LDR      R2,[R0, #+8]
   \       0x38   0x600A             STR      R2,[R1, #+0]
   \       0x3A   0x2200             MOVS     R2,#+0
   \       0x3C   0xE7EA             B.N      ??SE_executeCommand_2
    307          }
    308          
    309          #if defined(CRYPTOACC_PRESENT)
    310          
    311          /***************************************************************************//**
    312           * @brief
    313           *   Check whether the Root Code Output Mailbox is valid.
    314           *
    315           * @return True if the Root Code Output Mailbox is valid (magic and checksum OK)
    316           ******************************************************************************/
    317          bool rootIsOutputMailboxValid(void)
    318          {
    319            // Setup pointer to the Root Code Output Mailbox data structure
    320            // (must be stored in a RAM area which is not used by the root code)
    321            root_OutputMailbox_t *rootOutMb = (root_OutputMailbox_t *) SYSCFG->ROOTDATA1;
    322            uint32_t *mbPtr = (uint32_t*) rootOutMb;
    323            uint32_t checksum;
    324            unsigned int mbLen, cnt;
    325          
    326            // Verify magic word of mailbox
    327            if (rootOutMb->magic != SE_RESPONSE_MAILBOX_VALID) {
    328              return false;
    329            }
    330          
    331            // Get length of mailbox
    332            mbLen = sizeof(root_OutputMailbox_t) / sizeof(uint32_t) + rootOutMb->length;
    333            if (mbLen >= ROOT_MAILBOX_SIZE) {
    334              return false;
    335            }
    336            // Calculate checksum using bitwise XOR over all words in the mailbox
    337            // data structure, minus the CHECKSUM word at the end.
    338            for (checksum = 0, cnt = 0; cnt < mbLen; cnt++) {
    339              checksum ^= mbPtr[cnt];
    340            }
    341          
    342            // Verify that the calculated checksum is equal to the mailbox checksum.
    343            return (mbPtr[mbLen] == checksum);
    344          }
    345          
    346          /***************************************************************************//**
    347           * @brief
    348           *   Get current SE version
    349           *
    350           * @details
    351           *   This function returns the current root code version
    352           *
    353           * @param[in]  version
    354           *   Pointer to location where to copy the version of root code to.
    355           *
    356           * @return
    357           *   One of the SE_RESPONSE return codes:
    358           *   SE_RESPONSE_OK when the command was executed successfully
    359           *   SE_RESPONSE_INVALID_PARAMETER when an invalid parameter was passed
    360           *   SE_RESPONSE_MAILBOX_INVALID when the mailbox content is invalid
    361           ******************************************************************************/
    362          SE_Response_t SE_getVersion(uint32_t *version)
    363          {
    364            root_OutputMailbox_t *rootOutMb = (root_OutputMailbox_t *) SYSCFG->ROOTDATA1;
    365          
    366            if (version == NULL) {
    367              return SE_RESPONSE_INVALID_PARAMETER;
    368            }
    369          
    370            // First verify that the response is ok.
    371            if (!rootIsOutputMailboxValid()) {
    372              return SE_RESPONSE_MAILBOX_INVALID;
    373            }
    374          
    375            // Return the 'version' from the Output Mailbox
    376            *version = rootOutMb->version;
    377          
    378            return SE_RESPONSE_OK;
    379          }
    380          
    381          /***************************************************************************//**
    382           * @brief
    383           *   Get Root Code Configuration Status bits
    384           *
    385           * @details
    386           *   This function returns the current Root Code Configuration Status bits
    387           *
    388           * @param[in]  cfgStatus
    389           *   Pointer to location where to copy Configuration Status bits
    390           *   of the root code.
    391           *
    392           * @return
    393           *   One of the SE_RESPONSE return codes:
    394           *   SE_RESPONSE_OK when the command was executed successfully
    395           *   SE_RESPONSE_INVALID_PARAMETER when an invalid parameter was passed
    396           *   SE_RESPONSE_MAILBOX_INVALID when the mailbox content is invalid
    397           ******************************************************************************/
    398          SE_Response_t SE_getConfigStatusBits(uint32_t *cfgStatus)
    399          {
    400            root_OutputMailbox_t *rootOutMb = (root_OutputMailbox_t *) SYSCFG->ROOTDATA1;
    401          
    402            if (cfgStatus == NULL) {
    403              return SE_RESPONSE_INVALID_PARAMETER;
    404            }
    405          
    406            // First verify that the response is ok.
    407            if (!rootIsOutputMailboxValid()) {
    408              return SE_RESPONSE_MAILBOX_INVALID;
    409            }
    410          
    411            // Return the configuration status bits
    412            *cfgStatus = rootOutMb->status & ROOT_MB_OUTPUT_STATUS_CONFIG_BITS_MASK;
    413          
    414            return SE_RESPONSE_OK;
    415          }
    416          
    417          /***************************************************************************//**
    418           * @brief
    419           *   Check whether the running command has completed.
    420           *
    421           * @details
    422           *   This function polls the SE-to-host mailbox interrupt flag.
    423           *
    424           * @return True if a command has completed and the result is available
    425           ******************************************************************************/
    426          bool SE_isCommandCompleted(void)
    427          {
    428            root_OutputMailbox_t *rootOutMb = (root_OutputMailbox_t *) SYSCFG->ROOTDATA1;
    429          
    430            // First verify that the response is ok
    431            if (!rootIsOutputMailboxValid()) {
    432              return false;
    433            }
    434          
    435            // Check status MB_DONE flag of the mailbox
    436            return ((rootOutMb->status & ROOT_MB_DONE) == ROOT_MB_DONE);
    437          }
    438          
    439          /***************************************************************************//**
    440           * @brief
    441           *   Read the status of the previously executed command.
    442           *
    443           * @details
    444           *   This function reads the status of the previously executed command.
    445           *
    446           * @note
    447           *   The command response needs to be read for every executed command, and can
    448           *   only be read once per executed command (FIFO behavior).
    449           *
    450           * @return
    451           *   One of the SE_RESPONSE return codes:
    452           *   SE_RESPONSE_OK when the command was executed successfully or a signature
    453           *   was successfully verified,
    454           *   SE_RESPONSE_INVALID_COMMAND when the command ID was not recognized,
    455           *   SE_RESPONSE_AUTHORIZATION_ERROR when the command is not authorized,
    456           *   SE_RESPONSE_INVALID_SIGNATURE when signature verification failed,
    457           *   SE_RESPONSE_BUS_ERROR when a bus error was thrown during the command, e.g.
    458           *   because of conflicting Secure/Non-Secure memory accesses,
    459           *   SE_RESPONSE_CRYPTO_ERROR on an internal SE failure, or
    460           *   SE_RESPONSE_INVALID_PARAMETER when an invalid parameter was passed
    461           ******************************************************************************/
    462          SE_Response_t SE_readCommandResponse(void)
    463          {
    464            root_OutputMailbox_t *rootOutMb = (root_OutputMailbox_t *) SYSCFG->ROOTDATA1;
    465          
    466            SE_waitCommandCompletion();
    467          
    468            return (SE_Response_t)(rootOutMb->status & SE_RESPONSE_MASK);
    469          }
    470          
    471          /***************************************************************************//**
    472           * @brief
    473           *   Acknowledge and get status and output data of a completed command.
    474           *
    475           * @details
    476           *   This function acknowledges and gets the status and output data of a
    477           *   completed mailbox command.
    478           *   The mailbox command is acknowledged by inverting all bits in the checksum
    479           *   (XOR with 0xFFFFFFFF).
    480           *   The output data is copied into the linked list of output buffers pointed
    481           *   to in the given command data structure.
    482           *
    483           * @param[in]  command
    484           *   Pointer to a filled-out SE command structure.
    485           *
    486           * @return
    487           *   One of the SE_RESPONSE return codes.
    488           * @retval SE_RESPONSE_OK when the command was executed successfully or a
    489           *                        signature was successfully verified,
    490           * @retval SE_RESPONSE_INVALID_COMMAND when the command ID was not recognized,
    491           * @retval SE_RESPONSE_AUTHORIZATION_ERROR when the command is not authorized,
    492           * @retval SE_RESPONSE_INVALID_SIGNATURE when signature verification failed,
    493           * @retval SE_RESPONSE_BUS_ERROR when a bus error was thrown during the command,
    494           *                               e.g. because of conflicting Secure/Non-Secure
    495           *                               memory accesses,
    496           * @retval SE_RESPONSE_CRYPTO_ERROR on an internal SE failure, or
    497           * @retval SE_RESPONSE_INVALID_PARAMETER when an invalid parameter was passed
    498           * @retval SE_RESPONSE_MAILBOX_INVALID when mailbox command not done or invalid
    499           ******************************************************************************/
    500          SE_Response_t SE_ackCommand(SE_Command_t *command)
    501          {
    502            // Setup pointer to the Root Code Output Mailbox data structure
    503            // (must be stored in a RAM area which is not used by the root code)
    504            root_OutputMailbox_t *rootOutMb = (root_OutputMailbox_t *) SYSCFG->ROOTDATA1;
    505            uint32_t *mbData = (uint32_t*) rootOutMb->data;
    506            SE_DataTransfer_t *outDataDesc = command->data_out;
    507            unsigned int outDataLen, outDataCnt, i, outDescLen;
    508            uint32_t *outData;
    509          
    510            // First verify that the Output Mailbox includes a valid response.
    511            if (!SE_isCommandCompleted()) {
    512              return SE_RESPONSE_MAILBOX_INVALID;
    513            }
    514          
    515            // Get output data length
    516            outDataLen = rootOutMb->length;
    517          
    518            // Acknowledge the output mailbox response by invalidating checksum
    519            mbData[outDataLen] ^= 0xFFFFFFFFUL;
    520          
    521            // Check command status code
    522            if ((rootOutMb->status & SE_RESPONSE_MASK) != SE_RESPONSE_OK) {
    523              return rootOutMb->status & SE_RESPONSE_MASK;
    524            }
    525          
    526            // Copy data from the Output Mailbox to the linked list of output
    527            // buffers provided by the user
    528            outDataCnt = 0;
    529            while (outDataDesc && (outDataCnt < outDataLen)) {
    530              outData = (uint32_t*) outDataDesc->data;
    531              outDescLen =
    532                (outDataDesc->length & SE_DATATRANSFER_LENGTH_MASK) / sizeof(uint32_t);
    533              for (i = 0; (i < outDescLen) && (outDataCnt < outDataLen); i++) {
    534                outData[i] = mbData[outDataCnt++];
    535              }
    536              // If we have reached the end of a buffer, go to next buffer descriptor
    537              if (i == outDescLen) {
    538                outDataDesc = (SE_DataTransfer_t*)
    539                              ((uint32_t)outDataDesc->next & ~SE_DATATRANSFER_STOP);
    540              }
    541            }
    542          
    543            // Check if the output data list is too small to copy all output data in
    544            // mailbox.
    545            if ((outDataDesc == 0) && (outDataCnt < outDataLen)) {
    546              return SE_RESPONSE_INVALID_PARAMETER;
    547            }
    548          
    549            return SE_RESPONSE_OK;
    550          }
    551          
    552          #endif // #if defined(CRYPTOACC_PRESENT)
    553          
    554          #if defined(SEMAILBOX_PRESENT)
    555          
    556          /***************************************************************************//**
    557           * @brief
    558           *   Writes data to User Data section in MTP. Write data must be aligned to
    559           *    word size and contain a number of bytes that is divisable by four.
    560           * @note
    561           *   It is recommended to erase the flash page before performing a write.
    562           *
    563           * @param[in] offset
    564           *   Offset to the flash word to write to. Must be aligned to words.
    565           * @param[in] data
    566           *   Data to write to flash.
    567           * @param[in] numBytes
    568           *   Number of bytes to write to flash. NB: Must be divisable by four.
    569           * @return
    570           *   One of the SE_RESPONSE return codes.
    571           * @retval SE_RESPONSE_OK when the command was executed successfully or a
    572           *                        signature was successfully verified,
    573           * @retval SE_RESPONSE_INVALID_COMMAND when the command ID was not recognized,
    574           * @retval SE_RESPONSE_AUTHORIZATION_ERROR when the command is not authorized,
    575           * @retval SE_RESPONSE_INVALID_SIGNATURE when signature verification failed,
    576           * @retval SE_RESPONSE_BUS_ERROR when a bus error was thrown during the command,
    577           *                               e.g. because of conflicting Secure/Non-Secure
    578           *                               memory accesses,
    579           * @retval SE_RESPONSE_CRYPTO_ERROR on an internal SE failure, or
    580           * @retval SE_RESPONSE_INVALID_PARAMETER when an invalid parameter was passed
    581           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    582          SE_Response_t SE_writeUserData(uint32_t offset,
    583                                         void *data,
    584                                         uint32_t numBytes)
    585          {
   \                     SE_writeUserData: (+1)
   \        0x0   0xE92D 0x4EF8      PUSH     {R3-R7,R9-R11,LR}
   \        0x4   0xB08B             SUB      SP,SP,#+44
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x460E             MOV      R6,R1
   \        0xA   0x4615             MOV      R5,R2
    586            // SE command structures
    587            SE_Command_t command = SE_COMMAND_DEFAULT(SE_COMMAND_WRITE_USER_DATA);
   \        0xC   0xA803             ADD      R0,SP,#+12
   \        0xE   0x....'....        LDR.W    R1,??DataTable14
   \       0x12   0x....'....        BL       ?Subroutine2
    588            SE_DataTransfer_t userData = SE_DATATRANSFER_DEFAULT(data, numBytes);
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x16   0x....             LDR.N    R0,??DataTable14_1
   \       0x18   0xE890 0x0E00      LDM      R0,{R9-R11}
   \       0x1C   0x466F             MOV      R7,SP
   \       0x1E   0xF045 0x5100      ORR      R1,R5,#0x20000000
   \       0x22   0xE887 0x0E00      STM      R7,{R9-R11}
   \       0x26   0x9600             STR      R6,[SP, #+0]
   \       0x28   0x9102             STR      R1,[SP, #+8]
    589          
    590            SE_addDataInput(&command, &userData);
   \       0x2A   0x4669             MOV      R1,SP
   \       0x2C   0xA803             ADD      R0,SP,#+12
   \       0x2E   0x....'....        BL       SE_addDataInput
    591          
    592            SE_addParameter(&command, offset);
   \       0x32   0x4621             MOV      R1,R4
   \       0x34   0xA803             ADD      R0,SP,#+12
   \       0x36   0x....'....        BL       SE_addParameter
    593            SE_addParameter(&command, numBytes);
   \       0x3A   0x4629             MOV      R1,R5
   \       0x3C   0xA803             ADD      R0,SP,#+12
   \       0x3E   0x....'....        BL       SE_addParameter
    594          
    595            SE_executeCommand(&command);
   \       0x42   0x....             B.N      ?Subroutine0
    596            SE_Response_t res = SE_readCommandResponse();
    597            return res;
    598          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x2220             MOVS     R2,#+32
   \        0x2   0x....'....        B.W      __aeabi_memcpy4

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xA803             ADD      R0,SP,#+12
   \        0x2   0x....'....        BL       SE_executeCommand
   \        0x6   0x....'....        BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_8: (+1)
   \        0xA   0xB00C             ADD      SP,SP,#+48
   \        0xC   0xF400 0x2070      AND      R0,R0,#0xF0000
   \       0x10   0xE8BD 0x8EF0      POP      {R4-R7,R9-R11,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable14_15  ;; 0x4c000044
   \                     ??Subroutine3_0: (+1)
   \        0x2   0x6801             LDR      R1,[R0, #+0]
   \        0x4   0x02C9             LSLS     R1,R1,#+11
   \        0x6   0xD5FC             BPL.N    ??Subroutine3_0
   \        0x8   0x6900             LDR      R0,[R0, #+16]
   \        0xA   0x4770             BX       LR

   \                                 In section .rodata, align 4
   \                     ?_2:
   \        0x0   0x4309'0000        DC32 1124663296, 0H, 0H, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  

   \                                 In section .rodata, align 4
   \                     ?_3:
   \        0x0   0x0000'0000        DC32 0H, 1H, 0
   \              0x0000'0001  
   \              0x0000'0000  
    599          
    600          /***************************************************************************//**
    601           * @brief
    602           *   Erases User Data section in MTP.
    603           * @return
    604           *   One of the SE_RESPONSE return codes.
    605           * @retval SE_RESPONSE_OK when the command was executed successfully or a
    606           *                        signature was successfully verified,
    607           * @retval SE_RESPONSE_INVALID_COMMAND when the command ID was not recognized,
    608           * @retval SE_RESPONSE_AUTHORIZATION_ERROR when the command is not authorized,
    609           * @retval SE_RESPONSE_INVALID_SIGNATURE when signature verification failed,
    610           * @retval SE_RESPONSE_BUS_ERROR when a bus error was thrown during the command,
    611           *                               e.g. because of conflicting Secure/Non-Secure
    612           *                               memory accesses,
    613           * @retval SE_RESPONSE_CRYPTO_ERROR on an internal SE failure, or
    614           * @retval SE_RESPONSE_INVALID_PARAMETER when an invalid parameter was passed
    615           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    616          SE_Response_t SE_eraseUserData()
    617          {
   \                     SE_eraseUserData: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
    618            // SE command structures
    619            SE_Command_t command = SE_COMMAND_DEFAULT(SE_COMMAND_ERASE_USER_DATA);
   \        0x4   0x4668             MOV      R0,SP
   \        0x6   0x....             LDR.N    R1,??DataTable14_2
   \        0x8   0x....'....        BL       ?Subroutine2
    620          
    621            SE_addParameter(&command, SE_COMMAND_OPTION_ERASE_UD);
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0xC   0x....             LDR.N    R1,??DataTable14_3  ;; 0xde1e7ead
   \        0xE   0x4668             MOV      R0,SP
   \       0x10   0x....'....        BL       SE_addParameter
    622            SE_executeCommand(&command);
   \       0x14   0x....             B.N      ??Subroutine1_0
    623            SE_Response_t res = SE_readCommandResponse();
    624            return res;
    625          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x2220             MOVS     R2,#+32
   \        0x2   0x....'....        BL       __aeabi_memcpy4
   \                     ??Subroutine1_0: (+1)
   \        0x6   0x4668             MOV      R0,SP
   \        0x8   0x....'....        BL       SE_executeCommand
   \        0xC   0x....             LDR.N    R0,??DataTable14_15  ;; 0x4c000044
   \                     ??Subroutine1_1: (+1)
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x02C9             LSLS     R1,R1,#+11
   \       0x12   0xD5FC             BPL.N    ??Subroutine1_1
   \       0x14   0x6900             LDR      R0,[R0, #+16]
   \       0x16   0xB009             ADD      SP,SP,#+36
   \       0x18   0xF400 0x2070      AND      R0,R0,#0xF0000
   \       0x1C   0xBD00             POP      {PC}             ;; return

   \                                 In section .rodata, align 4
   \                     ?_4:
   \        0x0   0x430A'0000        DC32 1124728832, 0H, 0H, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
    626          
    627          /***************************************************************************//**
    628           * @brief
    629           *   Returns the current boot status, versions and system configuration.
    630           *
    631           * @param[out] status
    632           *   SE_Status_t containing current SE status.
    633           *
    634           * @return
    635           *   One of the SE_RESPONSE return codes.
    636           * @retval SE_RESPONSE_OK upon command completion. Errors are encoded in the
    637           *                        different parts of the returned status object.
    638           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    639          SE_Response_t SE_getStatus(SE_Status_t *status)
    640          {
   \                     SE_getStatus: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB094             SUB      SP,SP,#+80
   \        0x4   0x4604             MOV      R4,R0
    641            volatile uint32_t output[9] = { 0 };
   \        0x6   0xA803             ADD      R0,SP,#+12
   \        0x8   0x2124             MOVS     R1,#+36
   \        0xA   0x....'....        BL       __aeabi_memclr4
    642          
    643            // SE command structures
    644            SE_Command_t command = SE_COMMAND_DEFAULT(SE_COMMAND_GET_STATUS);
   \        0xE   0xA80C             ADD      R0,SP,#+48
   \       0x10   0x....             LDR.N    R1,??DataTable14_4
   \       0x12   0x....'....        BL       ?Subroutine2
    645            SE_DataTransfer_t outData = SE_DATATRANSFER_DEFAULT((void*)output, 4 * 9);
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x16   0x....             LDR.N    R1,??DataTable14_5
   \       0x18   0xE891 0x00E0      LDM      R1,{R5-R7}
   \       0x1C   0x4668             MOV      R0,SP
    646          
    647            SE_addDataOutput(&command, &outData);
   \       0x1E   0x4669             MOV      R1,SP
   \       0x20   0xE880 0x00E0      STM      R0,{R5-R7}
   \       0x24   0xA803             ADD      R0,SP,#+12
   \       0x26   0x9000             STR      R0,[SP, #+0]
   \       0x28   0xA80C             ADD      R0,SP,#+48
   \       0x2A   0x....'....        BL       SE_addDataOutput
    648          
    649            // Execute command and return response
    650            SE_executeCommand(&command);
   \       0x2E   0xA80C             ADD      R0,SP,#+48
   \       0x30   0x....'....        BL       SE_executeCommand
   \       0x34   0x....'....        BL       ?Subroutine3
    651            SE_Response_t res = SE_readCommandResponse();
    652          
    653            // Update status object
    654            status->bootStatus = output[4];
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x38   0x9907             LDR      R1,[SP, #+28]
   \       0x3A   0x6021             STR      R1,[R4, #+0]
    655            status->seFwVersion = output[5];
   \       0x3C   0x9A08             LDR      R2,[SP, #+32]
   \       0x3E   0xF400 0x2070      AND      R0,R0,#0xF0000
   \       0x42   0x6062             STR      R2,[R4, #+4]
    656            status->hostFwVersion = output[6];
   \       0x44   0x9909             LDR      R1,[SP, #+36]
   \       0x46   0x60A1             STR      R1,[R4, #+8]
    657          
    658            SE_DebugStatus_t debugStatus;
    659            debugStatus.debugLockEnabled = (output[7] & (1 << 0));
   \       0x48   0xA903             ADD      R1,SP,#+12
   \       0x4A   0x69CA             LDR      R2,[R1, #+28]
    660            debugStatus.deviceEraseEnabled = (output[7] & (1 << 1));
   \       0x4C   0x69CB             LDR      R3,[R1, #+28]
    661            debugStatus.secureDebugEnabled = (output[7] & (1 << 2));
   \       0x4E   0x69CD             LDR      R5,[R1, #+28]
    662            status->debugStatus = debugStatus;
   \       0x50   0x085B             LSRS     R3,R3,#+1
   \       0x52   0xF002 0x0201      AND      R2,R2,#0x1
   \       0x56   0x08AD             LSRS     R5,R5,#+2
   \       0x58   0xF003 0x0301      AND      R3,R3,#0x1
   \       0x5C   0xF005 0x0501      AND      R5,R5,#0x1
   \       0x60   0x7322             STRB     R2,[R4, #+12]
   \       0x62   0x7363             STRB     R3,[R4, #+13]
   \       0x64   0x73A5             STRB     R5,[R4, #+14]
    663          
    664            status->secureBootEnabled = ((output[8] & 0x1) && ((output[8] & ~0x1) == 0));
   \       0x66   0x6A0A             LDR      R2,[R1, #+32]
   \       0x68   0x07D3             LSLS     R3,R2,#+31
   \       0x6A   0xD506             BPL.N    ??SE_getStatus_0
   \       0x6C   0x6A09             LDR      R1,[R1, #+32]
   \       0x6E   0x0849             LSRS     R1,R1,#+1
   \       0x70   0x0049             LSLS     R1,R1,#+1
   \       0x72   0x1E49             SUBS     R1,R1,#+1
   \       0x74   0x4189             SBCS     R1,R1,R1
   \       0x76   0x0FC9             LSRS     R1,R1,#+31
   \       0x78   0xE000             B.N      ??SE_getStatus_1
   \                     ??SE_getStatus_0: (+1)
   \       0x7A   0x2100             MOVS     R1,#+0
   \                     ??SE_getStatus_1: (+1)
   \       0x7C   0x73E1             STRB     R1,[R4, #+15]
    665          
    666            return res;
   \       0x7E   0xB015             ADD      SP,SP,#+84
   \       0x80   0xBDF0             POP      {R4-R7,PC}       ;; return
    667          }

   \                                 In section .rodata, align 4
   \                     ?_5:
   \        0x0   0xFE01'0000        DC32 4261478400, 0H, 0H, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  

   \                                 In section .rodata, align 4
   \                     ?_6:
   \        0x0   0x0000'0000        DC32 0H, 1H, 536870948
   \              0x0000'0001  
   \              0x2000'0024  
    668          
    669          /***************************************************************************//**
    670           * @brief
    671           *   Read the serial number of the SE module.
    672           *
    673           * @param[out] serial
    674           *   Pointer to array of size 16 bytes.
    675           *
    676           * @return
    677           *   One of the SE_Response_t return codes.
    678           * @retval SE_RESPONSE_OK when serial number is returned successfully,
    679           * @retval SE_RESPONSE_INTERNAL_ERROR if not.
    680           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    681          SE_Response_t SE_serialNumber(void *serial)
    682          {
   \                     SE_serialNumber: (+1)
   \        0x0   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \        0x4   0xB08B             SUB      SP,SP,#+44
   \        0x6   0x4604             MOV      R4,R0
    683            // SE command structures
    684            SE_Command_t command = SE_COMMAND_DEFAULT(SE_COMMAND_READ_SERIAL);
   \        0x8   0xA803             ADD      R0,SP,#+12
   \        0xA   0x....             LDR.N    R1,??DataTable14_6
   \        0xC   0x....'....        BL       ?Subroutine2
    685            SE_DataTransfer_t outData = SE_DATATRANSFER_DEFAULT(serial, 16);
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x10   0x....             LDR.N    R6,??DataTable14_7
   \       0x12   0xE896 0x0380      LDM      R6,{R7-R9}
   \       0x16   0x466D             MOV      R5,SP
    686          
    687            SE_addDataOutput(&command, &outData);
   \       0x18   0x4669             MOV      R1,SP
   \       0x1A   0xE885 0x0380      STM      R5,{R7-R9}
   \       0x1E   0x9400             STR      R4,[SP, #+0]
   \       0x20   0xA803             ADD      R0,SP,#+12
   \       0x22   0x....'....        BL       SE_addDataOutput
    688          
    689            // Execute command and return response
    690            SE_executeCommand(&command);
   \       0x26   0xA803             ADD      R0,SP,#+12
   \       0x28   0x....'....        BL       SE_executeCommand
   \       0x2C   0x....'....        BL       ?Subroutine3
    691            SE_Response_t res = SE_readCommandResponse();
    692            return res;
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x30   0xB00B             ADD      SP,SP,#+44
   \       0x32   0xF400 0x2070      AND      R0,R0,#0xF0000
   \       0x36   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    693          }

   \                                 In section .rodata, align 4
   \                     ?_7:
   \        0x0   0xFE00'0000        DC32 4261412864, 0H, 0H, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  

   \                                 In section .rodata, align 4
   \                     ?_8:
   \        0x0   0x0000'0000        DC32 0H, 1H, 536870928
   \              0x0000'0001  
   \              0x2000'0010  
    694          
    695          /***************************************************************************//**
    696           * @brief
    697           *   Read pubkey or pubkey signature.
    698           *
    699           * @details
    700           *   Read out a public key stored in the SE, or its signature. The command can
    701           *   be used to read:
    702           *   * SE_KEY_TYPE_BOOT
    703           *   * SE_KEY_TYPE_AUTH
    704           *
    705           * @param[in] key_type
    706           *   ID of key type to read.
    707           *
    708           * @param[out] pubkey
    709           *   Pointer to a buffer to contain the returned public key.
    710           *   Must be word aligned and have a length of 64 bytes.
    711           *
    712           * @param[in] numBytes
    713           *   Length of pubkey buffer (64 bytes).
    714           *
    715           * @param[in] signature
    716           *   If true, read signature for the requested key type instead of the public
    717           *   key.
    718           *
    719           * @return
    720           *   One of the SE_RESPONSE return codes.
    721           * @retval SE_RESPONSE_OK when the command was executed successfully
    722           * @retval SE_RESPONSE_TEST_FAILED when the pubkey is not set
    723           * @retval SE_RESPONSE_INVALID_PARAMETER when an invalid type is passed
    724           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    725          SE_Response_t SE_readPubkey(uint32_t key_type, void *pubkey, uint32_t numBytes, bool signature)
    726          {
    727            EFM_ASSERT((key_type == SE_KEY_TYPE_BOOT)
    728                       || (key_type == SE_KEY_TYPE_AUTH));
    729          
    730            EFM_ASSERT(numBytes == 64);
    731            EFM_ASSERT(!((size_t)pubkey & 3U));
    732          
    733            // SE command structures
    734            uint32_t commandWord =
    735              (signature) ? SE_COMMAND_READ_PUBKEY_SIGNATURE : SE_COMMAND_READ_PUBKEY;
   \                     SE_readPubkey: (+1)
   \        0x0   0x2B00             CMP      R3,#+0
   \        0x2   0xE92D 0x4EF8      PUSH     {R3-R7,R9-R11,LR}
   \        0x6   0xB08B             SUB      SP,SP,#+44
   \        0x8   0x4607             MOV      R7,R0
   \        0xA   0xBF14             ITE      NE 
   \        0xC   0x....             LDRNE.N  R5,??DataTable14_8  ;; 0xff0a0001
   \        0xE   0x....             LDREQ.N  R5,??DataTable14_9  ;; 0xff080001
   \       0x10   0x460E             MOV      R6,R1
   \       0x12   0x4614             MOV      R4,R2
    736            SE_Command_t command = SE_COMMAND_DEFAULT(commandWord | key_type);
   \       0x14   0xA803             ADD      R0,SP,#+12
   \       0x16   0x2120             MOVS     R1,#+32
   \       0x18   0x....'....        BL       __aeabi_memclr4
    737          
    738            SE_DataTransfer_t pubkeyData = SE_DATATRANSFER_DEFAULT(pubkey, numBytes);
   \       0x1C   0x....             LDR.N    R0,??DataTable14_10
   \       0x1E   0x432F             ORRS     R7,R7,R5
   \       0x20   0xE890 0x0E00      LDM      R0,{R9-R11}
   \       0x24   0x9703             STR      R7,[SP, #+12]
   \       0x26   0x466F             MOV      R7,SP
   \       0x28   0xE887 0x0E00      STM      R7,{R9-R11}
   \       0x2C   0x9600             STR      R6,[SP, #+0]
   \       0x2E   0xF044 0x5400      ORR      R4,R4,#0x20000000
   \       0x32   0x9402             STR      R4,[SP, #+8]
    739            SE_addDataOutput(&command, &pubkeyData);
   \       0x34   0x4669             MOV      R1,SP
   \       0x36   0xA803             ADD      R0,SP,#+12
   \       0x38   0x....'....        BL       SE_addDataOutput
    740          
    741            SE_executeCommand(&command);
   \       0x3C                      REQUIRE ?Subroutine0
   \       0x3C                      ;; // Fall through to label ?Subroutine0
    742            SE_Response_t res = SE_readCommandResponse();
    743            return res;
    744          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0H, 0H, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  

   \                                 In section .rodata, align 4
   \                     ?_10:
   \        0x0   0x0000'0000        DC32 0H, 1H, 0
   \              0x0000'0001  
   \              0x0000'0000  
    745          
    746          /***************************************************************************//**
    747           * @brief
    748           *   Init pubkey or pubkey signature.
    749           *
    750           * @details
    751           *   Initialize public key stored in the SE, or its signature. The command can
    752           *   be used to write:
    753           *   * SE_KEY_TYPE_BOOT
    754           *   * SE_KEY_TYPE_AUTH
    755           *
    756           * @note
    757           *   These keys can not be overwritten, so this command can only be issued once
    758           *   per key per part.
    759           *
    760           * @param[in] key_type
    761           *   ID of key type to initialize.
    762           *
    763           * @param[in] pubkey
    764           *   Pointer to a buffer that contains the public key or signature.
    765           *   Must be word aligned and have a length of 64 bytes.
    766           *
    767           * @param[in] numBytes
    768           *   Length of pubkey buffer (64 bytes).
    769           *
    770           * @param[in] signature
    771           *   If true, initialize signature for the requested key type instead of the
    772           *   public key.
    773           *
    774           * @return
    775           *   One of the SE_RESPONSE return codes.
    776           * @retval SE_RESPONSE_OK when the command was executed successfully
    777           * @retval SE_RESPONSE_TEST_FAILED when the pubkey is not set
    778           * @retval SE_RESPONSE_INVALID_PARAMETER when an invalid type is passed
    779           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    780          SE_Response_t SE_initPubkey(uint32_t key_type, void *pubkey, uint32_t numBytes, bool signature)
    781          {
   \                     SE_initPubkey: (+1)
   \        0x0   0xE92D 0x47F8      PUSH     {R3-R10,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0xB08F             SUB      SP,SP,#+60
    782            EFM_ASSERT((key_type == SE_KEY_TYPE_BOOT)
    783                       || (key_type == SE_KEY_TYPE_AUTH));
    784          
    785            EFM_ASSERT(numBytes == 64);
    786            EFM_ASSERT(!((size_t)pubkey & 3U));
    787          
    788            // Find parity word
    789            volatile uint32_t parity = 0;
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x460D             MOV      R5,R1
   \        0xC   0x4616             MOV      R6,R2
   \        0xE   0x9000             STR      R0,[SP, #+0]
    790            for (size_t i = 0; i < numBytes / 4; i++) {
   \       0x10   0xE005             B.N      ??SE_initPubkey_0
    791              parity = parity ^ ((uint32_t *)pubkey)[i];
   \                     ??SE_initPubkey_1: (+1)
   \       0x12   0x9900             LDR      R1,[SP, #+0]
   \       0x14   0xF855 0x2020      LDR      R2,[R5, R0, LSL #+2]
    792            }
   \       0x18   0x1C40             ADDS     R0,R0,#+1
   \       0x1A   0x4051             EORS     R1,R2,R1
   \       0x1C   0x9100             STR      R1,[SP, #+0]
   \                     ??SE_initPubkey_0: (+1)
   \       0x1E   0xEBB0 0x0F96      CMP      R0,R6, LSR #+2
   \       0x22   0xD3F6             BCC.N    ??SE_initPubkey_1
    793          
    794            // SE command structures
    795            uint32_t commandWord =
    796              (signature) ? SE_COMMAND_INIT_PUBKEY_SIGNATURE : SE_COMMAND_INIT_PUBKEY;
   \       0x24   0x2B00             CMP      R3,#+0
    797            SE_Command_t command = SE_COMMAND_DEFAULT(commandWord | key_type);
   \       0x26   0xA807             ADD      R0,SP,#+28
    798          
    799            SE_DataTransfer_t parityData = SE_DATATRANSFER_DEFAULT(&parity, 4);
    800            SE_addDataInput(&command, &parityData);
   \       0x28   0xF046 0x5600      ORR      R6,R6,#0x20000000
   \       0x2C   0xBF14             ITE      NE 
   \       0x2E   0x....             LDRNE.N  R7,??DataTable14_11  ;; 0xff090001
   \       0x30   0x....             LDREQ.N  R7,??DataTable14_12  ;; 0xff070001
   \       0x32   0x2120             MOVS     R1,#+32
   \       0x34   0x....'....        BL       __aeabi_memclr4
   \       0x38   0x....             LDR.N    R0,??DataTable14_13
   \       0x3A   0x433C             ORRS     R4,R4,R7
   \       0x3C   0xE890 0x0700      LDM      R0,{R8-R10}
   \       0x40   0x9407             STR      R4,[SP, #+28]
   \       0x42   0xAC04             ADD      R4,SP,#+16
   \       0x44   0xE884 0x0700      STM      R4,{R8-R10}
   \       0x48   0xF8CD 0xD010      STR      SP,[SP, #+16]
   \       0x4C   0xA904             ADD      R1,SP,#+16
   \       0x4E   0xA807             ADD      R0,SP,#+28
   \       0x50   0x....'....        BL       SE_addDataInput
    801          
    802            SE_DataTransfer_t pubkeyData = SE_DATATRANSFER_DEFAULT(pubkey, numBytes);
   \       0x54   0x....             LDR.N    R1,??DataTable14_14
   \       0x56   0xE891 0x001C      LDM      R1,{R2-R4}
   \       0x5A   0xA801             ADD      R0,SP,#+4
    803            SE_addDataInput(&command, &pubkeyData);
   \       0x5C   0xA901             ADD      R1,SP,#+4
   \       0x5E   0xE880 0x001C      STM      R0,{R2-R4}
   \       0x62   0x9501             STR      R5,[SP, #+4]
   \       0x64   0x9603             STR      R6,[SP, #+12]
   \       0x66   0xA807             ADD      R0,SP,#+28
   \       0x68   0x....'....        BL       SE_addDataInput
    804          
    805            SE_executeCommand(&command);
   \       0x6C   0xA807             ADD      R0,SP,#+28
   \       0x6E   0x....'....        BL       SE_executeCommand
   \       0x72   0x....'....        BL       ?Subroutine3
    806            SE_Response_t res = SE_readCommandResponse();
    807            return res;
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x76   0xB010             ADD      SP,SP,#+64
   \       0x78   0xF400 0x2070      AND      R0,R0,#0xF0000
   \       0x7C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    808          }

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0H, 0H, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  

   \                                 In section .rodata, align 4
   \                     ?_12:
   \        0x0   0x0000'0000        DC32 0H, 1H, 536870916
   \              0x0000'0001  
   \              0x2000'0004  

   \                                 In section .rodata, align 4
   \                     ?_13:
   \        0x0   0x0000'0000        DC32 0H, 1H, 0
   \              0x0000'0001  
   \              0x0000'0000  
    809          
    810          /***************************************************************************//**
    811           * @brief
    812           *   Initialize SE OTP configuration.
    813           * @return
    814           *   One of the SE_RESPONSE return codes.
    815           * @retval SE_RESPONSE_OK when the command was executed successfully
    816           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    817          SE_Response_t SE_initOTP(SE_OTPInit_t *otp_init)
    818          {
   \                     SE_initOTP: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB099             SUB      SP,SP,#+100
    819            volatile uint32_t mcuSettingsFlags = 0;
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x9100             STR      R1,[SP, #+0]
    820          
    821            SE_Response_t res;
    822          
    823            if (otp_init->enableSecureBoot) {
   \        0xA   0x7820             LDRB     R0,[R4, #+0]
   \        0xC   0xB170             CBZ.N    R0,??SE_initOTP_0
    824              mcuSettingsFlags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ENABLE;
   \        0xE   0x9800             LDR      R0,[SP, #+0]
    825          
    826              uint8_t pubkey[64];
    827              res = SE_readPubkey(SE_KEY_TYPE_BOOT, &pubkey, 64, false);
    828              if (res != SE_RESPONSE_OK) {
   \       0x10   0x2300             MOVS     R3,#+0
   \       0x12   0x2240             MOVS     R2,#+64
   \       0x14   0xF440 0x3080      ORR      R0,R0,#0x10000
   \       0x18   0x9000             STR      R0,[SP, #+0]
   \       0x1A   0xA901             ADD      R1,SP,#+4
   \       0x1C   0xF44F 0x7080      MOV      R0,#+256
   \       0x20   0x....'....        BL       SE_readPubkey
   \       0x24   0xB110             CBZ.N    R0,??SE_initOTP_0
    829                return SE_RESPONSE_ABORT;
   \       0x26   0xF44F 0x2010      MOV      R0,#+589824
   \       0x2A   0xE04F             B.N      ??SE_initOTP_1
    830              }
    831            }
    832            if (otp_init->verifySecureBootCertificate) {
   \                     ??SE_initOTP_0: (+1)
   \       0x2C   0x7860             LDRB     R0,[R4, #+1]
   \       0x2E   0xB118             CBZ.N    R0,??SE_initOTP_2
    833              mcuSettingsFlags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_VERIFY_CERTIFICATE;
   \       0x30   0x9800             LDR      R0,[SP, #+0]
   \       0x32   0xF440 0x3000      ORR      R0,R0,#0x20000
   \       0x36   0x9000             STR      R0,[SP, #+0]
    834            }
    835            if (otp_init->enableAntiRollback) {
   \                     ??SE_initOTP_2: (+1)
   \       0x38   0x78A0             LDRB     R0,[R4, #+2]
   \       0x3A   0xB118             CBZ.N    R0,??SE_initOTP_3
    836              mcuSettingsFlags |= SE_OTP_MCU_SETTINGS_FLAG_SECURE_BOOT_ANTI_ROLLBACK;
   \       0x3C   0x9800             LDR      R0,[SP, #+0]
   \       0x3E   0xF440 0x2080      ORR      R0,R0,#0x40000
   \       0x42   0x9000             STR      R0,[SP, #+0]
    837            }
    838          
    839            volatile struct ReservedSettings {
    840              uint8_t reserved1[16];
    841              uint8_t reserved2[2];
    842              uint8_t reserved3[2];
    843            } reservedSettings = {
    844              { 0x00 },
    845              { 0xFF },
    846              { 0x00 }
    847            };
   \                     ??SE_initOTP_3: (+1)
   \       0x44   0xA80C             ADD      R0,SP,#+48
   \       0x46   0x....             LDR.N    R1,??DataTable14_16
   \       0x48   0x2214             MOVS     R2,#+20
   \       0x4A   0x....'....        BL       __aeabi_memcpy4
    848          
    849            // Find parity word
    850            uint32_t parity = 0;
    851            parity = parity ^ mcuSettingsFlags;
   \       0x4E   0x9C00             LDR      R4,[SP, #+0]
    852            for (size_t i = 0; i < 5; i++) {
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xA90C             ADD      R1,SP,#+48
    853              parity = parity ^ ((uint32_t*)(&reservedSettings))[i];
   \                     ??SE_initOTP_4: (+1)
   \       0x54   0xF851 0x2020      LDR      R2,[R1, R0, LSL #+2]
    854            }
   \       0x58   0x1C40             ADDS     R0,R0,#+1
   \       0x5A   0x4054             EORS     R4,R2,R4
   \       0x5C   0x2805             CMP      R0,#+5
   \       0x5E   0xD3F9             BCC.N    ??SE_initOTP_4
    855          
    856            // SE command structures
    857            SE_Command_t command = SE_COMMAND_DEFAULT(SE_COMMAND_INIT_OTP);
   \       0x60   0xA811             ADD      R0,SP,#+68
   \       0x62   0x....             LDR.N    R1,??DataTable14_17
   \       0x64   0x....'....        BL       ?Subroutine2
    858          
    859            volatile uint32_t parameters[2] = {
    860              parity,
    861              sizeof(mcuSettingsFlags)
    862              + sizeof(reservedSettings)
    863            };
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x68   0x....             LDR.N    R1,??DataTable14_18
   \       0x6A   0xE9D1 0x2300      LDRD     R2,R3,[R1, #+0]
   \       0x6E   0xA801             ADD      R0,SP,#+4
    864            SE_DataTransfer_t parametersData = SE_DATATRANSFER_DEFAULT(&parameters, 8);
   \       0x70   0xA901             ADD      R1,SP,#+4
   \       0x72   0xE9C0 0x2300      STRD     R2,R3,[R0, #+0]
   \       0x76   0x....             LDR.N    R0,??DataTable14_19
   \       0x78   0x9401             STR      R4,[SP, #+4]
   \       0x7A   0xE890 0x00E0      LDM      R0,{R5-R7}
   \       0x7E   0xAC09             ADD      R4,SP,#+36
    865            SE_addDataInput(&command, &parametersData);
   \       0x80   0xA811             ADD      R0,SP,#+68
   \       0x82   0xE884 0x00E0      STM      R4,{R5-R7}
   \       0x86   0x9109             STR      R1,[SP, #+36]
   \       0x88   0xA909             ADD      R1,SP,#+36
   \       0x8A   0x....'....        BL       SE_addDataInput
    866          
    867            SE_DataTransfer_t mcuSettingsFlagsData = SE_DATATRANSFER_DEFAULT(&mcuSettingsFlags, sizeof(mcuSettingsFlags));
   \       0x8E   0x....             LDR.N    R1,??DataTable14_20
   \       0x90   0xE891 0x001C      LDM      R1,{R2-R4}
   \       0x94   0xA806             ADD      R0,SP,#+24
    868            SE_addDataInput(&command, &mcuSettingsFlagsData);
   \       0x96   0xA906             ADD      R1,SP,#+24
   \       0x98   0xE880 0x001C      STM      R0,{R2-R4}
   \       0x9C   0xF8CD 0xD018      STR      SP,[SP, #+24]
   \       0xA0   0xA811             ADD      R0,SP,#+68
   \       0xA2   0x....'....        BL       SE_addDataInput
    869          
    870            SE_DataTransfer_t reservedSettingsData = SE_DATATRANSFER_DEFAULT(&reservedSettings, sizeof(reservedSettings));
   \       0xA6   0x....             LDR.N    R1,??DataTable14_21
   \       0xA8   0xE891 0x001C      LDM      R1,{R2-R4}
   \       0xAC   0xA803             ADD      R0,SP,#+12
   \       0xAE   0xAD0C             ADD      R5,SP,#+48
   \       0xB0   0xE880 0x001C      STM      R0,{R2-R4}
   \       0xB4   0x9503             STR      R5,[SP, #+12]
    871            SE_addDataInput(&command, &reservedSettingsData);
   \       0xB6   0xA903             ADD      R1,SP,#+12
   \       0xB8   0xA811             ADD      R0,SP,#+68
   \       0xBA   0x....'....        BL       SE_addDataInput
    872          
    873            SE_executeCommand(&command);
   \       0xBE   0xA811             ADD      R0,SP,#+68
   \       0xC0   0x....'....        BL       SE_executeCommand
   \       0xC4   0x....'....        BL       ?Subroutine3
    874            res = SE_readCommandResponse();
    875          
    876            return res;
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0xC8   0xF400 0x2070      AND      R0,R0,#0xF0000
   \                     ??SE_initOTP_1: (+1)
   \       0xCC   0xB019             ADD      SP,SP,#+100
   \       0xCE   0xBDF0             POP      {R4-R7,PC}       ;; return
    877          }

   \                                 In section .rodata, align 4
   \                     ?_14:
   \        0x0   0xFF00'0001        DC32 4278190081, 0H, 0H, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  

   \                                 In section .rodata, align 4
   \                     ?_15:
   \        0x0   0x0000'0000        DC32 0, 24
   \              0x0000'0018  

   \                                 In section .rodata, align 4
   \                     ?_16:
   \        0x0   0x0000'0000        DC32 0H, 1H, 536870920
   \              0x0000'0001  
   \              0x2000'0008  

   \                                 In section .rodata, align 4
   \                     ?_17:
   \        0x0   0x0000'0000        DC32 0H, 1H, 536870916
   \              0x0000'0001  
   \              0x2000'0004  

   \                                 In section .rodata, align 4
   \                     ?_18:
   \        0x0   0x0000'0000        DC32 0H, 1H, 536870932
   \              0x0000'0001  
   \              0x2000'0014  
    878          
    879          /***************************************************************************//**
    880           * @brief
    881           *   Returns the current debug lock configuration.
    882           * @param[out] status
    883           *   The command returns a DebugStatus_t with the current status of the
    884           *   debug configuration.
    885           * @return
    886           *   One of the SE_RESPONSE return codes.
    887           * @retval SE_RESPONSE_OK when the command was executed successfully.
    888           * @retval SE_RESPONSE_INTERNAL_ERROR if there are configuration errors.
    889           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    890          SE_Response_t SE_debugLockStatus(SE_DebugStatus_t *status)
    891          {
   \                     SE_debugLockStatus: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB08C             SUB      SP,SP,#+48
   \        0x4   0x4604             MOV      R4,R0
    892            SE_Response_t res;
    893          
    894            // SE command structures
    895            SE_Command_t command = SE_COMMAND_DEFAULT(SE_COMMAND_DBG_LOCK_STATUS);
   \        0x6   0xA804             ADD      R0,SP,#+16
   \        0x8   0x....             LDR.N    R1,??DataTable14_22
   \        0xA   0x....'....        BL       ?Subroutine2
    896          
    897            volatile uint32_t status_word = 0;
   \                     ??CrossCallReturnLabel_5: (+1)
   \        0xE   0x2500             MOVS     R5,#+0
   \       0x10   0x9500             STR      R5,[SP, #+0]
    898            SE_DataTransfer_t statusData = SE_DATATRANSFER_DEFAULT((void*)&status_word, 4);
   \       0x12   0x....             LDR.N    R1,??DataTable14_23
   \       0x14   0xE891 0x004C      LDM      R1,{R2,R3,R6}
   \       0x18   0xA801             ADD      R0,SP,#+4
    899            SE_addDataOutput(&command, &statusData);
   \       0x1A   0xA901             ADD      R1,SP,#+4
   \       0x1C   0xE880 0x004C      STM      R0,{R2,R3,R6}
   \       0x20   0xF8CD 0xD004      STR      SP,[SP, #+4]
   \       0x24   0xA804             ADD      R0,SP,#+16
   \       0x26   0x....'....        BL       SE_addDataOutput
    900          
    901            SE_executeCommand(&command);
   \       0x2A   0xA804             ADD      R0,SP,#+16
   \       0x2C   0x....'....        BL       SE_executeCommand
   \       0x30   0x....'....        BL       ?Subroutine3
    902            res = SE_readCommandResponse();
    903          
    904            status->debugLockEnabled = (status_word & (1 << 0));
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x34   0x9900             LDR      R1,[SP, #+0]
   \       0x36   0xF001 0x0101      AND      R1,R1,#0x1
   \       0x3A   0x7021             STRB     R1,[R4, #+0]
    905            status->deviceEraseEnabled = (status_word & (1 << 1));
   \       0x3C   0x9A00             LDR      R2,[SP, #+0]
    906            status->secureDebugEnabled = (status_word & (1 << 2));
    907          
    908            return res;
   \       0x3E   0xF400 0x2070      AND      R0,R0,#0xF0000
   \       0x42   0x0852             LSRS     R2,R2,#+1
   \       0x44   0xF002 0x0201      AND      R2,R2,#0x1
   \       0x48   0x7062             STRB     R2,[R4, #+1]
   \       0x4A   0x9900             LDR      R1,[SP, #+0]
   \       0x4C   0x0889             LSRS     R1,R1,#+2
   \       0x4E   0xF001 0x0101      AND      R1,R1,#0x1
   \       0x52   0x70A1             STRB     R1,[R4, #+2]
   \       0x54   0xB00C             ADD      SP,SP,#+48
   \       0x56   0xBD70             POP      {R4-R6,PC}       ;; return
    909          }

   \                                 In section .rodata, align 4
   \                     ?_19:
   \        0x0   0x4311'0000        DC32 1125187584, 0H, 0H, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  

   \                                 In section .rodata, align 4
   \                     ?_20:
   \        0x0   0x0000'0000        DC32 0H, 1H, 536870916
   \              0x0000'0001  
   \              0x2000'0004  
    910          
    911          /***************************************************************************//**
    912           * @brief
    913           *   Enables the debug lock for the part.
    914           * @details
    915           *   The debug port will be closed and the only way to open it is through
    916           *   device erase (if enabled) or through secure debug unlock (if enabled).
    917           * @return
    918           *   One of the SE_RESPONSE return codes.
    919           * @retval SE_RESPONSE_OK when the command was executed successfully.
    920           * @retval SE_RESPONSE_INTERNAL_ERROR there was a problem locking the debug port.
    921           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    922          SE_Response_t SE_debugLockApply(void)
    923          {
   \                     SE_debugLockApply: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
    924            SE_Command_t command = SE_COMMAND_DEFAULT(SE_COMMAND_DBG_LOCK_APPLY);
   \        0x4   0x4668             MOV      R0,SP
   \        0x6   0x....             LDR.N    R1,??DataTable14_24
   \        0x8   0x....             B.N      ?Subroutine1
    925            SE_executeCommand(&command);
    926          
    927            return SE_readCommandResponse();
    928          }

   \                                 In section .rodata, align 4
   \                     ?_21:
   \        0x0   0x430C'0000        DC32 1124859904, 0H, 0H, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
    929          
    930          /***************************************************************************//**
    931           * @brief
    932           *   Enables the secure debug functionality.
    933           * @details
    934           *   Enables the secure debug functionality that can be used to open a locked
    935           *   debug port through the Get challenge and Open debug commands. This command
    936           *   can only be executed before the debug port is locked, and after a secure
    937           *   debug public key has been installed in the SE.
    938           * @return
    939           *   One of the SE_RESPONSE return codes.
    940           * @retval SE_RESPONSE_OK when the command was executed successfully.
    941           * @retval SE_RESPONSE_INVALID_COMMAND if debug port is locked.
    942           * @retval SE_RESPONSE_INVALID_PARAMETER if secure debug certificates are
    943           *                                       missing.
    944           * @retval SE_RESPONSE_INTERNAL_ERROR if there was a problem during execution.
    945           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    946          SE_Response_t SE_debugSecureEnable(void)
    947          {
   \                     SE_debugSecureEnable: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
    948            SE_Command_t command = SE_COMMAND_DEFAULT(SE_COMMAND_DBG_LOCK_ENABLE_SECURE);
   \        0x4   0x4668             MOV      R0,SP
   \        0x6   0x....             LDR.N    R1,??DataTable14_25
   \        0x8                      REQUIRE ?Subroutine1
   \        0x8                      ;; // Fall through to label ?Subroutine1
    949            SE_executeCommand(&command);
    950          
    951            return SE_readCommandResponse();
    952          }

   \                                 In section .rodata, align 4
   \                     ?_22:
   \        0x0   0x430D'0000        DC32 1124925440, 0H, 0H, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
    953          
    954          /***************************************************************************//**
    955           * @brief
    956           *   Disables the secure debug functionality.
    957           * @details
    958           *   Disables the secure debug functionality that can be used to open a
    959           *   locked debug port.
    960           * @return
    961           *   One of the SE_RESPONSE return codes.
    962           * @retval SE_RESPONSE_OK when the command was executed successfully.
    963           * @retval SE_RESPONSE_INTERNAL_ERROR if there was a problem during execution.
    964           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    965          SE_Response_t SE_debugSecureDisable(void)
    966          {
   \                     SE_debugSecureDisable: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
    967            SE_Command_t command = SE_COMMAND_DEFAULT(SE_COMMAND_DBG_LOCK_DISABLE_SECURE);
   \        0x4   0x4668             MOV      R0,SP
   \        0x6   0x....             LDR.N    R1,??DataTable14_26
   \        0x8   0x....             B.N      ?Subroutine1
    968            SE_executeCommand(&command);
    969          
    970            return SE_readCommandResponse();
    971          }

   \                                 In section .rodata, align 4
   \                     ?_23:
   \        0x0   0x430E'0000        DC32 1124990976, 0H, 0H, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
    972          
    973          /***************************************************************************//**
    974           * @brief
    975           *   Performs a device mass erase and debug unlock.
    976           *
    977           * @details
    978           *   Performs a device mass erase and resets the debug configuration to its
    979           *   initial unlocked state. Only available before DEVICE_ERASE_DISABLE has
    980           *   been executed.
    981           *
    982           * @note
    983           *   This command clears and verifies the complete flash and ram of the
    984           *   system, excluding the user data pages and one-time programmable
    985           *   commissioning information in the secure element.
    986           *
    987           * @return
    988           *   One of the SE_RESPONSE return codes.
    989           * @retval SE_RESPONSE_OK when the command was executed successfully.
    990           * @retval SE_RESPONSE_INVALID_COMMAND if device erase is disabled.
    991           * @retval SE_RESPONSE_INTERNAL_ERROR if there was a problem during execution.
    992           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    993          SE_Response_t SE_deviceErase(void)
    994          {
   \                     SE_deviceErase: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
    995            SE_Command_t command = SE_COMMAND_DEFAULT(SE_COMMAND_DEVICE_ERASE);
   \        0x4   0x4668             MOV      R0,SP
   \        0x6   0x....             LDR.N    R1,??DataTable14_27
   \        0x8   0x....             B.N      ?Subroutine1
    996            SE_executeCommand(&command);
    997          
    998            return SE_readCommandResponse();
    999          }

   \                                 In section .rodata, align 4
   \                     ?_24:
   \        0x0   0x430F'0000        DC32 1125056512, 0H, 0H, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   1000          
   1001          /***************************************************************************//**
   1002           * @brief
   1003           *   Disabled device erase functionality.
   1004           *
   1005           * @details
   1006           *   This command disables the device erase command. It does not lock the
   1007           *   debug interface to the part, but it is a permanent action for the part.
   1008           *   If device erase is disabled and the device is debug locked, there is no
   1009           *   way to permanently unlock the part. If secure debug unlock is enabled,
   1010           *   secure debug unlock can still be used to temporarily open the debug port.
   1011           *
   1012           * @warning
   1013           *   This command permanently disables the device erase functionality!
   1014           *
   1015           * @return
   1016           *   One of the SE_RESPONSE return codes.
   1017           * @retval SE_RESPONSE_OK when the command was executed successfully.
   1018           * @retval SE_RESPONSE_INTERNAL_ERROR if there was a problem during execution.
   1019           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1020          SE_Response_t SE_deviceEraseDisable(void)
   1021          {
   \                     SE_deviceEraseDisable: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   1022            SE_Command_t command = SE_COMMAND_DEFAULT(SE_COMMAND_DEVICE_ERASE_DISABLE);
   \        0x4   0x4668             MOV      R0,SP
   \        0x6   0x....             LDR.N    R1,??DataTable14_28
   \        0x8   0x....             B.N      ?Subroutine1
   1023            SE_executeCommand(&command);
   1024          
   1025            return SE_readCommandResponse();
   1026          }

   \                                 In section .rodata, align 4
   \                     ?_25:
   \        0x0   0x4310'0000        DC32 1125122048, 0H, 0H, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x....'....        DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x....'....        DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x....'....        DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0xDE1E'7EAD        DC32     0xde1e7ead

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \        0x0   0x....'....        DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \        0x0   0x....'....        DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \        0x0   0x....'....        DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \        0x0   0x....'....        DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \        0x0   0xFF0A'0001        DC32     0xff0a0001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \        0x0   0xFF08'0001        DC32     0xff080001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \        0x0   0x....'....        DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \        0x0   0xFF09'0001        DC32     0xff090001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \        0x0   0xFF07'0001        DC32     0xff070001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_13:
   \        0x0   0x....'....        DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_14:
   \        0x0   0x....'....        DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_15:
   \        0x0   0x4C00'0044        DC32     0x4c000044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_16:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_17:
   \        0x0   0x....'....        DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_18:
   \        0x0   0x....'....        DC32     ?_15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_19:
   \        0x0   0x....'....        DC32     ?_16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_20:
   \        0x0   0x....'....        DC32     ?_17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_21:
   \        0x0   0x....'....        DC32     ?_18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_22:
   \        0x0   0x....'....        DC32     ?_19

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_23:
   \        0x0   0x....'....        DC32     ?_20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_24:
   \        0x0   0x....'....        DC32     ?_21

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_25:
   \        0x0   0x....'....        DC32     ?_22

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_26:
   \        0x0   0x....'....        DC32     ?_23

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_27:
   \        0x0   0x....'....        DC32     ?_24

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_28:
   \        0x0   0x....'....        DC32     ?_25

   \                                 In section .rodata, align 4
   \        0x0   0x0000'0000        DC32 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  
   \              0x0000'0000  

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0xFF 0x00    
   \              0x00 0x00    
   1027          
   1028          #endif // #if defined(SEMAILBOX_PRESENT)
   1029          
   1030          /** @} (end addtogroup SE) */
   1031          /** @} (end addtogroup emlib) */
   1032          
   1033          #endif /* defined(SEMAILBOX_PRESENT) || defined(CRYPTOACC_PRESENT) */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   SE_addDataInput
       0   SE_addDataOutput
       0   SE_addParameter
      40   SE_debugLockApply
        40   -> SE_executeCommand
        40   -> __aeabi_memcpy4
      64   SE_debugLockStatus
        64   -> SE_addDataOutput
        64   -> SE_executeCommand
        64   -> __aeabi_memcpy4
      40   SE_debugSecureDisable
        40   -> SE_executeCommand
        40   -> __aeabi_memcpy4
      40   SE_debugSecureEnable
        40   -> SE_executeCommand
        40   -> __aeabi_memcpy4
      40   SE_deviceErase
        40   -> SE_executeCommand
        40   -> __aeabi_memcpy4
      40   SE_deviceEraseDisable
        40   -> SE_executeCommand
        40   -> __aeabi_memcpy4
      40   SE_eraseUserData
        40   -> SE_addParameter
        40   -> SE_executeCommand
        40   -> __aeabi_memcpy4
       8   SE_executeCommand
     104   SE_getStatus
       104   -> SE_addDataOutput
       104   -> SE_executeCommand
       104   -> __aeabi_memclr4
       104   -> __aeabi_memcpy4
     120   SE_initOTP
       120   -> SE_addDataInput
       120   -> SE_executeCommand
       120   -> SE_readPubkey
       120   -> __aeabi_memcpy4
      96   SE_initPubkey
        96   -> SE_addDataInput
        96   -> SE_executeCommand
        96   -> __aeabi_memclr4
      80   SE_readPubkey
        80   -> SE_addDataOutput
        80   -> SE_executeCommand
        80   -> __aeabi_memclr4
      72   SE_serialNumber
        72   -> SE_addDataOutput
        72   -> SE_executeCommand
        72   -> __aeabi_memcpy4
      80   SE_writeUserData
        80   -> SE_addDataInput
        80   -> SE_addParameter
        80   -> SE_executeCommand
        80   -> __aeabi_memcpy4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_15
       4  ??DataTable14_16
       4  ??DataTable14_17
       4  ??DataTable14_18
       4  ??DataTable14_19
       4  ??DataTable14_2
       4  ??DataTable14_20
       4  ??DataTable14_21
       4  ??DataTable14_22
       4  ??DataTable14_23
       4  ??DataTable14_24
       4  ??DataTable14_25
       4  ??DataTable14_26
       4  ??DataTable14_27
       4  ??DataTable14_28
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      20  ?Subroutine0
      30  ?Subroutine1
       6  ?Subroutine2
      12  ?Subroutine3
      36  ?_0
      20  ?_1
      12  ?_10
      32  ?_11
      12  ?_12
      12  ?_13
      32  ?_14
       8  ?_15
      12  ?_16
      12  ?_17
      12  ?_18
      32  ?_19
      32  ?_2
      12  ?_20
      32  ?_21
      32  ?_22
      32  ?_23
      32  ?_24
      32  ?_25
      12  ?_3
      32  ?_4
      32  ?_5
      12  ?_6
      32  ?_7
      12  ?_8
      32  ?_9
      20  SE_addDataInput
      20  SE_addDataOutput
      20  SE_addParameter
      10  SE_debugLockApply
      88  SE_debugLockStatus
      10  SE_debugSecureDisable
       8  SE_debugSecureEnable
      10  SE_deviceErase
      10  SE_deviceEraseDisable
      22  SE_eraseUserData
      62  SE_executeCommand
     130  SE_getStatus
     208  SE_initOTP
     128  SE_initPubkey
      60  SE_readPubkey
      58  SE_serialNumber
      68  SE_writeUserData

 
   600 bytes in section .rodata
 1 116 bytes in section .text
 
 1 116 bytes of CODE  memory
   600 bytes of CONST memory

Errors: none
Warnings: none
