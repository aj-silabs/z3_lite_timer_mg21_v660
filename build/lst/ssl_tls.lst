###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:19:55
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\ssl_tls.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW4C42.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\ssl_tls.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"ssl_tls.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0
#        -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\ssl_tls.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\ssl_tls.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\ssl_tls.c
      1          /***************************************************************************//**
      2           * # License
      3           *
      4           * The licensor of this software is Silicon Laboratories Inc. Your use of this
      5           * software is governed by the terms of Silicon Labs Master Software License
      6           * Agreement (MSLA) available at
      7           * www.silabs.com/about-us/legal/master-software-license-agreement. This
      8           * software is Third Party Software licensed by Silicon Labs from a third party
      9           * and is governed by the sections of the MSLA applicable to Third Party
     10           * Software and the additional terms set forth below.
     11           *
     12           ******************************************************************************/
     13          /*
     14           *  SSLv3/TLSv1 shared functions
     15           *
     16           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
     17           *  SPDX-License-Identifier: Apache-2.0
     18           *
     19           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
     20           *  not use this file except in compliance with the License.
     21           *  You may obtain a copy of the License at
     22           *
     23           *  http://www.apache.org/licenses/LICENSE-2.0
     24           *
     25           *  Unless required by applicable law or agreed to in writing, software
     26           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     27           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     28           *  See the License for the specific language governing permissions and
     29           *  limitations under the License.
     30           *
     31           *  This file is part of mbed TLS (https://tls.mbed.org)
     32           */
     33          /*
     34           *  The SSL 3.0 specification was drafted by Netscape in 1996,
     35           *  and became an IETF standard in 1999.
     36           *
     37           *  http://wp.netscape.com/eng/ssl3/
     38           *  http://www.ietf.org/rfc/rfc2246.txt
     39           *  http://www.ietf.org/rfc/rfc4346.txt
     40           */
     41          
     42          #if !defined(MBEDTLS_CONFIG_FILE)
     43          #include "mbedtls/config.h"
     44          #else
     45          #include MBEDTLS_CONFIG_FILE
     46          #endif
     47          
     48          #if defined(MBEDTLS_SSL_TLS_C)
     49          
     50          #if defined(MBEDTLS_PLATFORM_C)
     51          #include "mbedtls/platform.h"
     52          #else
     53          #include <stdlib.h>
     54          #define mbedtls_calloc    calloc
     55          #define mbedtls_free      free
     56          #endif
     57          
     58          #include "mbedtls/debug.h"
     59          #include "mbedtls/ssl.h"
     60          #include "mbedtls/ssl_internal.h"
     61          
     62          #include <string.h>
     63          
     64          #if defined(MBEDTLS_X509_CRT_PARSE_C)
     65          #include "mbedtls/oid.h"
     66          #endif
     67          
     68          /* Implementation that should never be optimized out by the compiler */
     69          static void mbedtls_zeroize( void *v, size_t n ) {
     70              volatile unsigned char *p = v; while( n-- ) *p++ = 0;
     71          }
     72          
     73          /* Length of the "epoch" field in the record header */
     74          static inline size_t ssl_ep_len( const mbedtls_ssl_context *ssl )
     75          {
     76          #if defined(MBEDTLS_SSL_PROTO_DTLS)
     77              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
     78                  return( 2 );
     79          #else
     80              ((void) ssl);
     81          #endif
     82              return( 0 );
     83          }
     84          
     85          /*
     86           * Start a timer.
     87           * Passing millisecs = 0 cancels a running timer.
     88           */
     89          static void ssl_set_timer( mbedtls_ssl_context *ssl, uint32_t millisecs )
     90          {
     91              if( ssl->f_set_timer == NULL )
     92                  return;
     93          
     94              MBEDTLS_SSL_DEBUG_MSG( 3, ( "set_timer to %d ms", (int) millisecs ) );
     95              ssl->f_set_timer( ssl->p_timer, millisecs / 4, millisecs );
     96          }
     97          
     98          /*
     99           * Return -1 is timer is expired, 0 if it isn't.
    100           */
    101          static int ssl_check_timer( mbedtls_ssl_context *ssl )
    102          {
    103              if( ssl->f_get_timer == NULL )
    104                  return( 0 );
    105          
    106              if( ssl->f_get_timer( ssl->p_timer ) == 2 )
    107              {
    108                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "timer expired" ) );
    109                  return( -1 );
    110              }
    111          
    112              return( 0 );
    113          }
    114          
    115          #if defined(MBEDTLS_SSL_PROTO_DTLS)
    116          /*
    117           * Double the retransmit timeout value, within the allowed range,
    118           * returning -1 if the maximum value has already been reached.
    119           */
    120          static int ssl_double_retransmit_timeout( mbedtls_ssl_context *ssl )
    121          {
    122              uint32_t new_timeout;
    123          
    124              if( ssl->handshake->retransmit_timeout >= ssl->conf->hs_timeout_max )
    125                  return( -1 );
    126          
    127              new_timeout = 2 * ssl->handshake->retransmit_timeout;
    128          
    129              /* Avoid arithmetic overflow and range overflow */
    130              if( new_timeout < ssl->handshake->retransmit_timeout ||
    131                  new_timeout > ssl->conf->hs_timeout_max )
    132              {
    133                  new_timeout = ssl->conf->hs_timeout_max;
    134              }
    135          
    136              ssl->handshake->retransmit_timeout = new_timeout;
    137              MBEDTLS_SSL_DEBUG_MSG( 3, ( "update timeout value to %d millisecs",
    138                                  ssl->handshake->retransmit_timeout ) );
    139          
    140              return( 0 );
    141          }
    142          
    143          static void ssl_reset_retransmit_timeout( mbedtls_ssl_context *ssl )
    144          {
    145              ssl->handshake->retransmit_timeout = ssl->conf->hs_timeout_min;
    146              MBEDTLS_SSL_DEBUG_MSG( 3, ( "update timeout value to %d millisecs",
    147                                  ssl->handshake->retransmit_timeout ) );
    148          }
    149          #endif /* MBEDTLS_SSL_PROTO_DTLS */
    150          
    151          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
    152          /*
    153           * Convert max_fragment_length codes to length.
    154           * RFC 6066 says:
    155           *    enum{
    156           *        2^9(1), 2^10(2), 2^11(3), 2^12(4), (255)
    157           *    } MaxFragmentLength;
    158           * and we add 0 -> extension unused
    159           */
    160          static unsigned int mfl_code_to_length[MBEDTLS_SSL_MAX_FRAG_LEN_INVALID] =
    161          {
    162              MBEDTLS_SSL_MAX_CONTENT_LEN,    /* MBEDTLS_SSL_MAX_FRAG_LEN_NONE */
    163              512,                    /* MBEDTLS_SSL_MAX_FRAG_LEN_512  */
    164              1024,                   /* MBEDTLS_SSL_MAX_FRAG_LEN_1024 */
    165              2048,                   /* MBEDTLS_SSL_MAX_FRAG_LEN_2048 */
    166              4096,                   /* MBEDTLS_SSL_MAX_FRAG_LEN_4096 */
    167          };
    168          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
    169          
    170          #if defined(MBEDTLS_SSL_CLI_C)
    171          static int ssl_session_copy( mbedtls_ssl_session *dst, const mbedtls_ssl_session *src )
    172          {
    173              mbedtls_ssl_session_free( dst );
    174              memcpy( dst, src, sizeof( mbedtls_ssl_session ) );
    175          
    176          #if defined(MBEDTLS_X509_CRT_PARSE_C)
    177              if( src->peer_cert != NULL )
    178              {
    179                  int ret;
    180          
    181                  dst->peer_cert = mbedtls_calloc( 1, sizeof(mbedtls_x509_crt) );
    182                  if( dst->peer_cert == NULL )
    183                      return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
    184          
    185                  mbedtls_x509_crt_init( dst->peer_cert );
    186          
    187                  if( ( ret = mbedtls_x509_crt_parse_der( dst->peer_cert, src->peer_cert->raw.p,
    188                                                  src->peer_cert->raw.len ) ) != 0 )
    189                  {
    190                      mbedtls_free( dst->peer_cert );
    191                      dst->peer_cert = NULL;
    192                      return( ret );
    193                  }
    194              }
    195          #endif /* MBEDTLS_X509_CRT_PARSE_C */
    196          
    197          #if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_CLI_C)
    198              if( src->ticket != NULL )
    199              {
    200                  dst->ticket = mbedtls_calloc( 1, src->ticket_len );
    201                  if( dst->ticket == NULL )
    202                      return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
    203          
    204                  memcpy( dst->ticket, src->ticket, src->ticket_len );
    205              }
    206          #endif /* MBEDTLS_SSL_SESSION_TICKETS && MBEDTLS_SSL_CLI_C */
    207          
    208              return( 0 );
    209          }
    210          #endif /* MBEDTLS_SSL_CLI_C */
    211          
    212          #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
    213          int (*mbedtls_ssl_hw_record_init)( mbedtls_ssl_context *ssl,
    214                               const unsigned char *key_enc, const unsigned char *key_dec,
    215                               size_t keylen,
    216                               const unsigned char *iv_enc,  const unsigned char *iv_dec,
    217                               size_t ivlen,
    218                               const unsigned char *mac_enc, const unsigned char *mac_dec,
    219                               size_t maclen ) = NULL;
    220          int (*mbedtls_ssl_hw_record_activate)( mbedtls_ssl_context *ssl, int direction) = NULL;
    221          int (*mbedtls_ssl_hw_record_reset)( mbedtls_ssl_context *ssl ) = NULL;
    222          int (*mbedtls_ssl_hw_record_write)( mbedtls_ssl_context *ssl ) = NULL;
    223          int (*mbedtls_ssl_hw_record_read)( mbedtls_ssl_context *ssl ) = NULL;
    224          int (*mbedtls_ssl_hw_record_finish)( mbedtls_ssl_context *ssl ) = NULL;
    225          #endif /* MBEDTLS_SSL_HW_RECORD_ACCEL */
    226          
    227          /*
    228           * Key material generation
    229           */
    230          #if defined(MBEDTLS_SSL_PROTO_SSL3)
    231          static int ssl3_prf( const unsigned char *secret, size_t slen,
    232                               const char *label,
    233                               const unsigned char *random, size_t rlen,
    234                               unsigned char *dstbuf, size_t dlen )
    235          {
    236              int ret = 0;
    237              size_t i;
    238              mbedtls_md5_context md5;
    239              mbedtls_sha1_context sha1;
    240              unsigned char padding[16];
    241              unsigned char sha1sum[20];
    242              ((void)label);
    243          
    244              mbedtls_md5_init(  &md5  );
    245              mbedtls_sha1_init( &sha1 );
    246          
    247              /*
    248               *  SSLv3:
    249               *    block =
    250               *      MD5( secret + SHA1( 'A'    + secret + random ) ) +
    251               *      MD5( secret + SHA1( 'BB'   + secret + random ) ) +
    252               *      MD5( secret + SHA1( 'CCC'  + secret + random ) ) +
    253               *      ...
    254               */
    255              for( i = 0; i < dlen / 16; i++ )
    256              {
    257                  memset( padding, (unsigned char) ('A' + i), 1 + i );
    258          
    259                  if( ( ret = mbedtls_sha1_starts_ret( &sha1 ) ) != 0 )
    260                      goto exit;
    261                  if( ( ret = mbedtls_sha1_update_ret( &sha1, padding, 1 + i ) ) != 0 )
    262                      goto exit;
    263                  if( ( ret = mbedtls_sha1_update_ret( &sha1, secret, slen ) ) != 0 )
    264                      goto exit;
    265                  if( ( ret = mbedtls_sha1_update_ret( &sha1, random, rlen ) ) != 0 )
    266                      goto exit;
    267                  if( ( ret = mbedtls_sha1_finish_ret( &sha1, sha1sum ) ) != 0 )
    268                      goto exit;
    269          
    270                  if( ( ret = mbedtls_md5_starts_ret( &md5 ) ) != 0 )
    271                      goto exit;
    272                  if( ( ret = mbedtls_md5_update_ret( &md5, secret, slen ) ) != 0 )
    273                      goto exit;
    274                  if( ( ret = mbedtls_md5_update_ret( &md5, sha1sum, 20 ) ) != 0 )
    275                      goto exit;
    276                  if( ( ret = mbedtls_md5_finish_ret( &md5, dstbuf + i * 16 ) ) != 0 )
    277                      goto exit;
    278              }
    279          
    280          exit:
    281              mbedtls_md5_free(  &md5  );
    282              mbedtls_sha1_free( &sha1 );
    283          
    284              mbedtls_zeroize( padding, sizeof( padding ) );
    285              mbedtls_zeroize( sha1sum, sizeof( sha1sum ) );
    286          
    287              return( ret );
    288          }
    289          #endif /* MBEDTLS_SSL_PROTO_SSL3 */
    290          
    291          #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1)
    292          static int tls1_prf( const unsigned char *secret, size_t slen,
    293                               const char *label,
    294                               const unsigned char *random, size_t rlen,
    295                               unsigned char *dstbuf, size_t dlen )
    296          {
    297              size_t nb, hs;
    298              size_t i, j, k;
    299              const unsigned char *S1, *S2;
    300              unsigned char tmp[128];
    301              unsigned char h_i[20];
    302              const mbedtls_md_info_t *md_info;
    303              mbedtls_md_context_t md_ctx;
    304              int ret;
    305          
    306              mbedtls_md_init( &md_ctx );
    307          
    308              if( sizeof( tmp ) < 20 + strlen( label ) + rlen )
    309                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
    310          
    311              hs = ( slen + 1 ) / 2;
    312              S1 = secret;
    313              S2 = secret + slen - hs;
    314          
    315              nb = strlen( label );
    316              memcpy( tmp + 20, label, nb );
    317              memcpy( tmp + 20 + nb, random, rlen );
    318              nb += rlen;
    319          
    320              /*
    321               * First compute P_md5(secret,label+random)[0..dlen]
    322               */
    323              if( ( md_info = mbedtls_md_info_from_type( MBEDTLS_MD_MD5 ) ) == NULL )
    324                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
    325          
    326              if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 1 ) ) != 0 )
    327                  return( ret );
    328          
    329              mbedtls_md_hmac_starts( &md_ctx, S1, hs );
    330              mbedtls_md_hmac_update( &md_ctx, tmp + 20, nb );
    331              mbedtls_md_hmac_finish( &md_ctx, 4 + tmp );
    332          
    333              for( i = 0; i < dlen; i += 16 )
    334              {
    335                  mbedtls_md_hmac_reset ( &md_ctx );
    336                  mbedtls_md_hmac_update( &md_ctx, 4 + tmp, 16 + nb );
    337                  mbedtls_md_hmac_finish( &md_ctx, h_i );
    338          
    339                  mbedtls_md_hmac_reset ( &md_ctx );
    340                  mbedtls_md_hmac_update( &md_ctx, 4 + tmp, 16 );
    341                  mbedtls_md_hmac_finish( &md_ctx, 4 + tmp );
    342          
    343                  k = ( i + 16 > dlen ) ? dlen % 16 : 16;
    344          
    345                  for( j = 0; j < k; j++ )
    346                      dstbuf[i + j]  = h_i[j];
    347              }
    348          
    349              mbedtls_md_free( &md_ctx );
    350          
    351              /*
    352               * XOR out with P_sha1(secret,label+random)[0..dlen]
    353               */
    354              if( ( md_info = mbedtls_md_info_from_type( MBEDTLS_MD_SHA1 ) ) == NULL )
    355                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
    356          
    357              if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 1 ) ) != 0 )
    358                  return( ret );
    359          
    360              mbedtls_md_hmac_starts( &md_ctx, S2, hs );
    361              mbedtls_md_hmac_update( &md_ctx, tmp + 20, nb );
    362              mbedtls_md_hmac_finish( &md_ctx, tmp );
    363          
    364              for( i = 0; i < dlen; i += 20 )
    365              {
    366                  mbedtls_md_hmac_reset ( &md_ctx );
    367                  mbedtls_md_hmac_update( &md_ctx, tmp, 20 + nb );
    368                  mbedtls_md_hmac_finish( &md_ctx, h_i );
    369          
    370                  mbedtls_md_hmac_reset ( &md_ctx );
    371                  mbedtls_md_hmac_update( &md_ctx, tmp, 20 );
    372                  mbedtls_md_hmac_finish( &md_ctx, tmp );
    373          
    374                  k = ( i + 20 > dlen ) ? dlen % 20 : 20;
    375          
    376                  for( j = 0; j < k; j++ )
    377                      dstbuf[i + j] = (unsigned char)( dstbuf[i + j] ^ h_i[j] );
    378              }
    379          
    380              mbedtls_md_free( &md_ctx );
    381          
    382              mbedtls_zeroize( tmp, sizeof( tmp ) );
    383              mbedtls_zeroize( h_i, sizeof( h_i ) );
    384          
    385              return( 0 );
    386          }
    387          #endif /* MBEDTLS_SSL_PROTO_TLS1) || MBEDTLS_SSL_PROTO_TLS1_1 */
    388          
    389          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
    390          static int tls_prf_generic( mbedtls_md_type_t md_type,
    391                                      const unsigned char *secret, size_t slen,
    392                                      const char *label,
    393                                      const unsigned char *random, size_t rlen,
    394                                      unsigned char *dstbuf, size_t dlen )
    395          {
    396              size_t nb;
    397              size_t i, j, k, md_len;
    398              unsigned char tmp[128];
    399              unsigned char h_i[MBEDTLS_MD_MAX_SIZE];
    400              const mbedtls_md_info_t *md_info;
    401              mbedtls_md_context_t md_ctx;
    402              int ret;
    403          
    404              mbedtls_md_init( &md_ctx );
    405          
    406              if( ( md_info = mbedtls_md_info_from_type( md_type ) ) == NULL )
    407                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
    408          
    409              md_len = mbedtls_md_get_size( md_info );
    410          
    411              if( sizeof( tmp ) < md_len + strlen( label ) + rlen )
    412                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
    413          
    414              nb = strlen( label );
    415              memcpy( tmp + md_len, label, nb );
    416              memcpy( tmp + md_len + nb, random, rlen );
    417              nb += rlen;
    418          
    419              /*
    420               * Compute P_<hash>(secret, label + random)[0..dlen]
    421               */
    422              if ( ( ret = mbedtls_md_setup( &md_ctx, md_info, 1 ) ) != 0 )
    423                  return( ret );
    424          
    425              mbedtls_md_hmac_starts( &md_ctx, secret, slen );
    426              mbedtls_md_hmac_update( &md_ctx, tmp + md_len, nb );
    427              mbedtls_md_hmac_finish( &md_ctx, tmp );
    428          
    429              for( i = 0; i < dlen; i += md_len )
    430              {
    431                  mbedtls_md_hmac_reset ( &md_ctx );
    432                  mbedtls_md_hmac_update( &md_ctx, tmp, md_len + nb );
    433                  mbedtls_md_hmac_finish( &md_ctx, h_i );
    434          
    435                  mbedtls_md_hmac_reset ( &md_ctx );
    436                  mbedtls_md_hmac_update( &md_ctx, tmp, md_len );
    437                  mbedtls_md_hmac_finish( &md_ctx, tmp );
    438          
    439                  k = ( i + md_len > dlen ) ? dlen % md_len : md_len;
    440          
    441                  for( j = 0; j < k; j++ )
    442                      dstbuf[i + j]  = h_i[j];
    443              }
    444          
    445              mbedtls_md_free( &md_ctx );
    446          
    447              mbedtls_zeroize( tmp, sizeof( tmp ) );
    448              mbedtls_zeroize( h_i, sizeof( h_i ) );
    449          
    450              return( 0 );
    451          }
    452          
    453          #if defined(MBEDTLS_SHA256_C)
    454          static int tls_prf_sha256( const unsigned char *secret, size_t slen,
    455                                     const char *label,
    456                                     const unsigned char *random, size_t rlen,
    457                                     unsigned char *dstbuf, size_t dlen )
    458          {
    459              return( tls_prf_generic( MBEDTLS_MD_SHA256, secret, slen,
    460                                       label, random, rlen, dstbuf, dlen ) );
    461          }
    462          #endif /* MBEDTLS_SHA256_C */
    463          
    464          #if defined(MBEDTLS_SHA512_C)
    465          static int tls_prf_sha384( const unsigned char *secret, size_t slen,
    466                                     const char *label,
    467                                     const unsigned char *random, size_t rlen,
    468                                     unsigned char *dstbuf, size_t dlen )
    469          {
    470              return( tls_prf_generic( MBEDTLS_MD_SHA384, secret, slen,
    471                                       label, random, rlen, dstbuf, dlen ) );
    472          }
    473          #endif /* MBEDTLS_SHA512_C */
    474          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
    475          
    476          static void ssl_update_checksum_start( mbedtls_ssl_context *, const unsigned char *, size_t );
    477          
    478          #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
    479              defined(MBEDTLS_SSL_PROTO_TLS1_1)
    480          static void ssl_update_checksum_md5sha1( mbedtls_ssl_context *, const unsigned char *, size_t );
    481          #endif
    482          
    483          #if defined(MBEDTLS_SSL_PROTO_SSL3)
    484          static void ssl_calc_verify_ssl( mbedtls_ssl_context *, unsigned char * );
    485          static void ssl_calc_finished_ssl( mbedtls_ssl_context *, unsigned char *, int );
    486          #endif
    487          
    488          #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1)
    489          static void ssl_calc_verify_tls( mbedtls_ssl_context *, unsigned char * );
    490          static void ssl_calc_finished_tls( mbedtls_ssl_context *, unsigned char *, int );
    491          #endif
    492          
    493          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
    494          #if defined(MBEDTLS_SHA256_C)
    495          static void ssl_update_checksum_sha256( mbedtls_ssl_context *, const unsigned char *, size_t );
    496          static void ssl_calc_verify_tls_sha256( mbedtls_ssl_context *,unsigned char * );
    497          static void ssl_calc_finished_tls_sha256( mbedtls_ssl_context *,unsigned char *, int );
    498          #endif
    499          
    500          #if defined(MBEDTLS_SHA512_C)
    501          static void ssl_update_checksum_sha384( mbedtls_ssl_context *, const unsigned char *, size_t );
    502          static void ssl_calc_verify_tls_sha384( mbedtls_ssl_context *, unsigned char * );
    503          static void ssl_calc_finished_tls_sha384( mbedtls_ssl_context *, unsigned char *, int );
    504          #endif
    505          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
    506          
    507          int mbedtls_ssl_derive_keys( mbedtls_ssl_context *ssl )
    508          {
    509              int ret = 0;
    510              unsigned char tmp[64];
    511              unsigned char keyblk[256];
    512              unsigned char *key1;
    513              unsigned char *key2;
    514              unsigned char *mac_enc;
    515              unsigned char *mac_dec;
    516              size_t mac_key_len;
    517              size_t iv_copy_len;
    518              const mbedtls_cipher_info_t *cipher_info;
    519              const mbedtls_md_info_t *md_info;
    520          
    521              mbedtls_ssl_session *session = ssl->session_negotiate;
    522              mbedtls_ssl_transform *transform = ssl->transform_negotiate;
    523              mbedtls_ssl_handshake_params *handshake = ssl->handshake;
    524          
    525              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> derive keys" ) );
    526          
    527              cipher_info = mbedtls_cipher_info_from_type( transform->ciphersuite_info->cipher );
    528              if( cipher_info == NULL )
    529              {
    530                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "cipher info for %d not found",
    531                                      transform->ciphersuite_info->cipher ) );
    532                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
    533              }
    534          
    535              md_info = mbedtls_md_info_from_type( transform->ciphersuite_info->mac );
    536              if( md_info == NULL )
    537              {
    538                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "mbedtls_md info for %d not found",
    539                                      transform->ciphersuite_info->mac ) );
    540                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
    541              }
    542          
    543              /*
    544               * Set appropriate PRF function and other SSL / TLS / TLS1.2 functions
    545               */
    546          #if defined(MBEDTLS_SSL_PROTO_SSL3)
    547              if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    548              {
    549                  handshake->tls_prf = ssl3_prf;
    550                  handshake->calc_verify = ssl_calc_verify_ssl;
    551                  handshake->calc_finished = ssl_calc_finished_ssl;
    552              }
    553              else
    554          #endif
    555          #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1)
    556              if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 )
    557              {
    558                  handshake->tls_prf = tls1_prf;
    559                  handshake->calc_verify = ssl_calc_verify_tls;
    560                  handshake->calc_finished = ssl_calc_finished_tls;
    561              }
    562              else
    563          #endif
    564          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
    565          #if defined(MBEDTLS_SHA512_C)
    566              if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 &&
    567                  transform->ciphersuite_info->mac == MBEDTLS_MD_SHA384 )
    568              {
    569                  handshake->tls_prf = tls_prf_sha384;
    570                  handshake->calc_verify = ssl_calc_verify_tls_sha384;
    571                  handshake->calc_finished = ssl_calc_finished_tls_sha384;
    572              }
    573              else
    574          #endif
    575          #if defined(MBEDTLS_SHA256_C)
    576              if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
    577              {
    578                  handshake->tls_prf = tls_prf_sha256;
    579                  handshake->calc_verify = ssl_calc_verify_tls_sha256;
    580                  handshake->calc_finished = ssl_calc_finished_tls_sha256;
    581              }
    582              else
    583          #endif
    584          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
    585              {
    586                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
    587                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
    588              }
    589          
    590              /*
    591               * SSLv3:
    592               *   master =
    593               *     MD5( premaster + SHA1( 'A'   + premaster + randbytes ) ) +
    594               *     MD5( premaster + SHA1( 'BB'  + premaster + randbytes ) ) +
    595               *     MD5( premaster + SHA1( 'CCC' + premaster + randbytes ) )
    596               *
    597               * TLSv1+:
    598               *   master = PRF( premaster, "master secret", randbytes )[0..47]
    599               */
    600              if( handshake->resume == 0 )
    601              {
    602                  MBEDTLS_SSL_DEBUG_BUF( 3, "premaster secret", handshake->premaster,
    603                                 handshake->pmslen );
    604          
    605          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
    606                  if( ssl->handshake->extended_ms == MBEDTLS_SSL_EXTENDED_MS_ENABLED )
    607                  {
    608                      unsigned char session_hash[48];
    609                      size_t hash_len;
    610          
    611                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "using extended master secret" ) );
    612          
    613                      ssl->handshake->calc_verify( ssl, session_hash );
    614          
    615          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
    616                      if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
    617                      {
    618          #if defined(MBEDTLS_SHA512_C)
    619                          if( ssl->transform_negotiate->ciphersuite_info->mac ==
    620                              MBEDTLS_MD_SHA384 )
    621                          {
    622                              hash_len = 48;
    623                          }
    624                          else
    625          #endif
    626                              hash_len = 32;
    627                      }
    628                      else
    629          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
    630                          hash_len = 36;
    631          
    632                      MBEDTLS_SSL_DEBUG_BUF( 3, "session hash", session_hash, hash_len );
    633          
    634                      ret = handshake->tls_prf( handshake->premaster, handshake->pmslen,
    635                                                "extended master secret",
    636                                                session_hash, hash_len,
    637                                                session->master, 48 );
    638                      if( ret != 0 )
    639                      {
    640                          MBEDTLS_SSL_DEBUG_RET( 1, "prf", ret );
    641                          return( ret );
    642                      }
    643          
    644                  }
    645                  else
    646          #endif
    647                  ret = handshake->tls_prf( handshake->premaster, handshake->pmslen,
    648                                            "master secret",
    649                                            handshake->randbytes, 64,
    650                                            session->master, 48 );
    651                  if( ret != 0 )
    652                  {
    653                      MBEDTLS_SSL_DEBUG_RET( 1, "prf", ret );
    654                      return( ret );
    655                  }
    656          
    657                  mbedtls_zeroize( handshake->premaster, sizeof(handshake->premaster) );
    658              }
    659              else
    660                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "no premaster (session resumed)" ) );
    661          
    662              /*
    663               * Swap the client and server random values.
    664               */
    665              memcpy( tmp, handshake->randbytes, 64 );
    666              memcpy( handshake->randbytes, tmp + 32, 32 );
    667              memcpy( handshake->randbytes + 32, tmp, 32 );
    668              mbedtls_zeroize( tmp, sizeof( tmp ) );
    669          
    670              /*
    671               *  SSLv3:
    672               *    key block =
    673               *      MD5( master + SHA1( 'A'    + master + randbytes ) ) +
    674               *      MD5( master + SHA1( 'BB'   + master + randbytes ) ) +
    675               *      MD5( master + SHA1( 'CCC'  + master + randbytes ) ) +
    676               *      MD5( master + SHA1( 'DDDD' + master + randbytes ) ) +
    677               *      ...
    678               *
    679               *  TLSv1:
    680               *    key block = PRF( master, "key expansion", randbytes )
    681               */
    682              ret = handshake->tls_prf( session->master, 48, "key expansion",
    683                                        handshake->randbytes, 64, keyblk, 256 );
    684              if( ret != 0 )
    685              {
    686                  MBEDTLS_SSL_DEBUG_RET( 1, "prf", ret );
    687                  return( ret );
    688              }
    689          
    690              MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite = %s",
    691                             mbedtls_ssl_get_ciphersuite_name( session->ciphersuite ) ) );
    692              MBEDTLS_SSL_DEBUG_BUF( 3, "master secret", session->master, 48 );
    693              MBEDTLS_SSL_DEBUG_BUF( 4, "random bytes", handshake->randbytes, 64 );
    694              MBEDTLS_SSL_DEBUG_BUF( 4, "key block", keyblk, 256 );
    695          
    696              mbedtls_zeroize( handshake->randbytes, sizeof( handshake->randbytes ) );
    697          
    698              /*
    699               * Determine the appropriate key, IV and MAC length.
    700               */
    701          
    702              transform->keylen = cipher_info->key_bitlen / 8;
    703          
    704              if( cipher_info->mode == MBEDTLS_MODE_GCM ||
    705                  cipher_info->mode == MBEDTLS_MODE_CCM )
    706              {
    707                  transform->maclen = 0;
    708                  mac_key_len = 0;
    709          
    710                  transform->ivlen = 12;
    711                  transform->fixed_ivlen = 4;
    712          
    713                  /* Minimum length is expicit IV + tag */
    714                  transform->minlen = transform->ivlen - transform->fixed_ivlen
    715                                      + ( transform->ciphersuite_info->flags &
    716                                          MBEDTLS_CIPHERSUITE_SHORT_TAG ? 8 : 16 );
    717              }
    718              else
    719              {
    720                  /* Initialize HMAC contexts */
    721                  if( ( ret = mbedtls_md_setup( &transform->md_ctx_enc, md_info, 1 ) ) != 0 ||
    722                      ( ret = mbedtls_md_setup( &transform->md_ctx_dec, md_info, 1 ) ) != 0 )
    723                  {
    724                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_setup", ret );
    725                      return( ret );
    726                  }
    727          
    728                  /* Get MAC length */
    729                  mac_key_len = mbedtls_md_get_size( md_info );
    730                  transform->maclen = mac_key_len;
    731          
    732          #if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
    733                  /*
    734                   * If HMAC is to be truncated, we shall keep the leftmost bytes,
    735                   * (rfc 6066 page 13 or rfc 2104 section 4),
    736                   * so we only need to adjust the length here.
    737                   */
    738                  if( session->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_ENABLED )
    739                  {
    740                      transform->maclen = MBEDTLS_SSL_TRUNCATED_HMAC_LEN;
    741          
    742          #if defined(MBEDTLS_SSL_TRUNCATED_HMAC_COMPAT)
    743                      /* Fall back to old, non-compliant version of the truncated
    744                       * HMAC implementation which also truncates the key
    745                       * (Mbed TLS versions from 1.3 to 2.6.0) */
    746                      mac_key_len = transform->maclen;
    747          #endif
    748                  }
    749          #endif /* MBEDTLS_SSL_TRUNCATED_HMAC */
    750          
    751                  /* IV length */
    752                  transform->ivlen = cipher_info->iv_size;
    753          
    754                  /* Minimum length */
    755                  if( cipher_info->mode == MBEDTLS_MODE_STREAM )
    756                      transform->minlen = transform->maclen;
    757                  else
    758                  {
    759                      /*
    760                       * GenericBlockCipher:
    761                       * 1. if EtM is in use: one block plus MAC
    762                       *    otherwise: * first multiple of blocklen greater than maclen
    763                       * 2. IV except for SSL3 and TLS 1.0
    764                       */
    765          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
    766                      if( session->encrypt_then_mac == MBEDTLS_SSL_ETM_ENABLED )
    767                      {
    768                          transform->minlen = transform->maclen
    769                                            + cipher_info->block_size;
    770                      }
    771                      else
    772          #endif
    773                      {
    774                          transform->minlen = transform->maclen
    775                                            + cipher_info->block_size
    776                                            - transform->maclen % cipher_info->block_size;
    777                      }
    778          
    779          #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1)
    780                      if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 ||
    781                          ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_1 )
    782                          ; /* No need to adjust minlen */
    783                      else
    784          #endif
    785          #if defined(MBEDTLS_SSL_PROTO_TLS1_1) || defined(MBEDTLS_SSL_PROTO_TLS1_2)
    786                      if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_2 ||
    787                          ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
    788                      {
    789                          transform->minlen += transform->ivlen;
    790                      }
    791                      else
    792          #endif
    793                      {
    794                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
    795                          return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
    796                      }
    797                  }
    798              }
    799          
    800              MBEDTLS_SSL_DEBUG_MSG( 3, ( "keylen: %d, minlen: %d, ivlen: %d, maclen: %d",
    801                             transform->keylen, transform->minlen, transform->ivlen,
    802                             transform->maclen ) );
    803          
    804              /*
    805               * Finally setup the cipher contexts, IVs and MAC secrets.
    806               */
    807          #if defined(MBEDTLS_SSL_CLI_C)
    808              if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
    809              {
    810                  key1 = keyblk + mac_key_len * 2;
    811                  key2 = keyblk + mac_key_len * 2 + transform->keylen;
    812          
    813                  mac_enc = keyblk;
    814                  mac_dec = keyblk + mac_key_len;
    815          
    816                  /*
    817                   * This is not used in TLS v1.1.
    818                   */
    819                  iv_copy_len = ( transform->fixed_ivlen ) ?
    820                                      transform->fixed_ivlen : transform->ivlen;
    821                  memcpy( transform->iv_enc, key2 + transform->keylen,  iv_copy_len );
    822                  memcpy( transform->iv_dec, key2 + transform->keylen + iv_copy_len,
    823                          iv_copy_len );
    824              }
    825              else
    826          #endif /* MBEDTLS_SSL_CLI_C */
    827          #if defined(MBEDTLS_SSL_SRV_C)
    828              if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER )
    829              {
    830                  key1 = keyblk + mac_key_len * 2 + transform->keylen;
    831                  key2 = keyblk + mac_key_len * 2;
    832          
    833                  mac_enc = keyblk + mac_key_len;
    834                  mac_dec = keyblk;
    835          
    836                  /*
    837                   * This is not used in TLS v1.1.
    838                   */
    839                  iv_copy_len = ( transform->fixed_ivlen ) ?
    840                                      transform->fixed_ivlen : transform->ivlen;
    841                  memcpy( transform->iv_dec, key1 + transform->keylen,  iv_copy_len );
    842                  memcpy( transform->iv_enc, key1 + transform->keylen + iv_copy_len,
    843                          iv_copy_len );
    844              }
    845              else
    846          #endif /* MBEDTLS_SSL_SRV_C */
    847              {
    848                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
    849                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
    850              }
    851          
    852          #if defined(MBEDTLS_SSL_PROTO_SSL3)
    853              if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    854              {
    855                  if( mac_key_len > sizeof transform->mac_enc )
    856                  {
    857                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
    858                      return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
    859                  }
    860          
    861                  memcpy( transform->mac_enc, mac_enc, mac_key_len );
    862                  memcpy( transform->mac_dec, mac_dec, mac_key_len );
    863              }
    864              else
    865          #endif /* MBEDTLS_SSL_PROTO_SSL3 */
    866          #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \
    867              defined(MBEDTLS_SSL_PROTO_TLS1_2)
    868              if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_1 )
    869              {
    870                  /* For HMAC-based ciphersuites, initialize the HMAC transforms.
    871                     For AEAD-based ciphersuites, there is nothing to do here. */
    872                  if( mac_key_len != 0 )
    873                  {
    874                      mbedtls_md_hmac_starts( &transform->md_ctx_enc, mac_enc, mac_key_len );
    875                      mbedtls_md_hmac_starts( &transform->md_ctx_dec, mac_dec, mac_key_len );
    876                  }
    877              }
    878              else
    879          #endif
    880              {
    881                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
    882                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
    883              }
    884          
    885          #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
    886              if( mbedtls_ssl_hw_record_init != NULL )
    887              {
    888                  int ret = 0;
    889          
    890                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "going for mbedtls_ssl_hw_record_init()" ) );
    891          
    892                  if( ( ret = mbedtls_ssl_hw_record_init( ssl, key1, key2, transform->keylen,
    893                                                  transform->iv_enc, transform->iv_dec,
    894                                                  iv_copy_len,
    895                                                  mac_enc, mac_dec,
    896                                                  mac_key_len ) ) != 0 )
    897                  {
    898                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_hw_record_init", ret );
    899                      return( MBEDTLS_ERR_SSL_HW_ACCEL_FAILED );
    900                  }
    901              }
    902          #endif /* MBEDTLS_SSL_HW_RECORD_ACCEL */
    903          
    904          #if defined(MBEDTLS_SSL_EXPORT_KEYS)
    905              if( ssl->conf->f_export_keys != NULL )
    906              {
    907                  ssl->conf->f_export_keys( ssl->conf->p_export_keys,
    908                                            session->master, keyblk,
    909                                            mac_key_len, transform->keylen,
    910                                            iv_copy_len );
    911              }
    912          #endif
    913          
    914              if( ( ret = mbedtls_cipher_setup( &transform->cipher_ctx_enc,
    915                                           cipher_info ) ) != 0 )
    916              {
    917                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_setup", ret );
    918                  return( ret );
    919              }
    920          
    921              if( ( ret = mbedtls_cipher_setup( &transform->cipher_ctx_dec,
    922                                           cipher_info ) ) != 0 )
    923              {
    924                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_setup", ret );
    925                  return( ret );
    926              }
    927          
    928              if( ( ret = mbedtls_cipher_setkey( &transform->cipher_ctx_enc, key1,
    929                                         cipher_info->key_bitlen,
    930                                         MBEDTLS_ENCRYPT ) ) != 0 )
    931              {
    932                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_setkey", ret );
    933                  return( ret );
    934              }
    935          
    936              if( ( ret = mbedtls_cipher_setkey( &transform->cipher_ctx_dec, key2,
    937                                         cipher_info->key_bitlen,
    938                                         MBEDTLS_DECRYPT ) ) != 0 )
    939              {
    940                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_setkey", ret );
    941                  return( ret );
    942              }
    943          
    944          #if defined(MBEDTLS_CIPHER_MODE_CBC)
    945              if( cipher_info->mode == MBEDTLS_MODE_CBC )
    946              {
    947                  if( ( ret = mbedtls_cipher_set_padding_mode( &transform->cipher_ctx_enc,
    948                                                       MBEDTLS_PADDING_NONE ) ) != 0 )
    949                  {
    950                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_set_padding_mode", ret );
    951                      return( ret );
    952                  }
    953          
    954                  if( ( ret = mbedtls_cipher_set_padding_mode( &transform->cipher_ctx_dec,
    955                                                       MBEDTLS_PADDING_NONE ) ) != 0 )
    956                  {
    957                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_set_padding_mode", ret );
    958                      return( ret );
    959                  }
    960              }
    961          #endif /* MBEDTLS_CIPHER_MODE_CBC */
    962          
    963              mbedtls_zeroize( keyblk, sizeof( keyblk ) );
    964          
    965          #if defined(MBEDTLS_ZLIB_SUPPORT)
    966              // Initialize compression
    967              //
    968              if( session->compression == MBEDTLS_SSL_COMPRESS_DEFLATE )
    969              {
    970                  if( ssl->compress_buf == NULL )
    971                  {
    972                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "Allocating compression buffer" ) );
    973                      ssl->compress_buf = mbedtls_calloc( 1, MBEDTLS_SSL_BUFFER_LEN );
    974                      if( ssl->compress_buf == NULL )
    975                      {
    976                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc(%d bytes) failed",
    977                                              MBEDTLS_SSL_BUFFER_LEN ) );
    978                          return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
    979                      }
    980                  }
    981          
    982                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "Initializing zlib states" ) );
    983          
    984                  memset( &transform->ctx_deflate, 0, sizeof( transform->ctx_deflate ) );
    985                  memset( &transform->ctx_inflate, 0, sizeof( transform->ctx_inflate ) );
    986          
    987                  if( deflateInit( &transform->ctx_deflate,
    988                                   Z_DEFAULT_COMPRESSION )   != Z_OK ||
    989                      inflateInit( &transform->ctx_inflate ) != Z_OK )
    990                  {
    991                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "Failed to initialize compression" ) );
    992                      return( MBEDTLS_ERR_SSL_COMPRESSION_FAILED );
    993                  }
    994              }
    995          #endif /* MBEDTLS_ZLIB_SUPPORT */
    996          
    997              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= derive keys" ) );
    998          
    999              return( 0 );
   1000          }
   1001          
   1002          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   1003          void ssl_calc_verify_ssl( mbedtls_ssl_context *ssl, unsigned char hash[36] )
   1004          {
   1005              mbedtls_md5_context md5;
   1006              mbedtls_sha1_context sha1;
   1007              unsigned char pad_1[48];
   1008              unsigned char pad_2[48];
   1009          
   1010              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc verify ssl" ) );
   1011          
   1012              mbedtls_md5_init( &md5 );
   1013              mbedtls_sha1_init( &sha1 );
   1014          
   1015              mbedtls_md5_clone( &md5, &ssl->handshake->fin_md5 );
   1016              mbedtls_sha1_clone( &sha1, &ssl->handshake->fin_sha1 );
   1017          
   1018              memset( pad_1, 0x36, 48 );
   1019              memset( pad_2, 0x5C, 48 );
   1020          
   1021              mbedtls_md5_update_ret( &md5, ssl->session_negotiate->master, 48 );
   1022              mbedtls_md5_update_ret( &md5, pad_1, 48 );
   1023              mbedtls_md5_finish_ret( &md5, hash );
   1024          
   1025              mbedtls_md5_starts_ret( &md5 );
   1026              mbedtls_md5_update_ret( &md5, ssl->session_negotiate->master, 48 );
   1027              mbedtls_md5_update_ret( &md5, pad_2, 48 );
   1028              mbedtls_md5_update_ret( &md5, hash,  16 );
   1029              mbedtls_md5_finish_ret( &md5, hash );
   1030          
   1031              mbedtls_sha1_update_ret( &sha1, ssl->session_negotiate->master, 48 );
   1032              mbedtls_sha1_update_ret( &sha1, pad_1, 40 );
   1033              mbedtls_sha1_finish_ret( &sha1, hash + 16 );
   1034          
   1035              mbedtls_sha1_starts_ret( &sha1 );
   1036              mbedtls_sha1_update_ret( &sha1, ssl->session_negotiate->master, 48 );
   1037              mbedtls_sha1_update_ret( &sha1, pad_2, 40 );
   1038              mbedtls_sha1_update_ret( &sha1, hash + 16, 20 );
   1039              mbedtls_sha1_finish_ret( &sha1, hash + 16 );
   1040          
   1041              MBEDTLS_SSL_DEBUG_BUF( 3, "calculated verify result", hash, 36 );
   1042              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc verify" ) );
   1043          
   1044              mbedtls_md5_free(  &md5  );
   1045              mbedtls_sha1_free( &sha1 );
   1046          
   1047              return;
   1048          }
   1049          #endif /* MBEDTLS_SSL_PROTO_SSL3 */
   1050          
   1051          #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1)
   1052          void ssl_calc_verify_tls( mbedtls_ssl_context *ssl, unsigned char hash[36] )
   1053          {
   1054              mbedtls_md5_context md5;
   1055              mbedtls_sha1_context sha1;
   1056          
   1057              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc verify tls" ) );
   1058          
   1059              mbedtls_md5_init( &md5 );
   1060              mbedtls_sha1_init( &sha1 );
   1061          
   1062              mbedtls_md5_clone( &md5, &ssl->handshake->fin_md5 );
   1063              mbedtls_sha1_clone( &sha1, &ssl->handshake->fin_sha1 );
   1064          
   1065               mbedtls_md5_finish_ret( &md5,  hash );
   1066              mbedtls_sha1_finish_ret( &sha1, hash + 16 );
   1067          
   1068              MBEDTLS_SSL_DEBUG_BUF( 3, "calculated verify result", hash, 36 );
   1069              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc verify" ) );
   1070          
   1071              mbedtls_md5_free(  &md5  );
   1072              mbedtls_sha1_free( &sha1 );
   1073          
   1074              return;
   1075          }
   1076          #endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 */
   1077          
   1078          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1079          #if defined(MBEDTLS_SHA256_C)
   1080          void ssl_calc_verify_tls_sha256( mbedtls_ssl_context *ssl, unsigned char hash[32] )
   1081          {
   1082              mbedtls_sha256_context sha256;
   1083          
   1084              mbedtls_sha256_init( &sha256 );
   1085          
   1086              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc verify sha256" ) );
   1087          
   1088              mbedtls_sha256_clone( &sha256, &ssl->handshake->fin_sha256 );
   1089              mbedtls_sha256_finish_ret( &sha256, hash );
   1090          
   1091              MBEDTLS_SSL_DEBUG_BUF( 3, "calculated verify result", hash, 32 );
   1092              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc verify" ) );
   1093          
   1094              mbedtls_sha256_free( &sha256 );
   1095          
   1096              return;
   1097          }
   1098          #endif /* MBEDTLS_SHA256_C */
   1099          
   1100          #if defined(MBEDTLS_SHA512_C)
   1101          void ssl_calc_verify_tls_sha384( mbedtls_ssl_context *ssl, unsigned char hash[48] )
   1102          {
   1103              mbedtls_sha512_context sha512;
   1104          
   1105              mbedtls_sha512_init( &sha512 );
   1106          
   1107              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc verify sha384" ) );
   1108          
   1109              mbedtls_sha512_clone( &sha512, &ssl->handshake->fin_sha512 );
   1110              mbedtls_sha512_finish_ret( &sha512, hash );
   1111          
   1112              MBEDTLS_SSL_DEBUG_BUF( 3, "calculated verify result", hash, 48 );
   1113              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc verify" ) );
   1114          
   1115              mbedtls_sha512_free( &sha512 );
   1116          
   1117              return;
   1118          }
   1119          #endif /* MBEDTLS_SHA512_C */
   1120          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   1121          
   1122          #if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)
   1123          int mbedtls_ssl_psk_derive_premaster( mbedtls_ssl_context *ssl, mbedtls_key_exchange_type_t key_ex )
   1124          {
   1125              unsigned char *p = ssl->handshake->premaster;
   1126              unsigned char *end = p + sizeof( ssl->handshake->premaster );
   1127              const unsigned char *psk = ssl->conf->psk;
   1128              size_t psk_len = ssl->conf->psk_len;
   1129          
   1130              /* If the psk callback was called, use its result */
   1131              if( ssl->handshake->psk != NULL )
   1132              {
   1133                  psk = ssl->handshake->psk;
   1134                  psk_len = ssl->handshake->psk_len;
   1135              }
   1136          
   1137              /*
   1138               * PMS = struct {
   1139               *     opaque other_secret<0..2^16-1>;
   1140               *     opaque psk<0..2^16-1>;
   1141               * };
   1142               * with "other_secret" depending on the particular key exchange
   1143               */
   1144          #if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED)
   1145              if( key_ex == MBEDTLS_KEY_EXCHANGE_PSK )
   1146              {
   1147                  if( end - p < 2 )
   1148                      return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   1149          
   1150                  *(p++) = (unsigned char)( psk_len >> 8 );
   1151                  *(p++) = (unsigned char)( psk_len      );
   1152          
   1153                  if( end < p || (size_t)( end - p ) < psk_len )
   1154                      return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   1155          
   1156                  memset( p, 0, psk_len );
   1157                  p += psk_len;
   1158              }
   1159              else
   1160          #endif /* MBEDTLS_KEY_EXCHANGE_PSK_ENABLED */
   1161          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
   1162              if( key_ex == MBEDTLS_KEY_EXCHANGE_RSA_PSK )
   1163              {
   1164                  /*
   1165                   * other_secret already set by the ClientKeyExchange message,
   1166                   * and is 48 bytes long
   1167                   */
   1168                  if( end - p < 2 )
   1169                      return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   1170          
   1171                  *p++ = 0;
   1172                  *p++ = 48;
   1173                  p += 48;
   1174              }
   1175              else
   1176          #endif /* MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */
   1177          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
   1178              if( key_ex == MBEDTLS_KEY_EXCHANGE_DHE_PSK )
   1179              {
   1180                  int ret;
   1181                  size_t len;
   1182          
   1183                  /* Write length only when we know the actual value */
   1184                  if( ( ret = mbedtls_dhm_calc_secret( &ssl->handshake->dhm_ctx,
   1185                                                p + 2, end - ( p + 2 ), &len,
   1186                                                ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
   1187                  {
   1188                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_dhm_calc_secret", ret );
   1189                      return( ret );
   1190                  }
   1191                  *(p++) = (unsigned char)( len >> 8 );
   1192                  *(p++) = (unsigned char)( len );
   1193                  p += len;
   1194          
   1195                  MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: K ", &ssl->handshake->dhm_ctx.K  );
   1196              }
   1197              else
   1198          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
   1199          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
   1200              if( key_ex == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )
   1201              {
   1202                  int ret;
   1203                  size_t zlen;
   1204          
   1205                  if( ( ret = mbedtls_ecdh_calc_secret( &ssl->handshake->ecdh_ctx, &zlen,
   1206                                                 p + 2, end - ( p + 2 ),
   1207                                                 ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
   1208                  {
   1209                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_calc_secret", ret );
   1210                      return( ret );
   1211                  }
   1212          
   1213                  *(p++) = (unsigned char)( zlen >> 8 );
   1214                  *(p++) = (unsigned char)( zlen      );
   1215                  p += zlen;
   1216          
   1217                  MBEDTLS_SSL_DEBUG_MPI( 3, "ECDH: z", &ssl->handshake->ecdh_ctx.z );
   1218              }
   1219              else
   1220          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
   1221              {
   1222                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   1223                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   1224              }
   1225          
   1226              /* opaque psk<0..2^16-1>; */
   1227              if( end - p < 2 )
   1228                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   1229          
   1230              *(p++) = (unsigned char)( psk_len >> 8 );
   1231              *(p++) = (unsigned char)( psk_len      );
   1232          
   1233              if( end < p || (size_t)( end - p ) < psk_len )
   1234                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   1235          
   1236              memcpy( p, psk, psk_len );
   1237              p += psk_len;
   1238          
   1239              ssl->handshake->pmslen = p - ssl->handshake->premaster;
   1240          
   1241              return( 0 );
   1242          }
   1243          #endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */
   1244          
   1245          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   1246          /*
   1247           * SSLv3.0 MAC functions
   1248           */
   1249          #define SSL_MAC_MAX_BYTES   20  /* MD-5 or SHA-1 */
   1250          static void ssl_mac( mbedtls_md_context_t *md_ctx,
   1251                               const unsigned char *secret,
   1252                               const unsigned char *buf, size_t len,
   1253                               const unsigned char *ctr, int type,
   1254                               unsigned char out[SSL_MAC_MAX_BYTES] )
   1255          {
   1256              unsigned char header[11];
   1257              unsigned char padding[48];
   1258              int padlen;
   1259              int md_size = mbedtls_md_get_size( md_ctx->md_info );
   1260              int md_type = mbedtls_md_get_type( md_ctx->md_info );
   1261          
   1262              /* Only MD5 and SHA-1 supported */
   1263              if( md_type == MBEDTLS_MD_MD5 )
   1264                  padlen = 48;
   1265              else
   1266                  padlen = 40;
   1267          
   1268              memcpy( header, ctr, 8 );
   1269              header[ 8] = (unsigned char)  type;
   1270              header[ 9] = (unsigned char)( len >> 8 );
   1271              header[10] = (unsigned char)( len      );
   1272          
   1273              memset( padding, 0x36, padlen );
   1274              mbedtls_md_starts( md_ctx );
   1275              mbedtls_md_update( md_ctx, secret,  md_size );
   1276              mbedtls_md_update( md_ctx, padding, padlen  );
   1277              mbedtls_md_update( md_ctx, header,  11      );
   1278              mbedtls_md_update( md_ctx, buf,     len     );
   1279              mbedtls_md_finish( md_ctx, out              );
   1280          
   1281              memset( padding, 0x5C, padlen );
   1282              mbedtls_md_starts( md_ctx );
   1283              mbedtls_md_update( md_ctx, secret,    md_size );
   1284              mbedtls_md_update( md_ctx, padding,   padlen  );
   1285              mbedtls_md_update( md_ctx, out,       md_size );
   1286              mbedtls_md_finish( md_ctx, out                );
   1287          }
   1288          #endif /* MBEDTLS_SSL_PROTO_SSL3 */
   1289          
   1290          #if defined(MBEDTLS_ARC4_C) || defined(MBEDTLS_CIPHER_NULL_CIPHER) ||     \
   1291              ( defined(MBEDTLS_CIPHER_MODE_CBC) &&                                  \
   1292                ( defined(MBEDTLS_AES_C) || defined(MBEDTLS_CAMELLIA_C) ) )
   1293          #define SSL_SOME_MODES_USE_MAC
   1294          #endif
   1295          
   1296          /* The function below is only used in the Lucky 13 counter-measure in
   1297           * ssl_decrypt_buf(). These are the defines that guard the call site. */
   1298          #if defined(SSL_SOME_MODES_USE_MAC) && \
   1299              ( defined(MBEDTLS_SSL_PROTO_TLS1) || \
   1300                defined(MBEDTLS_SSL_PROTO_TLS1_1) || \
   1301                defined(MBEDTLS_SSL_PROTO_TLS1_2) )
   1302          /* This function makes sure every byte in the memory region is accessed
   1303           * (in ascending addresses order) */
   1304          static void ssl_read_memory( unsigned char *p, size_t len )
   1305          {
   1306              unsigned char acc = 0;
   1307              volatile unsigned char force;
   1308          
   1309              for( ; len != 0; p++, len-- )
   1310                  acc ^= *p;
   1311          
   1312              force = acc;
   1313              (void) force;
   1314          }
   1315          #endif /* SSL_SOME_MODES_USE_MAC && ( TLS1 || TLS1_1 || TLS1_2 ) */
   1316          
   1317          /*
   1318           * Encryption/decryption functions
   1319           */
   1320          static int ssl_encrypt_buf( mbedtls_ssl_context *ssl )
   1321          {
   1322              mbedtls_cipher_mode_t mode;
   1323              int auth_done = 0;
   1324          
   1325              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> encrypt buf" ) );
   1326          
   1327              if( ssl->session_out == NULL || ssl->transform_out == NULL )
   1328              {
   1329                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   1330                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   1331              }
   1332          
   1333              mode = mbedtls_cipher_get_cipher_mode( &ssl->transform_out->cipher_ctx_enc );
   1334          
   1335              MBEDTLS_SSL_DEBUG_BUF( 4, "before encrypt: output payload",
   1336                                ssl->out_msg, ssl->out_msglen );
   1337          
   1338              if( ssl->out_msglen > MBEDTLS_SSL_MAX_CONTENT_LEN )
   1339              {
   1340                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "Record content %u too large, maximum %d",
   1341                                              (unsigned) ssl->out_msglen,
   1342                                              MBEDTLS_SSL_MAX_CONTENT_LEN ) );
   1343                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   1344              }
   1345          
   1346              /*
   1347               * Add MAC before if needed
   1348               */
   1349          #if defined(SSL_SOME_MODES_USE_MAC)
   1350              if( mode == MBEDTLS_MODE_STREAM ||
   1351                  ( mode == MBEDTLS_MODE_CBC
   1352          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   1353                    && ssl->session_out->encrypt_then_mac == MBEDTLS_SSL_ETM_DISABLED
   1354          #endif
   1355                  ) )
   1356              {
   1357          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   1358                  if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
   1359                  {
   1360                      unsigned char mac[SSL_MAC_MAX_BYTES];
   1361          
   1362                      ssl_mac( &ssl->transform_out->md_ctx_enc,
   1363                                ssl->transform_out->mac_enc,
   1364                                ssl->out_msg, ssl->out_msglen,
   1365                                ssl->out_ctr, ssl->out_msgtype,
   1366                                mac );
   1367          
   1368                      memcpy( ssl->out_msg + ssl->out_msglen, mac, ssl->transform_out->maclen );
   1369                  }
   1370                  else
   1371          #endif
   1372          #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \
   1373                  defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1374                  if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_1 )
   1375                  {
   1376                      unsigned char mac[MBEDTLS_SSL_MAC_ADD];
   1377          
   1378                      mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc, ssl->out_ctr, 8 );
   1379                      mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc, ssl->out_hdr, 3 );
   1380                      mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc, ssl->out_len, 2 );
   1381                      mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc,
   1382                                       ssl->out_msg, ssl->out_msglen );
   1383                      mbedtls_md_hmac_finish( &ssl->transform_out->md_ctx_enc, mac );
   1384                      mbedtls_md_hmac_reset( &ssl->transform_out->md_ctx_enc );
   1385          
   1386                      memcpy( ssl->out_msg + ssl->out_msglen, mac, ssl->transform_out->maclen );
   1387                  }
   1388                  else
   1389          #endif
   1390                  {
   1391                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   1392                      return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   1393                  }
   1394          
   1395                  MBEDTLS_SSL_DEBUG_BUF( 4, "computed mac",
   1396                                 ssl->out_msg + ssl->out_msglen,
   1397                                 ssl->transform_out->maclen );
   1398          
   1399                  ssl->out_msglen += ssl->transform_out->maclen;
   1400                  auth_done++;
   1401              }
   1402          #endif /* AEAD not the only option */
   1403          
   1404              /*
   1405               * Encrypt
   1406               */
   1407          #if defined(MBEDTLS_ARC4_C) || defined(MBEDTLS_CIPHER_NULL_CIPHER)
   1408              if( mode == MBEDTLS_MODE_STREAM )
   1409              {
   1410                  int ret;
   1411                  size_t olen = 0;
   1412          
   1413                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "before encrypt: msglen = %d, "
   1414                                      "including %d bytes of padding",
   1415                                 ssl->out_msglen, 0 ) );
   1416          
   1417                  if( ( ret = mbedtls_cipher_crypt( &ssl->transform_out->cipher_ctx_enc,
   1418                                             ssl->transform_out->iv_enc,
   1419                                             ssl->transform_out->ivlen,
   1420                                             ssl->out_msg, ssl->out_msglen,
   1421                                             ssl->out_msg, &olen ) ) != 0 )
   1422                  {
   1423                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_crypt", ret );
   1424                      return( ret );
   1425                  }
   1426          
   1427                  if( ssl->out_msglen != olen )
   1428                  {
   1429                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   1430                      return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   1431                  }
   1432              }
   1433              else
   1434          #endif /* MBEDTLS_ARC4_C || MBEDTLS_CIPHER_NULL_CIPHER */
   1435          #if defined(MBEDTLS_GCM_C) || defined(MBEDTLS_CCM_C)
   1436              if( mode == MBEDTLS_MODE_GCM ||
   1437                  mode == MBEDTLS_MODE_CCM )
   1438              {
   1439                  int ret;
   1440                  size_t enc_msglen, olen;
   1441                  unsigned char *enc_msg;
   1442                  unsigned char add_data[13];
   1443                  unsigned char taglen = ssl->transform_out->ciphersuite_info->flags &
   1444                                         MBEDTLS_CIPHERSUITE_SHORT_TAG ? 8 : 16;
   1445          
   1446                  memcpy( add_data, ssl->out_ctr, 8 );
   1447                  add_data[8]  = ssl->out_msgtype;
   1448                  mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
   1449                                     ssl->conf->transport, add_data + 9 );
   1450                  add_data[11] = ( ssl->out_msglen >> 8 ) & 0xFF;
   1451                  add_data[12] = ssl->out_msglen & 0xFF;
   1452          
   1453                  MBEDTLS_SSL_DEBUG_BUF( 4, "additional data used for AEAD",
   1454                                 add_data, 13 );
   1455          
   1456                  /*
   1457                   * Generate IV
   1458                   */
   1459                  if( ssl->transform_out->ivlen - ssl->transform_out->fixed_ivlen != 8 )
   1460                  {
   1461                      /* Reminder if we ever add an AEAD mode with a different size */
   1462                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   1463                      return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   1464                  }
   1465          
   1466                  memcpy( ssl->transform_out->iv_enc + ssl->transform_out->fixed_ivlen,
   1467                                       ssl->out_ctr, 8 );
   1468                  memcpy( ssl->out_iv, ssl->out_ctr, 8 );
   1469          
   1470                  MBEDTLS_SSL_DEBUG_BUF( 4, "IV used", ssl->out_iv,
   1471                          ssl->transform_out->ivlen - ssl->transform_out->fixed_ivlen );
   1472          
   1473                  /*
   1474                   * Fix pointer positions and message length with added IV
   1475                   */
   1476                  enc_msg = ssl->out_msg;
   1477                  enc_msglen = ssl->out_msglen;
   1478                  ssl->out_msglen += ssl->transform_out->ivlen -
   1479                                     ssl->transform_out->fixed_ivlen;
   1480          
   1481                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "before encrypt: msglen = %d, "
   1482                                      "including %d bytes of padding",
   1483                                 ssl->out_msglen, 0 ) );
   1484          
   1485                  /*
   1486                   * Encrypt and authenticate
   1487                   */
   1488                  if( ( ret = mbedtls_cipher_auth_encrypt( &ssl->transform_out->cipher_ctx_enc,
   1489                                                   ssl->transform_out->iv_enc,
   1490                                                   ssl->transform_out->ivlen,
   1491                                                   add_data, 13,
   1492                                                   enc_msg, enc_msglen,
   1493                                                   enc_msg, &olen,
   1494                                                   enc_msg + enc_msglen, taglen ) ) != 0 )
   1495                  {
   1496                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_auth_encrypt", ret );
   1497                      return( ret );
   1498                  }
   1499          
   1500                  if( olen != enc_msglen )
   1501                  {
   1502                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   1503                      return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   1504                  }
   1505          
   1506                  ssl->out_msglen += taglen;
   1507                  auth_done++;
   1508          
   1509                  MBEDTLS_SSL_DEBUG_BUF( 4, "after encrypt: tag", enc_msg + enc_msglen, taglen );
   1510              }
   1511              else
   1512          #endif /* MBEDTLS_GCM_C || MBEDTLS_CCM_C */
   1513          #if defined(MBEDTLS_CIPHER_MODE_CBC) &&                                    \
   1514              ( defined(MBEDTLS_AES_C) || defined(MBEDTLS_CAMELLIA_C) )
   1515              if( mode == MBEDTLS_MODE_CBC )
   1516              {
   1517                  int ret;
   1518                  unsigned char *enc_msg;
   1519                  size_t enc_msglen, padlen, olen = 0, i;
   1520          
   1521                  padlen = ssl->transform_out->ivlen - ( ssl->out_msglen + 1 ) %
   1522                           ssl->transform_out->ivlen;
   1523                  if( padlen == ssl->transform_out->ivlen )
   1524                      padlen = 0;
   1525          
   1526                  for( i = 0; i <= padlen; i++ )
   1527                      ssl->out_msg[ssl->out_msglen + i] = (unsigned char) padlen;
   1528          
   1529                  ssl->out_msglen += padlen + 1;
   1530          
   1531                  enc_msglen = ssl->out_msglen;
   1532                  enc_msg = ssl->out_msg;
   1533          
   1534          #if defined(MBEDTLS_SSL_PROTO_TLS1_1) || defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1535                  /*
   1536                   * Prepend per-record IV for block cipher in TLS v1.1 and up as per
   1537                   * Method 1 (6.2.3.2. in RFC4346 and RFC5246)
   1538                   */
   1539                  if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
   1540                  {
   1541                      /*
   1542                       * Generate IV
   1543                       */
   1544                      ret = ssl->conf->f_rng( ssl->conf->p_rng, ssl->transform_out->iv_enc,
   1545                                            ssl->transform_out->ivlen );
   1546                      if( ret != 0 )
   1547                          return( ret );
   1548          
   1549                      memcpy( ssl->out_iv, ssl->transform_out->iv_enc,
   1550                              ssl->transform_out->ivlen );
   1551          
   1552                      /*
   1553                       * Fix pointer positions and message length with added IV
   1554                       */
   1555                      enc_msg = ssl->out_msg;
   1556                      enc_msglen = ssl->out_msglen;
   1557                      ssl->out_msglen += ssl->transform_out->ivlen;
   1558                  }
   1559          #endif /* MBEDTLS_SSL_PROTO_TLS1_1 || MBEDTLS_SSL_PROTO_TLS1_2 */
   1560          
   1561                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "before encrypt: msglen = %d, "
   1562                                      "including %d bytes of IV and %d bytes of padding",
   1563                                      ssl->out_msglen, ssl->transform_out->ivlen,
   1564                                      padlen + 1 ) );
   1565          
   1566                  if( ( ret = mbedtls_cipher_crypt( &ssl->transform_out->cipher_ctx_enc,
   1567                                             ssl->transform_out->iv_enc,
   1568                                             ssl->transform_out->ivlen,
   1569                                             enc_msg, enc_msglen,
   1570                                             enc_msg, &olen ) ) != 0 )
   1571                  {
   1572                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_crypt", ret );
   1573                      return( ret );
   1574                  }
   1575          
   1576                  if( enc_msglen != olen )
   1577                  {
   1578                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   1579                      return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   1580                  }
   1581          
   1582          #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1)
   1583                  if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_2 )
   1584                  {
   1585                      /*
   1586                       * Save IV in SSL3 and TLS1
   1587                       */
   1588                      memcpy( ssl->transform_out->iv_enc,
   1589                              ssl->transform_out->cipher_ctx_enc.iv,
   1590                              ssl->transform_out->ivlen );
   1591                  }
   1592          #endif
   1593          
   1594          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   1595                  if( auth_done == 0 )
   1596                  {
   1597                      unsigned char mac[MBEDTLS_SSL_MAC_ADD];
   1598          
   1599                      /*
   1600                       * MAC(MAC_write_key, seq_num +
   1601                       *     TLSCipherText.type +
   1602                       *     TLSCipherText.version +
   1603                       *     length_of( (IV +) ENC(...) ) +
   1604                       *     IV + // except for TLS 1.0
   1605                       *     ENC(content + padding + padding_length));
   1606                       */
   1607                      unsigned char pseudo_hdr[13];
   1608          
   1609                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "using encrypt then mac" ) );
   1610          
   1611                      memcpy( pseudo_hdr +  0, ssl->out_ctr, 8 );
   1612                      memcpy( pseudo_hdr +  8, ssl->out_hdr, 3 );
   1613                      pseudo_hdr[11] = (unsigned char)( ( ssl->out_msglen >> 8 ) & 0xFF );
   1614                      pseudo_hdr[12] = (unsigned char)( ( ssl->out_msglen      ) & 0xFF );
   1615          
   1616                      MBEDTLS_SSL_DEBUG_BUF( 4, "MAC'd meta-data", pseudo_hdr, 13 );
   1617          
   1618                      mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc, pseudo_hdr, 13 );
   1619                      mbedtls_md_hmac_update( &ssl->transform_out->md_ctx_enc,
   1620                                       ssl->out_iv, ssl->out_msglen );
   1621                      mbedtls_md_hmac_finish( &ssl->transform_out->md_ctx_enc, mac );
   1622                      mbedtls_md_hmac_reset( &ssl->transform_out->md_ctx_enc );
   1623          
   1624                      memcpy( ssl->out_iv + ssl->out_msglen, mac,
   1625                              ssl->transform_out->maclen );
   1626          
   1627                      ssl->out_msglen += ssl->transform_out->maclen;
   1628                      auth_done++;
   1629                  }
   1630          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
   1631              }
   1632              else
   1633          #endif /* MBEDTLS_CIPHER_MODE_CBC &&
   1634                    ( MBEDTLS_AES_C || MBEDTLS_CAMELLIA_C ) */
   1635              {
   1636                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   1637                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   1638              }
   1639          
   1640              /* Make extra sure authentication was performed, exactly once */
   1641              if( auth_done != 1 )
   1642              {
   1643                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   1644                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   1645              }
   1646          
   1647              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= encrypt buf" ) );
   1648          
   1649              return( 0 );
   1650          }
   1651          
   1652          static int ssl_decrypt_buf( mbedtls_ssl_context *ssl )
   1653          {
   1654              size_t i;
   1655              mbedtls_cipher_mode_t mode;
   1656              int auth_done = 0;
   1657          #if defined(SSL_SOME_MODES_USE_MAC)
   1658              size_t padlen = 0, correct = 1;
   1659          #endif
   1660          
   1661              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> decrypt buf" ) );
   1662          
   1663              if( ssl->session_in == NULL || ssl->transform_in == NULL )
   1664              {
   1665                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   1666                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   1667              }
   1668          
   1669              mode = mbedtls_cipher_get_cipher_mode( &ssl->transform_in->cipher_ctx_dec );
   1670          
   1671              if( ssl->in_msglen < ssl->transform_in->minlen )
   1672              {
   1673                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "in_msglen (%d) < minlen (%d)",
   1674                                 ssl->in_msglen, ssl->transform_in->minlen ) );
   1675                  return( MBEDTLS_ERR_SSL_INVALID_MAC );
   1676              }
   1677          
   1678          #if defined(MBEDTLS_ARC4_C) || defined(MBEDTLS_CIPHER_NULL_CIPHER)
   1679              if( mode == MBEDTLS_MODE_STREAM )
   1680              {
   1681                  int ret;
   1682                  size_t olen = 0;
   1683          
   1684                  padlen = 0;
   1685          
   1686                  if( ( ret = mbedtls_cipher_crypt( &ssl->transform_in->cipher_ctx_dec,
   1687                                             ssl->transform_in->iv_dec,
   1688                                             ssl->transform_in->ivlen,
   1689                                             ssl->in_msg, ssl->in_msglen,
   1690                                             ssl->in_msg, &olen ) ) != 0 )
   1691                  {
   1692                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_crypt", ret );
   1693                      return( ret );
   1694                  }
   1695          
   1696                  if( ssl->in_msglen != olen )
   1697                  {
   1698                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   1699                      return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   1700                  }
   1701              }
   1702              else
   1703          #endif /* MBEDTLS_ARC4_C || MBEDTLS_CIPHER_NULL_CIPHER */
   1704          #if defined(MBEDTLS_GCM_C) || defined(MBEDTLS_CCM_C)
   1705              if( mode == MBEDTLS_MODE_GCM ||
   1706                  mode == MBEDTLS_MODE_CCM )
   1707              {
   1708                  int ret;
   1709                  size_t dec_msglen, olen;
   1710                  unsigned char *dec_msg;
   1711                  unsigned char *dec_msg_result;
   1712                  unsigned char add_data[13];
   1713                  unsigned char taglen = ssl->transform_in->ciphersuite_info->flags &
   1714                                         MBEDTLS_CIPHERSUITE_SHORT_TAG ? 8 : 16;
   1715                  size_t explicit_iv_len = ssl->transform_in->ivlen -
   1716                                           ssl->transform_in->fixed_ivlen;
   1717          
   1718                  if( ssl->in_msglen < explicit_iv_len + taglen )
   1719                  {
   1720                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "msglen (%d) < explicit_iv_len (%d) "
   1721                                          "+ taglen (%d)", ssl->in_msglen,
   1722                                          explicit_iv_len, taglen ) );
   1723                      return( MBEDTLS_ERR_SSL_INVALID_MAC );
   1724                  }
   1725                  dec_msglen = ssl->in_msglen - explicit_iv_len - taglen;
   1726          
   1727                  dec_msg = ssl->in_msg;
   1728                  dec_msg_result = ssl->in_msg;
   1729                  ssl->in_msglen = dec_msglen;
   1730          
   1731                  memcpy( add_data, ssl->in_ctr, 8 );
   1732                  add_data[8]  = ssl->in_msgtype;
   1733                  mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
   1734                                     ssl->conf->transport, add_data + 9 );
   1735                  add_data[11] = ( ssl->in_msglen >> 8 ) & 0xFF;
   1736                  add_data[12] = ssl->in_msglen & 0xFF;
   1737          
   1738                  MBEDTLS_SSL_DEBUG_BUF( 4, "additional data used for AEAD",
   1739                                 add_data, 13 );
   1740          
   1741                  memcpy( ssl->transform_in->iv_dec + ssl->transform_in->fixed_ivlen,
   1742                          ssl->in_iv,
   1743                          ssl->transform_in->ivlen - ssl->transform_in->fixed_ivlen );
   1744          
   1745                  MBEDTLS_SSL_DEBUG_BUF( 4, "IV used", ssl->transform_in->iv_dec,
   1746                                               ssl->transform_in->ivlen );
   1747                  MBEDTLS_SSL_DEBUG_BUF( 4, "TAG used", dec_msg + dec_msglen, taglen );
   1748          
   1749                  /*
   1750                   * Decrypt and authenticate
   1751                   */
   1752                  if( ( ret = mbedtls_cipher_auth_decrypt( &ssl->transform_in->cipher_ctx_dec,
   1753                                                   ssl->transform_in->iv_dec,
   1754                                                   ssl->transform_in->ivlen,
   1755                                                   add_data, 13,
   1756                                                   dec_msg, dec_msglen,
   1757                                                   dec_msg_result, &olen,
   1758                                                   dec_msg + dec_msglen, taglen ) ) != 0 )
   1759                  {
   1760                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_auth_decrypt", ret );
   1761          
   1762                      if( ret == MBEDTLS_ERR_CIPHER_AUTH_FAILED )
   1763                          return( MBEDTLS_ERR_SSL_INVALID_MAC );
   1764          
   1765                      return( ret );
   1766                  }
   1767                  auth_done++;
   1768          
   1769                  if( olen != dec_msglen )
   1770                  {
   1771                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   1772                      return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   1773                  }
   1774              }
   1775              else
   1776          #endif /* MBEDTLS_GCM_C || MBEDTLS_CCM_C */
   1777          #if defined(MBEDTLS_CIPHER_MODE_CBC) &&                                    \
   1778              ( defined(MBEDTLS_AES_C) || defined(MBEDTLS_CAMELLIA_C) )
   1779              if( mode == MBEDTLS_MODE_CBC )
   1780              {
   1781                  /*
   1782                   * Decrypt and check the padding
   1783                   */
   1784                  int ret;
   1785                  unsigned char *dec_msg;
   1786                  unsigned char *dec_msg_result;
   1787                  size_t dec_msglen;
   1788                  size_t minlen = 0;
   1789                  size_t olen = 0;
   1790          
   1791                  /*
   1792                   * Check immediate ciphertext sanity
   1793                   */
   1794          #if defined(MBEDTLS_SSL_PROTO_TLS1_1) || defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1795                  if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
   1796                      minlen += ssl->transform_in->ivlen;
   1797          #endif
   1798          
   1799                  if( ssl->in_msglen < minlen + ssl->transform_in->ivlen ||
   1800                      ssl->in_msglen < minlen + ssl->transform_in->maclen + 1 )
   1801                  {
   1802                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "msglen (%d) < max( ivlen(%d), maclen (%d) "
   1803                                          "+ 1 ) ( + expl IV )", ssl->in_msglen,
   1804                                          ssl->transform_in->ivlen,
   1805                                          ssl->transform_in->maclen ) );
   1806                      return( MBEDTLS_ERR_SSL_INVALID_MAC );
   1807                  }
   1808          
   1809                  dec_msglen = ssl->in_msglen;
   1810                  dec_msg = ssl->in_msg;
   1811                  dec_msg_result = ssl->in_msg;
   1812          
   1813                  /*
   1814                   * Authenticate before decrypt if enabled
   1815                   */
   1816          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   1817                  if( ssl->session_in->encrypt_then_mac == MBEDTLS_SSL_ETM_ENABLED )
   1818                  {
   1819                      unsigned char mac_expect[MBEDTLS_SSL_MAC_ADD];
   1820                      unsigned char pseudo_hdr[13];
   1821          
   1822                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "using encrypt then mac" ) );
   1823          
   1824                      dec_msglen -= ssl->transform_in->maclen;
   1825                      ssl->in_msglen -= ssl->transform_in->maclen;
   1826          
   1827                      memcpy( pseudo_hdr +  0, ssl->in_ctr, 8 );
   1828                      memcpy( pseudo_hdr +  8, ssl->in_hdr, 3 );
   1829                      pseudo_hdr[11] = (unsigned char)( ( ssl->in_msglen >> 8 ) & 0xFF );
   1830                      pseudo_hdr[12] = (unsigned char)( ( ssl->in_msglen      ) & 0xFF );
   1831          
   1832                      MBEDTLS_SSL_DEBUG_BUF( 4, "MAC'd meta-data", pseudo_hdr, 13 );
   1833          
   1834                      mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, pseudo_hdr, 13 );
   1835                      mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec,
   1836                                       ssl->in_iv, ssl->in_msglen );
   1837                      mbedtls_md_hmac_finish( &ssl->transform_in->md_ctx_dec, mac_expect );
   1838                      mbedtls_md_hmac_reset( &ssl->transform_in->md_ctx_dec );
   1839          
   1840                      MBEDTLS_SSL_DEBUG_BUF( 4, "message  mac", ssl->in_iv + ssl->in_msglen,
   1841                                                        ssl->transform_in->maclen );
   1842                      MBEDTLS_SSL_DEBUG_BUF( 4, "expected mac", mac_expect,
   1843                                                        ssl->transform_in->maclen );
   1844          
   1845                      if( mbedtls_ssl_safer_memcmp( ssl->in_iv + ssl->in_msglen, mac_expect,
   1846                                                    ssl->transform_in->maclen ) != 0 )
   1847                      {
   1848                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "message mac does not match" ) );
   1849          
   1850                          return( MBEDTLS_ERR_SSL_INVALID_MAC );
   1851                      }
   1852                      auth_done++;
   1853                  }
   1854          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
   1855          
   1856                  /*
   1857                   * Check length sanity
   1858                   */
   1859                  if( ssl->in_msglen % ssl->transform_in->ivlen != 0 )
   1860                  {
   1861                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "msglen (%d) %% ivlen (%d) != 0",
   1862                                     ssl->in_msglen, ssl->transform_in->ivlen ) );
   1863                      return( MBEDTLS_ERR_SSL_INVALID_MAC );
   1864                  }
   1865          
   1866          #if defined(MBEDTLS_SSL_PROTO_TLS1_1) || defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1867                  /*
   1868                   * Initialize for prepended IV for block cipher in TLS v1.1 and up
   1869                   */
   1870                  if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
   1871                  {
   1872                      dec_msglen -= ssl->transform_in->ivlen;
   1873                      ssl->in_msglen -= ssl->transform_in->ivlen;
   1874          
   1875                      for( i = 0; i < ssl->transform_in->ivlen; i++ )
   1876                          ssl->transform_in->iv_dec[i] = ssl->in_iv[i];
   1877                  }
   1878          #endif /* MBEDTLS_SSL_PROTO_TLS1_1 || MBEDTLS_SSL_PROTO_TLS1_2 */
   1879          
   1880                  if( ( ret = mbedtls_cipher_crypt( &ssl->transform_in->cipher_ctx_dec,
   1881                                             ssl->transform_in->iv_dec,
   1882                                             ssl->transform_in->ivlen,
   1883                                             dec_msg, dec_msglen,
   1884                                             dec_msg_result, &olen ) ) != 0 )
   1885                  {
   1886                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_cipher_crypt", ret );
   1887                      return( ret );
   1888                  }
   1889          
   1890                  if( dec_msglen != olen )
   1891                  {
   1892                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   1893                      return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   1894                  }
   1895          
   1896          #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1)
   1897                  if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_2 )
   1898                  {
   1899                      /*
   1900                       * Save IV in SSL3 and TLS1
   1901                       */
   1902                      memcpy( ssl->transform_in->iv_dec,
   1903                              ssl->transform_in->cipher_ctx_dec.iv,
   1904                              ssl->transform_in->ivlen );
   1905                  }
   1906          #endif
   1907          
   1908                  padlen = 1 + ssl->in_msg[ssl->in_msglen - 1];
   1909          
   1910                  if( ssl->in_msglen < ssl->transform_in->maclen + padlen &&
   1911                      auth_done == 0 )
   1912                  {
   1913          #if defined(MBEDTLS_SSL_DEBUG_ALL)
   1914                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "msglen (%d) < maclen (%d) + padlen (%d)",
   1915                                  ssl->in_msglen, ssl->transform_in->maclen, padlen ) );
   1916          #endif
   1917                      padlen = 0;
   1918                      correct = 0;
   1919                  }
   1920          
   1921          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   1922                  if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
   1923                  {
   1924                      if( padlen > ssl->transform_in->ivlen )
   1925                      {
   1926          #if defined(MBEDTLS_SSL_DEBUG_ALL)
   1927                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad padding length: is %d, "
   1928                                              "should be no more than %d",
   1929                                         padlen, ssl->transform_in->ivlen ) );
   1930          #endif
   1931                          correct = 0;
   1932                      }
   1933                  }
   1934                  else
   1935          #endif /* MBEDTLS_SSL_PROTO_SSL3 */
   1936          #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \
   1937              defined(MBEDTLS_SSL_PROTO_TLS1_2)
   1938                  if( ssl->minor_ver > MBEDTLS_SSL_MINOR_VERSION_0 )
   1939                  {
   1940                      /*
   1941                       * TLSv1+: always check the padding up to the first failure
   1942                       * and fake check up to 256 bytes of padding
   1943                       */
   1944                      size_t pad_count = 0, real_count = 1;
   1945                      size_t padding_idx = ssl->in_msglen - padlen;
   1946          
   1947                      /*
   1948                       * Padding is guaranteed to be incorrect if:
   1949                       *   1. padlen > ssl->in_msglen
   1950                       *
   1951                       *   2. padding_idx > MBEDTLS_SSL_MAX_CONTENT_LEN +
   1952                       *                     ssl->transform_in->maclen
   1953                       *
   1954                       * In both cases we reset padding_idx to a safe value (0) to
   1955                       * prevent out-of-buffer reads.
   1956                       */
   1957                      correct &= ( padlen <= ssl->in_msglen );
   1958                      correct &= ( padding_idx <= MBEDTLS_SSL_MAX_CONTENT_LEN +
   1959                                                 ssl->transform_in->maclen );
   1960          
   1961                      padding_idx *= correct;
   1962          
   1963                      for( i = 0; i < 256; i++ )
   1964                      {
   1965                          real_count &= ( i < padlen );
   1966                          pad_count += real_count *
   1967                                       ( ssl->in_msg[padding_idx + i] == padlen - 1 );
   1968                      }
   1969          
   1970                      correct &= ( pad_count == padlen ); /* Only 1 on correct padding */
   1971          
   1972          #if defined(MBEDTLS_SSL_DEBUG_ALL)
   1973                      if( padlen > 0 && correct == 0 )
   1974                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad padding byte detected" ) );
   1975          #endif
   1976                      padlen &= correct * 0x1FF;
   1977                  }
   1978                  else
   1979          #endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \
   1980                    MBEDTLS_SSL_PROTO_TLS1_2 */
   1981                  {
   1982                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   1983                      return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   1984                  }
   1985          
   1986                  ssl->in_msglen -= padlen;
   1987              }
   1988              else
   1989          #endif /* MBEDTLS_CIPHER_MODE_CBC &&
   1990                    ( MBEDTLS_AES_C || MBEDTLS_CAMELLIA_C ) */
   1991              {
   1992                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   1993                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   1994              }
   1995          
   1996          #if defined(MBEDTLS_SSL_DEBUG_ALL)
   1997              MBEDTLS_SSL_DEBUG_BUF( 4, "raw buffer after decryption",
   1998                             ssl->in_msg, ssl->in_msglen );
   1999          #endif
   2000          
   2001              /*
   2002               * Authenticate if not done yet.
   2003               * Compute the MAC regardless of the padding result (RFC4346, CBCTIME).
   2004               */
   2005          #if defined(SSL_SOME_MODES_USE_MAC)
   2006              if( auth_done == 0 )
   2007              {
   2008                  unsigned char mac_expect[MBEDTLS_SSL_MAC_ADD];
   2009          
   2010                  ssl->in_msglen -= ssl->transform_in->maclen;
   2011          
   2012                  ssl->in_len[0] = (unsigned char)( ssl->in_msglen >> 8 );
   2013                  ssl->in_len[1] = (unsigned char)( ssl->in_msglen      );
   2014          
   2015          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   2016                  if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
   2017                  {
   2018                      ssl_mac( &ssl->transform_in->md_ctx_dec,
   2019                                ssl->transform_in->mac_dec,
   2020                                ssl->in_msg, ssl->in_msglen,
   2021                                ssl->in_ctr, ssl->in_msgtype,
   2022                                mac_expect );
   2023                  }
   2024                  else
   2025          #endif /* MBEDTLS_SSL_PROTO_SSL3 */
   2026          #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \
   2027                  defined(MBEDTLS_SSL_PROTO_TLS1_2)
   2028                  if( ssl->minor_ver > MBEDTLS_SSL_MINOR_VERSION_0 )
   2029                  {
   2030                      /*
   2031                       * Process MAC and always update for padlen afterwards to make
   2032                       * total time independent of padlen.
   2033                       *
   2034                       * Known timing attacks:
   2035                       *  - Lucky Thirteen (http://www.isg.rhul.ac.uk/tls/TLStiming.pdf)
   2036                       *
   2037                       * To compensate for different timings for the MAC calculation
   2038                       * depending on how much padding was removed (which is determined
   2039                       * by padlen), process extra_run more blocks through the hash
   2040                       * function.
   2041                       *
   2042                       * The formula in the paper is
   2043                       *   extra_run = ceil( (L1-55) / 64 ) - ceil( (L2-55) / 64 )
   2044                       * where L1 is the size of the header plus the decrypted message
   2045                       * plus CBC padding and L2 is the size of the header plus the
   2046                       * decrypted message. This is for an underlying hash function
   2047                       * with 64-byte blocks.
   2048                       * We use ( (Lx+8) / 64 ) to handle 'negative Lx' values
   2049                       * correctly. We round down instead of up, so -56 is the correct
   2050                       * value for our calculations instead of -55.
   2051                       *
   2052                       * Repeat the formula rather than defining a block_size variable.
   2053                       * This avoids requiring division by a variable at runtime
   2054                       * (which would be marginally less efficient and would require
   2055                       * linking an extra division function in some builds).
   2056                       */
   2057                      size_t j, extra_run = 0;
   2058          
   2059                      /*
   2060                       * The next two sizes are the minimum and maximum values of
   2061                       * in_msglen over all padlen values.
   2062                       *
   2063                       * They're independent of padlen, since we previously did
   2064                       * in_msglen -= padlen.
   2065                       *
   2066                       * Note that max_len + maclen is never more than the buffer
   2067                       * length, as we previously did in_msglen -= maclen too.
   2068                       */
   2069                      const size_t max_len = ssl->in_msglen + padlen;
   2070                      const size_t min_len = ( max_len > 256 ) ? max_len - 256 : 0;
   2071          
   2072                      switch( ssl->transform_in->ciphersuite_info->mac )
   2073                      {
   2074          #if defined(MBEDTLS_MD5_C) || defined(MBEDTLS_SHA1_C) || \
   2075              defined(MBEDTLS_SHA256_C)
   2076                          case MBEDTLS_MD_MD5:
   2077                          case MBEDTLS_MD_SHA1:
   2078                          case MBEDTLS_MD_SHA256:
   2079                              /* 8 bytes of message size, 64-byte compression blocks */
   2080                              extra_run = ( 13 + ssl->in_msglen + padlen + 8 ) / 64 -
   2081                                          ( 13 + ssl->in_msglen          + 8 ) / 64;
   2082                              break;
   2083          #endif
   2084          #if defined(MBEDTLS_SHA512_C)
   2085                          case MBEDTLS_MD_SHA384:
   2086                              /* 16 bytes of message size, 128-byte compression blocks */
   2087                              extra_run = ( 13 + ssl->in_msglen + padlen + 16 ) / 128 -
   2088                                          ( 13 + ssl->in_msglen          + 16 ) / 128;
   2089                              break;
   2090          #endif
   2091                          default:
   2092                              MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   2093                              return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   2094                      }
   2095          
   2096                      extra_run &= correct * 0xFF;
   2097          
   2098                      mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, ssl->in_ctr, 8 );
   2099                      mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, ssl->in_hdr, 3 );
   2100                      mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, ssl->in_len, 2 );
   2101                      mbedtls_md_hmac_update( &ssl->transform_in->md_ctx_dec, ssl->in_msg,
   2102                                       ssl->in_msglen );
   2103                      /* Make sure we access everything even when padlen > 0. This
   2104                       * makes the synchronisation requirements for just-in-time
   2105                       * Prime+Probe attacks much tighter and hopefully impractical. */
   2106                      ssl_read_memory( ssl->in_msg + ssl->in_msglen, padlen );
   2107                      mbedtls_md_hmac_finish( &ssl->transform_in->md_ctx_dec, mac_expect );
   2108          
   2109                      /* Call mbedtls_md_process at least once due to cache attacks
   2110                       * that observe whether md_process() was called of not */
   2111                      for( j = 0; j < extra_run + 1; j++ )
   2112                          mbedtls_md_process( &ssl->transform_in->md_ctx_dec, ssl->in_msg );
   2113          
   2114                      mbedtls_md_hmac_reset( &ssl->transform_in->md_ctx_dec );
   2115          
   2116                      /* Make sure we access all the memory that could contain the MAC,
   2117                       * before we check it in the next code block. This makes the
   2118                       * synchronisation requirements for just-in-time Prime+Probe
   2119                       * attacks much tighter and hopefully impractical. */
   2120                      ssl_read_memory( ssl->in_msg + min_len,
   2121                                           max_len - min_len + ssl->transform_in->maclen );
   2122                  }
   2123                  else
   2124          #endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \
   2125                        MBEDTLS_SSL_PROTO_TLS1_2 */
   2126                  {
   2127                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   2128                      return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   2129                  }
   2130          
   2131          #if defined(MBEDTLS_SSL_DEBUG_ALL)
   2132                  MBEDTLS_SSL_DEBUG_BUF( 4, "expected mac", mac_expect, ssl->transform_in->maclen );
   2133                  MBEDTLS_SSL_DEBUG_BUF( 4, "message  mac", ssl->in_msg + ssl->in_msglen,
   2134                                         ssl->transform_in->maclen );
   2135          #endif
   2136          
   2137                  if( mbedtls_ssl_safer_memcmp( ssl->in_msg + ssl->in_msglen, mac_expect,
   2138                                                ssl->transform_in->maclen ) != 0 )
   2139                  {
   2140          #if defined(MBEDTLS_SSL_DEBUG_ALL)
   2141                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "message mac does not match" ) );
   2142          #endif
   2143                      correct = 0;
   2144                  }
   2145                  auth_done++;
   2146              }
   2147          
   2148              /*
   2149               * Finally check the correct flag
   2150               */
   2151              if( correct == 0 )
   2152                  return( MBEDTLS_ERR_SSL_INVALID_MAC );
   2153          #endif /* SSL_SOME_MODES_USE_MAC */
   2154          
   2155              /* Make extra sure authentication was performed, exactly once */
   2156              if( auth_done != 1 )
   2157              {
   2158                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   2159                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   2160              }
   2161          
   2162              if( ssl->in_msglen == 0 )
   2163              {
   2164          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   2165                  if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3
   2166                      && ssl->in_msgtype != MBEDTLS_SSL_MSG_APPLICATION_DATA )
   2167                  {
   2168                      /* TLS v1.2 explicitly disallows zero-length messages which are not application data */
   2169                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "invalid zero-length message type: %d", ssl->in_msgtype ) );
   2170                      return( MBEDTLS_ERR_SSL_INVALID_RECORD );
   2171                  }
   2172          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   2173          
   2174                  ssl->nb_zero++;
   2175          
   2176                  /*
   2177                   * Three or more empty messages may be a DoS attack
   2178                   * (excessive CPU consumption).
   2179                   */
   2180                  if( ssl->nb_zero > 3 )
   2181                  {
   2182                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "received four consecutive empty "
   2183                                          "messages, possible DoS attack" ) );
   2184                      return( MBEDTLS_ERR_SSL_INVALID_MAC );
   2185                  }
   2186              }
   2187              else
   2188                  ssl->nb_zero = 0;
   2189          
   2190          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   2191              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   2192              {
   2193                  ; /* in_ctr read from peer, not maintained internally */
   2194              }
   2195              else
   2196          #endif
   2197              {
   2198                  for( i = 8; i > ssl_ep_len( ssl ); i-- )
   2199                      if( ++ssl->in_ctr[i - 1] != 0 )
   2200                          break;
   2201          
   2202                  /* The loop goes to its end iff the counter is wrapping */
   2203                  if( i == ssl_ep_len( ssl ) )
   2204                  {
   2205                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "incoming message counter would wrap" ) );
   2206                      return( MBEDTLS_ERR_SSL_COUNTER_WRAPPING );
   2207                  }
   2208              }
   2209          
   2210              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= decrypt buf" ) );
   2211          
   2212              return( 0 );
   2213          }
   2214          
   2215          #undef MAC_NONE
   2216          #undef MAC_PLAINTEXT
   2217          #undef MAC_CIPHERTEXT
   2218          
   2219          #if defined(MBEDTLS_ZLIB_SUPPORT)
   2220          /*
   2221           * Compression/decompression functions
   2222           */
   2223          static int ssl_compress_buf( mbedtls_ssl_context *ssl )
   2224          {
   2225              int ret;
   2226              unsigned char *msg_post = ssl->out_msg;
   2227              ptrdiff_t bytes_written = ssl->out_msg - ssl->out_buf;
   2228              size_t len_pre = ssl->out_msglen;
   2229              unsigned char *msg_pre = ssl->compress_buf;
   2230          
   2231              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> compress buf" ) );
   2232          
   2233              if( len_pre == 0 )
   2234                  return( 0 );
   2235          
   2236              memcpy( msg_pre, ssl->out_msg, len_pre );
   2237          
   2238              MBEDTLS_SSL_DEBUG_MSG( 3, ( "before compression: msglen = %d, ",
   2239                             ssl->out_msglen ) );
   2240          
   2241              MBEDTLS_SSL_DEBUG_BUF( 4, "before compression: output payload",
   2242                             ssl->out_msg, ssl->out_msglen );
   2243          
   2244              ssl->transform_out->ctx_deflate.next_in = msg_pre;
   2245              ssl->transform_out->ctx_deflate.avail_in = len_pre;
   2246              ssl->transform_out->ctx_deflate.next_out = msg_post;
   2247              ssl->transform_out->ctx_deflate.avail_out = MBEDTLS_SSL_BUFFER_LEN - bytes_written;
   2248          
   2249              ret = deflate( &ssl->transform_out->ctx_deflate, Z_SYNC_FLUSH );
   2250              if( ret != Z_OK )
   2251              {
   2252                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "failed to perform compression (%d)", ret ) );
   2253                  return( MBEDTLS_ERR_SSL_COMPRESSION_FAILED );
   2254              }
   2255          
   2256              ssl->out_msglen = MBEDTLS_SSL_BUFFER_LEN -
   2257                                ssl->transform_out->ctx_deflate.avail_out - bytes_written;
   2258          
   2259              MBEDTLS_SSL_DEBUG_MSG( 3, ( "after compression: msglen = %d, ",
   2260                             ssl->out_msglen ) );
   2261          
   2262              MBEDTLS_SSL_DEBUG_BUF( 4, "after compression: output payload",
   2263                             ssl->out_msg, ssl->out_msglen );
   2264          
   2265              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= compress buf" ) );
   2266          
   2267              return( 0 );
   2268          }
   2269          
   2270          static int ssl_decompress_buf( mbedtls_ssl_context *ssl )
   2271          {
   2272              int ret;
   2273              unsigned char *msg_post = ssl->in_msg;
   2274              ptrdiff_t header_bytes = ssl->in_msg - ssl->in_buf;
   2275              size_t len_pre = ssl->in_msglen;
   2276              unsigned char *msg_pre = ssl->compress_buf;
   2277          
   2278              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> decompress buf" ) );
   2279          
   2280              if( len_pre == 0 )
   2281                  return( 0 );
   2282          
   2283              memcpy( msg_pre, ssl->in_msg, len_pre );
   2284          
   2285              MBEDTLS_SSL_DEBUG_MSG( 3, ( "before decompression: msglen = %d, ",
   2286                             ssl->in_msglen ) );
   2287          
   2288              MBEDTLS_SSL_DEBUG_BUF( 4, "before decompression: input payload",
   2289                             ssl->in_msg, ssl->in_msglen );
   2290          
   2291              ssl->transform_in->ctx_inflate.next_in = msg_pre;
   2292              ssl->transform_in->ctx_inflate.avail_in = len_pre;
   2293              ssl->transform_in->ctx_inflate.next_out = msg_post;
   2294              ssl->transform_in->ctx_inflate.avail_out = MBEDTLS_SSL_BUFFER_LEN -
   2295                                                         header_bytes;
   2296          
   2297              ret = inflate( &ssl->transform_in->ctx_inflate, Z_SYNC_FLUSH );
   2298              if( ret != Z_OK )
   2299              {
   2300                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "failed to perform decompression (%d)", ret ) );
   2301                  return( MBEDTLS_ERR_SSL_COMPRESSION_FAILED );
   2302              }
   2303          
   2304              ssl->in_msglen = MBEDTLS_SSL_BUFFER_LEN -
   2305                               ssl->transform_in->ctx_inflate.avail_out - header_bytes;
   2306          
   2307              MBEDTLS_SSL_DEBUG_MSG( 3, ( "after decompression: msglen = %d, ",
   2308                             ssl->in_msglen ) );
   2309          
   2310              MBEDTLS_SSL_DEBUG_BUF( 4, "after decompression: input payload",
   2311                             ssl->in_msg, ssl->in_msglen );
   2312          
   2313              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= decompress buf" ) );
   2314          
   2315              return( 0 );
   2316          }
   2317          #endif /* MBEDTLS_ZLIB_SUPPORT */
   2318          
   2319          #if defined(MBEDTLS_SSL_SRV_C) && defined(MBEDTLS_SSL_RENEGOTIATION)
   2320          static int ssl_write_hello_request( mbedtls_ssl_context *ssl );
   2321          
   2322          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   2323          static int ssl_resend_hello_request( mbedtls_ssl_context *ssl )
   2324          {
   2325              /* If renegotiation is not enforced, retransmit until we would reach max
   2326               * timeout if we were using the usual handshake doubling scheme */
   2327              if( ssl->conf->renego_max_records < 0 )
   2328              {
   2329                  uint32_t ratio = ssl->conf->hs_timeout_max / ssl->conf->hs_timeout_min + 1;
   2330                  unsigned char doublings = 1;
   2331          
   2332                  while( ratio != 0 )
   2333                  {
   2334                      ++doublings;
   2335                      ratio >>= 1;
   2336                  }
   2337          
   2338                  if( ++ssl->renego_records_seen > doublings )
   2339                  {
   2340                      MBEDTLS_SSL_DEBUG_MSG( 2, ( "no longer retransmitting hello request" ) );
   2341                      return( 0 );
   2342                  }
   2343              }
   2344          
   2345              return( ssl_write_hello_request( ssl ) );
   2346          }
   2347          #endif
   2348          #endif /* MBEDTLS_SSL_SRV_C && MBEDTLS_SSL_RENEGOTIATION */
   2349          
   2350          /*
   2351           * Fill the input message buffer by appending data to it.
   2352           * The amount of data already fetched is in ssl->in_left.
   2353           *
   2354           * If we return 0, is it guaranteed that (at least) nb_want bytes are
   2355           * available (from this read and/or a previous one). Otherwise, an error code
   2356           * is returned (possibly EOF or WANT_READ).
   2357           *
   2358           * With stream transport (TLS) on success ssl->in_left == nb_want, but
   2359           * with datagram transport (DTLS) on success ssl->in_left >= nb_want,
   2360           * since we always read a whole datagram at once.
   2361           *
   2362           * For DTLS, it is up to the caller to set ssl->next_record_offset when
   2363           * they're done reading a record.
   2364           */
   2365          int mbedtls_ssl_fetch_input( mbedtls_ssl_context *ssl, size_t nb_want )
   2366          {
   2367              int ret;
   2368              size_t len;
   2369          
   2370              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> fetch input" ) );
   2371          
   2372              if( ssl->f_recv == NULL && ssl->f_recv_timeout == NULL )
   2373              {
   2374                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "Bad usage of mbedtls_ssl_set_bio() "
   2375                                      "or mbedtls_ssl_set_bio()" ) );
   2376                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   2377              }
   2378          
   2379              if( nb_want > MBEDTLS_SSL_BUFFER_LEN - (size_t)( ssl->in_hdr - ssl->in_buf ) )
   2380              {
   2381                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "requesting more data than fits" ) );
   2382                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   2383              }
   2384          
   2385          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   2386              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   2387              {
   2388                  uint32_t timeout;
   2389          
   2390                  /* Just to be sure */
   2391                  if( ssl->f_set_timer == NULL || ssl->f_get_timer == NULL )
   2392                  {
   2393                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "You must use "
   2394                                  "mbedtls_ssl_set_timer_cb() for DTLS" ) );
   2395                      return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   2396                  }
   2397          
   2398                  /*
   2399                   * The point is, we need to always read a full datagram at once, so we
   2400                   * sometimes read more then requested, and handle the additional data.
   2401                   * It could be the rest of the current record (while fetching the
   2402                   * header) and/or some other records in the same datagram.
   2403                   */
   2404          
   2405                  /*
   2406                   * Move to the next record in the already read datagram if applicable
   2407                   */
   2408                  if( ssl->next_record_offset != 0 )
   2409                  {
   2410                      if( ssl->in_left < ssl->next_record_offset )
   2411                      {
   2412                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   2413                          return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   2414                      }
   2415          
   2416                      ssl->in_left -= ssl->next_record_offset;
   2417          
   2418                      if( ssl->in_left != 0 )
   2419                      {
   2420                          MBEDTLS_SSL_DEBUG_MSG( 2, ( "next record in same datagram, offset: %d",
   2421                                              ssl->next_record_offset ) );
   2422                          memmove( ssl->in_hdr,
   2423                                   ssl->in_hdr + ssl->next_record_offset,
   2424                                   ssl->in_left );
   2425                      }
   2426          
   2427                      ssl->next_record_offset = 0;
   2428                  }
   2429          
   2430                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "in_left: %d, nb_want: %d",
   2431                                 ssl->in_left, nb_want ) );
   2432          
   2433                  /*
   2434                   * Done if we already have enough data.
   2435                   */
   2436                  if( nb_want <= ssl->in_left)
   2437                  {
   2438                      MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= fetch input" ) );
   2439                      return( 0 );
   2440                  }
   2441          
   2442                  /*
   2443                   * A record can't be split accross datagrams. If we need to read but
   2444                   * are not at the beginning of a new record, the caller did something
   2445                   * wrong.
   2446                   */
   2447                  if( ssl->in_left != 0 )
   2448                  {
   2449                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   2450                      return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   2451                  }
   2452          
   2453                  /*
   2454                   * Don't even try to read if time's out already.
   2455                   * This avoids by-passing the timer when repeatedly receiving messages
   2456                   * that will end up being dropped.
   2457                   */
   2458                  if( ssl_check_timer( ssl ) != 0 )
   2459                      ret = MBEDTLS_ERR_SSL_TIMEOUT;
   2460                  else
   2461                  {
   2462                      len = MBEDTLS_SSL_BUFFER_LEN - ( ssl->in_hdr - ssl->in_buf );
   2463          
   2464                      if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
   2465                          timeout = ssl->handshake->retransmit_timeout;
   2466                      else
   2467                          timeout = ssl->conf->read_timeout;
   2468          
   2469                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "f_recv_timeout: %u ms", timeout ) );
   2470          
   2471                      if( ssl->f_recv_timeout != NULL )
   2472                          ret = ssl->f_recv_timeout( ssl->p_bio, ssl->in_hdr, len,
   2473                                                                              timeout );
   2474                      else
   2475                          ret = ssl->f_recv( ssl->p_bio, ssl->in_hdr, len );
   2476          
   2477                      MBEDTLS_SSL_DEBUG_RET( 2, "ssl->f_recv(_timeout)", ret );
   2478          
   2479                      if( ret == 0 )
   2480                          return( MBEDTLS_ERR_SSL_CONN_EOF );
   2481                  }
   2482          
   2483                  if( ret == MBEDTLS_ERR_SSL_TIMEOUT )
   2484                  {
   2485                      MBEDTLS_SSL_DEBUG_MSG( 2, ( "timeout" ) );
   2486                      ssl_set_timer( ssl, 0 );
   2487          
   2488                      if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
   2489                      {
   2490                          if( ssl_double_retransmit_timeout( ssl ) != 0 )
   2491                          {
   2492                              MBEDTLS_SSL_DEBUG_MSG( 1, ( "handshake timeout" ) );
   2493                              return( MBEDTLS_ERR_SSL_TIMEOUT );
   2494                          }
   2495          
   2496                          if( ( ret = mbedtls_ssl_resend( ssl ) ) != 0 )
   2497                          {
   2498                              MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_resend", ret );
   2499                              return( ret );
   2500                          }
   2501          
   2502                          return( MBEDTLS_ERR_SSL_WANT_READ );
   2503                      }
   2504          #if defined(MBEDTLS_SSL_SRV_C) && defined(MBEDTLS_SSL_RENEGOTIATION)
   2505                      else if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
   2506                               ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING )
   2507                      {
   2508                          if( ( ret = ssl_resend_hello_request( ssl ) ) != 0 )
   2509                          {
   2510                              MBEDTLS_SSL_DEBUG_RET( 1, "ssl_resend_hello_request", ret );
   2511                              return( ret );
   2512                          }
   2513          
   2514                          return( MBEDTLS_ERR_SSL_WANT_READ );
   2515                      }
   2516          #endif /* MBEDTLS_SSL_SRV_C && MBEDTLS_SSL_RENEGOTIATION */
   2517                  }
   2518          
   2519                  if( ret < 0 )
   2520                      return( ret );
   2521          
   2522                  ssl->in_left = ret;
   2523              }
   2524              else
   2525          #endif
   2526              {
   2527                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "in_left: %d, nb_want: %d",
   2528                                 ssl->in_left, nb_want ) );
   2529          
   2530                  while( ssl->in_left < nb_want )
   2531                  {
   2532                      len = nb_want - ssl->in_left;
   2533          
   2534                      if( ssl_check_timer( ssl ) != 0 )
   2535                          ret = MBEDTLS_ERR_SSL_TIMEOUT;
   2536                      else
   2537                      {
   2538                          if( ssl->f_recv_timeout != NULL )
   2539                          {
   2540                              ret = ssl->f_recv_timeout( ssl->p_bio,
   2541                                                         ssl->in_hdr + ssl->in_left, len,
   2542                                                         ssl->conf->read_timeout );
   2543                          }
   2544                          else
   2545                          {
   2546                              ret = ssl->f_recv( ssl->p_bio,
   2547                                                 ssl->in_hdr + ssl->in_left, len );
   2548                          }
   2549                      }
   2550          
   2551                      MBEDTLS_SSL_DEBUG_MSG( 2, ( "in_left: %d, nb_want: %d",
   2552                                                  ssl->in_left, nb_want ) );
   2553                      MBEDTLS_SSL_DEBUG_RET( 2, "ssl->f_recv(_timeout)", ret );
   2554          
   2555                      if( ret == 0 )
   2556                          return( MBEDTLS_ERR_SSL_CONN_EOF );
   2557          
   2558                      if( ret < 0 )
   2559                          return( ret );
   2560          
   2561                      if ( (size_t)ret > len || ( INT_MAX > SIZE_MAX && ret > SIZE_MAX ) )
   2562                      {
   2563                          MBEDTLS_SSL_DEBUG_MSG( 1,
   2564                              ( "f_recv returned %d bytes but only %lu were requested",
   2565                              ret, (unsigned long)len ) );
   2566                          return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   2567                      }
   2568          
   2569                      ssl->in_left += ret;
   2570                  }
   2571              }
   2572          
   2573              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= fetch input" ) );
   2574          
   2575              return( 0 );
   2576          }
   2577          
   2578          /*
   2579           * Flush any data not yet written
   2580           */
   2581          int mbedtls_ssl_flush_output( mbedtls_ssl_context *ssl )
   2582          {
   2583              int ret;
   2584              unsigned char *buf, i;
   2585          
   2586              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> flush output" ) );
   2587          
   2588              if( ssl->f_send == NULL )
   2589              {
   2590                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "Bad usage of mbedtls_ssl_set_bio() "
   2591                                      "or mbedtls_ssl_set_bio()" ) );
   2592                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   2593              }
   2594          
   2595              /* Avoid incrementing counter if data is flushed */
   2596              if( ssl->out_left == 0 )
   2597              {
   2598                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= flush output" ) );
   2599                  return( 0 );
   2600              }
   2601          
   2602              while( ssl->out_left > 0 )
   2603              {
   2604                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "message length: %d, out_left: %d",
   2605                                 mbedtls_ssl_hdr_len( ssl ) + ssl->out_msglen, ssl->out_left ) );
   2606          
   2607                  buf = ssl->out_hdr + mbedtls_ssl_hdr_len( ssl ) +
   2608                        ssl->out_msglen - ssl->out_left;
   2609                  ret = ssl->f_send( ssl->p_bio, buf, ssl->out_left );
   2610          
   2611                  MBEDTLS_SSL_DEBUG_RET( 2, "ssl->f_send", ret );
   2612          
   2613                  if( ret <= 0 )
   2614                      return( ret );
   2615          
   2616                  if( (size_t)ret > ssl->out_left || ( INT_MAX > SIZE_MAX && ret > SIZE_MAX ) )
   2617                  {
   2618                      MBEDTLS_SSL_DEBUG_MSG( 1,
   2619                          ( "f_send returned %d bytes but only %lu bytes were sent",
   2620                          ret, (unsigned long)ssl->out_left ) );
   2621                      return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   2622                  }
   2623          
   2624                  ssl->out_left -= ret;
   2625              }
   2626          
   2627              for( i = 8; i > ssl_ep_len( ssl ); i-- )
   2628                  if( ++ssl->out_ctr[i - 1] != 0 )
   2629                      break;
   2630          
   2631              /* The loop goes to its end iff the counter is wrapping */
   2632              if( i == ssl_ep_len( ssl ) )
   2633              {
   2634                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "outgoing message counter would wrap" ) );
   2635                  return( MBEDTLS_ERR_SSL_COUNTER_WRAPPING );
   2636              }
   2637          
   2638              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= flush output" ) );
   2639          
   2640              return( 0 );
   2641          }
   2642          
   2643          /*
   2644           * Functions to handle the DTLS retransmission state machine
   2645           */
   2646          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   2647          /*
   2648           * Append current handshake message to current outgoing flight
   2649           */
   2650          static int ssl_flight_append( mbedtls_ssl_context *ssl )
   2651          {
   2652              mbedtls_ssl_flight_item *msg;
   2653          
   2654              /* Allocate space for current message */
   2655              if( ( msg = mbedtls_calloc( 1, sizeof(  mbedtls_ssl_flight_item ) ) ) == NULL )
   2656              {
   2657                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc %d bytes failed",
   2658                                      sizeof( mbedtls_ssl_flight_item ) ) );
   2659                  return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
   2660              }
   2661          
   2662              if( ( msg->p = mbedtls_calloc( 1, ssl->out_msglen ) ) == NULL )
   2663              {
   2664                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc %d bytes failed", ssl->out_msglen ) );
   2665                  mbedtls_free( msg );
   2666                  return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
   2667              }
   2668          
   2669              /* Copy current handshake message with headers */
   2670              memcpy( msg->p, ssl->out_msg, ssl->out_msglen );
   2671              msg->len = ssl->out_msglen;
   2672              msg->type = ssl->out_msgtype;
   2673              msg->next = NULL;
   2674          
   2675              /* Append to the current flight */
   2676              if( ssl->handshake->flight == NULL )
   2677                  ssl->handshake->flight = msg;
   2678              else
   2679              {
   2680                  mbedtls_ssl_flight_item *cur = ssl->handshake->flight;
   2681                  while( cur->next != NULL )
   2682                      cur = cur->next;
   2683                  cur->next = msg;
   2684              }
   2685          
   2686              return( 0 );
   2687          }
   2688          
   2689          /*
   2690           * Free the current flight of handshake messages
   2691           */
   2692          static void ssl_flight_free( mbedtls_ssl_flight_item *flight )
   2693          {
   2694              mbedtls_ssl_flight_item *cur = flight;
   2695              mbedtls_ssl_flight_item *next;
   2696          
   2697              while( cur != NULL )
   2698              {
   2699                  next = cur->next;
   2700          
   2701                  mbedtls_free( cur->p );
   2702                  mbedtls_free( cur );
   2703          
   2704                  cur = next;
   2705              }
   2706          }
   2707          
   2708          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   2709          static void ssl_dtls_replay_reset( mbedtls_ssl_context *ssl );
   2710          #endif
   2711          
   2712          /*
   2713           * Swap transform_out and out_ctr with the alternative ones
   2714           */
   2715          static void ssl_swap_epochs( mbedtls_ssl_context *ssl )
   2716          {
   2717              mbedtls_ssl_transform *tmp_transform;
   2718              unsigned char tmp_out_ctr[8];
   2719          
   2720              if( ssl->transform_out == ssl->handshake->alt_transform_out )
   2721              {
   2722                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "skip swap epochs" ) );
   2723                  return;
   2724              }
   2725          
   2726              MBEDTLS_SSL_DEBUG_MSG( 3, ( "swap epochs" ) );
   2727          
   2728              /* Swap transforms */
   2729              tmp_transform                     = ssl->transform_out;
   2730              ssl->transform_out                = ssl->handshake->alt_transform_out;
   2731              ssl->handshake->alt_transform_out = tmp_transform;
   2732          
   2733              /* Swap epoch + sequence_number */
   2734              memcpy( tmp_out_ctr,                 ssl->out_ctr,                8 );
   2735              memcpy( ssl->out_ctr,                ssl->handshake->alt_out_ctr, 8 );
   2736              memcpy( ssl->handshake->alt_out_ctr, tmp_out_ctr,                 8 );
   2737          
   2738              /* Adjust to the newly activated transform */
   2739              if( ssl->transform_out != NULL &&
   2740                  ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
   2741              {
   2742                  ssl->out_msg = ssl->out_iv + ssl->transform_out->ivlen -
   2743                                               ssl->transform_out->fixed_ivlen;
   2744              }
   2745              else
   2746                  ssl->out_msg = ssl->out_iv;
   2747          
   2748          #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
   2749              if( mbedtls_ssl_hw_record_activate != NULL )
   2750              {
   2751                  if( ( ret = mbedtls_ssl_hw_record_activate( ssl, MBEDTLS_SSL_CHANNEL_OUTBOUND ) ) != 0 )
   2752                  {
   2753                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_hw_record_activate", ret );
   2754                      return( MBEDTLS_ERR_SSL_HW_ACCEL_FAILED );
   2755                  }
   2756              }
   2757          #endif
   2758          }
   2759          
   2760          /*
   2761           * Retransmit the current flight of messages.
   2762           *
   2763           * Need to remember the current message in case flush_output returns
   2764           * WANT_WRITE, causing us to exit this function and come back later.
   2765           * This function must be called until state is no longer SENDING.
   2766           */
   2767          int mbedtls_ssl_resend( mbedtls_ssl_context *ssl )
   2768          {
   2769              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> mbedtls_ssl_resend" ) );
   2770          
   2771              if( ssl->handshake->retransmit_state != MBEDTLS_SSL_RETRANS_SENDING )
   2772              {
   2773                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "initialise resending" ) );
   2774          
   2775                  ssl->handshake->cur_msg = ssl->handshake->flight;
   2776                  ssl_swap_epochs( ssl );
   2777          
   2778                  ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_SENDING;
   2779              }
   2780          
   2781              while( ssl->handshake->cur_msg != NULL )
   2782              {
   2783                  int ret;
   2784                  mbedtls_ssl_flight_item *cur = ssl->handshake->cur_msg;
   2785          
   2786                  /* Swap epochs before sending Finished: we can't do it after
   2787                   * sending ChangeCipherSpec, in case write returns WANT_READ.
   2788                   * Must be done before copying, may change out_msg pointer */
   2789                  if( cur->type == MBEDTLS_SSL_MSG_HANDSHAKE &&
   2790                      cur->p[0] == MBEDTLS_SSL_HS_FINISHED )
   2791                  {
   2792                      ssl_swap_epochs( ssl );
   2793                  }
   2794          
   2795                  memcpy( ssl->out_msg, cur->p, cur->len );
   2796                  ssl->out_msglen = cur->len;
   2797                  ssl->out_msgtype = cur->type;
   2798          
   2799                  ssl->handshake->cur_msg = cur->next;
   2800          
   2801                  MBEDTLS_SSL_DEBUG_BUF( 3, "resent handshake message header", ssl->out_msg, 12 );
   2802          
   2803                  if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
   2804                  {
   2805                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
   2806                      return( ret );
   2807                  }
   2808              }
   2809          
   2810              if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER )
   2811                  ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_FINISHED;
   2812              else
   2813              {
   2814                  ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_WAITING;
   2815                  ssl_set_timer( ssl, ssl->handshake->retransmit_timeout );
   2816              }
   2817          
   2818              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= mbedtls_ssl_resend" ) );
   2819          
   2820              return( 0 );
   2821          }
   2822          
   2823          /*
   2824           * To be called when the last message of an incoming flight is received.
   2825           */
   2826          void mbedtls_ssl_recv_flight_completed( mbedtls_ssl_context *ssl )
   2827          {
   2828              /* We won't need to resend that one any more */
   2829              ssl_flight_free( ssl->handshake->flight );
   2830              ssl->handshake->flight = NULL;
   2831              ssl->handshake->cur_msg = NULL;
   2832          
   2833              /* The next incoming flight will start with this msg_seq */
   2834              ssl->handshake->in_flight_start_seq = ssl->handshake->in_msg_seq;
   2835          
   2836              /* Cancel timer */
   2837              ssl_set_timer( ssl, 0 );
   2838          
   2839              if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
   2840                  ssl->in_msg[0] == MBEDTLS_SSL_HS_FINISHED )
   2841              {
   2842                  ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_FINISHED;
   2843              }
   2844              else
   2845                  ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_PREPARING;
   2846          }
   2847          
   2848          /*
   2849           * To be called when the last message of an outgoing flight is send.
   2850           */
   2851          void mbedtls_ssl_send_flight_completed( mbedtls_ssl_context *ssl )
   2852          {
   2853              ssl_reset_retransmit_timeout( ssl );
   2854              ssl_set_timer( ssl, ssl->handshake->retransmit_timeout );
   2855          
   2856              if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
   2857                  ssl->in_msg[0] == MBEDTLS_SSL_HS_FINISHED )
   2858              {
   2859                  ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_FINISHED;
   2860              }
   2861              else
   2862                  ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_WAITING;
   2863          }
   2864          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   2865          
   2866          /*
   2867           * Record layer functions
   2868           */
   2869          
   2870          /*
   2871           * Write current record.
   2872           * Uses ssl->out_msgtype, ssl->out_msglen and bytes at ssl->out_msg.
   2873           */
   2874          int mbedtls_ssl_write_record( mbedtls_ssl_context *ssl )
   2875          {
   2876              int ret, done = 0, out_msg_type;
   2877              size_t len = ssl->out_msglen;
   2878          
   2879              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write record" ) );
   2880          
   2881          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   2882              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   2883                  ssl->handshake != NULL &&
   2884                  ssl->handshake->retransmit_state == MBEDTLS_SSL_RETRANS_SENDING )
   2885              {
   2886                  ; /* Skip special handshake treatment when resending */
   2887              }
   2888              else
   2889          #endif
   2890              if( ssl->out_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
   2891              {
   2892                  out_msg_type = ssl->out_msg[0];
   2893          
   2894                  if( out_msg_type != MBEDTLS_SSL_HS_HELLO_REQUEST &&
   2895                      ssl->handshake == NULL )
   2896                  {
   2897                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   2898                      return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   2899                  }
   2900          
   2901                  ssl->out_msg[1] = (unsigned char)( ( len - 4 ) >> 16 );
   2902                  ssl->out_msg[2] = (unsigned char)( ( len - 4 ) >>  8 );
   2903                  ssl->out_msg[3] = (unsigned char)( ( len - 4 )       );
   2904          
   2905                  /*
   2906                   * DTLS has additional fields in the Handshake layer,
   2907                   * between the length field and the actual payload:
   2908                   *      uint16 message_seq;
   2909                   *      uint24 fragment_offset;
   2910                   *      uint24 fragment_length;
   2911                   */
   2912          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   2913                  if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   2914                  {
   2915                      /* Make room for the additional DTLS fields */
   2916                      if( MBEDTLS_SSL_MAX_CONTENT_LEN - ssl->out_msglen < 8 )
   2917                      {
   2918                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "DTLS handshake message too large: "
   2919                                        "size %u, maximum %u",
   2920                                         (unsigned) ( ssl->in_hslen - 4 ),
   2921                                         (unsigned) ( MBEDTLS_SSL_MAX_CONTENT_LEN - 12 ) ) );
   2922                          return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   2923                      }
   2924          
   2925                      memmove( ssl->out_msg + 12, ssl->out_msg + 4, len - 4 );
   2926                      ssl->out_msglen += 8;
   2927                      len += 8;
   2928          
   2929                      /* Write message_seq and update it, except for HelloRequest */
   2930                      if( out_msg_type != MBEDTLS_SSL_HS_HELLO_REQUEST )
   2931                      {
   2932                          ssl->out_msg[4] = ( ssl->handshake->out_msg_seq >> 8 ) & 0xFF;
   2933                          ssl->out_msg[5] = ( ssl->handshake->out_msg_seq      ) & 0xFF;
   2934                          ++( ssl->handshake->out_msg_seq );
   2935                      }
   2936                      else
   2937                      {
   2938                          ssl->out_msg[4] = 0;
   2939                          ssl->out_msg[5] = 0;
   2940                      }
   2941          
   2942                      /* We don't fragment, so frag_offset = 0 and frag_len = len */
   2943                      memset( ssl->out_msg + 6, 0x00, 3 );
   2944                      memcpy( ssl->out_msg + 9, ssl->out_msg + 1, 3 );
   2945                  }
   2946          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   2947          
   2948                  if( out_msg_type != MBEDTLS_SSL_HS_HELLO_REQUEST )
   2949                      ssl->handshake->update_checksum( ssl, ssl->out_msg, len );
   2950              }
   2951          
   2952              /* Save handshake and CCS messages for resending */
   2953          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   2954              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   2955                  ssl->handshake != NULL &&
   2956                  ssl->handshake->retransmit_state != MBEDTLS_SSL_RETRANS_SENDING &&
   2957                  ( ssl->out_msgtype == MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC ||
   2958                    ssl->out_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE ) )
   2959              {
   2960                  if( ( ret = ssl_flight_append( ssl ) ) != 0 )
   2961                  {
   2962                      MBEDTLS_SSL_DEBUG_RET( 1, "ssl_flight_append", ret );
   2963                      return( ret );
   2964                  }
   2965              }
   2966          #endif
   2967          
   2968          #if defined(MBEDTLS_ZLIB_SUPPORT)
   2969              if( ssl->transform_out != NULL &&
   2970                  ssl->session_out->compression == MBEDTLS_SSL_COMPRESS_DEFLATE )
   2971              {
   2972                  if( ( ret = ssl_compress_buf( ssl ) ) != 0 )
   2973                  {
   2974                      MBEDTLS_SSL_DEBUG_RET( 1, "ssl_compress_buf", ret );
   2975                      return( ret );
   2976                  }
   2977          
   2978                  len = ssl->out_msglen;
   2979              }
   2980          #endif /*MBEDTLS_ZLIB_SUPPORT */
   2981          
   2982          #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
   2983              if( mbedtls_ssl_hw_record_write != NULL )
   2984              {
   2985                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "going for mbedtls_ssl_hw_record_write()" ) );
   2986          
   2987                  ret = mbedtls_ssl_hw_record_write( ssl );
   2988                  if( ret != 0 && ret != MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH )
   2989                  {
   2990                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_hw_record_write", ret );
   2991                      return( MBEDTLS_ERR_SSL_HW_ACCEL_FAILED );
   2992                  }
   2993          
   2994                  if( ret == 0 )
   2995                      done = 1;
   2996              }
   2997          #endif /* MBEDTLS_SSL_HW_RECORD_ACCEL */
   2998              if( !done )
   2999              {
   3000                  ssl->out_hdr[0] = (unsigned char) ssl->out_msgtype;
   3001                  mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
   3002                                     ssl->conf->transport, ssl->out_hdr + 1 );
   3003          
   3004                  ssl->out_len[0] = (unsigned char)( len >> 8 );
   3005                  ssl->out_len[1] = (unsigned char)( len      );
   3006          
   3007                  if( ssl->transform_out != NULL )
   3008                  {
   3009                      if( ( ret = ssl_encrypt_buf( ssl ) ) != 0 )
   3010                      {
   3011                          MBEDTLS_SSL_DEBUG_RET( 1, "ssl_encrypt_buf", ret );
   3012                          return( ret );
   3013                      }
   3014          
   3015                      len = ssl->out_msglen;
   3016                      ssl->out_len[0] = (unsigned char)( len >> 8 );
   3017                      ssl->out_len[1] = (unsigned char)( len      );
   3018                  }
   3019          
   3020                  ssl->out_left = mbedtls_ssl_hdr_len( ssl ) + ssl->out_msglen;
   3021          
   3022                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "output record: msgtype = %d, "
   3023                                      "version = [%d:%d], msglen = %d",
   3024                                 ssl->out_hdr[0], ssl->out_hdr[1], ssl->out_hdr[2],
   3025                               ( ssl->out_len[0] << 8 ) | ssl->out_len[1] ) );
   3026          
   3027                  MBEDTLS_SSL_DEBUG_BUF( 4, "output record sent to network",
   3028                                 ssl->out_hdr, mbedtls_ssl_hdr_len( ssl ) + ssl->out_msglen );
   3029              }
   3030          
   3031              if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )
   3032              {
   3033                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_flush_output", ret );
   3034                  return( ret );
   3035              }
   3036          
   3037              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write record" ) );
   3038          
   3039              return( 0 );
   3040          }
   3041          
   3042          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3043          /*
   3044           * Mark bits in bitmask (used for DTLS HS reassembly)
   3045           */
   3046          static void ssl_bitmask_set( unsigned char *mask, size_t offset, size_t len )
   3047          {
   3048              unsigned int start_bits, end_bits;
   3049          
   3050              start_bits = 8 - ( offset % 8 );
   3051              if( start_bits != 8 )
   3052              {
   3053                  size_t first_byte_idx = offset / 8;
   3054          
   3055                  /* Special case */
   3056                  if( len <= start_bits )
   3057                  {
   3058                      for( ; len != 0; len-- )
   3059                          mask[first_byte_idx] |= 1 << ( start_bits - len );
   3060          
   3061                      /* Avoid potential issues with offset or len becoming invalid */
   3062                      return;
   3063                  }
   3064          
   3065                  offset += start_bits; /* Now offset % 8 == 0 */
   3066                  len -= start_bits;
   3067          
   3068                  for( ; start_bits != 0; start_bits-- )
   3069                      mask[first_byte_idx] |= 1 << ( start_bits - 1 );
   3070              }
   3071          
   3072              end_bits = len % 8;
   3073              if( end_bits != 0 )
   3074              {
   3075                  size_t last_byte_idx = ( offset + len ) / 8;
   3076          
   3077                  len -= end_bits; /* Now len % 8 == 0 */
   3078          
   3079                  for( ; end_bits != 0; end_bits-- )
   3080                      mask[last_byte_idx] |= 1 << ( 8 - end_bits );
   3081              }
   3082          
   3083              memset( mask + offset / 8, 0xFF, len / 8 );
   3084          }
   3085          
   3086          /*
   3087           * Check that bitmask is full
   3088           */
   3089          static int ssl_bitmask_check( unsigned char *mask, size_t len )
   3090          {
   3091              size_t i;
   3092          
   3093              for( i = 0; i < len / 8; i++ )
   3094                  if( mask[i] != 0xFF )
   3095                      return( -1 );
   3096          
   3097              for( i = 0; i < len % 8; i++ )
   3098                  if( ( mask[len / 8] & ( 1 << ( 7 - i ) ) ) == 0 )
   3099                      return( -1 );
   3100          
   3101              return( 0 );
   3102          }
   3103          
   3104          /*
   3105           * Reassemble fragmented DTLS handshake messages.
   3106           *
   3107           * Use a temporary buffer for reassembly, divided in two parts:
   3108           * - the first holds the reassembled message (including handshake header),
   3109           * - the second holds a bitmask indicating which parts of the message
   3110           *   (excluding headers) have been received so far.
   3111           */
   3112          static int ssl_reassemble_dtls_handshake( mbedtls_ssl_context *ssl )
   3113          {
   3114              unsigned char *msg, *bitmask;
   3115              size_t frag_len, frag_off;
   3116              size_t msg_len = ssl->in_hslen - 12; /* Without headers */
   3117          
   3118              if( ssl->handshake == NULL )
   3119              {
   3120                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "not supported outside handshake (for now)" ) );
   3121                  return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
   3122              }
   3123          
   3124              /*
   3125               * For first fragment, check size and allocate buffer
   3126               */
   3127              if( ssl->handshake->hs_msg == NULL )
   3128              {
   3129                  size_t alloc_len;
   3130          
   3131                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "initialize reassembly, total length = %d",
   3132                                      msg_len ) );
   3133          
   3134                  if( ssl->in_hslen > MBEDTLS_SSL_MAX_CONTENT_LEN )
   3135                  {
   3136                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "handshake message too large" ) );
   3137                      return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
   3138                  }
   3139          
   3140                  /* The bitmask needs one bit per byte of message excluding header */
   3141                  alloc_len = 12 + msg_len + msg_len / 8 + ( msg_len % 8 != 0 );
   3142          
   3143                  ssl->handshake->hs_msg = mbedtls_calloc( 1, alloc_len );
   3144                  if( ssl->handshake->hs_msg == NULL )
   3145                  {
   3146                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc failed (%d bytes)", alloc_len ) );
   3147                      return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
   3148                  }
   3149          
   3150                  /* Prepare final header: copy msg_type, length and message_seq,
   3151                   * then add standardised fragment_offset and fragment_length */
   3152                  memcpy( ssl->handshake->hs_msg, ssl->in_msg, 6 );
   3153                  memset( ssl->handshake->hs_msg + 6, 0, 3 );
   3154                  memcpy( ssl->handshake->hs_msg + 9,
   3155                          ssl->handshake->hs_msg + 1, 3 );
   3156              }
   3157              else
   3158              {
   3159                  /* Make sure msg_type and length are consistent */
   3160                  if( memcmp( ssl->handshake->hs_msg, ssl->in_msg, 4 ) != 0 )
   3161                  {
   3162                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "fragment header mismatch" ) );
   3163                      return( MBEDTLS_ERR_SSL_INVALID_RECORD );
   3164                  }
   3165              }
   3166          
   3167              msg = ssl->handshake->hs_msg + 12;
   3168              bitmask = msg + msg_len;
   3169          
   3170              /*
   3171               * Check and copy current fragment
   3172               */
   3173              frag_off = ( ssl->in_msg[6]  << 16 ) |
   3174                         ( ssl->in_msg[7]  << 8  ) |
   3175                           ssl->in_msg[8];
   3176              frag_len = ( ssl->in_msg[9]  << 16 ) |
   3177                         ( ssl->in_msg[10] << 8  ) |
   3178                           ssl->in_msg[11];
   3179          
   3180              if( frag_off + frag_len > msg_len )
   3181              {
   3182                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "invalid fragment offset/len: %d + %d > %d",
   3183                                    frag_off, frag_len, msg_len ) );
   3184                  return( MBEDTLS_ERR_SSL_INVALID_RECORD );
   3185              }
   3186          
   3187              if( frag_len + 12 > ssl->in_msglen )
   3188              {
   3189                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "invalid fragment length: %d + 12 > %d",
   3190                                    frag_len, ssl->in_msglen ) );
   3191                  return( MBEDTLS_ERR_SSL_INVALID_RECORD );
   3192              }
   3193          
   3194              MBEDTLS_SSL_DEBUG_MSG( 2, ( "adding fragment, offset = %d, length = %d",
   3195                                  frag_off, frag_len ) );
   3196          
   3197              memcpy( msg + frag_off, ssl->in_msg + 12, frag_len );
   3198              ssl_bitmask_set( bitmask, frag_off, frag_len );
   3199          
   3200              /*
   3201               * Do we have the complete message by now?
   3202               * If yes, finalize it, else ask to read the next record.
   3203               */
   3204              if( ssl_bitmask_check( bitmask, msg_len ) != 0 )
   3205              {
   3206                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "message is not complete yet" ) );
   3207                  return( MBEDTLS_ERR_SSL_WANT_READ );
   3208              }
   3209          
   3210              MBEDTLS_SSL_DEBUG_MSG( 2, ( "handshake message completed" ) );
   3211          
   3212              if( frag_len + 12 < ssl->in_msglen )
   3213              {
   3214                  /*
   3215                   * We'got more handshake messages in the same record.
   3216                   * This case is not handled now because no know implementation does
   3217                   * that and it's hard to test, so we prefer to fail cleanly for now.
   3218                   */
   3219                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "last fragment not alone in its record" ) );
   3220                  return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
   3221              }
   3222          
   3223              if( ssl->in_left > ssl->next_record_offset )
   3224              {
   3225                  /*
   3226                   * We've got more data in the buffer after the current record,
   3227                   * that we don't want to overwrite. Move it before writing the
   3228                   * reassembled message, and adjust in_left and next_record_offset.
   3229                   */
   3230                  unsigned char *cur_remain = ssl->in_hdr + ssl->next_record_offset;
   3231                  unsigned char *new_remain = ssl->in_msg + ssl->in_hslen;
   3232                  size_t remain_len = ssl->in_left - ssl->next_record_offset;
   3233          
   3234                  /* First compute and check new lengths */
   3235                  ssl->next_record_offset = new_remain - ssl->in_hdr;
   3236                  ssl->in_left = ssl->next_record_offset + remain_len;
   3237          
   3238                  if( ssl->in_left > MBEDTLS_SSL_BUFFER_LEN -
   3239                                     (size_t)( ssl->in_hdr - ssl->in_buf ) )
   3240                  {
   3241                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "reassembled message too large for buffer" ) );
   3242                      return( MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL );
   3243                  }
   3244          
   3245                  memmove( new_remain, cur_remain, remain_len );
   3246              }
   3247          
   3248              memcpy( ssl->in_msg, ssl->handshake->hs_msg, ssl->in_hslen );
   3249          
   3250              mbedtls_zeroize( ssl->handshake->hs_msg, ssl->in_hslen );
   3251              mbedtls_free( ssl->handshake->hs_msg );
   3252              ssl->handshake->hs_msg = NULL;
   3253          
   3254              MBEDTLS_SSL_DEBUG_BUF( 3, "reassembled handshake message",
   3255                             ssl->in_msg, ssl->in_hslen );
   3256          
   3257              return( 0 );
   3258          }
   3259          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   3260          
   3261          int mbedtls_ssl_prepare_handshake_record( mbedtls_ssl_context *ssl )
   3262          {
   3263              if( ssl->in_msglen < mbedtls_ssl_hs_hdr_len( ssl ) )
   3264              {
   3265                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "handshake message too short: %d",
   3266                                      ssl->in_msglen ) );
   3267                  return( MBEDTLS_ERR_SSL_INVALID_RECORD );
   3268              }
   3269          
   3270              ssl->in_hslen = mbedtls_ssl_hs_hdr_len( ssl ) + (
   3271                              ( ssl->in_msg[1] << 16 ) |
   3272                              ( ssl->in_msg[2] << 8  ) |
   3273                                ssl->in_msg[3] );
   3274          
   3275              MBEDTLS_SSL_DEBUG_MSG( 3, ( "handshake message: msglen ="
   3276                                  " %d, type = %d, hslen = %d",
   3277                                  ssl->in_msglen, ssl->in_msg[0], ssl->in_hslen ) );
   3278          
   3279          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3280              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   3281              {
   3282                  int ret;
   3283                  unsigned int recv_msg_seq = ( ssl->in_msg[4] << 8 ) | ssl->in_msg[5];
   3284          
   3285                  /* ssl->handshake is NULL when receiving ClientHello for renego */
   3286                  if( ssl->handshake != NULL &&
   3287                      recv_msg_seq != ssl->handshake->in_msg_seq )
   3288                  {
   3289                      /* Retransmit only on last message from previous flight, to avoid
   3290                       * too many retransmissions.
   3291                       * Besides, No sane server ever retransmits HelloVerifyRequest */
   3292                      if( recv_msg_seq == ssl->handshake->in_flight_start_seq - 1 &&
   3293                          ssl->in_msg[0] != MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST )
   3294                      {
   3295                          MBEDTLS_SSL_DEBUG_MSG( 2, ( "received message from last flight, "
   3296                                              "message_seq = %d, start_of_flight = %d",
   3297                                              recv_msg_seq,
   3298                                              ssl->handshake->in_flight_start_seq ) );
   3299          
   3300                          if( ( ret = mbedtls_ssl_resend( ssl ) ) != 0 )
   3301                          {
   3302                              MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_resend", ret );
   3303                              return( ret );
   3304                          }
   3305                      }
   3306                      else
   3307                      {
   3308                          MBEDTLS_SSL_DEBUG_MSG( 2, ( "dropping out-of-sequence message: "
   3309                                              "message_seq = %d, expected = %d",
   3310                                              recv_msg_seq,
   3311                                              ssl->handshake->in_msg_seq ) );
   3312                      }
   3313          
   3314                      return( MBEDTLS_ERR_SSL_WANT_READ );
   3315                  }
   3316                  /* Wait until message completion to increment in_msg_seq */
   3317          
   3318                  /* Reassemble if current message is fragmented or reassembly is
   3319                   * already in progress */
   3320                  if( ssl->in_msglen < ssl->in_hslen ||
   3321                      memcmp( ssl->in_msg + 6, "\0\0\0",        3 ) != 0 ||
   3322                      memcmp( ssl->in_msg + 9, ssl->in_msg + 1, 3 ) != 0 ||
   3323                      ( ssl->handshake != NULL && ssl->handshake->hs_msg != NULL ) )
   3324                  {
   3325                      MBEDTLS_SSL_DEBUG_MSG( 2, ( "found fragmented DTLS handshake message" ) );
   3326          
   3327                      if( ( ret = ssl_reassemble_dtls_handshake( ssl ) ) != 0 )
   3328                      {
   3329                          MBEDTLS_SSL_DEBUG_RET( 1, "ssl_reassemble_dtls_handshake", ret );
   3330                          return( ret );
   3331                      }
   3332                  }
   3333              }
   3334              else
   3335          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   3336              /* With TLS we don't handle fragmentation (for now) */
   3337              if( ssl->in_msglen < ssl->in_hslen )
   3338              {
   3339                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "TLS handshake fragmentation not supported" ) );
   3340                  return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
   3341              }
   3342          
   3343              return( 0 );
   3344          }
   3345          
   3346          void mbedtls_ssl_update_handshake_status( mbedtls_ssl_context *ssl )
   3347          {
   3348          
   3349              if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER &&
   3350                  ssl->handshake != NULL )
   3351              {
   3352                  ssl->handshake->update_checksum( ssl, ssl->in_msg, ssl->in_hslen );
   3353              }
   3354          
   3355              /* Handshake message is complete, increment counter */
   3356          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3357              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   3358                  ssl->handshake != NULL )
   3359              {
   3360                  ssl->handshake->in_msg_seq++;
   3361              }
   3362          #endif
   3363          }
   3364          
   3365          /*
   3366           * DTLS anti-replay: RFC 6347 4.1.2.6
   3367           *
   3368           * in_window is a field of bits numbered from 0 (lsb) to 63 (msb).
   3369           * Bit n is set iff record number in_window_top - n has been seen.
   3370           *
   3371           * Usually, in_window_top is the last record number seen and the lsb of
   3372           * in_window is set. The only exception is the initial state (record number 0
   3373           * not seen yet).
   3374           */
   3375          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   3376          static void ssl_dtls_replay_reset( mbedtls_ssl_context *ssl )
   3377          {
   3378              ssl->in_window_top = 0;
   3379              ssl->in_window = 0;
   3380          }
   3381          
   3382          static inline uint64_t ssl_load_six_bytes( unsigned char *buf )
   3383          {
   3384              return( ( (uint64_t) buf[0] << 40 ) |
   3385                      ( (uint64_t) buf[1] << 32 ) |
   3386                      ( (uint64_t) buf[2] << 24 ) |
   3387                      ( (uint64_t) buf[3] << 16 ) |
   3388                      ( (uint64_t) buf[4] <<  8 ) |
   3389                      ( (uint64_t) buf[5]       ) );
   3390          }
   3391          
   3392          /*
   3393           * Return 0 if sequence number is acceptable, -1 otherwise
   3394           */
   3395          int mbedtls_ssl_dtls_replay_check( mbedtls_ssl_context *ssl )
   3396          {
   3397              uint64_t rec_seqnum = ssl_load_six_bytes( ssl->in_ctr + 2 );
   3398              uint64_t bit;
   3399          
   3400              if( ssl->conf->anti_replay == MBEDTLS_SSL_ANTI_REPLAY_DISABLED )
   3401                  return( 0 );
   3402          
   3403              if( rec_seqnum > ssl->in_window_top )
   3404                  return( 0 );
   3405          
   3406              bit = ssl->in_window_top - rec_seqnum;
   3407          
   3408              if( bit >= 64 )
   3409                  return( -1 );
   3410          
   3411              if( ( ssl->in_window & ( (uint64_t) 1 << bit ) ) != 0 )
   3412                  return( -1 );
   3413          
   3414              return( 0 );
   3415          }
   3416          
   3417          /*
   3418           * Update replay window on new validated record
   3419           */
   3420          void mbedtls_ssl_dtls_replay_update( mbedtls_ssl_context *ssl )
   3421          {
   3422              uint64_t rec_seqnum = ssl_load_six_bytes( ssl->in_ctr + 2 );
   3423          
   3424              if( ssl->conf->anti_replay == MBEDTLS_SSL_ANTI_REPLAY_DISABLED )
   3425                  return;
   3426          
   3427              if( rec_seqnum > ssl->in_window_top )
   3428              {
   3429                  /* Update window_top and the contents of the window */
   3430                  uint64_t shift = rec_seqnum - ssl->in_window_top;
   3431          
   3432                  if( shift >= 64 )
   3433                      ssl->in_window = 1;
   3434                  else
   3435                  {
   3436                      ssl->in_window <<= shift;
   3437                      ssl->in_window |= 1;
   3438                  }
   3439          
   3440                  ssl->in_window_top = rec_seqnum;
   3441              }
   3442              else
   3443              {
   3444                  /* Mark that number as seen in the current window */
   3445                  uint64_t bit = ssl->in_window_top - rec_seqnum;
   3446          
   3447                  if( bit < 64 ) /* Always true, but be extra sure */
   3448                      ssl->in_window |= (uint64_t) 1 << bit;
   3449              }
   3450          }
   3451          #endif /* MBEDTLS_SSL_DTLS_ANTI_REPLAY */
   3452          
   3453          #if defined(MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE) && defined(MBEDTLS_SSL_SRV_C)
   3454          /* Forward declaration */
   3455          static int ssl_session_reset_int( mbedtls_ssl_context *ssl, int partial );
   3456          
   3457          /*
   3458           * Without any SSL context, check if a datagram looks like a ClientHello with
   3459           * a valid cookie, and if it doesn't, generate a HelloVerifyRequest message.
   3460           * Both input and output include full DTLS headers.
   3461           *
   3462           * - if cookie is valid, return 0
   3463           * - if ClientHello looks superficially valid but cookie is not,
   3464           *   fill obuf and set olen, then
   3465           *   return MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED
   3466           * - otherwise return a specific error code
   3467           */
   3468          static int ssl_check_dtls_clihlo_cookie(
   3469                                     mbedtls_ssl_cookie_write_t *f_cookie_write,
   3470                                     mbedtls_ssl_cookie_check_t *f_cookie_check,
   3471                                     void *p_cookie,
   3472                                     const unsigned char *cli_id, size_t cli_id_len,
   3473                                     const unsigned char *in, size_t in_len,
   3474                                     unsigned char *obuf, size_t buf_len, size_t *olen )
   3475          {
   3476              size_t sid_len, cookie_len;
   3477              unsigned char *p;
   3478          
   3479              if( f_cookie_write == NULL || f_cookie_check == NULL )
   3480                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   3481          
   3482              /*
   3483               * Structure of ClientHello with record and handshake headers,
   3484               * and expected values. We don't need to check a lot, more checks will be
   3485               * done when actually parsing the ClientHello - skipping those checks
   3486               * avoids code duplication and does not make cookie forging any easier.
   3487               *
   3488               *  0-0  ContentType type;                  copied, must be handshake
   3489               *  1-2  ProtocolVersion version;           copied
   3490               *  3-4  uint16 epoch;                      copied, must be 0
   3491               *  5-10 uint48 sequence_number;            copied
   3492               * 11-12 uint16 length;                     (ignored)
   3493               *
   3494               * 13-13 HandshakeType msg_type;            (ignored)
   3495               * 14-16 uint24 length;                     (ignored)
   3496               * 17-18 uint16 message_seq;                copied
   3497               * 19-21 uint24 fragment_offset;            copied, must be 0
   3498               * 22-24 uint24 fragment_length;            (ignored)
   3499               *
   3500               * 25-26 ProtocolVersion client_version;    (ignored)
   3501               * 27-58 Random random;                     (ignored)
   3502               * 59-xx SessionID session_id;              1 byte len + sid_len content
   3503               * 60+   opaque cookie<0..2^8-1>;           1 byte len + content
   3504               *       ...
   3505               *
   3506               * Minimum length is 61 bytes.
   3507               */
   3508              if( in_len < 61 ||
   3509                  in[0] != MBEDTLS_SSL_MSG_HANDSHAKE ||
   3510                  in[3] != 0 || in[4] != 0 ||
   3511                  in[19] != 0 || in[20] != 0 || in[21] != 0 )
   3512              {
   3513                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   3514              }
   3515          
   3516              sid_len = in[59];
   3517              if( sid_len > in_len - 61 )
   3518                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   3519          
   3520              cookie_len = in[60 + sid_len];
   3521              if( cookie_len > in_len - 60 )
   3522                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   3523          
   3524              if( f_cookie_check( p_cookie, in + sid_len + 61, cookie_len,
   3525                                  cli_id, cli_id_len ) == 0 )
   3526              {
   3527                  /* Valid cookie */
   3528                  return( 0 );
   3529              }
   3530          
   3531              /*
   3532               * If we get here, we've got an invalid cookie, let's prepare HVR.
   3533               *
   3534               *  0-0  ContentType type;                  copied
   3535               *  1-2  ProtocolVersion version;           copied
   3536               *  3-4  uint16 epoch;                      copied
   3537               *  5-10 uint48 sequence_number;            copied
   3538               * 11-12 uint16 length;                     olen - 13
   3539               *
   3540               * 13-13 HandshakeType msg_type;            hello_verify_request
   3541               * 14-16 uint24 length;                     olen - 25
   3542               * 17-18 uint16 message_seq;                copied
   3543               * 19-21 uint24 fragment_offset;            copied
   3544               * 22-24 uint24 fragment_length;            olen - 25
   3545               *
   3546               * 25-26 ProtocolVersion server_version;    0xfe 0xff
   3547               * 27-27 opaque cookie<0..2^8-1>;           cookie_len = olen - 27, cookie
   3548               *
   3549               * Minimum length is 28.
   3550               */
   3551              if( buf_len < 28 )
   3552                  return( MBEDTLS_ERR_SSL_BUFFER_TOO_SMALL );
   3553          
   3554              /* Copy most fields and adapt others */
   3555              memcpy( obuf, in, 25 );
   3556              obuf[13] = MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST;
   3557              obuf[25] = 0xfe;
   3558              obuf[26] = 0xff;
   3559          
   3560              /* Generate and write actual cookie */
   3561              p = obuf + 28;
   3562              if( f_cookie_write( p_cookie,
   3563                                  &p, obuf + buf_len, cli_id, cli_id_len ) != 0 )
   3564              {
   3565                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   3566              }
   3567          
   3568              *olen = p - obuf;
   3569          
   3570              /* Go back and fill length fields */
   3571              obuf[27] = (unsigned char)( *olen - 28 );
   3572          
   3573              obuf[14] = obuf[22] = (unsigned char)( ( *olen - 25 ) >> 16 );
   3574              obuf[15] = obuf[23] = (unsigned char)( ( *olen - 25 ) >>  8 );
   3575              obuf[16] = obuf[24] = (unsigned char)( ( *olen - 25 )       );
   3576          
   3577              obuf[11] = (unsigned char)( ( *olen - 13 ) >>  8 );
   3578              obuf[12] = (unsigned char)( ( *olen - 13 )       );
   3579          
   3580              return( MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED );
   3581          }
   3582          
   3583          /*
   3584           * Handle possible client reconnect with the same UDP quadruplet
   3585           * (RFC 6347 Section 4.2.8).
   3586           *
   3587           * Called by ssl_parse_record_header() in case we receive an epoch 0 record
   3588           * that looks like a ClientHello.
   3589           *
   3590           * - if the input looks like a ClientHello without cookies,
   3591           *   send back HelloVerifyRequest, then
   3592           *   return MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED
   3593           * - if the input looks like a ClientHello with a valid cookie,
   3594           *   reset the session of the current context, and
   3595           *   return MBEDTLS_ERR_SSL_CLIENT_RECONNECT
   3596           * - if anything goes wrong, return a specific error code
   3597           *
   3598           * mbedtls_ssl_read_record() will ignore the record if anything else than
   3599           * MBEDTLS_ERR_SSL_CLIENT_RECONNECT or 0 is returned, although this function
   3600           * cannot not return 0.
   3601           */
   3602          static int ssl_handle_possible_reconnect( mbedtls_ssl_context *ssl )
   3603          {
   3604              int ret;
   3605              size_t len;
   3606          
   3607              ret = ssl_check_dtls_clihlo_cookie(
   3608                      ssl->conf->f_cookie_write,
   3609                      ssl->conf->f_cookie_check,
   3610                      ssl->conf->p_cookie,
   3611                      ssl->cli_id, ssl->cli_id_len,
   3612                      ssl->in_buf, ssl->in_left,
   3613                      ssl->out_buf, MBEDTLS_SSL_MAX_CONTENT_LEN, &len );
   3614          
   3615              MBEDTLS_SSL_DEBUG_RET( 2, "ssl_check_dtls_clihlo_cookie", ret );
   3616          
   3617              if( ret == MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED )
   3618              {
   3619                  /* Don't check write errors as we can't do anything here.
   3620                   * If the error is permanent we'll catch it later,
   3621                   * if it's not, then hopefully it'll work next time. */
   3622                  (void) ssl->f_send( ssl->p_bio, ssl->out_buf, len );
   3623          
   3624                  return( MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED );
   3625              }
   3626          
   3627              if( ret == 0 )
   3628              {
   3629                  /* Got a valid cookie, partially reset context */
   3630                  if( ( ret = ssl_session_reset_int( ssl, 1 ) ) != 0 )
   3631                  {
   3632                      MBEDTLS_SSL_DEBUG_RET( 1, "reset", ret );
   3633                      return( ret );
   3634                  }
   3635          
   3636                  return( MBEDTLS_ERR_SSL_CLIENT_RECONNECT );
   3637              }
   3638          
   3639              return( ret );
   3640          }
   3641          #endif /* MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE && MBEDTLS_SSL_SRV_C */
   3642          
   3643          /*
   3644           * ContentType type;
   3645           * ProtocolVersion version;
   3646           * uint16 epoch;            // DTLS only
   3647           * uint48 sequence_number;  // DTLS only
   3648           * uint16 length;
   3649           *
   3650           * Return 0 if header looks sane (and, for DTLS, the record is expected)
   3651           * MBEDTLS_ERR_SSL_INVALID_RECORD if the header looks bad,
   3652           * MBEDTLS_ERR_SSL_UNEXPECTED_RECORD (DTLS only) if sane but unexpected.
   3653           *
   3654           * With DTLS, mbedtls_ssl_read_record() will:
   3655           * 1. proceed with the record if this function returns 0
   3656           * 2. drop only the current record if this function returns UNEXPECTED_RECORD
   3657           * 3. return CLIENT_RECONNECT if this function return that value
   3658           * 4. drop the whole datagram if this function returns anything else.
   3659           * Point 2 is needed when the peer is resending, and we have already received
   3660           * the first record from a datagram but are still waiting for the others.
   3661           */
   3662          static int ssl_parse_record_header( mbedtls_ssl_context *ssl )
   3663          {
   3664              int major_ver, minor_ver;
   3665          
   3666              MBEDTLS_SSL_DEBUG_BUF( 4, "input record header", ssl->in_hdr, mbedtls_ssl_hdr_len( ssl ) );
   3667          
   3668              ssl->in_msgtype =  ssl->in_hdr[0];
   3669              ssl->in_msglen = ( ssl->in_len[0] << 8 ) | ssl->in_len[1];
   3670              mbedtls_ssl_read_version( &major_ver, &minor_ver, ssl->conf->transport, ssl->in_hdr + 1 );
   3671          
   3672              MBEDTLS_SSL_DEBUG_MSG( 3, ( "input record: msgtype = %d, "
   3673                                  "version = [%d:%d], msglen = %d",
   3674                                  ssl->in_msgtype,
   3675                                  major_ver, minor_ver, ssl->in_msglen ) );
   3676          
   3677              /* Check record type */
   3678              if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE &&
   3679                  ssl->in_msgtype != MBEDTLS_SSL_MSG_ALERT &&
   3680                  ssl->in_msgtype != MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC &&
   3681                  ssl->in_msgtype != MBEDTLS_SSL_MSG_APPLICATION_DATA )
   3682              {
   3683                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "unknown record type" ) );
   3684          
   3685          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3686                  /* Silently ignore invalid DTLS records as recommended by RFC 6347
   3687                   * Section 4.1.2.7 */
   3688                  if( ssl->conf->transport != MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   3689          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   3690                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   3691                                              MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );
   3692          
   3693                  return( MBEDTLS_ERR_SSL_INVALID_RECORD );
   3694              }
   3695          
   3696              /* Check version */
   3697              if( major_ver != ssl->major_ver )
   3698              {
   3699                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "major version mismatch" ) );
   3700                  return( MBEDTLS_ERR_SSL_INVALID_RECORD );
   3701              }
   3702          
   3703              if( minor_ver > ssl->conf->max_minor_ver )
   3704              {
   3705                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "minor version mismatch" ) );
   3706                  return( MBEDTLS_ERR_SSL_INVALID_RECORD );
   3707              }
   3708          
   3709              /* Check length against the size of our buffer */
   3710              if( ssl->in_msglen > MBEDTLS_SSL_BUFFER_LEN
   3711                                   - (size_t)( ssl->in_msg - ssl->in_buf ) )
   3712              {
   3713                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
   3714                  return( MBEDTLS_ERR_SSL_INVALID_RECORD );
   3715              }
   3716          
   3717              /* Check length against bounds of the current transform and version */
   3718              if( ssl->transform_in == NULL )
   3719              {
   3720                  if( ssl->in_msglen < 1 ||
   3721                      ssl->in_msglen > MBEDTLS_SSL_MAX_CONTENT_LEN )
   3722                  {
   3723                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
   3724                      return( MBEDTLS_ERR_SSL_INVALID_RECORD );
   3725                  }
   3726              }
   3727              else
   3728              {
   3729                  if( ssl->in_msglen < ssl->transform_in->minlen )
   3730                  {
   3731                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
   3732                      return( MBEDTLS_ERR_SSL_INVALID_RECORD );
   3733                  }
   3734          
   3735          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   3736                  if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 &&
   3737                      ssl->in_msglen > ssl->transform_in->minlen + MBEDTLS_SSL_MAX_CONTENT_LEN )
   3738                  {
   3739                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
   3740                      return( MBEDTLS_ERR_SSL_INVALID_RECORD );
   3741                  }
   3742          #endif
   3743          #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \
   3744              defined(MBEDTLS_SSL_PROTO_TLS1_2)
   3745                  /*
   3746                   * TLS encrypted messages can have up to 256 bytes of padding
   3747                   */
   3748                  if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_1 &&
   3749                      ssl->in_msglen > ssl->transform_in->minlen +
   3750                                       MBEDTLS_SSL_MAX_CONTENT_LEN + 256 )
   3751                  {
   3752                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
   3753                      return( MBEDTLS_ERR_SSL_INVALID_RECORD );
   3754                  }
   3755          #endif
   3756              }
   3757          
   3758              /*
   3759               * DTLS-related tests done last, because most of them may result in
   3760               * silently dropping the record (but not the whole datagram), and we only
   3761               * want to consider that after ensuring that the "basic" fields (type,
   3762               * version, length) are sane.
   3763               */
   3764          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3765              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   3766              {
   3767                  unsigned int rec_epoch = ( ssl->in_ctr[0] << 8 ) | ssl->in_ctr[1];
   3768          
   3769                  /* Drop unexpected ChangeCipherSpec messages */
   3770                  if( ssl->in_msgtype == MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC &&
   3771                      ssl->state != MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC &&
   3772                      ssl->state != MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC )
   3773                  {
   3774                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "dropping unexpected ChangeCipherSpec" ) );
   3775                      return( MBEDTLS_ERR_SSL_UNEXPECTED_RECORD );
   3776                  }
   3777          
   3778                  /* Drop unexpected ApplicationData records,
   3779                   * except at the beginning of renegotiations */
   3780                  if( ssl->in_msgtype == MBEDTLS_SSL_MSG_APPLICATION_DATA &&
   3781                      ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER
   3782          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   3783                      && ! ( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
   3784                             ssl->state == MBEDTLS_SSL_SERVER_HELLO )
   3785          #endif
   3786                      )
   3787                  {
   3788                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "dropping unexpected ApplicationData" ) );
   3789                      return( MBEDTLS_ERR_SSL_UNEXPECTED_RECORD );
   3790                  }
   3791          
   3792                  /* Check epoch (and sequence number) with DTLS */
   3793                  if( rec_epoch != ssl->in_epoch )
   3794                  {
   3795                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "record from another epoch: "
   3796                                                  "expected %d, received %d",
   3797                                                  ssl->in_epoch, rec_epoch ) );
   3798          
   3799          #if defined(MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE) && defined(MBEDTLS_SSL_SRV_C)
   3800                      /*
   3801                       * Check for an epoch 0 ClientHello. We can't use in_msg here to
   3802                       * access the first byte of record content (handshake type), as we
   3803                       * have an active transform (possibly iv_len != 0), so use the
   3804                       * fact that the record header len is 13 instead.
   3805                       */
   3806                      if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
   3807                          ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER &&
   3808                          rec_epoch == 0 &&
   3809                          ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
   3810                          ssl->in_left > 13 &&
   3811                          ssl->in_buf[13] == MBEDTLS_SSL_HS_CLIENT_HELLO )
   3812                      {
   3813                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "possible client reconnect "
   3814                                                      "from the same port" ) );
   3815                          return( ssl_handle_possible_reconnect( ssl ) );
   3816                      }
   3817                      else
   3818          #endif /* MBEDTLS_SSL_DTLS_CLIENT_PORT_REUSE && MBEDTLS_SSL_SRV_C */
   3819                          return( MBEDTLS_ERR_SSL_UNEXPECTED_RECORD );
   3820                  }
   3821          
   3822          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   3823                  /* Replay detection only works for the current epoch */
   3824                  if( rec_epoch == ssl->in_epoch &&
   3825                      mbedtls_ssl_dtls_replay_check( ssl ) != 0 )
   3826                  {
   3827                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "replayed record" ) );
   3828                      return( MBEDTLS_ERR_SSL_UNEXPECTED_RECORD );
   3829                  }
   3830          #endif
   3831              }
   3832          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   3833          
   3834              return( 0 );
   3835          }
   3836          
   3837          /*
   3838           * If applicable, decrypt (and decompress) record content
   3839           */
   3840          static int ssl_prepare_record_content( mbedtls_ssl_context *ssl )
   3841          {
   3842              int ret, done = 0;
   3843          
   3844              MBEDTLS_SSL_DEBUG_BUF( 4, "input record from network",
   3845                             ssl->in_hdr, mbedtls_ssl_hdr_len( ssl ) + ssl->in_msglen );
   3846          
   3847          #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
   3848              if( mbedtls_ssl_hw_record_read != NULL )
   3849              {
   3850                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "going for mbedtls_ssl_hw_record_read()" ) );
   3851          
   3852                  ret = mbedtls_ssl_hw_record_read( ssl );
   3853                  if( ret != 0 && ret != MBEDTLS_ERR_SSL_HW_ACCEL_FALLTHROUGH )
   3854                  {
   3855                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_hw_record_read", ret );
   3856                      return( MBEDTLS_ERR_SSL_HW_ACCEL_FAILED );
   3857                  }
   3858          
   3859                  if( ret == 0 )
   3860                      done = 1;
   3861              }
   3862          #endif /* MBEDTLS_SSL_HW_RECORD_ACCEL */
   3863              if( !done && ssl->transform_in != NULL )
   3864              {
   3865                  if( ( ret = ssl_decrypt_buf( ssl ) ) != 0 )
   3866                  {
   3867                      MBEDTLS_SSL_DEBUG_RET( 1, "ssl_decrypt_buf", ret );
   3868                      return( ret );
   3869                  }
   3870          
   3871                  MBEDTLS_SSL_DEBUG_BUF( 4, "input payload after decrypt",
   3872                                 ssl->in_msg, ssl->in_msglen );
   3873          
   3874                  if( ssl->in_msglen > MBEDTLS_SSL_MAX_CONTENT_LEN )
   3875                  {
   3876                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad message length" ) );
   3877                      return( MBEDTLS_ERR_SSL_INVALID_RECORD );
   3878                  }
   3879              }
   3880          
   3881          #if defined(MBEDTLS_ZLIB_SUPPORT)
   3882              if( ssl->transform_in != NULL &&
   3883                  ssl->session_in->compression == MBEDTLS_SSL_COMPRESS_DEFLATE )
   3884              {
   3885                  if( ( ret = ssl_decompress_buf( ssl ) ) != 0 )
   3886                  {
   3887                      MBEDTLS_SSL_DEBUG_RET( 1, "ssl_decompress_buf", ret );
   3888                      return( ret );
   3889                  }
   3890              }
   3891          #endif /* MBEDTLS_ZLIB_SUPPORT */
   3892          
   3893          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   3894              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   3895              {
   3896                  mbedtls_ssl_dtls_replay_update( ssl );
   3897              }
   3898          #endif
   3899          
   3900              return( 0 );
   3901          }
   3902          
   3903          static void ssl_handshake_wrapup_free_hs_transform( mbedtls_ssl_context *ssl );
   3904          
   3905          /*
   3906           * Read a record.
   3907           *
   3908           * Silently ignore non-fatal alert (and for DTLS, invalid records as well,
   3909           * RFC 6347 4.1.2.7) and continue reading until a valid record is found.
   3910           *
   3911           */
   3912          int mbedtls_ssl_read_record( mbedtls_ssl_context *ssl )
   3913          {
   3914              int ret;
   3915          
   3916              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> read record" ) );
   3917          
   3918              if( ssl->keep_current_message == 0 )
   3919              {
   3920                  do {
   3921          
   3922                      if( ( ret = mbedtls_ssl_read_record_layer( ssl ) ) != 0 )
   3923                      {
   3924                          MBEDTLS_SSL_DEBUG_RET( 1, ( "mbedtls_ssl_read_record_layer" ), ret );
   3925                          return( ret );
   3926                      }
   3927          
   3928                      ret = mbedtls_ssl_handle_message_type( ssl );
   3929          
   3930                  } while( MBEDTLS_ERR_SSL_NON_FATAL == ret );
   3931          
   3932                  if( 0 != ret )
   3933                  {
   3934                      MBEDTLS_SSL_DEBUG_RET( 1, ( "mbedtls_ssl_read_record_layer" ), ret );
   3935                      return( ret );
   3936                  }
   3937          
   3938                  if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
   3939                  {
   3940                      mbedtls_ssl_update_handshake_status( ssl );
   3941                  }
   3942              }
   3943              else
   3944              {
   3945                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= reuse previously read message" ) );
   3946                  ssl->keep_current_message = 0;
   3947              }
   3948          
   3949              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= read record" ) );
   3950          
   3951              return( 0 );
   3952          }
   3953          
   3954          int mbedtls_ssl_read_record_layer( mbedtls_ssl_context *ssl )
   3955          {
   3956              int ret;
   3957          
   3958              /*
   3959               * Step A
   3960               *
   3961               * Consume last content-layer message and potentially
   3962               * update in_msglen which keeps track of the contents'
   3963               * consumption state.
   3964               *
   3965               * (1) Handshake messages:
   3966               *     Remove last handshake message, move content
   3967               *     and adapt in_msglen.
   3968               *
   3969               * (2) Alert messages:
   3970               *     Consume whole record content, in_msglen = 0.
   3971               *
   3972               *     NOTE: This needs to be fixed, since like for
   3973               *     handshake messages it is allowed to have
   3974               *     multiple alerts witin a single record.
   3975               *     Internal reference IOTSSL-1321.
   3976               *
   3977               * (3) Change cipher spec:
   3978               *     Consume whole record content, in_msglen = 0.
   3979               *
   3980               * (4) Application data:
   3981               *     Don't do anything - the record layer provides
   3982               *     the application data as a stream transport
   3983               *     and consumes through mbedtls_ssl_read only.
   3984               *
   3985               */
   3986          
   3987              /* Case (1): Handshake messages */
   3988              if( ssl->in_hslen != 0 )
   3989              {
   3990                  /* Hard assertion to be sure that no application data
   3991                   * is in flight, as corrupting ssl->in_msglen during
   3992                   * ssl->in_offt != NULL is fatal. */
   3993                  if( ssl->in_offt != NULL )
   3994                  {
   3995                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   3996                      return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   3997                  }
   3998          
   3999                  /*
   4000                   * Get next Handshake message in the current record
   4001                   */
   4002          
   4003                  /* Notes:
   4004                   * (1) in_hslen is *NOT* necessarily the size of the
   4005                   *     current handshake content: If DTLS handshake
   4006                   *     fragmentation is used, that's the fragment
   4007                   *     size instead. Using the total handshake message
   4008                   *     size here is FAULTY and should be changed at
   4009                   *     some point. Internal reference IOTSSL-1414.
   4010                   * (2) While it doesn't seem to cause problems, one
   4011                   *     has to be very careful not to assume that in_hslen
   4012                   *     is always <= in_msglen in a sensible communication.
   4013                   *     Again, it's wrong for DTLS handshake fragmentation.
   4014                   *     The following check is therefore mandatory, and
   4015                   *     should not be treated as a silently corrected assertion.
   4016                   *     Additionally, ssl->in_hslen might be arbitrarily out of
   4017                   *     bounds after handling a DTLS message with an unexpected
   4018                   *     sequence number, see mbedtls_ssl_prepare_handshake_record.
   4019                   */
   4020                  if( ssl->in_hslen < ssl->in_msglen )
   4021                  {
   4022                      ssl->in_msglen -= ssl->in_hslen;
   4023                      memmove( ssl->in_msg, ssl->in_msg + ssl->in_hslen,
   4024                               ssl->in_msglen );
   4025          
   4026                      MBEDTLS_SSL_DEBUG_BUF( 4, "remaining content in record",
   4027                                             ssl->in_msg, ssl->in_msglen );
   4028                  }
   4029                  else
   4030                  {
   4031                      ssl->in_msglen = 0;
   4032                  }
   4033          
   4034                  ssl->in_hslen   = 0;
   4035              }
   4036              /* Case (4): Application data */
   4037              else if( ssl->in_offt != NULL )
   4038              {
   4039                  return( 0 );
   4040              }
   4041              /* Everything else (CCS & Alerts) */
   4042              else
   4043              {
   4044                  ssl->in_msglen = 0;
   4045              }
   4046          
   4047              /*
   4048               * Step B
   4049               *
   4050               * Fetch and decode new record if current one is fully consumed.
   4051               *
   4052               */
   4053          
   4054              if( ssl->in_msglen > 0 )
   4055              {
   4056                  /* There's something left to be processed in the current record. */
   4057                  return( 0 );
   4058              }
   4059          
   4060              /* Need to fetch a new record */
   4061          
   4062          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4063          read_record_header:
   4064          #endif
   4065          
   4066              /* Current record either fully processed or to be discarded. */
   4067          
   4068              if( ( ret = mbedtls_ssl_fetch_input( ssl, mbedtls_ssl_hdr_len( ssl ) ) ) != 0 )
   4069              {
   4070                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
   4071                  return( ret );
   4072              }
   4073          
   4074              if( ( ret = ssl_parse_record_header( ssl ) ) != 0 )
   4075              {
   4076          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4077                  if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   4078                      ret != MBEDTLS_ERR_SSL_CLIENT_RECONNECT )
   4079                  {
   4080                      if( ret == MBEDTLS_ERR_SSL_UNEXPECTED_RECORD )
   4081                      {
   4082                          /* Skip unexpected record (but not whole datagram) */
   4083                          ssl->next_record_offset = ssl->in_msglen
   4084                                                  + mbedtls_ssl_hdr_len( ssl );
   4085          
   4086                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "discarding unexpected record "
   4087                                                      "(header)" ) );
   4088                      }
   4089                      else
   4090                      {
   4091                          /* Skip invalid record and the rest of the datagram */
   4092                          ssl->next_record_offset = 0;
   4093                          ssl->in_left = 0;
   4094          
   4095                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "discarding invalid record "
   4096                                                      "(header)" ) );
   4097                      }
   4098          
   4099                      /* Get next record */
   4100                      goto read_record_header;
   4101                  }
   4102          #endif
   4103                  return( ret );
   4104              }
   4105          
   4106              /*
   4107               * Read and optionally decrypt the message contents
   4108               */
   4109              if( ( ret = mbedtls_ssl_fetch_input( ssl,
   4110                                           mbedtls_ssl_hdr_len( ssl ) + ssl->in_msglen ) ) != 0 )
   4111              {
   4112                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
   4113                  return( ret );
   4114              }
   4115          
   4116              /* Done reading this record, get ready for the next one */
   4117          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4118              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   4119                  ssl->next_record_offset = ssl->in_msglen + mbedtls_ssl_hdr_len( ssl );
   4120              else
   4121          #endif
   4122                  ssl->in_left = 0;
   4123          
   4124              if( ( ret = ssl_prepare_record_content( ssl ) ) != 0 )
   4125              {
   4126          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4127                  if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   4128                  {
   4129                      /* Silently discard invalid records */
   4130                      if( ret == MBEDTLS_ERR_SSL_INVALID_RECORD ||
   4131                          ret == MBEDTLS_ERR_SSL_INVALID_MAC )
   4132                      {
   4133                          /* Except when waiting for Finished as a bad mac here
   4134                           * probably means something went wrong in the handshake
   4135                           * (eg wrong psk used, mitm downgrade attempt, etc.) */
   4136                          if( ssl->state == MBEDTLS_SSL_CLIENT_FINISHED ||
   4137                              ssl->state == MBEDTLS_SSL_SERVER_FINISHED )
   4138                          {
   4139          #if defined(MBEDTLS_SSL_ALL_ALERT_MESSAGES)
   4140                              if( ret == MBEDTLS_ERR_SSL_INVALID_MAC )
   4141                              {
   4142                                  mbedtls_ssl_send_alert_message( ssl,
   4143                                          MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   4144                                          MBEDTLS_SSL_ALERT_MSG_BAD_RECORD_MAC );
   4145                              }
   4146          #endif
   4147                              return( ret );
   4148                          }
   4149          
   4150          #if defined(MBEDTLS_SSL_DTLS_BADMAC_LIMIT)
   4151                          if( ssl->conf->badmac_limit != 0 &&
   4152                              ++ssl->badmac_seen >= ssl->conf->badmac_limit )
   4153                          {
   4154                              MBEDTLS_SSL_DEBUG_MSG( 1, ( "too many records with bad MAC" ) );
   4155                              return( MBEDTLS_ERR_SSL_INVALID_MAC );
   4156                          }
   4157          #endif
   4158          
   4159                          /* As above, invalid records cause
   4160                           * dismissal of the whole datagram. */
   4161          
   4162                          ssl->next_record_offset = 0;
   4163                          ssl->in_left = 0;
   4164          
   4165                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "discarding invalid record (mac)" ) );
   4166                          goto read_record_header;
   4167                      }
   4168          
   4169                      return( ret );
   4170                  }
   4171                  else
   4172          #endif
   4173                  {
   4174                      /* Error out (and send alert) on invalid records */
   4175          #if defined(MBEDTLS_SSL_ALL_ALERT_MESSAGES)
   4176                      if( ret == MBEDTLS_ERR_SSL_INVALID_MAC )
   4177                      {
   4178                          mbedtls_ssl_send_alert_message( ssl,
   4179                                  MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   4180                                  MBEDTLS_SSL_ALERT_MSG_BAD_RECORD_MAC );
   4181                      }
   4182          #endif
   4183                      return( ret );
   4184                  }
   4185              }
   4186          
   4187              /*
   4188               * When we sent the last flight of the handshake, we MUST respond to a
   4189               * retransmit of the peer's previous flight with a retransmit. (In
   4190               * practice, only the Finished message will make it, other messages
   4191               * including CCS use the old transform so they're dropped as invalid.)
   4192               *
   4193               * If the record we received is not a handshake message, however, it
   4194               * means the peer received our last flight so we can clean up
   4195               * handshake info.
   4196               *
   4197               * This check needs to be done before prepare_handshake() due to an edge
   4198               * case: if the client immediately requests renegotiation, this
   4199               * finishes the current handshake first, avoiding the new ClientHello
   4200               * being mistaken for an ancient message in the current handshake.
   4201               */
   4202          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4203              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   4204                  ssl->handshake != NULL &&
   4205                  ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER )
   4206              {
   4207                  if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE &&
   4208                          ssl->in_msg[0] == MBEDTLS_SSL_HS_FINISHED )
   4209                  {
   4210                      MBEDTLS_SSL_DEBUG_MSG( 2, ( "received retransmit of last flight" ) );
   4211          
   4212                      if( ( ret = mbedtls_ssl_resend( ssl ) ) != 0 )
   4213                      {
   4214                          MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_resend", ret );
   4215                          return( ret );
   4216                      }
   4217          
   4218                      return( MBEDTLS_ERR_SSL_WANT_READ );
   4219                  }
   4220                  else
   4221                  {
   4222                      ssl_handshake_wrapup_free_hs_transform( ssl );
   4223                  }
   4224              }
   4225          #endif
   4226          
   4227              return( 0 );
   4228          }
   4229          
   4230          int mbedtls_ssl_handle_message_type( mbedtls_ssl_context *ssl )
   4231          {
   4232              int ret;
   4233          
   4234              /*
   4235               * Handle particular types of records
   4236               */
   4237              if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
   4238              {
   4239                  if( ( ret = mbedtls_ssl_prepare_handshake_record( ssl ) ) != 0 )
   4240                  {
   4241                      return( ret );
   4242                  }
   4243              }
   4244          
   4245              if( ssl->in_msgtype == MBEDTLS_SSL_MSG_ALERT )
   4246              {
   4247                  if( ssl->in_msglen != 2 )
   4248                  {
   4249                      /* Note: Standard allows for more than one 2 byte alert
   4250                         to be packed in a single message, but Mbed TLS doesn't
   4251                         currently support this. */
   4252                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "invalid alert message, len: %d",
   4253                                     ssl->in_msglen ) );
   4254                      return( MBEDTLS_ERR_SSL_INVALID_RECORD );
   4255                  }
   4256          
   4257                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "got an alert message, type: [%d:%d]",
   4258                                 ssl->in_msg[0], ssl->in_msg[1] ) );
   4259          
   4260                  /*
   4261                   * Ignore non-fatal alerts, except close_notify and no_renegotiation
   4262                   */
   4263                  if( ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_FATAL )
   4264                  {
   4265                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "is a fatal alert message (msg %d)",
   4266                                     ssl->in_msg[1] ) );
   4267                      return( MBEDTLS_ERR_SSL_FATAL_ALERT_MESSAGE );
   4268                  }
   4269          
   4270                  if( ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING &&
   4271                      ssl->in_msg[1] == MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY )
   4272                  {
   4273                      MBEDTLS_SSL_DEBUG_MSG( 2, ( "is a close notify message" ) );
   4274                      return( MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY );
   4275                  }
   4276          
   4277          #if defined(MBEDTLS_SSL_RENEGOTIATION_ENABLED)
   4278                  if( ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING &&
   4279                      ssl->in_msg[1] == MBEDTLS_SSL_ALERT_MSG_NO_RENEGOTIATION )
   4280                  {
   4281                      MBEDTLS_SSL_DEBUG_MSG( 2, ( "is a SSLv3 no_cert" ) );
   4282                      /* Will be handled when trying to parse ServerHello */
   4283                      return( 0 );
   4284                  }
   4285          #endif
   4286          
   4287          #if defined(MBEDTLS_SSL_PROTO_SSL3) && defined(MBEDTLS_SSL_SRV_C)
   4288                  if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 &&
   4289                      ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
   4290                      ssl->in_msg[0] == MBEDTLS_SSL_ALERT_LEVEL_WARNING &&
   4291                      ssl->in_msg[1] == MBEDTLS_SSL_ALERT_MSG_NO_CERT )
   4292                  {
   4293                      MBEDTLS_SSL_DEBUG_MSG( 2, ( "is a SSLv3 no_cert" ) );
   4294                      /* Will be handled in mbedtls_ssl_parse_certificate() */
   4295                      return( 0 );
   4296                  }
   4297          #endif /* MBEDTLS_SSL_PROTO_SSL3 && MBEDTLS_SSL_SRV_C */
   4298          
   4299                  /* Silently ignore: fetch new message */
   4300                  return MBEDTLS_ERR_SSL_NON_FATAL;
   4301              }
   4302          
   4303              return( 0 );
   4304          }
   4305          
   4306          int mbedtls_ssl_send_fatal_handshake_failure( mbedtls_ssl_context *ssl )
   4307          {
   4308              int ret;
   4309          
   4310              if( ( ret = mbedtls_ssl_send_alert_message( ssl,
   4311                              MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   4312                              MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE ) ) != 0 )
   4313              {
   4314                  return( ret );
   4315              }
   4316          
   4317              return( 0 );
   4318          }
   4319          
   4320          int mbedtls_ssl_send_alert_message( mbedtls_ssl_context *ssl,
   4321                                      unsigned char level,
   4322                                      unsigned char message )
   4323          {
   4324              int ret;
   4325          
   4326              if( ssl == NULL || ssl->conf == NULL )
   4327                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   4328          
   4329              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> send alert message" ) );
   4330              MBEDTLS_SSL_DEBUG_MSG( 3, ( "send alert level=%u message=%u", level, message ));
   4331          
   4332              ssl->out_msgtype = MBEDTLS_SSL_MSG_ALERT;
   4333              ssl->out_msglen = 2;
   4334              ssl->out_msg[0] = level;
   4335              ssl->out_msg[1] = message;
   4336          
   4337              if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
   4338              {
   4339                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
   4340                  return( ret );
   4341              }
   4342              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= send alert message" ) );
   4343          
   4344              return( 0 );
   4345          }
   4346          
   4347          /*
   4348           * Handshake functions
   4349           */
   4350          #if !defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)         && \
   4351              !defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)     && \
   4352              !defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)     && \
   4353              !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED)   && \
   4354              !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) && \
   4355              !defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)    && \
   4356              !defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
   4357          /* No certificate support -> dummy functions */
   4358          int mbedtls_ssl_write_certificate( mbedtls_ssl_context *ssl )
   4359          {
   4360              const mbedtls_ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
   4361          
   4362              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write certificate" ) );
   4363          
   4364              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
   4365                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
   4366                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
   4367                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
   4368              {
   4369                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate" ) );
   4370                  ssl->state++;
   4371                  return( 0 );
   4372              }
   4373          
   4374              MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   4375              return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   4376          }
   4377          
   4378          int mbedtls_ssl_parse_certificate( mbedtls_ssl_context *ssl )
   4379          {
   4380              const mbedtls_ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
   4381          
   4382              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse certificate" ) );
   4383          
   4384              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
   4385                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
   4386                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
   4387                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
   4388              {
   4389                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate" ) );
   4390                  ssl->state++;
   4391                  return( 0 );
   4392              }
   4393          
   4394              MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   4395              return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   4396          }
   4397          
   4398          #else
   4399          /* Some certificate support -> implement write and parse */
   4400          
   4401          int mbedtls_ssl_write_certificate( mbedtls_ssl_context *ssl )
   4402          {
   4403              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   4404              size_t i, n;
   4405              const mbedtls_x509_crt *crt;
   4406              const mbedtls_ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
   4407          
   4408              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write certificate" ) );
   4409          
   4410              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
   4411                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
   4412                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
   4413                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
   4414              {
   4415                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate" ) );
   4416                  ssl->state++;
   4417                  return( 0 );
   4418              }
   4419          
   4420          #if defined(MBEDTLS_SSL_CLI_C)
   4421              if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
   4422              {
   4423                  if( ssl->client_auth == 0 )
   4424                  {
   4425                      MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate" ) );
   4426                      ssl->state++;
   4427                      return( 0 );
   4428                  }
   4429          
   4430          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   4431                  /*
   4432                   * If using SSLv3 and got no cert, send an Alert message
   4433                   * (otherwise an empty Certificate message will be sent).
   4434                   */
   4435                  if( mbedtls_ssl_own_cert( ssl )  == NULL &&
   4436                      ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
   4437                  {
   4438                      ssl->out_msglen  = 2;
   4439                      ssl->out_msgtype = MBEDTLS_SSL_MSG_ALERT;
   4440                      ssl->out_msg[0]  = MBEDTLS_SSL_ALERT_LEVEL_WARNING;
   4441                      ssl->out_msg[1]  = MBEDTLS_SSL_ALERT_MSG_NO_CERT;
   4442          
   4443                      MBEDTLS_SSL_DEBUG_MSG( 2, ( "got no certificate to send" ) );
   4444                      goto write_msg;
   4445                  }
   4446          #endif /* MBEDTLS_SSL_PROTO_SSL3 */
   4447              }
   4448          #endif /* MBEDTLS_SSL_CLI_C */
   4449          #if defined(MBEDTLS_SSL_SRV_C)
   4450              if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER )
   4451              {
   4452                  if( mbedtls_ssl_own_cert( ssl ) == NULL )
   4453                  {
   4454                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no certificate to send" ) );
   4455                      return( MBEDTLS_ERR_SSL_CERTIFICATE_REQUIRED );
   4456                  }
   4457              }
   4458          #endif
   4459          
   4460              MBEDTLS_SSL_DEBUG_CRT( 3, "own certificate", mbedtls_ssl_own_cert( ssl ) );
   4461          
   4462              /*
   4463               *     0  .  0    handshake type
   4464               *     1  .  3    handshake length
   4465               *     4  .  6    length of all certs
   4466               *     7  .  9    length of cert. 1
   4467               *    10  . n-1   peer certificate
   4468               *     n  . n+2   length of cert. 2
   4469               *    n+3 . ...   upper level cert, etc.
   4470               */
   4471              i = 7;
   4472              crt = mbedtls_ssl_own_cert( ssl );
   4473          
   4474              while( crt != NULL )
   4475              {
   4476                  n = crt->raw.len;
   4477                  if( n > MBEDTLS_SSL_MAX_CONTENT_LEN - 3 - i )
   4478                  {
   4479                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "certificate too large, %d > %d",
   4480                                     i + 3 + n, MBEDTLS_SSL_MAX_CONTENT_LEN ) );
   4481                      return( MBEDTLS_ERR_SSL_CERTIFICATE_TOO_LARGE );
   4482                  }
   4483          
   4484                  ssl->out_msg[i    ] = (unsigned char)( n >> 16 );
   4485                  ssl->out_msg[i + 1] = (unsigned char)( n >>  8 );
   4486                  ssl->out_msg[i + 2] = (unsigned char)( n       );
   4487          
   4488                  i += 3; memcpy( ssl->out_msg + i, crt->raw.p, n );
   4489                  i += n; crt = crt->next;
   4490              }
   4491          
   4492              ssl->out_msg[4]  = (unsigned char)( ( i - 7 ) >> 16 );
   4493              ssl->out_msg[5]  = (unsigned char)( ( i - 7 ) >>  8 );
   4494              ssl->out_msg[6]  = (unsigned char)( ( i - 7 )       );
   4495          
   4496              ssl->out_msglen  = i;
   4497              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   4498              ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE;
   4499          
   4500          #if defined(MBEDTLS_SSL_PROTO_SSL3) && defined(MBEDTLS_SSL_CLI_C)
   4501          write_msg:
   4502          #endif
   4503          
   4504              ssl->state++;
   4505          
   4506              if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
   4507              {
   4508                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
   4509                  return( ret );
   4510              }
   4511          
   4512              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write certificate" ) );
   4513          
   4514              return( ret );
   4515          }
   4516          
   4517          int mbedtls_ssl_parse_certificate( mbedtls_ssl_context *ssl )
   4518          {
   4519              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   4520              size_t i, n;
   4521              const mbedtls_ssl_ciphersuite_t *ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
   4522              int authmode = ssl->conf->authmode;
   4523              uint8_t alert;
   4524          
   4525              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse certificate" ) );
   4526          
   4527              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
   4528                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
   4529                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
   4530                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
   4531              {
   4532                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate" ) );
   4533                  ssl->state++;
   4534                  return( 0 );
   4535              }
   4536          
   4537          #if defined(MBEDTLS_SSL_SRV_C)
   4538              if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
   4539                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )
   4540              {
   4541                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate" ) );
   4542                  ssl->state++;
   4543                  return( 0 );
   4544              }
   4545          
   4546          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   4547              if( ssl->handshake->sni_authmode != MBEDTLS_SSL_VERIFY_UNSET )
   4548                  authmode = ssl->handshake->sni_authmode;
   4549          #endif
   4550          
   4551              if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
   4552                  authmode == MBEDTLS_SSL_VERIFY_NONE )
   4553              {
   4554                  ssl->session_negotiate->verify_result = MBEDTLS_X509_BADCERT_SKIP_VERIFY;
   4555                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate" ) );
   4556                  ssl->state++;
   4557                  return( 0 );
   4558              }
   4559          #endif
   4560          
   4561              if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
   4562              {
   4563                  /* mbedtls_ssl_read_record may have sent an alert already. We
   4564                     let it decide whether to alert. */
   4565                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
   4566                  return( ret );
   4567              }
   4568          
   4569              ssl->state++;
   4570          
   4571          #if defined(MBEDTLS_SSL_SRV_C)
   4572          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   4573              /*
   4574               * Check if the client sent an empty certificate
   4575               */
   4576              if( ssl->conf->endpoint  == MBEDTLS_SSL_IS_SERVER &&
   4577                  ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
   4578              {
   4579                  if( ssl->in_msglen  == 2                        &&
   4580                      ssl->in_msgtype == MBEDTLS_SSL_MSG_ALERT            &&
   4581                      ssl->in_msg[0]  == MBEDTLS_SSL_ALERT_LEVEL_WARNING  &&
   4582                      ssl->in_msg[1]  == MBEDTLS_SSL_ALERT_MSG_NO_CERT )
   4583                  {
   4584                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "SSLv3 client has no certificate" ) );
   4585          
   4586                      /* The client was asked for a certificate but didn't send
   4587                         one. The client should know what's going on, so we
   4588                         don't send an alert. */
   4589                      ssl->session_negotiate->verify_result = MBEDTLS_X509_BADCERT_MISSING;
   4590                      if( authmode == MBEDTLS_SSL_VERIFY_OPTIONAL )
   4591                          return( 0 );
   4592                      else
   4593                          return( MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE );
   4594                  }
   4595              }
   4596          #endif /* MBEDTLS_SSL_PROTO_SSL3 */
   4597          
   4598          #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \
   4599              defined(MBEDTLS_SSL_PROTO_TLS1_2)
   4600              if( ssl->conf->endpoint  == MBEDTLS_SSL_IS_SERVER &&
   4601                  ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )
   4602              {
   4603                  if( ssl->in_hslen   == 3 + mbedtls_ssl_hs_hdr_len( ssl ) &&
   4604                      ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE    &&
   4605                      ssl->in_msg[0]  == MBEDTLS_SSL_HS_CERTIFICATE   &&
   4606                      memcmp( ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl ), "\0\0\0", 3 ) == 0 )
   4607                  {
   4608                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "TLSv1 client has no certificate" ) );
   4609          
   4610                      /* The client was asked for a certificate but didn't send
   4611                         one. The client should know what's going on, so we
   4612                         don't send an alert. */
   4613                      ssl->session_negotiate->verify_result = MBEDTLS_X509_BADCERT_MISSING;
   4614                      if( authmode == MBEDTLS_SSL_VERIFY_OPTIONAL )
   4615                          return( 0 );
   4616                      else
   4617                          return( MBEDTLS_ERR_SSL_NO_CLIENT_CERTIFICATE );
   4618                  }
   4619              }
   4620          #endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \
   4621                    MBEDTLS_SSL_PROTO_TLS1_2 */
   4622          #endif /* MBEDTLS_SSL_SRV_C */
   4623          
   4624              if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
   4625              {
   4626                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
   4627                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   4628                                                  MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );
   4629                  return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
   4630              }
   4631          
   4632              if( ssl->in_msg[0] != MBEDTLS_SSL_HS_CERTIFICATE ||
   4633                  ssl->in_hslen < mbedtls_ssl_hs_hdr_len( ssl ) + 3 + 3 )
   4634              {
   4635                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
   4636                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   4637                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   4638                  return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );
   4639              }
   4640          
   4641              i = mbedtls_ssl_hs_hdr_len( ssl );
   4642          
   4643              /*
   4644               * Same message structure as in mbedtls_ssl_write_certificate()
   4645               */
   4646              n = ( ssl->in_msg[i+1] << 8 ) | ssl->in_msg[i+2];
   4647          
   4648              if( ssl->in_msg[i] != 0 ||
   4649                  ssl->in_hslen != n + 3 + mbedtls_ssl_hs_hdr_len( ssl ) )
   4650              {
   4651                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
   4652                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   4653                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   4654                  return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );
   4655              }
   4656          
   4657              /* In case we tried to reuse a session but it failed */
   4658              if( ssl->session_negotiate->peer_cert != NULL )
   4659              {
   4660                  mbedtls_x509_crt_free( ssl->session_negotiate->peer_cert );
   4661                  mbedtls_free( ssl->session_negotiate->peer_cert );
   4662              }
   4663          
   4664              if( ( ssl->session_negotiate->peer_cert = mbedtls_calloc( 1,
   4665                              sizeof( mbedtls_x509_crt ) ) ) == NULL )
   4666              {
   4667                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc(%d bytes) failed",
   4668                                 sizeof( mbedtls_x509_crt ) ) );
   4669                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   4670                                                  MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );
   4671                  return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
   4672              }
   4673          
   4674              mbedtls_x509_crt_init( ssl->session_negotiate->peer_cert );
   4675          
   4676              i += 3;
   4677          
   4678              while( i < ssl->in_hslen )
   4679              {
   4680                  if ( i + 3 > ssl->in_hslen ) {
   4681                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
   4682                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   4683                                                     MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   4684                      return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );
   4685                  }
   4686                  if( ssl->in_msg[i] != 0 )
   4687                  {
   4688                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
   4689                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   4690                                                      MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   4691                      return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );
   4692                  }
   4693          
   4694                  n = ( (unsigned int) ssl->in_msg[i + 1] << 8 )
   4695                      | (unsigned int) ssl->in_msg[i + 2];
   4696                  i += 3;
   4697          
   4698                  if( n < 128 || i + n > ssl->in_hslen )
   4699                  {
   4700                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate message" ) );
   4701                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   4702                                                      MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   4703                      return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );
   4704                  }
   4705          
   4706                  ret = mbedtls_x509_crt_parse_der( ssl->session_negotiate->peer_cert,
   4707                                            ssl->in_msg + i, n );
   4708                  switch( ret )
   4709                  {
   4710                  case 0: /*ok*/
   4711                  case MBEDTLS_ERR_X509_UNKNOWN_SIG_ALG + MBEDTLS_ERR_OID_NOT_FOUND:
   4712                      /* Ignore certificate with an unknown algorithm: maybe a
   4713                         prior certificate was already trusted. */
   4714                      break;
   4715          
   4716                  case MBEDTLS_ERR_X509_ALLOC_FAILED:
   4717                      alert = MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR;
   4718                      goto crt_parse_der_failed;
   4719          
   4720                  case MBEDTLS_ERR_X509_UNKNOWN_VERSION:
   4721                      alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
   4722                      goto crt_parse_der_failed;
   4723          
   4724                  default:
   4725                      alert = MBEDTLS_SSL_ALERT_MSG_BAD_CERT;
   4726                  crt_parse_der_failed:
   4727                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL, alert );
   4728                      MBEDTLS_SSL_DEBUG_RET( 1, " mbedtls_x509_crt_parse_der", ret );
   4729                      return( ret );
   4730                  }
   4731          
   4732                  i += n;
   4733              }
   4734          
   4735              MBEDTLS_SSL_DEBUG_CRT( 3, "peer certificate", ssl->session_negotiate->peer_cert );
   4736          
   4737              /*
   4738               * On client, make sure the server cert doesn't change during renego to
   4739               * avoid "triple handshake" attack: https://secure-resumption.com/
   4740               */
   4741          #if defined(MBEDTLS_SSL_RENEGOTIATION) && defined(MBEDTLS_SSL_CLI_C)
   4742              if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT &&
   4743                  ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
   4744              {
   4745                  if( ssl->session->peer_cert == NULL )
   4746                  {
   4747                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "new server cert during renegotiation" ) );
   4748                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   4749                                                      MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED );
   4750                      return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );
   4751                  }
   4752          
   4753                  if( ssl->session->peer_cert->raw.len !=
   4754                      ssl->session_negotiate->peer_cert->raw.len ||
   4755                      memcmp( ssl->session->peer_cert->raw.p,
   4756                              ssl->session_negotiate->peer_cert->raw.p,
   4757                              ssl->session->peer_cert->raw.len ) != 0 )
   4758                  {
   4759                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "server cert changed during renegotiation" ) );
   4760                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   4761                                                      MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED );
   4762                      return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE );
   4763                  }
   4764              }
   4765          #endif /* MBEDTLS_SSL_RENEGOTIATION && MBEDTLS_SSL_CLI_C */
   4766          
   4767              if( authmode != MBEDTLS_SSL_VERIFY_NONE )
   4768              {
   4769                  mbedtls_x509_crt *ca_chain;
   4770                  mbedtls_x509_crl *ca_crl;
   4771          
   4772          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   4773                  if( ssl->handshake->sni_ca_chain != NULL )
   4774                  {
   4775                      ca_chain = ssl->handshake->sni_ca_chain;
   4776                      ca_crl   = ssl->handshake->sni_ca_crl;
   4777                  }
   4778                  else
   4779          #endif
   4780                  {
   4781                      ca_chain = ssl->conf->ca_chain;
   4782                      ca_crl   = ssl->conf->ca_crl;
   4783                  }
   4784          
   4785                  /*
   4786                   * Main check: verify certificate
   4787                   */
   4788                  ret = mbedtls_x509_crt_verify_with_profile(
   4789                                          ssl->session_negotiate->peer_cert,
   4790                                          ca_chain, ca_crl,
   4791                                          ssl->conf->cert_profile,
   4792                                          ssl->hostname,
   4793                                         &ssl->session_negotiate->verify_result,
   4794                                          ssl->conf->f_vrfy, ssl->conf->p_vrfy );
   4795          
   4796                  if( ret != 0 )
   4797                  {
   4798                      MBEDTLS_SSL_DEBUG_RET( 1, "x509_verify_cert", ret );
   4799                  }
   4800          
   4801                  /*
   4802                   * Secondary checks: always done, but change 'ret' only if it was 0
   4803                   */
   4804          
   4805          #if defined(MBEDTLS_ECP_C)
   4806                  {
   4807                      const mbedtls_pk_context *pk = &ssl->session_negotiate->peer_cert->pk;
   4808          
   4809                      /* If certificate uses an EC key, make sure the curve is OK */
   4810                      if( mbedtls_pk_can_do( pk, MBEDTLS_PK_ECKEY ) &&
   4811                          mbedtls_ssl_check_curve( ssl, mbedtls_pk_ec( *pk )->grp.id ) != 0 )
   4812                      {
   4813                          ssl->session_negotiate->verify_result |= MBEDTLS_X509_BADCERT_BAD_KEY;
   4814          
   4815                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate (EC key curve)" ) );
   4816                          if( ret == 0 )
   4817                              ret = MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE;
   4818                      }
   4819                  }
   4820          #endif /* MBEDTLS_ECP_C */
   4821          
   4822                  if( mbedtls_ssl_check_cert_usage( ssl->session_negotiate->peer_cert,
   4823                                           ciphersuite_info,
   4824                                           ! ssl->conf->endpoint,
   4825                                           &ssl->session_negotiate->verify_result ) != 0 )
   4826                  {
   4827                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate (usage extensions)" ) );
   4828                      if( ret == 0 )
   4829                          ret = MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE;
   4830                  }
   4831          
   4832                  /* mbedtls_x509_crt_verify_with_profile is supposed to report a
   4833                   * verification failure through MBEDTLS_ERR_X509_CERT_VERIFY_FAILED,
   4834                   * with details encoded in the verification flags. All other kinds
   4835                   * of error codes, including those from the user provided f_vrfy
   4836                   * functions, are treated as fatal and lead to a failure of
   4837                   * ssl_parse_certificate even if verification was optional. */
   4838                  if( authmode == MBEDTLS_SSL_VERIFY_OPTIONAL &&
   4839                      ( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED ||
   4840                        ret == MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE ) )
   4841                  {
   4842                      ret = 0;
   4843                  }
   4844          
   4845                  if( ca_chain == NULL && authmode == MBEDTLS_SSL_VERIFY_REQUIRED )
   4846                  {
   4847                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no CA chain" ) );
   4848                      ret = MBEDTLS_ERR_SSL_CA_CHAIN_REQUIRED;
   4849                  }
   4850          
   4851                  if( ret != 0 )
   4852                  {
   4853                      /* The certificate may have been rejected for several reasons.
   4854                         Pick one and send the corresponding alert. Which alert to send
   4855                         may be a subject of debate in some cases. */
   4856                      if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_OTHER )
   4857                          alert = MBEDTLS_SSL_ALERT_MSG_ACCESS_DENIED;
   4858                      else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_CN_MISMATCH )
   4859                          alert = MBEDTLS_SSL_ALERT_MSG_BAD_CERT;
   4860                      else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_KEY_USAGE )
   4861                          alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
   4862                      else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_EXT_KEY_USAGE )
   4863                          alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
   4864                      else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_NS_CERT_TYPE )
   4865                          alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
   4866                      else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_BAD_PK )
   4867                          alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
   4868                      else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_BAD_KEY )
   4869                          alert = MBEDTLS_SSL_ALERT_MSG_UNSUPPORTED_CERT;
   4870                      else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_EXPIRED )
   4871                          alert = MBEDTLS_SSL_ALERT_MSG_CERT_EXPIRED;
   4872                      else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_REVOKED )
   4873                          alert = MBEDTLS_SSL_ALERT_MSG_CERT_REVOKED;
   4874                      else if( ssl->session_negotiate->verify_result & MBEDTLS_X509_BADCERT_NOT_TRUSTED )
   4875                          alert = MBEDTLS_SSL_ALERT_MSG_UNKNOWN_CA;
   4876                      else
   4877                          alert = MBEDTLS_SSL_ALERT_MSG_CERT_UNKNOWN;
   4878                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   4879                                                      alert );
   4880                  }
   4881          
   4882          #if defined(MBEDTLS_DEBUG_C)
   4883                  if( ssl->session_negotiate->verify_result != 0 )
   4884                  {
   4885                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "! Certificate verification flags %x",
   4886                                                  ssl->session_negotiate->verify_result ) );
   4887                  }
   4888                  else
   4889                  {
   4890                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "Certificate verification flags clear" ) );
   4891                  }
   4892          #endif /* MBEDTLS_DEBUG_C */
   4893              }
   4894          
   4895              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse certificate" ) );
   4896          
   4897              return( ret );
   4898          }
   4899          #endif /* !MBEDTLS_KEY_EXCHANGE_RSA_ENABLED
   4900                    !MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED
   4901                    !MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED
   4902                    !MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED
   4903                    !MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED
   4904                    !MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED
   4905                    !MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
   4906          
   4907          int mbedtls_ssl_write_change_cipher_spec( mbedtls_ssl_context *ssl )
   4908          {
   4909              int ret;
   4910          
   4911              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write change cipher spec" ) );
   4912          
   4913              ssl->out_msgtype = MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC;
   4914              ssl->out_msglen  = 1;
   4915              ssl->out_msg[0]  = 1;
   4916          
   4917              ssl->state++;
   4918          
   4919              if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
   4920              {
   4921                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
   4922                  return( ret );
   4923              }
   4924          
   4925              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write change cipher spec" ) );
   4926          
   4927              return( 0 );
   4928          }
   4929          
   4930          int mbedtls_ssl_parse_change_cipher_spec( mbedtls_ssl_context *ssl )
   4931          {
   4932              int ret;
   4933          
   4934              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse change cipher spec" ) );
   4935          
   4936              if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
   4937              {
   4938                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
   4939                  return( ret );
   4940              }
   4941          
   4942              if( ssl->in_msgtype != MBEDTLS_SSL_MSG_CHANGE_CIPHER_SPEC )
   4943              {
   4944                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad change cipher spec message" ) );
   4945                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   4946                                                  MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );
   4947                  return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
   4948              }
   4949          
   4950              if( ssl->in_msglen != 1 || ssl->in_msg[0] != 1 )
   4951              {
   4952                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad change cipher spec message" ) );
   4953                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   4954                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   4955                  return( MBEDTLS_ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC );
   4956              }
   4957          
   4958              /*
   4959               * Switch to our negotiated transform and session parameters for inbound
   4960               * data.
   4961               */
   4962              MBEDTLS_SSL_DEBUG_MSG( 3, ( "switching to new transform spec for inbound data" ) );
   4963              ssl->transform_in = ssl->transform_negotiate;
   4964              ssl->session_in = ssl->session_negotiate;
   4965          
   4966          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4967              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   4968              {
   4969          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   4970                  ssl_dtls_replay_reset( ssl );
   4971          #endif
   4972          
   4973                  /* Increment epoch */
   4974                  if( ++ssl->in_epoch == 0 )
   4975                  {
   4976                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "DTLS epoch would wrap" ) );
   4977                      /* This is highly unlikely to happen for legitimate reasons, so
   4978                         treat it as an attack and don't send an alert. */
   4979                      return( MBEDTLS_ERR_SSL_COUNTER_WRAPPING );
   4980                  }
   4981              }
   4982              else
   4983          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   4984              memset( ssl->in_ctr, 0, 8 );
   4985          
   4986              /*
   4987               * Set the in_msg pointer to the correct location based on IV length
   4988               */
   4989              if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
   4990              {
   4991                  ssl->in_msg = ssl->in_iv + ssl->transform_negotiate->ivlen -
   4992                                ssl->transform_negotiate->fixed_ivlen;
   4993              }
   4994              else
   4995                  ssl->in_msg = ssl->in_iv;
   4996          
   4997          #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
   4998              if( mbedtls_ssl_hw_record_activate != NULL )
   4999              {
   5000                  if( ( ret = mbedtls_ssl_hw_record_activate( ssl, MBEDTLS_SSL_CHANNEL_INBOUND ) ) != 0 )
   5001                  {
   5002                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_hw_record_activate", ret );
   5003                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   5004                                                      MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );
   5005                      return( MBEDTLS_ERR_SSL_HW_ACCEL_FAILED );
   5006                  }
   5007              }
   5008          #endif
   5009          
   5010              ssl->state++;
   5011          
   5012              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse change cipher spec" ) );
   5013          
   5014              return( 0 );
   5015          }
   5016          
   5017          void mbedtls_ssl_optimize_checksum( mbedtls_ssl_context *ssl,
   5018                                      const mbedtls_ssl_ciphersuite_t *ciphersuite_info )
   5019          {
   5020              ((void) ciphersuite_info);
   5021          
   5022          #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
   5023              defined(MBEDTLS_SSL_PROTO_TLS1_1)
   5024              if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 )
   5025                  ssl->handshake->update_checksum = ssl_update_checksum_md5sha1;
   5026              else
   5027          #endif
   5028          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5029          #if defined(MBEDTLS_SHA512_C)
   5030              if( ciphersuite_info->mac == MBEDTLS_MD_SHA384 )
   5031                  ssl->handshake->update_checksum = ssl_update_checksum_sha384;
   5032              else
   5033          #endif
   5034          #if defined(MBEDTLS_SHA256_C)
   5035              if( ciphersuite_info->mac != MBEDTLS_MD_SHA384 )
   5036                  ssl->handshake->update_checksum = ssl_update_checksum_sha256;
   5037              else
   5038          #endif
   5039          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   5040              {
   5041                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   5042                  return;
   5043              }
   5044          }
   5045          
   5046          void mbedtls_ssl_reset_checksum( mbedtls_ssl_context *ssl )
   5047          {
   5048          #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
   5049              defined(MBEDTLS_SSL_PROTO_TLS1_1)
   5050               mbedtls_md5_starts_ret( &ssl->handshake->fin_md5  );
   5051              mbedtls_sha1_starts_ret( &ssl->handshake->fin_sha1 );
   5052          #endif
   5053          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5054          #if defined(MBEDTLS_SHA256_C)
   5055              mbedtls_sha256_starts_ret( &ssl->handshake->fin_sha256, 0 );
   5056          #endif
   5057          #if defined(MBEDTLS_SHA512_C)
   5058              mbedtls_sha512_starts_ret( &ssl->handshake->fin_sha512, 1 );
   5059          #endif
   5060          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   5061          }
   5062          
   5063          static void ssl_update_checksum_start( mbedtls_ssl_context *ssl,
   5064                                                 const unsigned char *buf, size_t len )
   5065          {
   5066          #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
   5067              defined(MBEDTLS_SSL_PROTO_TLS1_1)
   5068               mbedtls_md5_update_ret( &ssl->handshake->fin_md5 , buf, len );
   5069              mbedtls_sha1_update_ret( &ssl->handshake->fin_sha1, buf, len );
   5070          #endif
   5071          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5072          #if defined(MBEDTLS_SHA256_C)
   5073              mbedtls_sha256_update_ret( &ssl->handshake->fin_sha256, buf, len );
   5074          #endif
   5075          #if defined(MBEDTLS_SHA512_C)
   5076              mbedtls_sha512_update_ret( &ssl->handshake->fin_sha512, buf, len );
   5077          #endif
   5078          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   5079          }
   5080          
   5081          #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
   5082              defined(MBEDTLS_SSL_PROTO_TLS1_1)
   5083          static void ssl_update_checksum_md5sha1( mbedtls_ssl_context *ssl,
   5084                                                   const unsigned char *buf, size_t len )
   5085          {
   5086               mbedtls_md5_update_ret( &ssl->handshake->fin_md5 , buf, len );
   5087              mbedtls_sha1_update_ret( &ssl->handshake->fin_sha1, buf, len );
   5088          }
   5089          #endif
   5090          
   5091          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5092          #if defined(MBEDTLS_SHA256_C)
   5093          static void ssl_update_checksum_sha256( mbedtls_ssl_context *ssl,
   5094                                                  const unsigned char *buf, size_t len )
   5095          {
   5096              mbedtls_sha256_update_ret( &ssl->handshake->fin_sha256, buf, len );
   5097          }
   5098          #endif
   5099          
   5100          #if defined(MBEDTLS_SHA512_C)
   5101          static void ssl_update_checksum_sha384( mbedtls_ssl_context *ssl,
   5102                                                  const unsigned char *buf, size_t len )
   5103          {
   5104              mbedtls_sha512_update_ret( &ssl->handshake->fin_sha512, buf, len );
   5105          }
   5106          #endif
   5107          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   5108          
   5109          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   5110          static void ssl_calc_finished_ssl(
   5111                          mbedtls_ssl_context *ssl, unsigned char *buf, int from )
   5112          {
   5113              const char *sender;
   5114              mbedtls_md5_context  md5;
   5115              mbedtls_sha1_context sha1;
   5116          
   5117              unsigned char padbuf[48];
   5118              unsigned char md5sum[16];
   5119              unsigned char sha1sum[20];
   5120          
   5121              mbedtls_ssl_session *session = ssl->session_negotiate;
   5122              if( !session )
   5123                  session = ssl->session;
   5124          
   5125              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc  finished ssl" ) );
   5126          
   5127              mbedtls_md5_init( &md5 );
   5128              mbedtls_sha1_init( &sha1 );
   5129          
   5130              mbedtls_md5_clone( &md5, &ssl->handshake->fin_md5 );
   5131              mbedtls_sha1_clone( &sha1, &ssl->handshake->fin_sha1 );
   5132          
   5133              /*
   5134               * SSLv3:
   5135               *   hash =
   5136               *      MD5( master + pad2 +
   5137               *          MD5( handshake + sender + master + pad1 ) )
   5138               *   + SHA1( master + pad2 +
   5139               *         SHA1( handshake + sender + master + pad1 ) )
   5140               */
   5141          
   5142          #if !defined(MBEDTLS_MD5_ALT)
   5143              MBEDTLS_SSL_DEBUG_BUF( 4, "finished  md5 state", (unsigned char *)
   5144                              md5.state, sizeof(  md5.state ) );
   5145          #endif
   5146          
   5147          #if !defined(MBEDTLS_SHA1_ALT)
   5148              MBEDTLS_SSL_DEBUG_BUF( 4, "finished sha1 state", (unsigned char *)
   5149                             sha1.state, sizeof( sha1.state ) );
   5150          #endif
   5151          
   5152              sender = ( from == MBEDTLS_SSL_IS_CLIENT ) ? "CLNT"
   5153                                                 : "SRVR";
   5154          
   5155              memset( padbuf, 0x36, 48 );
   5156          
   5157              mbedtls_md5_update_ret( &md5, (const unsigned char *) sender, 4 );
   5158              mbedtls_md5_update_ret( &md5, session->master, 48 );
   5159              mbedtls_md5_update_ret( &md5, padbuf, 48 );
   5160              mbedtls_md5_finish_ret( &md5, md5sum );
   5161          
   5162              mbedtls_sha1_update_ret( &sha1, (const unsigned char *) sender, 4 );
   5163              mbedtls_sha1_update_ret( &sha1, session->master, 48 );
   5164              mbedtls_sha1_update_ret( &sha1, padbuf, 40 );
   5165              mbedtls_sha1_finish_ret( &sha1, sha1sum );
   5166          
   5167              memset( padbuf, 0x5C, 48 );
   5168          
   5169              mbedtls_md5_starts_ret( &md5 );
   5170              mbedtls_md5_update_ret( &md5, session->master, 48 );
   5171              mbedtls_md5_update_ret( &md5, padbuf, 48 );
   5172              mbedtls_md5_update_ret( &md5, md5sum, 16 );
   5173              mbedtls_md5_finish_ret( &md5, buf );
   5174          
   5175              mbedtls_sha1_starts_ret( &sha1 );
   5176              mbedtls_sha1_update_ret( &sha1, session->master, 48 );
   5177              mbedtls_sha1_update_ret( &sha1, padbuf , 40 );
   5178              mbedtls_sha1_update_ret( &sha1, sha1sum, 20 );
   5179              mbedtls_sha1_finish_ret( &sha1, buf + 16 );
   5180          
   5181              MBEDTLS_SSL_DEBUG_BUF( 3, "calc finished result", buf, 36 );
   5182          
   5183              mbedtls_md5_free(  &md5  );
   5184              mbedtls_sha1_free( &sha1 );
   5185          
   5186              mbedtls_zeroize(  padbuf, sizeof(  padbuf ) );
   5187              mbedtls_zeroize(  md5sum, sizeof(  md5sum ) );
   5188              mbedtls_zeroize( sha1sum, sizeof( sha1sum ) );
   5189          
   5190              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc  finished" ) );
   5191          }
   5192          #endif /* MBEDTLS_SSL_PROTO_SSL3 */
   5193          
   5194          #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1)
   5195          static void ssl_calc_finished_tls(
   5196                          mbedtls_ssl_context *ssl, unsigned char *buf, int from )
   5197          {
   5198              int len = 12;
   5199              const char *sender;
   5200              mbedtls_md5_context  md5;
   5201              mbedtls_sha1_context sha1;
   5202              unsigned char padbuf[36];
   5203          
   5204              mbedtls_ssl_session *session = ssl->session_negotiate;
   5205              if( !session )
   5206                  session = ssl->session;
   5207          
   5208              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc  finished tls" ) );
   5209          
   5210              mbedtls_md5_init( &md5 );
   5211              mbedtls_sha1_init( &sha1 );
   5212          
   5213              mbedtls_md5_clone( &md5, &ssl->handshake->fin_md5 );
   5214              mbedtls_sha1_clone( &sha1, &ssl->handshake->fin_sha1 );
   5215          
   5216              /*
   5217               * TLSv1:
   5218               *   hash = PRF( master, finished_label,
   5219               *               MD5( handshake ) + SHA1( handshake ) )[0..11]
   5220               */
   5221          
   5222          #if !defined(MBEDTLS_MD5_ALT)
   5223              MBEDTLS_SSL_DEBUG_BUF( 4, "finished  md5 state", (unsigned char *)
   5224                              md5.state, sizeof(  md5.state ) );
   5225          #endif
   5226          
   5227          #if !defined(MBEDTLS_SHA1_ALT)
   5228              MBEDTLS_SSL_DEBUG_BUF( 4, "finished sha1 state", (unsigned char *)
   5229                             sha1.state, sizeof( sha1.state ) );
   5230          #endif
   5231          
   5232              sender = ( from == MBEDTLS_SSL_IS_CLIENT )
   5233                       ? "client finished"
   5234                       : "server finished";
   5235          
   5236              mbedtls_md5_finish_ret(  &md5, padbuf );
   5237              mbedtls_sha1_finish_ret( &sha1, padbuf + 16 );
   5238          
   5239              ssl->handshake->tls_prf( session->master, 48, sender,
   5240                                       padbuf, 36, buf, len );
   5241          
   5242              MBEDTLS_SSL_DEBUG_BUF( 3, "calc finished result", buf, len );
   5243          
   5244              mbedtls_md5_free(  &md5  );
   5245              mbedtls_sha1_free( &sha1 );
   5246          
   5247              mbedtls_zeroize(  padbuf, sizeof(  padbuf ) );
   5248          
   5249              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc  finished" ) );
   5250          }
   5251          #endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 */
   5252          
   5253          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5254          #if defined(MBEDTLS_SHA256_C)
   5255          static void ssl_calc_finished_tls_sha256(
   5256                          mbedtls_ssl_context *ssl, unsigned char *buf, int from )
   5257          {
   5258              int len = 12;
   5259              const char *sender;
   5260              mbedtls_sha256_context sha256;
   5261              unsigned char padbuf[32];
   5262          
   5263              mbedtls_ssl_session *session = ssl->session_negotiate;
   5264              if( !session )
   5265                  session = ssl->session;
   5266          
   5267              mbedtls_sha256_init( &sha256 );
   5268          
   5269              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc  finished tls sha256" ) );
   5270          
   5271              mbedtls_sha256_clone( &sha256, &ssl->handshake->fin_sha256 );
   5272          
   5273              /*
   5274               * TLSv1.2:
   5275               *   hash = PRF( master, finished_label,
   5276               *               Hash( handshake ) )[0.11]
   5277               */
   5278          
   5279          #if !defined(MBEDTLS_SHA256_ALT)
   5280              MBEDTLS_SSL_DEBUG_BUF( 4, "finished sha2 state", (unsigned char *)
   5281                             sha256.state, sizeof( sha256.state ) );
   5282          #endif
   5283          
   5284              sender = ( from == MBEDTLS_SSL_IS_CLIENT )
   5285                       ? "client finished"
   5286                       : "server finished";
   5287          
   5288              mbedtls_sha256_finish_ret( &sha256, padbuf );
   5289          
   5290              ssl->handshake->tls_prf( session->master, 48, sender,
   5291                                       padbuf, 32, buf, len );
   5292          
   5293              MBEDTLS_SSL_DEBUG_BUF( 3, "calc finished result", buf, len );
   5294          
   5295              mbedtls_sha256_free( &sha256 );
   5296          
   5297              mbedtls_zeroize(  padbuf, sizeof(  padbuf ) );
   5298          
   5299              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc  finished" ) );
   5300          }
   5301          #endif /* MBEDTLS_SHA256_C */
   5302          
   5303          #if defined(MBEDTLS_SHA512_C)
   5304          static void ssl_calc_finished_tls_sha384(
   5305                          mbedtls_ssl_context *ssl, unsigned char *buf, int from )
   5306          {
   5307              int len = 12;
   5308              const char *sender;
   5309              mbedtls_sha512_context sha512;
   5310              unsigned char padbuf[48];
   5311          
   5312              mbedtls_ssl_session *session = ssl->session_negotiate;
   5313              if( !session )
   5314                  session = ssl->session;
   5315          
   5316              mbedtls_sha512_init( &sha512 );
   5317          
   5318              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> calc  finished tls sha384" ) );
   5319          
   5320              mbedtls_sha512_clone( &sha512, &ssl->handshake->fin_sha512 );
   5321          
   5322              /*
   5323               * TLSv1.2:
   5324               *   hash = PRF( master, finished_label,
   5325               *               Hash( handshake ) )[0.11]
   5326               */
   5327          
   5328          #if !defined(MBEDTLS_SHA512_ALT)
   5329              MBEDTLS_SSL_DEBUG_BUF( 4, "finished sha512 state", (unsigned char *)
   5330                             sha512.state, sizeof( sha512.state ) );
   5331          #endif
   5332          
   5333              sender = ( from == MBEDTLS_SSL_IS_CLIENT )
   5334                       ? "client finished"
   5335                       : "server finished";
   5336          
   5337              mbedtls_sha512_finish_ret( &sha512, padbuf );
   5338          
   5339              ssl->handshake->tls_prf( session->master, 48, sender,
   5340                                       padbuf, 48, buf, len );
   5341          
   5342              MBEDTLS_SSL_DEBUG_BUF( 3, "calc finished result", buf, len );
   5343          
   5344              mbedtls_sha512_free( &sha512 );
   5345          
   5346              mbedtls_zeroize(  padbuf, sizeof( padbuf ) );
   5347          
   5348              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= calc  finished" ) );
   5349          }
   5350          #endif /* MBEDTLS_SHA512_C */
   5351          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   5352          
   5353          static void ssl_handshake_wrapup_free_hs_transform( mbedtls_ssl_context *ssl )
   5354          {
   5355              MBEDTLS_SSL_DEBUG_MSG( 3, ( "=> handshake wrapup: final free" ) );
   5356          
   5357              /*
   5358               * Free our handshake params
   5359               */
   5360              mbedtls_ssl_handshake_free( ssl->handshake );
   5361              mbedtls_free( ssl->handshake );
   5362              ssl->handshake = NULL;
   5363          
   5364              /*
   5365               * Free the previous transform and swith in the current one
   5366               */
   5367              if( ssl->transform )
   5368              {
   5369                  mbedtls_ssl_transform_free( ssl->transform );
   5370                  mbedtls_free( ssl->transform );
   5371              }
   5372              ssl->transform = ssl->transform_negotiate;
   5373              ssl->transform_negotiate = NULL;
   5374          
   5375              MBEDTLS_SSL_DEBUG_MSG( 3, ( "<= handshake wrapup: final free" ) );
   5376          }
   5377          
   5378          void mbedtls_ssl_handshake_wrapup( mbedtls_ssl_context *ssl )
   5379          {
   5380              int resume = ssl->handshake->resume;
   5381          
   5382              MBEDTLS_SSL_DEBUG_MSG( 3, ( "=> handshake wrapup" ) );
   5383          
   5384          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   5385              if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
   5386              {
   5387                  ssl->renego_status =  MBEDTLS_SSL_RENEGOTIATION_DONE;
   5388                  ssl->renego_records_seen = 0;
   5389              }
   5390          #endif
   5391          
   5392              /*
   5393               * Free the previous session and switch in the current one
   5394               */
   5395              if( ssl->session )
   5396              {
   5397          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   5398                  /* RFC 7366 3.1: keep the EtM state */
   5399                  ssl->session_negotiate->encrypt_then_mac =
   5400                            ssl->session->encrypt_then_mac;
   5401          #endif
   5402          
   5403                  mbedtls_ssl_session_free( ssl->session );
   5404                  mbedtls_free( ssl->session );
   5405              }
   5406              ssl->session = ssl->session_negotiate;
   5407              ssl->session_negotiate = NULL;
   5408          
   5409              /*
   5410               * Add cache entry
   5411               */
   5412              if( ssl->conf->f_set_cache != NULL &&
   5413                  ssl->session->id_len != 0 &&
   5414                  resume == 0 )
   5415              {
   5416                  if( ssl->conf->f_set_cache( ssl->conf->p_cache, ssl->session ) != 0 )
   5417                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "cache did not store session" ) );
   5418              }
   5419          
   5420          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5421              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   5422                  ssl->handshake->flight != NULL )
   5423              {
   5424                  /* Cancel handshake timer */
   5425                  ssl_set_timer( ssl, 0 );
   5426          
   5427                  /* Keep last flight around in case we need to resend it:
   5428                   * we need the handshake and transform structures for that */
   5429                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "skip freeing handshake and transform" ) );
   5430              }
   5431              else
   5432          #endif
   5433                  ssl_handshake_wrapup_free_hs_transform( ssl );
   5434          
   5435              ssl->state++;
   5436          
   5437              MBEDTLS_SSL_DEBUG_MSG( 3, ( "<= handshake wrapup" ) );
   5438          }
   5439          
   5440          int mbedtls_ssl_write_finished( mbedtls_ssl_context *ssl )
   5441          {
   5442              int ret, hash_len;
   5443          
   5444              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write finished" ) );
   5445          
   5446              /*
   5447               * Set the out_msg pointer to the correct location based on IV length
   5448               */
   5449              if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
   5450              {
   5451                  ssl->out_msg = ssl->out_iv + ssl->transform_negotiate->ivlen -
   5452                                 ssl->transform_negotiate->fixed_ivlen;
   5453              }
   5454              else
   5455                  ssl->out_msg = ssl->out_iv;
   5456          
   5457              ssl->handshake->calc_finished( ssl, ssl->out_msg + 4, ssl->conf->endpoint );
   5458          
   5459              /*
   5460               * RFC 5246 7.4.9 (Page 63) says 12 is the default length and ciphersuites
   5461               * may define some other value. Currently (early 2016), no defined
   5462               * ciphersuite does this (and this is unlikely to change as activity has
   5463               * moved to TLS 1.3 now) so we can keep the hardcoded 12 here.
   5464               */
   5465              hash_len = ( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 ) ? 36 : 12;
   5466          
   5467          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   5468              ssl->verify_data_len = hash_len;
   5469              memcpy( ssl->own_verify_data, ssl->out_msg + 4, hash_len );
   5470          #endif
   5471          
   5472              ssl->out_msglen  = 4 + hash_len;
   5473              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   5474              ssl->out_msg[0]  = MBEDTLS_SSL_HS_FINISHED;
   5475          
   5476              /*
   5477               * In case of session resuming, invert the client and server
   5478               * ChangeCipherSpec messages order.
   5479               */
   5480              if( ssl->handshake->resume != 0 )
   5481              {
   5482          #if defined(MBEDTLS_SSL_CLI_C)
   5483                  if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
   5484                      ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
   5485          #endif
   5486          #if defined(MBEDTLS_SSL_SRV_C)
   5487                  if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER )
   5488                      ssl->state = MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC;
   5489          #endif
   5490              }
   5491              else
   5492                  ssl->state++;
   5493          
   5494              /*
   5495               * Switch to our negotiated transform and session parameters for outbound
   5496               * data.
   5497               */
   5498              MBEDTLS_SSL_DEBUG_MSG( 3, ( "switching to new transform spec for outbound data" ) );
   5499          
   5500          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5501              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   5502              {
   5503                  unsigned char i;
   5504          
   5505                  /* Remember current epoch settings for resending */
   5506                  ssl->handshake->alt_transform_out = ssl->transform_out;
   5507                  memcpy( ssl->handshake->alt_out_ctr, ssl->out_ctr, 8 );
   5508          
   5509                  /* Set sequence_number to zero */
   5510                  memset( ssl->out_ctr + 2, 0, 6 );
   5511          
   5512                  /* Increment epoch */
   5513                  for( i = 2; i > 0; i-- )
   5514                      if( ++ssl->out_ctr[i - 1] != 0 )
   5515                          break;
   5516          
   5517                  /* The loop goes to its end iff the counter is wrapping */
   5518                  if( i == 0 )
   5519                  {
   5520                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "DTLS epoch would wrap" ) );
   5521                      return( MBEDTLS_ERR_SSL_COUNTER_WRAPPING );
   5522                  }
   5523              }
   5524              else
   5525          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   5526              memset( ssl->out_ctr, 0, 8 );
   5527          
   5528              ssl->transform_out = ssl->transform_negotiate;
   5529              ssl->session_out = ssl->session_negotiate;
   5530          
   5531          #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
   5532              if( mbedtls_ssl_hw_record_activate != NULL )
   5533              {
   5534                  if( ( ret = mbedtls_ssl_hw_record_activate( ssl, MBEDTLS_SSL_CHANNEL_OUTBOUND ) ) != 0 )
   5535                  {
   5536                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_hw_record_activate", ret );
   5537                      return( MBEDTLS_ERR_SSL_HW_ACCEL_FAILED );
   5538                  }
   5539              }
   5540          #endif
   5541          
   5542          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5543              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   5544                  mbedtls_ssl_send_flight_completed( ssl );
   5545          #endif
   5546          
   5547              if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
   5548              {
   5549                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
   5550                  return( ret );
   5551              }
   5552          
   5553              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write finished" ) );
   5554          
   5555              return( 0 );
   5556          }
   5557          
   5558          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   5559          #define SSL_MAX_HASH_LEN 36
   5560          #else
   5561          #define SSL_MAX_HASH_LEN 12
   5562          #endif
   5563          
   5564          int mbedtls_ssl_parse_finished( mbedtls_ssl_context *ssl )
   5565          {
   5566              int ret;
   5567              unsigned int hash_len;
   5568              unsigned char buf[SSL_MAX_HASH_LEN];
   5569          
   5570              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse finished" ) );
   5571          
   5572              ssl->handshake->calc_finished( ssl, buf, ssl->conf->endpoint ^ 1 );
   5573          
   5574              if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
   5575              {
   5576                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
   5577                  return( ret );
   5578              }
   5579          
   5580              if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
   5581              {
   5582                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad finished message" ) );
   5583                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   5584                                                  MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );
   5585                  return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
   5586              }
   5587          
   5588              /* There is currently no ciphersuite using another length with TLS 1.2 */
   5589          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   5590              if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
   5591                  hash_len = 36;
   5592              else
   5593          #endif
   5594                  hash_len = 12;
   5595          
   5596              if( ssl->in_msg[0] != MBEDTLS_SSL_HS_FINISHED ||
   5597                  ssl->in_hslen  != mbedtls_ssl_hs_hdr_len( ssl ) + hash_len )
   5598              {
   5599                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad finished message" ) );
   5600                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   5601                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   5602                  return( MBEDTLS_ERR_SSL_BAD_HS_FINISHED );
   5603              }
   5604          
   5605              if( mbedtls_ssl_safer_memcmp( ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl ),
   5606                                buf, hash_len ) != 0 )
   5607              {
   5608                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad finished message" ) );
   5609                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   5610                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   5611                  return( MBEDTLS_ERR_SSL_BAD_HS_FINISHED );
   5612              }
   5613          
   5614          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   5615              ssl->verify_data_len = hash_len;
   5616              memcpy( ssl->peer_verify_data, buf, hash_len );
   5617          #endif
   5618          
   5619              if( ssl->handshake->resume != 0 )
   5620              {
   5621          #if defined(MBEDTLS_SSL_CLI_C)
   5622                  if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
   5623                      ssl->state = MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC;
   5624          #endif
   5625          #if defined(MBEDTLS_SSL_SRV_C)
   5626                  if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER )
   5627                      ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
   5628          #endif
   5629              }
   5630              else
   5631                  ssl->state++;
   5632          
   5633          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5634              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   5635                  mbedtls_ssl_recv_flight_completed( ssl );
   5636          #endif
   5637          
   5638              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse finished" ) );
   5639          
   5640              return( 0 );
   5641          }
   5642          
   5643          static void ssl_handshake_params_init( mbedtls_ssl_handshake_params *handshake )
   5644          {
   5645              memset( handshake, 0, sizeof( mbedtls_ssl_handshake_params ) );
   5646          
   5647          #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
   5648              defined(MBEDTLS_SSL_PROTO_TLS1_1)
   5649               mbedtls_md5_init(   &handshake->fin_md5  );
   5650              mbedtls_sha1_init(   &handshake->fin_sha1 );
   5651               mbedtls_md5_starts_ret( &handshake->fin_md5  );
   5652              mbedtls_sha1_starts_ret( &handshake->fin_sha1 );
   5653          #endif
   5654          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   5655          #if defined(MBEDTLS_SHA256_C)
   5656              mbedtls_sha256_init(   &handshake->fin_sha256    );
   5657              mbedtls_sha256_starts_ret( &handshake->fin_sha256, 0 );
   5658          #endif
   5659          #if defined(MBEDTLS_SHA512_C)
   5660              mbedtls_sha512_init(   &handshake->fin_sha512    );
   5661              mbedtls_sha512_starts_ret( &handshake->fin_sha512, 1 );
   5662          #endif
   5663          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   5664          
   5665              handshake->update_checksum = ssl_update_checksum_start;
   5666          
   5667          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
   5668              defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
   5669              mbedtls_ssl_sig_hash_set_init( &handshake->hash_algs );
   5670          #endif
   5671          
   5672          #if defined(MBEDTLS_DHM_C)
   5673              mbedtls_dhm_init( &handshake->dhm_ctx );
   5674          #endif
   5675          #if defined(MBEDTLS_ECDH_C)
   5676              mbedtls_ecdh_init( &handshake->ecdh_ctx );
   5677          #endif
   5678          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   5679              mbedtls_ecjpake_init( &handshake->ecjpake_ctx );
   5680          #if defined(MBEDTLS_SSL_CLI_C)
   5681              handshake->ecjpake_cache = NULL;
   5682              handshake->ecjpake_cache_len = 0;
   5683          #endif
   5684          #endif
   5685          
   5686          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   5687              handshake->sni_authmode = MBEDTLS_SSL_VERIFY_UNSET;
   5688          #endif
   5689          }
   5690          
   5691          static void ssl_transform_init( mbedtls_ssl_transform *transform )
   5692          {
   5693              memset( transform, 0, sizeof(mbedtls_ssl_transform) );
   5694          
   5695              mbedtls_cipher_init( &transform->cipher_ctx_enc );
   5696              mbedtls_cipher_init( &transform->cipher_ctx_dec );
   5697          
   5698              mbedtls_md_init( &transform->md_ctx_enc );
   5699              mbedtls_md_init( &transform->md_ctx_dec );
   5700          }
   5701          
   5702          void mbedtls_ssl_session_init( mbedtls_ssl_session *session )
   5703          {
   5704              memset( session, 0, sizeof(mbedtls_ssl_session) );
   5705          }
   5706          
   5707          static int ssl_handshake_init( mbedtls_ssl_context *ssl )
   5708          {
   5709              /* Clear old handshake information if present */
   5710              if( ssl->transform_negotiate )
   5711                  mbedtls_ssl_transform_free( ssl->transform_negotiate );
   5712              if( ssl->session_negotiate )
   5713                  mbedtls_ssl_session_free( ssl->session_negotiate );
   5714              if( ssl->handshake )
   5715                  mbedtls_ssl_handshake_free( ssl->handshake );
   5716          
   5717              /*
   5718               * Either the pointers are now NULL or cleared properly and can be freed.
   5719               * Now allocate missing structures.
   5720               */
   5721              if( ssl->transform_negotiate == NULL )
   5722              {
   5723                  ssl->transform_negotiate = mbedtls_calloc( 1, sizeof(mbedtls_ssl_transform) );
   5724              }
   5725          
   5726              if( ssl->session_negotiate == NULL )
   5727              {
   5728                  ssl->session_negotiate = mbedtls_calloc( 1, sizeof(mbedtls_ssl_session) );
   5729              }
   5730          
   5731              if( ssl->handshake == NULL )
   5732              {
   5733                  ssl->handshake = mbedtls_calloc( 1, sizeof(mbedtls_ssl_handshake_params) );
   5734              }
   5735          
   5736              /* All pointers should exist and can be directly freed without issue */
   5737              if( ssl->handshake == NULL ||
   5738                  ssl->transform_negotiate == NULL ||
   5739                  ssl->session_negotiate == NULL )
   5740              {
   5741                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc() of ssl sub-contexts failed" ) );
   5742          
   5743                  mbedtls_free( ssl->handshake );
   5744                  mbedtls_free( ssl->transform_negotiate );
   5745                  mbedtls_free( ssl->session_negotiate );
   5746          
   5747                  ssl->handshake = NULL;
   5748                  ssl->transform_negotiate = NULL;
   5749                  ssl->session_negotiate = NULL;
   5750          
   5751                  return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
   5752              }
   5753          
   5754              /* Initialize structures */
   5755              mbedtls_ssl_session_init( ssl->session_negotiate );
   5756              ssl_transform_init( ssl->transform_negotiate );
   5757              ssl_handshake_params_init( ssl->handshake );
   5758          
   5759          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5760              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   5761              {
   5762                  ssl->handshake->alt_transform_out = ssl->transform_out;
   5763          
   5764                  if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
   5765                      ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_PREPARING;
   5766                  else
   5767                      ssl->handshake->retransmit_state = MBEDTLS_SSL_RETRANS_WAITING;
   5768          
   5769                  ssl_set_timer( ssl, 0 );
   5770              }
   5771          #endif
   5772          
   5773              return( 0 );
   5774          }
   5775          
   5776          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(MBEDTLS_SSL_SRV_C)
   5777          /* Dummy cookie callbacks for defaults */
   5778          static int ssl_cookie_write_dummy( void *ctx,
   5779                                unsigned char **p, unsigned char *end,
   5780                                const unsigned char *cli_id, size_t cli_id_len )
   5781          {
   5782              ((void) ctx);
   5783              ((void) p);
   5784              ((void) end);
   5785              ((void) cli_id);
   5786              ((void) cli_id_len);
   5787          
   5788              return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
   5789          }
   5790          
   5791          static int ssl_cookie_check_dummy( void *ctx,
   5792                                const unsigned char *cookie, size_t cookie_len,
   5793                                const unsigned char *cli_id, size_t cli_id_len )
   5794          {
   5795              ((void) ctx);
   5796              ((void) cookie);
   5797              ((void) cookie_len);
   5798              ((void) cli_id);
   5799              ((void) cli_id_len);
   5800          
   5801              return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
   5802          }
   5803          #endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY && MBEDTLS_SSL_SRV_C */
   5804          
   5805          /*
   5806           * Initialize an SSL context
   5807           */
   5808          void mbedtls_ssl_init( mbedtls_ssl_context *ssl )
   5809          {
   5810              memset( ssl, 0, sizeof( mbedtls_ssl_context ) );
   5811          }
   5812          
   5813          /*
   5814           * Setup an SSL context
   5815           */
   5816          int mbedtls_ssl_setup( mbedtls_ssl_context *ssl,
   5817                                 const mbedtls_ssl_config *conf )
   5818          {
   5819              int ret;
   5820              const size_t len = MBEDTLS_SSL_BUFFER_LEN;
   5821          
   5822              ssl->conf = conf;
   5823          
   5824              /*
   5825               * Prepare base structures
   5826               */
   5827              ssl->in_buf = NULL;
   5828              ssl->out_buf = NULL;
   5829              if( ( ssl-> in_buf = mbedtls_calloc( 1, len ) ) == NULL ||
   5830                  ( ssl->out_buf = mbedtls_calloc( 1, len ) ) == NULL )
   5831              {
   5832                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "alloc(%d bytes) failed", len ) );
   5833                  ret = MBEDTLS_ERR_SSL_ALLOC_FAILED;
   5834                  goto error;
   5835              }
   5836          
   5837          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5838              if( conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   5839              {
   5840                  ssl->out_hdr = ssl->out_buf;
   5841                  ssl->out_ctr = ssl->out_buf +  3;
   5842                  ssl->out_len = ssl->out_buf + 11;
   5843                  ssl->out_iv  = ssl->out_buf + 13;
   5844                  ssl->out_msg = ssl->out_buf + 13;
   5845          
   5846                  ssl->in_hdr = ssl->in_buf;
   5847                  ssl->in_ctr = ssl->in_buf +  3;
   5848                  ssl->in_len = ssl->in_buf + 11;
   5849                  ssl->in_iv  = ssl->in_buf + 13;
   5850                  ssl->in_msg = ssl->in_buf + 13;
   5851              }
   5852              else
   5853          #endif
   5854              {
   5855                  ssl->out_ctr = ssl->out_buf;
   5856                  ssl->out_hdr = ssl->out_buf +  8;
   5857                  ssl->out_len = ssl->out_buf + 11;
   5858                  ssl->out_iv  = ssl->out_buf + 13;
   5859                  ssl->out_msg = ssl->out_buf + 13;
   5860          
   5861                  ssl->in_ctr = ssl->in_buf;
   5862                  ssl->in_hdr = ssl->in_buf +  8;
   5863                  ssl->in_len = ssl->in_buf + 11;
   5864                  ssl->in_iv  = ssl->in_buf + 13;
   5865                  ssl->in_msg = ssl->in_buf + 13;
   5866              }
   5867          
   5868              if( ( ret = ssl_handshake_init( ssl ) ) != 0 )
   5869                  goto error;
   5870          
   5871              return( 0 );
   5872          
   5873          error:
   5874              mbedtls_free( ssl->in_buf );
   5875              mbedtls_free( ssl->out_buf );
   5876          
   5877              ssl->conf = NULL;
   5878          
   5879              ssl->in_buf = NULL;
   5880              ssl->out_buf = NULL;
   5881          
   5882              ssl->in_hdr = NULL;
   5883              ssl->in_ctr = NULL;
   5884              ssl->in_len = NULL;
   5885              ssl->in_iv = NULL;
   5886              ssl->in_msg = NULL;
   5887          
   5888              ssl->out_hdr = NULL;
   5889              ssl->out_ctr = NULL;
   5890              ssl->out_len = NULL;
   5891              ssl->out_iv = NULL;
   5892              ssl->out_msg = NULL;
   5893          
   5894              return( ret );
   5895          }
   5896          
   5897          /*
   5898           * Reset an initialized and used SSL context for re-use while retaining
   5899           * all application-set variables, function pointers and data.
   5900           *
   5901           * If partial is non-zero, keep data in the input buffer and client ID.
   5902           * (Use when a DTLS client reconnects from the same port.)
   5903           */
   5904          static int ssl_session_reset_int( mbedtls_ssl_context *ssl, int partial )
   5905          {
   5906              int ret;
   5907          
   5908              ssl->state = MBEDTLS_SSL_HELLO_REQUEST;
   5909          
   5910              /* Cancel any possibly running timer */
   5911              ssl_set_timer( ssl, 0 );
   5912          
   5913          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   5914              ssl->renego_status = MBEDTLS_SSL_INITIAL_HANDSHAKE;
   5915              ssl->renego_records_seen = 0;
   5916          
   5917              ssl->verify_data_len = 0;
   5918              memset( ssl->own_verify_data, 0, MBEDTLS_SSL_VERIFY_DATA_MAX_LEN );
   5919              memset( ssl->peer_verify_data, 0, MBEDTLS_SSL_VERIFY_DATA_MAX_LEN );
   5920          #endif
   5921              ssl->secure_renegotiation = MBEDTLS_SSL_LEGACY_RENEGOTIATION;
   5922          
   5923              ssl->in_offt = NULL;
   5924          
   5925              ssl->in_msg = ssl->in_buf + 13;
   5926              ssl->in_msgtype = 0;
   5927              ssl->in_msglen = 0;
   5928              if( partial == 0 )
   5929                  ssl->in_left = 0;
   5930          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   5931              ssl->next_record_offset = 0;
   5932              ssl->in_epoch = 0;
   5933          #endif
   5934          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   5935              ssl_dtls_replay_reset( ssl );
   5936          #endif
   5937          
   5938              ssl->in_hslen = 0;
   5939              ssl->nb_zero = 0;
   5940          
   5941              ssl->keep_current_message = 0;
   5942          
   5943              ssl->out_msg = ssl->out_buf + 13;
   5944              ssl->out_msgtype = 0;
   5945              ssl->out_msglen = 0;
   5946              ssl->out_left = 0;
   5947          #if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)
   5948              if( ssl->split_done != MBEDTLS_SSL_CBC_RECORD_SPLITTING_DISABLED )
   5949                  ssl->split_done = 0;
   5950          #endif
   5951          
   5952              ssl->transform_in = NULL;
   5953              ssl->transform_out = NULL;
   5954          
   5955              ssl->session_in = NULL;
   5956              ssl->session_out = NULL;
   5957          
   5958              memset( ssl->out_buf, 0, MBEDTLS_SSL_BUFFER_LEN );
   5959          
   5960              if( partial == 0 )
   5961                  memset( ssl->in_buf, 0, MBEDTLS_SSL_BUFFER_LEN );
   5962          
   5963          #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
   5964              if( mbedtls_ssl_hw_record_reset != NULL )
   5965              {
   5966                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "going for mbedtls_ssl_hw_record_reset()" ) );
   5967                  if( ( ret = mbedtls_ssl_hw_record_reset( ssl ) ) != 0 )
   5968                  {
   5969                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_hw_record_reset", ret );
   5970                      return( MBEDTLS_ERR_SSL_HW_ACCEL_FAILED );
   5971                  }
   5972              }
   5973          #endif
   5974          
   5975              if( ssl->transform )
   5976              {
   5977                  mbedtls_ssl_transform_free( ssl->transform );
   5978                  mbedtls_free( ssl->transform );
   5979                  ssl->transform = NULL;
   5980              }
   5981          
   5982              if( ssl->session )
   5983              {
   5984                  mbedtls_ssl_session_free( ssl->session );
   5985                  mbedtls_free( ssl->session );
   5986                  ssl->session = NULL;
   5987              }
   5988          
   5989          #if defined(MBEDTLS_SSL_ALPN)
   5990              ssl->alpn_chosen = NULL;
   5991          #endif
   5992          
   5993          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(MBEDTLS_SSL_SRV_C)
   5994              if( partial == 0 )
   5995              {
   5996                  mbedtls_free( ssl->cli_id );
   5997                  ssl->cli_id = NULL;
   5998                  ssl->cli_id_len = 0;
   5999              }
   6000          #endif
   6001          
   6002              if( ( ret = ssl_handshake_init( ssl ) ) != 0 )
   6003                  return( ret );
   6004          
   6005              return( 0 );
   6006          }
   6007          
   6008          /*
   6009           * Reset an initialized and used SSL context for re-use while retaining
   6010           * all application-set variables, function pointers and data.
   6011           */
   6012          int mbedtls_ssl_session_reset( mbedtls_ssl_context *ssl )
   6013          {
   6014              return( ssl_session_reset_int( ssl, 0 ) );
   6015          }
   6016          
   6017          /*
   6018           * SSL set accessors
   6019           */
   6020          void mbedtls_ssl_conf_endpoint( mbedtls_ssl_config *conf, int endpoint )
   6021          {
   6022              conf->endpoint   = endpoint;
   6023          }
   6024          
   6025          void mbedtls_ssl_conf_transport( mbedtls_ssl_config *conf, int transport )
   6026          {
   6027              conf->transport = transport;
   6028          }
   6029          
   6030          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   6031          void mbedtls_ssl_conf_dtls_anti_replay( mbedtls_ssl_config *conf, char mode )
   6032          {
   6033              conf->anti_replay = mode;
   6034          }
   6035          #endif
   6036          
   6037          #if defined(MBEDTLS_SSL_DTLS_BADMAC_LIMIT)
   6038          void mbedtls_ssl_conf_dtls_badmac_limit( mbedtls_ssl_config *conf, unsigned limit )
   6039          {
   6040              conf->badmac_limit = limit;
   6041          }
   6042          #endif
   6043          
   6044          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   6045          void mbedtls_ssl_conf_handshake_timeout( mbedtls_ssl_config *conf, uint32_t min, uint32_t max )
   6046          {
   6047              conf->hs_timeout_min = min;
   6048              conf->hs_timeout_max = max;
   6049          }
   6050          #endif
   6051          
   6052          void mbedtls_ssl_conf_authmode( mbedtls_ssl_config *conf, int authmode )
   6053          {
   6054              conf->authmode   = authmode;
   6055          }
   6056          
   6057          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   6058          void mbedtls_ssl_conf_verify( mbedtls_ssl_config *conf,
   6059                               int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
   6060                               void *p_vrfy )
   6061          {
   6062              conf->f_vrfy      = f_vrfy;
   6063              conf->p_vrfy      = p_vrfy;
   6064          }
   6065          #endif /* MBEDTLS_X509_CRT_PARSE_C */
   6066          
   6067          void mbedtls_ssl_conf_rng( mbedtls_ssl_config *conf,
   6068                            int (*f_rng)(void *, unsigned char *, size_t),
   6069                            void *p_rng )
   6070          {
   6071              conf->f_rng      = f_rng;
   6072              conf->p_rng      = p_rng;
   6073          }
   6074          
   6075          void mbedtls_ssl_conf_dbg( mbedtls_ssl_config *conf,
   6076                            void (*f_dbg)(void *, int, const char *, int, const char *),
   6077                            void  *p_dbg )
   6078          {
   6079              conf->f_dbg      = f_dbg;
   6080              conf->p_dbg      = p_dbg;
   6081          }
   6082          
   6083          void mbedtls_ssl_set_bio( mbedtls_ssl_context *ssl,
   6084                  void *p_bio,
   6085                  mbedtls_ssl_send_t *f_send,
   6086                  mbedtls_ssl_recv_t *f_recv,
   6087                  mbedtls_ssl_recv_timeout_t *f_recv_timeout )
   6088          {
   6089              ssl->p_bio          = p_bio;
   6090              ssl->f_send         = f_send;
   6091              ssl->f_recv         = f_recv;
   6092              ssl->f_recv_timeout = f_recv_timeout;
   6093          }
   6094          
   6095          void mbedtls_ssl_conf_read_timeout( mbedtls_ssl_config *conf, uint32_t timeout )
   6096          {
   6097              conf->read_timeout   = timeout;
   6098          }
   6099          
   6100          void mbedtls_ssl_set_timer_cb( mbedtls_ssl_context *ssl,
   6101                                         void *p_timer,
   6102                                         mbedtls_ssl_set_timer_t *f_set_timer,
   6103                                         mbedtls_ssl_get_timer_t *f_get_timer )
   6104          {
   6105              ssl->p_timer        = p_timer;
   6106              ssl->f_set_timer    = f_set_timer;
   6107              ssl->f_get_timer    = f_get_timer;
   6108          
   6109              /* Make sure we start with no timer running */
   6110              ssl_set_timer( ssl, 0 );
   6111          }
   6112          
   6113          #if defined(MBEDTLS_SSL_SRV_C)
   6114          void mbedtls_ssl_conf_session_cache( mbedtls_ssl_config *conf,
   6115                  void *p_cache,
   6116                  int (*f_get_cache)(void *, mbedtls_ssl_session *),
   6117                  int (*f_set_cache)(void *, const mbedtls_ssl_session *) )
   6118          {
   6119              conf->p_cache = p_cache;
   6120              conf->f_get_cache = f_get_cache;
   6121              conf->f_set_cache = f_set_cache;
   6122          }
   6123          #endif /* MBEDTLS_SSL_SRV_C */
   6124          
   6125          #if defined(MBEDTLS_SSL_CLI_C)
   6126          int mbedtls_ssl_set_session( mbedtls_ssl_context *ssl, const mbedtls_ssl_session *session )
   6127          {
   6128              int ret;
   6129          
   6130              if( ssl == NULL ||
   6131                  session == NULL ||
   6132                  ssl->session_negotiate == NULL ||
   6133                  ssl->conf->endpoint != MBEDTLS_SSL_IS_CLIENT )
   6134              {
   6135                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   6136              }
   6137          
   6138              if( ( ret = ssl_session_copy( ssl->session_negotiate, session ) ) != 0 )
   6139                  return( ret );
   6140          
   6141              ssl->handshake->resume = 1;
   6142          
   6143              return( 0 );
   6144          }
   6145          #endif /* MBEDTLS_SSL_CLI_C */
   6146          
   6147          void mbedtls_ssl_conf_ciphersuites( mbedtls_ssl_config *conf,
   6148                                             const int *ciphersuites )
   6149          {
   6150              conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_0] = ciphersuites;
   6151              conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_1] = ciphersuites;
   6152              conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_2] = ciphersuites;
   6153              conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_3] = ciphersuites;
   6154          }
   6155          
   6156          void mbedtls_ssl_conf_ciphersuites_for_version( mbedtls_ssl_config *conf,
   6157                                                 const int *ciphersuites,
   6158                                                 int major, int minor )
   6159          {
   6160              if( major != MBEDTLS_SSL_MAJOR_VERSION_3 )
   6161                  return;
   6162          
   6163              if( minor < MBEDTLS_SSL_MINOR_VERSION_0 || minor > MBEDTLS_SSL_MINOR_VERSION_3 )
   6164                  return;
   6165          
   6166              conf->ciphersuite_list[minor] = ciphersuites;
   6167          }
   6168          
   6169          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   6170          void mbedtls_ssl_conf_cert_profile( mbedtls_ssl_config *conf,
   6171                                              const mbedtls_x509_crt_profile *profile )
   6172          {
   6173              conf->cert_profile = profile;
   6174          }
   6175          
   6176          /* Append a new keycert entry to a (possibly empty) list */
   6177          static int ssl_append_key_cert( mbedtls_ssl_key_cert **head,
   6178                                          mbedtls_x509_crt *cert,
   6179                                          mbedtls_pk_context *key )
   6180          {
   6181              mbedtls_ssl_key_cert *new_cert;
   6182          
   6183              new_cert = mbedtls_calloc( 1, sizeof( mbedtls_ssl_key_cert ) );
   6184              if( new_cert == NULL )
   6185                  return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
   6186          
   6187              new_cert->cert = cert;
   6188              new_cert->key  = key;
   6189              new_cert->next = NULL;
   6190          
   6191              /* Update head is the list was null, else add to the end */
   6192              if( *head == NULL )
   6193              {
   6194                  *head = new_cert;
   6195              }
   6196              else
   6197              {
   6198                  mbedtls_ssl_key_cert *cur = *head;
   6199                  while( cur->next != NULL )
   6200                      cur = cur->next;
   6201                  cur->next = new_cert;
   6202              }
   6203          
   6204              return( 0 );
   6205          }
   6206          
   6207          int mbedtls_ssl_conf_own_cert( mbedtls_ssl_config *conf,
   6208                                        mbedtls_x509_crt *own_cert,
   6209                                        mbedtls_pk_context *pk_key )
   6210          {
   6211              return( ssl_append_key_cert( &conf->key_cert, own_cert, pk_key ) );
   6212          }
   6213          
   6214          void mbedtls_ssl_conf_ca_chain( mbedtls_ssl_config *conf,
   6215                                         mbedtls_x509_crt *ca_chain,
   6216                                         mbedtls_x509_crl *ca_crl )
   6217          {
   6218              conf->ca_chain   = ca_chain;
   6219              conf->ca_crl     = ca_crl;
   6220          }
   6221          #endif /* MBEDTLS_X509_CRT_PARSE_C */
   6222          
   6223          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   6224          int mbedtls_ssl_set_hs_own_cert( mbedtls_ssl_context *ssl,
   6225                                           mbedtls_x509_crt *own_cert,
   6226                                           mbedtls_pk_context *pk_key )
   6227          {
   6228              return( ssl_append_key_cert( &ssl->handshake->sni_key_cert,
   6229                                           own_cert, pk_key ) );
   6230          }
   6231          
   6232          void mbedtls_ssl_set_hs_ca_chain( mbedtls_ssl_context *ssl,
   6233                                            mbedtls_x509_crt *ca_chain,
   6234                                            mbedtls_x509_crl *ca_crl )
   6235          {
   6236              ssl->handshake->sni_ca_chain   = ca_chain;
   6237              ssl->handshake->sni_ca_crl     = ca_crl;
   6238          }
   6239          
   6240          void mbedtls_ssl_set_hs_authmode( mbedtls_ssl_context *ssl,
   6241                                            int authmode )
   6242          {
   6243              ssl->handshake->sni_authmode = authmode;
   6244          }
   6245          #endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
   6246          
   6247          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   6248          /*
   6249           * Set EC J-PAKE password for current handshake
   6250           */
   6251          int mbedtls_ssl_set_hs_ecjpake_password( mbedtls_ssl_context *ssl,
   6252                                                   const unsigned char *pw,
   6253                                                   size_t pw_len )
   6254          {
   6255              mbedtls_ecjpake_role role;
   6256          
   6257              if( ssl->handshake == NULL || ssl->conf == NULL )
   6258                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   6259          
   6260              if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER )
   6261                  role = MBEDTLS_ECJPAKE_SERVER;
   6262              else
   6263                  role = MBEDTLS_ECJPAKE_CLIENT;
   6264          
   6265              return( mbedtls_ecjpake_setup( &ssl->handshake->ecjpake_ctx,
   6266                                             role,
   6267                                             MBEDTLS_MD_SHA256,
   6268                                             MBEDTLS_ECP_DP_SECP256R1,
   6269                                             pw, pw_len ) );
   6270          }
   6271          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   6272          
   6273          #if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)
   6274          int mbedtls_ssl_conf_psk( mbedtls_ssl_config *conf,
   6275                          const unsigned char *psk, size_t psk_len,
   6276                          const unsigned char *psk_identity, size_t psk_identity_len )
   6277          {
   6278              if( psk == NULL || psk_identity == NULL )
   6279                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   6280          
   6281              if( psk_len > MBEDTLS_PSK_MAX_LEN )
   6282                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   6283          
   6284              /* Identity len will be encoded on two bytes */
   6285              if( ( psk_identity_len >> 16 ) != 0 ||
   6286                  psk_identity_len > MBEDTLS_SSL_MAX_CONTENT_LEN )
   6287              {
   6288                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   6289              }
   6290          
   6291              if( conf->psk != NULL )
   6292              {
   6293                  mbedtls_zeroize( conf->psk, conf->psk_len );
   6294          
   6295                  mbedtls_free( conf->psk );
   6296                  conf->psk = NULL;
   6297                  conf->psk_len = 0;
   6298              }
   6299              if( conf->psk_identity != NULL )
   6300              {
   6301                  mbedtls_free( conf->psk_identity );
   6302                  conf->psk_identity = NULL;
   6303                  conf->psk_identity_len = 0;
   6304              }
   6305          
   6306              if( ( conf->psk = mbedtls_calloc( 1, psk_len ) ) == NULL ||
   6307                  ( conf->psk_identity = mbedtls_calloc( 1, psk_identity_len ) ) == NULL )
   6308              {
   6309                  mbedtls_free( conf->psk );
   6310                  mbedtls_free( conf->psk_identity );
   6311                  conf->psk = NULL;
   6312                  conf->psk_identity = NULL;
   6313                  return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
   6314              }
   6315          
   6316              conf->psk_len = psk_len;
   6317              conf->psk_identity_len = psk_identity_len;
   6318          
   6319              memcpy( conf->psk, psk, conf->psk_len );
   6320              memcpy( conf->psk_identity, psk_identity, conf->psk_identity_len );
   6321          
   6322              return( 0 );
   6323          }
   6324          
   6325          int mbedtls_ssl_set_hs_psk( mbedtls_ssl_context *ssl,
   6326                                      const unsigned char *psk, size_t psk_len )
   6327          {
   6328              if( psk == NULL || ssl->handshake == NULL )
   6329                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   6330          
   6331              if( psk_len > MBEDTLS_PSK_MAX_LEN )
   6332                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   6333          
   6334              if( ssl->handshake->psk != NULL )
   6335              {
   6336                  mbedtls_zeroize( ssl->handshake->psk, ssl->handshake->psk_len );
   6337                  mbedtls_free( ssl->handshake->psk );
   6338                  ssl->handshake->psk_len = 0;
   6339              }
   6340          
   6341              if( ( ssl->handshake->psk = mbedtls_calloc( 1, psk_len ) ) == NULL )
   6342                  return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
   6343          
   6344              ssl->handshake->psk_len = psk_len;
   6345              memcpy( ssl->handshake->psk, psk, ssl->handshake->psk_len );
   6346          
   6347              return( 0 );
   6348          }
   6349          
   6350          void mbedtls_ssl_conf_psk_cb( mbedtls_ssl_config *conf,
   6351                               int (*f_psk)(void *, mbedtls_ssl_context *, const unsigned char *,
   6352                               size_t),
   6353                               void *p_psk )
   6354          {
   6355              conf->f_psk = f_psk;
   6356              conf->p_psk = p_psk;
   6357          }
   6358          #endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */
   6359          
   6360          #if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_SRV_C)
   6361          
   6362          #if !defined(MBEDTLS_DEPRECATED_REMOVED)
   6363          int mbedtls_ssl_conf_dh_param( mbedtls_ssl_config *conf, const char *dhm_P, const char *dhm_G )
   6364          {
   6365              int ret;
   6366          
   6367              if( ( ret = mbedtls_mpi_read_string( &conf->dhm_P, 16, dhm_P ) ) != 0 ||
   6368                  ( ret = mbedtls_mpi_read_string( &conf->dhm_G, 16, dhm_G ) ) != 0 )
   6369              {
   6370                  mbedtls_mpi_free( &conf->dhm_P );
   6371                  mbedtls_mpi_free( &conf->dhm_G );
   6372                  return( ret );
   6373              }
   6374          
   6375              return( 0 );
   6376          }
   6377          #endif /* MBEDTLS_DEPRECATED_REMOVED */
   6378          
   6379          int mbedtls_ssl_conf_dh_param_bin( mbedtls_ssl_config *conf,
   6380                                             const unsigned char *dhm_P, size_t P_len,
   6381                                             const unsigned char *dhm_G, size_t G_len )
   6382          {
   6383              int ret;
   6384          
   6385              if( ( ret = mbedtls_mpi_read_binary( &conf->dhm_P, dhm_P, P_len ) ) != 0 ||
   6386                  ( ret = mbedtls_mpi_read_binary( &conf->dhm_G, dhm_G, G_len ) ) != 0 )
   6387              {
   6388                  mbedtls_mpi_free( &conf->dhm_P );
   6389                  mbedtls_mpi_free( &conf->dhm_G );
   6390                  return( ret );
   6391              }
   6392          
   6393              return( 0 );
   6394          }
   6395          
   6396          int mbedtls_ssl_conf_dh_param_ctx( mbedtls_ssl_config *conf, mbedtls_dhm_context *dhm_ctx )
   6397          {
   6398              int ret;
   6399          
   6400              if( ( ret = mbedtls_mpi_copy( &conf->dhm_P, &dhm_ctx->P ) ) != 0 ||
   6401                  ( ret = mbedtls_mpi_copy( &conf->dhm_G, &dhm_ctx->G ) ) != 0 )
   6402              {
   6403                  mbedtls_mpi_free( &conf->dhm_P );
   6404                  mbedtls_mpi_free( &conf->dhm_G );
   6405                  return( ret );
   6406              }
   6407          
   6408              return( 0 );
   6409          }
   6410          #endif /* MBEDTLS_DHM_C && MBEDTLS_SSL_SRV_C */
   6411          
   6412          #if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_CLI_C)
   6413          /*
   6414           * Set the minimum length for Diffie-Hellman parameters
   6415           */
   6416          void mbedtls_ssl_conf_dhm_min_bitlen( mbedtls_ssl_config *conf,
   6417                                                unsigned int bitlen )
   6418          {
   6419              conf->dhm_min_bitlen = bitlen;
   6420          }
   6421          #endif /* MBEDTLS_DHM_C && MBEDTLS_SSL_CLI_C */
   6422          
   6423          #if defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
   6424          /*
   6425           * Set allowed/preferred hashes for handshake signatures
   6426           */
   6427          void mbedtls_ssl_conf_sig_hashes( mbedtls_ssl_config *conf,
   6428                                            const int *hashes )
   6429          {
   6430              conf->sig_hashes = hashes;
   6431          }
   6432          #endif /* MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
   6433          
   6434          #if defined(MBEDTLS_ECP_C)
   6435          /*
   6436           * Set the allowed elliptic curves
   6437           */
   6438          void mbedtls_ssl_conf_curves( mbedtls_ssl_config *conf,
   6439                                       const mbedtls_ecp_group_id *curve_list )
   6440          {
   6441              conf->curve_list = curve_list;
   6442          }
   6443          #endif /* MBEDTLS_ECP_C */
   6444          
   6445          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   6446          int mbedtls_ssl_set_hostname( mbedtls_ssl_context *ssl, const char *hostname )
   6447          {
   6448              /* Initialize to suppress unnecessary compiler warning */
   6449              size_t hostname_len = 0;
   6450          
   6451              /* Check if new hostname is valid before
   6452               * making any change to current one */
   6453              if( hostname != NULL )
   6454              {
   6455                  hostname_len = strlen( hostname );
   6456          
   6457                  if( hostname_len > MBEDTLS_SSL_MAX_HOST_NAME_LEN )
   6458                      return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   6459              }
   6460          
   6461              /* Now it's clear that we will overwrite the old hostname,
   6462               * so we can free it safely */
   6463          
   6464              if( ssl->hostname != NULL )
   6465              {
   6466                  mbedtls_zeroize( ssl->hostname, strlen( ssl->hostname ) );
   6467                  mbedtls_free( ssl->hostname );
   6468              }
   6469          
   6470              /* Passing NULL as hostname shall clear the old one */
   6471          
   6472              if( hostname == NULL )
   6473              {
   6474                  ssl->hostname = NULL;
   6475              }
   6476              else
   6477              {
   6478                  ssl->hostname = mbedtls_calloc( 1, hostname_len + 1 );
   6479                  if( ssl->hostname == NULL )
   6480                      return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
   6481          
   6482                  memcpy( ssl->hostname, hostname, hostname_len );
   6483          
   6484                  ssl->hostname[hostname_len] = '\0';
   6485              }
   6486          
   6487              return( 0 );
   6488          }
   6489          #endif /* MBEDTLS_X509_CRT_PARSE_C */
   6490          
   6491          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   6492          void mbedtls_ssl_conf_sni( mbedtls_ssl_config *conf,
   6493                            int (*f_sni)(void *, mbedtls_ssl_context *,
   6494                                          const unsigned char *, size_t),
   6495                            void *p_sni )
   6496          {
   6497              conf->f_sni = f_sni;
   6498              conf->p_sni = p_sni;
   6499          }
   6500          #endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
   6501          
   6502          #if defined(MBEDTLS_SSL_ALPN)
   6503          int mbedtls_ssl_conf_alpn_protocols( mbedtls_ssl_config *conf, const char **protos )
   6504          {
   6505              size_t cur_len, tot_len;
   6506              const char **p;
   6507          
   6508              /*
   6509               * RFC 7301 3.1: "Empty strings MUST NOT be included and byte strings
   6510               * MUST NOT be truncated."
   6511               * We check lengths now rather than later.
   6512               */
   6513              tot_len = 0;
   6514              for( p = protos; *p != NULL; p++ )
   6515              {
   6516                  cur_len = strlen( *p );
   6517                  tot_len += cur_len;
   6518          
   6519                  if( cur_len == 0 || cur_len > 255 || tot_len > 65535 )
   6520                      return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   6521              }
   6522          
   6523              conf->alpn_list = protos;
   6524          
   6525              return( 0 );
   6526          }
   6527          
   6528          const char *mbedtls_ssl_get_alpn_protocol( const mbedtls_ssl_context *ssl )
   6529          {
   6530              return( ssl->alpn_chosen );
   6531          }
   6532          #endif /* MBEDTLS_SSL_ALPN */
   6533          
   6534          void mbedtls_ssl_conf_max_version( mbedtls_ssl_config *conf, int major, int minor )
   6535          {
   6536              conf->max_major_ver = major;
   6537              conf->max_minor_ver = minor;
   6538          }
   6539          
   6540          void mbedtls_ssl_conf_min_version( mbedtls_ssl_config *conf, int major, int minor )
   6541          {
   6542              conf->min_major_ver = major;
   6543              conf->min_minor_ver = minor;
   6544          }
   6545          
   6546          #if defined(MBEDTLS_SSL_FALLBACK_SCSV) && defined(MBEDTLS_SSL_CLI_C)
   6547          void mbedtls_ssl_conf_fallback( mbedtls_ssl_config *conf, char fallback )
   6548          {
   6549              conf->fallback = fallback;
   6550          }
   6551          #endif
   6552          
   6553          #if defined(MBEDTLS_SSL_SRV_C)
   6554          void mbedtls_ssl_conf_cert_req_ca_list( mbedtls_ssl_config *conf,
   6555                                                    char cert_req_ca_list )
   6556          {
   6557              conf->cert_req_ca_list = cert_req_ca_list;
   6558          }
   6559          #endif
   6560          
   6561          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   6562          void mbedtls_ssl_conf_encrypt_then_mac( mbedtls_ssl_config *conf, char etm )
   6563          {
   6564              conf->encrypt_then_mac = etm;
   6565          }
   6566          #endif
   6567          
   6568          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
   6569          void mbedtls_ssl_conf_extended_master_secret( mbedtls_ssl_config *conf, char ems )
   6570          {
   6571              conf->extended_ms = ems;
   6572          }
   6573          #endif
   6574          
   6575          #if defined(MBEDTLS_ARC4_C)
   6576          void mbedtls_ssl_conf_arc4_support( mbedtls_ssl_config *conf, char arc4 )
   6577          {
   6578              conf->arc4_disabled = arc4;
   6579          }
   6580          #endif
   6581          
   6582          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   6583          int mbedtls_ssl_conf_max_frag_len( mbedtls_ssl_config *conf, unsigned char mfl_code )
   6584          {
   6585              if( mfl_code >= MBEDTLS_SSL_MAX_FRAG_LEN_INVALID ||
   6586                  mfl_code_to_length[mfl_code] > MBEDTLS_SSL_MAX_CONTENT_LEN )
   6587              {
   6588                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   6589              }
   6590          
   6591              conf->mfl_code = mfl_code;
   6592          
   6593              return( 0 );
   6594          }
   6595          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
   6596          
   6597          #if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
   6598          void mbedtls_ssl_conf_truncated_hmac( mbedtls_ssl_config *conf, int truncate )
   6599          {
   6600              conf->trunc_hmac = truncate;
   6601          }
   6602          #endif /* MBEDTLS_SSL_TRUNCATED_HMAC */
   6603          
   6604          #if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)
   6605          void mbedtls_ssl_conf_cbc_record_splitting( mbedtls_ssl_config *conf, char split )
   6606          {
   6607              conf->cbc_record_splitting = split;
   6608          }
   6609          #endif
   6610          
   6611          void mbedtls_ssl_conf_legacy_renegotiation( mbedtls_ssl_config *conf, int allow_legacy )
   6612          {
   6613              conf->allow_legacy_renegotiation = allow_legacy;
   6614          }
   6615          
   6616          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   6617          void mbedtls_ssl_conf_renegotiation( mbedtls_ssl_config *conf, int renegotiation )
   6618          {
   6619              conf->disable_renegotiation = renegotiation;
   6620          }
   6621          
   6622          void mbedtls_ssl_conf_renegotiation_enforced( mbedtls_ssl_config *conf, int max_records )
   6623          {
   6624              conf->renego_max_records = max_records;
   6625          }
   6626          
   6627          void mbedtls_ssl_conf_renegotiation_period( mbedtls_ssl_config *conf,
   6628                                             const unsigned char period[8] )
   6629          {
   6630              memcpy( conf->renego_period, period, 8 );
   6631          }
   6632          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   6633          
   6634          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   6635          #if defined(MBEDTLS_SSL_CLI_C)
   6636          void mbedtls_ssl_conf_session_tickets( mbedtls_ssl_config *conf, int use_tickets )
   6637          {
   6638              conf->session_tickets = use_tickets;
   6639          }
   6640          #endif
   6641          
   6642          #if defined(MBEDTLS_SSL_SRV_C)
   6643          void mbedtls_ssl_conf_session_tickets_cb( mbedtls_ssl_config *conf,
   6644                  mbedtls_ssl_ticket_write_t *f_ticket_write,
   6645                  mbedtls_ssl_ticket_parse_t *f_ticket_parse,
   6646                  void *p_ticket )
   6647          {
   6648              conf->f_ticket_write = f_ticket_write;
   6649              conf->f_ticket_parse = f_ticket_parse;
   6650              conf->p_ticket       = p_ticket;
   6651          }
   6652          #endif
   6653          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   6654          
   6655          #if defined(MBEDTLS_SSL_EXPORT_KEYS)
   6656          void mbedtls_ssl_conf_export_keys_cb( mbedtls_ssl_config *conf,
   6657                  mbedtls_ssl_export_keys_t *f_export_keys,
   6658                  void *p_export_keys )
   6659          {
   6660              conf->f_export_keys = f_export_keys;
   6661              conf->p_export_keys = p_export_keys;
   6662          }
   6663          #endif
   6664          
   6665          /*
   6666           * SSL get accessors
   6667           */
   6668          size_t mbedtls_ssl_get_bytes_avail( const mbedtls_ssl_context *ssl )
   6669          {
   6670              return( ssl->in_offt == NULL ? 0 : ssl->in_msglen );
   6671          }
   6672          
   6673          uint32_t mbedtls_ssl_get_verify_result( const mbedtls_ssl_context *ssl )
   6674          {
   6675              if( ssl->session != NULL )
   6676                  return( ssl->session->verify_result );
   6677          
   6678              if( ssl->session_negotiate != NULL )
   6679                  return( ssl->session_negotiate->verify_result );
   6680          
   6681              return( 0xFFFFFFFF );
   6682          }
   6683          
   6684          const char *mbedtls_ssl_get_ciphersuite( const mbedtls_ssl_context *ssl )
   6685          {
   6686              if( ssl == NULL || ssl->session == NULL )
   6687                  return( NULL );
   6688          
   6689              return mbedtls_ssl_get_ciphersuite_name( ssl->session->ciphersuite );
   6690          }
   6691          
   6692          const char *mbedtls_ssl_get_version( const mbedtls_ssl_context *ssl )
   6693          {
   6694          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   6695              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   6696              {
   6697                  switch( ssl->minor_ver )
   6698                  {
   6699                      case MBEDTLS_SSL_MINOR_VERSION_2:
   6700                          return( "DTLSv1.0" );
   6701          
   6702                      case MBEDTLS_SSL_MINOR_VERSION_3:
   6703                          return( "DTLSv1.2" );
   6704          
   6705                      default:
   6706                          return( "unknown (DTLS)" );
   6707                  }
   6708              }
   6709          #endif
   6710          
   6711              switch( ssl->minor_ver )
   6712              {
   6713                  case MBEDTLS_SSL_MINOR_VERSION_0:
   6714                      return( "SSLv3.0" );
   6715          
   6716                  case MBEDTLS_SSL_MINOR_VERSION_1:
   6717                      return( "TLSv1.0" );
   6718          
   6719                  case MBEDTLS_SSL_MINOR_VERSION_2:
   6720                      return( "TLSv1.1" );
   6721          
   6722                  case MBEDTLS_SSL_MINOR_VERSION_3:
   6723                      return( "TLSv1.2" );
   6724          
   6725                  default:
   6726                      return( "unknown" );
   6727              }
   6728          }
   6729          
   6730          int mbedtls_ssl_get_record_expansion( const mbedtls_ssl_context *ssl )
   6731          {
   6732              size_t transform_expansion = 0;
   6733              const mbedtls_ssl_transform *transform = ssl->transform_out;
   6734              unsigned block_size;
   6735          
   6736              if( transform == NULL )
   6737                  return( (int) mbedtls_ssl_hdr_len( ssl ) );
   6738          
   6739          #if defined(MBEDTLS_ZLIB_SUPPORT)
   6740              if( ssl->session_out->compression != MBEDTLS_SSL_COMPRESS_NULL )
   6741                  return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
   6742          #endif
   6743          
   6744              switch( mbedtls_cipher_get_cipher_mode( &transform->cipher_ctx_enc ) )
   6745              {
   6746                  case MBEDTLS_MODE_GCM:
   6747                  case MBEDTLS_MODE_CCM:
   6748                  case MBEDTLS_MODE_STREAM:
   6749                      transform_expansion = transform->minlen;
   6750                      break;
   6751          
   6752                  case MBEDTLS_MODE_CBC:
   6753          
   6754                      block_size = mbedtls_cipher_get_block_size(
   6755                          &transform->cipher_ctx_enc );
   6756          
   6757                      /* Expansion due to the addition of the MAC. */
   6758                      transform_expansion += transform->maclen;
   6759          
   6760                      /* Expansion due to the addition of CBC padding;
   6761                       * Theoretically up to 256 bytes, but we never use
   6762                       * more than the block size of the underlying cipher. */
   6763                      transform_expansion += block_size;
   6764          
   6765                      /* For TLS 1.1 or higher, an explicit IV is added
   6766                       * after the record header. */
   6767          #if defined(MBEDTLS_SSL_PROTO_TLS1_1) || defined(MBEDTLS_SSL_PROTO_TLS1_2)
   6768                      if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_2 )
   6769                          transform_expansion += block_size;
   6770          #endif /* MBEDTLS_SSL_PROTO_TLS1_1 || MBEDTLS_SSL_PROTO_TLS1_2 */
   6771          
   6772                      break;
   6773          
   6774                  default:
   6775                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   6776                      return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   6777              }
   6778          
   6779              return( (int)( mbedtls_ssl_hdr_len( ssl ) + transform_expansion ) );
   6780          }
   6781          
   6782          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   6783          size_t mbedtls_ssl_get_max_frag_len( const mbedtls_ssl_context *ssl )
   6784          {
   6785              size_t max_len;
   6786          
   6787              /*
   6788               * Assume mfl_code is correct since it was checked when set
   6789               */
   6790              max_len = mfl_code_to_length[ssl->conf->mfl_code];
   6791          
   6792              /*
   6793               * Check if a smaller max length was negotiated
   6794               */
   6795              if( ssl->session_out != NULL &&
   6796                  mfl_code_to_length[ssl->session_out->mfl_code] < max_len )
   6797              {
   6798                  max_len = mfl_code_to_length[ssl->session_out->mfl_code];
   6799              }
   6800          
   6801              return max_len;
   6802          }
   6803          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
   6804          
   6805          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   6806          const mbedtls_x509_crt *mbedtls_ssl_get_peer_cert( const mbedtls_ssl_context *ssl )
   6807          {
   6808              if( ssl == NULL || ssl->session == NULL )
   6809                  return( NULL );
   6810          
   6811              return( ssl->session->peer_cert );
   6812          }
   6813          #endif /* MBEDTLS_X509_CRT_PARSE_C */
   6814          
   6815          #if defined(MBEDTLS_SSL_CLI_C)
   6816          int mbedtls_ssl_get_session( const mbedtls_ssl_context *ssl, mbedtls_ssl_session *dst )
   6817          {
   6818              if( ssl == NULL ||
   6819                  dst == NULL ||
   6820                  ssl->session == NULL ||
   6821                  ssl->conf->endpoint != MBEDTLS_SSL_IS_CLIENT )
   6822              {
   6823                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   6824              }
   6825          
   6826              return( ssl_session_copy( dst, ssl->session ) );
   6827          }
   6828          #endif /* MBEDTLS_SSL_CLI_C */
   6829          
   6830          /*
   6831           * Perform a single step of the SSL handshake
   6832           */
   6833          int mbedtls_ssl_handshake_step( mbedtls_ssl_context *ssl )
   6834          {
   6835              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   6836          
   6837              if( ssl == NULL || ssl->conf == NULL )
   6838                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   6839          
   6840          #if defined(MBEDTLS_SSL_CLI_C)
   6841              if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
   6842                  ret = mbedtls_ssl_handshake_client_step( ssl );
   6843          #endif
   6844          #if defined(MBEDTLS_SSL_SRV_C)
   6845              if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER )
   6846                  ret = mbedtls_ssl_handshake_server_step( ssl );
   6847          #endif
   6848          
   6849              return( ret );
   6850          }
   6851          
   6852          /*
   6853           * Perform the SSL handshake
   6854           */
   6855          int mbedtls_ssl_handshake( mbedtls_ssl_context *ssl )
   6856          {
   6857              int ret = 0;
   6858          
   6859              if( ssl == NULL || ssl->conf == NULL )
   6860                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   6861          
   6862              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> handshake" ) );
   6863          
   6864              while( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
   6865              {
   6866                  ret = mbedtls_ssl_handshake_step( ssl );
   6867          
   6868                  if( ret != 0 )
   6869                      break;
   6870              }
   6871          
   6872              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= handshake" ) );
   6873          
   6874              return( ret );
   6875          }
   6876          
   6877          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   6878          #if defined(MBEDTLS_SSL_SRV_C)
   6879          /*
   6880           * Write HelloRequest to request renegotiation on server
   6881           */
   6882          static int ssl_write_hello_request( mbedtls_ssl_context *ssl )
   6883          {
   6884              int ret;
   6885          
   6886              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write hello request" ) );
   6887          
   6888              ssl->out_msglen  = 4;
   6889              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   6890              ssl->out_msg[0]  = MBEDTLS_SSL_HS_HELLO_REQUEST;
   6891          
   6892              if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
   6893              {
   6894                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
   6895                  return( ret );
   6896              }
   6897          
   6898              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write hello request" ) );
   6899          
   6900              return( 0 );
   6901          }
   6902          #endif /* MBEDTLS_SSL_SRV_C */
   6903          
   6904          /*
   6905           * Actually renegotiate current connection, triggered by either:
   6906           * - any side: calling mbedtls_ssl_renegotiate(),
   6907           * - client: receiving a HelloRequest during mbedtls_ssl_read(),
   6908           * - server: receiving any handshake message on server during mbedtls_ssl_read() after
   6909           *   the initial handshake is completed.
   6910           * If the handshake doesn't complete due to waiting for I/O, it will continue
   6911           * during the next calls to mbedtls_ssl_renegotiate() or mbedtls_ssl_read() respectively.
   6912           */
   6913          static int ssl_start_renegotiation( mbedtls_ssl_context *ssl )
   6914          {
   6915              int ret;
   6916          
   6917              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> renegotiate" ) );
   6918          
   6919              if( ( ret = ssl_handshake_init( ssl ) ) != 0 )
   6920                  return( ret );
   6921          
   6922              /* RFC 6347 4.2.2: "[...] the HelloRequest will have message_seq = 0 and
   6923               * the ServerHello will have message_seq = 1" */
   6924          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   6925              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   6926                  ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING )
   6927              {
   6928                  if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER )
   6929                      ssl->handshake->out_msg_seq = 1;
   6930                  else
   6931                      ssl->handshake->in_msg_seq = 1;
   6932              }
   6933          #endif
   6934          
   6935              ssl->state = MBEDTLS_SSL_HELLO_REQUEST;
   6936              ssl->renego_status = MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS;
   6937          
   6938              if( ( ret = mbedtls_ssl_handshake( ssl ) ) != 0 )
   6939              {
   6940                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_handshake", ret );
   6941                  return( ret );
   6942              }
   6943          
   6944              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= renegotiate" ) );
   6945          
   6946              return( 0 );
   6947          }
   6948          
   6949          /*
   6950           * Renegotiate current connection on client,
   6951           * or request renegotiation on server
   6952           */
   6953          int mbedtls_ssl_renegotiate( mbedtls_ssl_context *ssl )
   6954          {
   6955              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   6956          
   6957              if( ssl == NULL || ssl->conf == NULL )
   6958                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   6959          
   6960          #if defined(MBEDTLS_SSL_SRV_C)
   6961              /* On server, just send the request */
   6962              if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER )
   6963              {
   6964                  if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
   6965                      return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   6966          
   6967                  ssl->renego_status = MBEDTLS_SSL_RENEGOTIATION_PENDING;
   6968          
   6969                  /* Did we already try/start sending HelloRequest? */
   6970                  if( ssl->out_left != 0 )
   6971                      return( mbedtls_ssl_flush_output( ssl ) );
   6972          
   6973                  return( ssl_write_hello_request( ssl ) );
   6974              }
   6975          #endif /* MBEDTLS_SSL_SRV_C */
   6976          
   6977          #if defined(MBEDTLS_SSL_CLI_C)
   6978              /*
   6979               * On client, either start the renegotiation process or,
   6980               * if already in progress, continue the handshake
   6981               */
   6982              if( ssl->renego_status != MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
   6983              {
   6984                  if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
   6985                      return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   6986          
   6987                  if( ( ret = ssl_start_renegotiation( ssl ) ) != 0 )
   6988                  {
   6989                      MBEDTLS_SSL_DEBUG_RET( 1, "ssl_start_renegotiation", ret );
   6990                      return( ret );
   6991                  }
   6992              }
   6993              else
   6994              {
   6995                  if( ( ret = mbedtls_ssl_handshake( ssl ) ) != 0 )
   6996                  {
   6997                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_handshake", ret );
   6998                      return( ret );
   6999                  }
   7000              }
   7001          #endif /* MBEDTLS_SSL_CLI_C */
   7002          
   7003              return( ret );
   7004          }
   7005          
   7006          /*
   7007           * Check record counters and renegotiate if they're above the limit.
   7008           */
   7009          static int ssl_check_ctr_renegotiate( mbedtls_ssl_context *ssl )
   7010          {
   7011              size_t ep_len = ssl_ep_len( ssl );
   7012              int in_ctr_cmp;
   7013              int out_ctr_cmp;
   7014          
   7015              if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER ||
   7016                  ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING ||
   7017                  ssl->conf->disable_renegotiation == MBEDTLS_SSL_RENEGOTIATION_DISABLED )
   7018              {
   7019                  return( 0 );
   7020              }
   7021          
   7022              in_ctr_cmp = memcmp( ssl->in_ctr + ep_len,
   7023                                  ssl->conf->renego_period + ep_len, 8 - ep_len );
   7024              out_ctr_cmp = memcmp( ssl->out_ctr + ep_len,
   7025                                    ssl->conf->renego_period + ep_len, 8 - ep_len );
   7026          
   7027              if( in_ctr_cmp <= 0 && out_ctr_cmp <= 0 )
   7028              {
   7029                  return( 0 );
   7030              }
   7031          
   7032              MBEDTLS_SSL_DEBUG_MSG( 1, ( "record counter limit reached: renegotiate" ) );
   7033              return( mbedtls_ssl_renegotiate( ssl ) );
   7034          }
   7035          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   7036          
   7037          /*
   7038           * Receive application data decrypted from the SSL layer
   7039           */
   7040          int mbedtls_ssl_read( mbedtls_ssl_context *ssl, unsigned char *buf, size_t len )
   7041          {
   7042              int ret;
   7043              size_t n;
   7044          
   7045              if( ssl == NULL || ssl->conf == NULL )
   7046                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   7047          
   7048              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> read" ) );
   7049          
   7050          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   7051              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   7052              {
   7053                  if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )
   7054                      return( ret );
   7055          
   7056                  if( ssl->handshake != NULL &&
   7057                      ssl->handshake->retransmit_state == MBEDTLS_SSL_RETRANS_SENDING )
   7058                  {
   7059                      if( ( ret = mbedtls_ssl_resend( ssl ) ) != 0 )
   7060                          return( ret );
   7061                  }
   7062              }
   7063          #endif
   7064          
   7065              /*
   7066               * Check if renegotiation is necessary and/or handshake is
   7067               * in process. If yes, perform/continue, and fall through
   7068               * if an unexpected packet is received while the client
   7069               * is waiting for the ServerHello.
   7070               *
   7071               * (There is no equivalent to the last condition on
   7072               *  the server-side as it is not treated as within
   7073               *  a handshake while waiting for the ClientHello
   7074               *  after a renegotiation request.)
   7075               */
   7076          
   7077          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   7078              ret = ssl_check_ctr_renegotiate( ssl );
   7079              if( ret != MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO &&
   7080                  ret != 0 )
   7081              {
   7082                  MBEDTLS_SSL_DEBUG_RET( 1, "ssl_check_ctr_renegotiate", ret );
   7083                  return( ret );
   7084              }
   7085          #endif
   7086          
   7087              if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
   7088              {
   7089                  ret = mbedtls_ssl_handshake( ssl );
   7090                  if( ret != MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO &&
   7091                      ret != 0 )
   7092                  {
   7093                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_handshake", ret );
   7094                      return( ret );
   7095                  }
   7096              }
   7097          
   7098              if( ssl->in_offt == NULL )
   7099              {
   7100                  /* Start timer if not already running */
   7101                  if( ssl->f_get_timer != NULL &&
   7102                      ssl->f_get_timer( ssl->p_timer ) == -1 )
   7103                  {
   7104                      ssl_set_timer( ssl, ssl->conf->read_timeout );
   7105                  }
   7106          
   7107                  if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
   7108                  {
   7109                      if( ret == MBEDTLS_ERR_SSL_CONN_EOF )
   7110                          return( 0 );
   7111          
   7112                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
   7113                      return( ret );
   7114                  }
   7115          
   7116                  if( ssl->in_msglen  == 0 &&
   7117                      ssl->in_msgtype == MBEDTLS_SSL_MSG_APPLICATION_DATA )
   7118                  {
   7119                      /*
   7120                       * OpenSSL sends empty messages to randomize the IV
   7121                       */
   7122                      if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
   7123                      {
   7124                          if( ret == MBEDTLS_ERR_SSL_CONN_EOF )
   7125                              return( 0 );
   7126          
   7127                          MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
   7128                          return( ret );
   7129                      }
   7130                  }
   7131          
   7132                  if( ssl->in_msgtype == MBEDTLS_SSL_MSG_HANDSHAKE )
   7133                  {
   7134                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "received handshake message" ) );
   7135          
   7136                      /*
   7137                       * - For client-side, expect SERVER_HELLO_REQUEST.
   7138                       * - For server-side, expect CLIENT_HELLO.
   7139                       * - Fail (TLS) or silently drop record (DTLS) in other cases.
   7140                       */
   7141          
   7142          #if defined(MBEDTLS_SSL_CLI_C)
   7143                      if( ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT &&
   7144                          ( ssl->in_msg[0] != MBEDTLS_SSL_HS_HELLO_REQUEST ||
   7145                            ssl->in_hslen  != mbedtls_ssl_hs_hdr_len( ssl ) ) )
   7146                      {
   7147                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "handshake received (not HelloRequest)" ) );
   7148          
   7149                          /* With DTLS, drop the packet (probably from last handshake) */
   7150          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   7151                          if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   7152                              return( MBEDTLS_ERR_SSL_WANT_READ );
   7153          #endif
   7154                          return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
   7155                      }
   7156          #endif /* MBEDTLS_SSL_CLI_C */
   7157          
   7158          #if defined(MBEDTLS_SSL_SRV_C)
   7159                      if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
   7160                          ssl->in_msg[0] != MBEDTLS_SSL_HS_CLIENT_HELLO )
   7161                      {
   7162                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "handshake received (not ClientHello)" ) );
   7163          
   7164                          /* With DTLS, drop the packet (probably from last handshake) */
   7165          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   7166                          if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   7167                              return( MBEDTLS_ERR_SSL_WANT_READ );
   7168          #endif
   7169                          return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
   7170                      }
   7171          #endif /* MBEDTLS_SSL_SRV_C */
   7172          
   7173          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   7174                      /* Determine whether renegotiation attempt should be accepted */
   7175                      if( ! ( ssl->conf->disable_renegotiation == MBEDTLS_SSL_RENEGOTIATION_DISABLED ||
   7176                              ( ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
   7177                                ssl->conf->allow_legacy_renegotiation ==
   7178                                                             MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION ) ) )
   7179                      {
   7180                          /*
   7181                           * Accept renegotiation request
   7182                           */
   7183          
   7184                          /* DTLS clients need to know renego is server-initiated */
   7185          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   7186                          if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   7187                              ssl->conf->endpoint == MBEDTLS_SSL_IS_CLIENT )
   7188                          {
   7189                              ssl->renego_status = MBEDTLS_SSL_RENEGOTIATION_PENDING;
   7190                          }
   7191          #endif
   7192                          ret = ssl_start_renegotiation( ssl );
   7193                          if( ret != MBEDTLS_ERR_SSL_WAITING_SERVER_HELLO_RENEGO &&
   7194                              ret != 0 )
   7195                          {
   7196                              MBEDTLS_SSL_DEBUG_RET( 1, "ssl_start_renegotiation", ret );
   7197                              return( ret );
   7198                          }
   7199                      }
   7200                      else
   7201          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   7202                      {
   7203                          /*
   7204                           * Refuse renegotiation
   7205                           */
   7206          
   7207                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "refusing renegotiation, sending alert" ) );
   7208          
   7209          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   7210                          if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
   7211                          {
   7212                              /* SSLv3 does not have a "no_renegotiation" warning, so
   7213                                 we send a fatal alert and abort the connection. */
   7214                              mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   7215                                                              MBEDTLS_SSL_ALERT_MSG_UNEXPECTED_MESSAGE );
   7216                              return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
   7217                          }
   7218                          else
   7219          #endif /* MBEDTLS_SSL_PROTO_SSL3 */
   7220          #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \
   7221              defined(MBEDTLS_SSL_PROTO_TLS1_2)
   7222                          if( ssl->minor_ver >= MBEDTLS_SSL_MINOR_VERSION_1 )
   7223                          {
   7224                              if( ( ret = mbedtls_ssl_send_alert_message( ssl,
   7225                                              MBEDTLS_SSL_ALERT_LEVEL_WARNING,
   7226                                              MBEDTLS_SSL_ALERT_MSG_NO_RENEGOTIATION ) ) != 0 )
   7227                              {
   7228                                  return( ret );
   7229                              }
   7230                          }
   7231                          else
   7232          #endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 ||
   7233                    MBEDTLS_SSL_PROTO_TLS1_2 */
   7234                          {
   7235                              MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   7236                              return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   7237                          }
   7238                      }
   7239          
   7240                      return( MBEDTLS_ERR_SSL_WANT_READ );
   7241                  }
   7242          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   7243                  else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING )
   7244                  {
   7245                      if( ssl->conf->renego_max_records >= 0 )
   7246                      {
   7247                          if( ++ssl->renego_records_seen > ssl->conf->renego_max_records )
   7248                          {
   7249                              MBEDTLS_SSL_DEBUG_MSG( 1, ( "renegotiation requested, "
   7250                                                  "but not honored by client" ) );
   7251                              return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
   7252                          }
   7253                      }
   7254                  }
   7255          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   7256          
   7257                  /* Fatal and closure alerts handled by mbedtls_ssl_read_record() */
   7258                  if( ssl->in_msgtype == MBEDTLS_SSL_MSG_ALERT )
   7259                  {
   7260                      MBEDTLS_SSL_DEBUG_MSG( 2, ( "ignoring non-fatal non-closure alert" ) );
   7261                      return( MBEDTLS_ERR_SSL_WANT_READ );
   7262                  }
   7263          
   7264                  if( ssl->in_msgtype != MBEDTLS_SSL_MSG_APPLICATION_DATA )
   7265                  {
   7266                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad application data message" ) );
   7267                      return( MBEDTLS_ERR_SSL_UNEXPECTED_MESSAGE );
   7268                  }
   7269          
   7270                  ssl->in_offt = ssl->in_msg;
   7271          
   7272                  /* We're going to return something now, cancel timer,
   7273                   * except if handshake (renegotiation) is in progress */
   7274                  if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER )
   7275                      ssl_set_timer( ssl, 0 );
   7276          
   7277          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   7278                  /* If we requested renego but received AppData, resend HelloRequest.
   7279                   * Do it now, after setting in_offt, to avoid taking this branch
   7280                   * again if ssl_write_hello_request() returns WANT_WRITE */
   7281          #if defined(MBEDTLS_SSL_SRV_C) && defined(MBEDTLS_SSL_RENEGOTIATION)
   7282                  if( ssl->conf->endpoint == MBEDTLS_SSL_IS_SERVER &&
   7283                      ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_PENDING )
   7284                  {
   7285                      if( ( ret = ssl_resend_hello_request( ssl ) ) != 0 )
   7286                      {
   7287                          MBEDTLS_SSL_DEBUG_RET( 1, "ssl_resend_hello_request", ret );
   7288                          return( ret );
   7289                      }
   7290                  }
   7291          #endif /* MBEDTLS_SSL_SRV_C && MBEDTLS_SSL_RENEGOTIATION */
   7292          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   7293              }
   7294          
   7295              n = ( len < ssl->in_msglen )
   7296                  ? len : ssl->in_msglen;
   7297          
   7298              memcpy( buf, ssl->in_offt, n );
   7299              ssl->in_msglen -= n;
   7300          
   7301              if( ssl->in_msglen == 0 )
   7302              {
   7303                  /* all bytes consumed */
   7304                  ssl->in_offt = NULL;
   7305                  ssl->keep_current_message = 0;
   7306              }
   7307              else
   7308              {
   7309                  /* more data available */
   7310                  ssl->in_offt += n;
   7311              }
   7312          
   7313              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= read" ) );
   7314          
   7315              return( (int) n );
   7316          }
   7317          
   7318          /*
   7319           * Send application data to be encrypted by the SSL layer, taking care of max
   7320           * fragment length and buffer size.
   7321           *
   7322           * According to RFC 5246 Section 6.2.1:
   7323           *
   7324           *      Zero-length fragments of Application data MAY be sent as they are
   7325           *      potentially useful as a traffic analysis countermeasure.
   7326           *
   7327           * Therefore, it is possible that the input message length is 0 and the
   7328           * corresponding return code is 0 on success.
   7329           */
   7330          static int ssl_write_real( mbedtls_ssl_context *ssl,
   7331                                     const unsigned char *buf, size_t len )
   7332          {
   7333              int ret;
   7334          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   7335              size_t max_len = mbedtls_ssl_get_max_frag_len( ssl );
   7336          #else
   7337              size_t max_len = MBEDTLS_SSL_MAX_CONTENT_LEN;
   7338          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
   7339              if( len > max_len )
   7340              {
   7341          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   7342                  if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   7343                  {
   7344                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "fragment larger than the (negotiated) "
   7345                                          "maximum fragment length: %d > %d",
   7346                                          len, max_len ) );
   7347                      return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   7348                  }
   7349                  else
   7350          #endif
   7351                      len = max_len;
   7352              }
   7353          
   7354              if( ssl->out_left != 0 )
   7355              {
   7356                  /*
   7357                   * The user has previously tried to send the data and
   7358                   * MBEDTLS_ERR_SSL_WANT_WRITE or the message was only partially
   7359                   * written. In this case, we expect the high-level write function
   7360                   * (e.g. mbedtls_ssl_write()) to be called with the same parameters
   7361                   */
   7362                  if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )
   7363                  {
   7364                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_flush_output", ret );
   7365                      return( ret );
   7366                  }
   7367              }
   7368              else
   7369              {
   7370                  /*
   7371                   * The user is trying to send a message the first time, so we need to
   7372                   * copy the data into the internal buffers and setup the data structure
   7373                   * to keep track of partial writes
   7374                   */
   7375                  ssl->out_msglen  = len;
   7376                  ssl->out_msgtype = MBEDTLS_SSL_MSG_APPLICATION_DATA;
   7377                  memcpy( ssl->out_msg, buf, len );
   7378          
   7379                  if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
   7380                  {
   7381                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
   7382                      return( ret );
   7383                  }
   7384              }
   7385          
   7386              return( (int) len );
   7387          }
   7388          
   7389          /*
   7390           * Write application data, doing 1/n-1 splitting if necessary.
   7391           *
   7392           * With non-blocking I/O, ssl_write_real() may return WANT_WRITE,
   7393           * then the caller will call us again with the same arguments, so
   7394           * remember whether we already did the split or not.
   7395           */
   7396          #if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)
   7397          static int ssl_write_split( mbedtls_ssl_context *ssl,
   7398                                      const unsigned char *buf, size_t len )
   7399          {
   7400              int ret;
   7401          
   7402              if( ssl->conf->cbc_record_splitting ==
   7403                      MBEDTLS_SSL_CBC_RECORD_SPLITTING_DISABLED ||
   7404                  len <= 1 ||
   7405                  ssl->minor_ver > MBEDTLS_SSL_MINOR_VERSION_1 ||
   7406                  mbedtls_cipher_get_cipher_mode( &ssl->transform_out->cipher_ctx_enc )
   7407                                          != MBEDTLS_MODE_CBC )
   7408              {
   7409                  return( ssl_write_real( ssl, buf, len ) );
   7410              }
   7411          
   7412              if( ssl->split_done == 0 )
   7413              {
   7414                  if( ( ret = ssl_write_real( ssl, buf, 1 ) ) <= 0 )
   7415                      return( ret );
   7416                  ssl->split_done = 1;
   7417              }
   7418          
   7419              if( ( ret = ssl_write_real( ssl, buf + 1, len - 1 ) ) <= 0 )
   7420                  return( ret );
   7421              ssl->split_done = 0;
   7422          
   7423              return( ret + 1 );
   7424          }
   7425          #endif /* MBEDTLS_SSL_CBC_RECORD_SPLITTING */
   7426          
   7427          /*
   7428           * Write application data (public-facing wrapper)
   7429           */
   7430          int mbedtls_ssl_write( mbedtls_ssl_context *ssl, const unsigned char *buf, size_t len )
   7431          {
   7432              int ret;
   7433          
   7434              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write" ) );
   7435          
   7436              if( ssl == NULL || ssl->conf == NULL )
   7437                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   7438          
   7439          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   7440              if( ( ret = ssl_check_ctr_renegotiate( ssl ) ) != 0 )
   7441              {
   7442                  MBEDTLS_SSL_DEBUG_RET( 1, "ssl_check_ctr_renegotiate", ret );
   7443                  return( ret );
   7444              }
   7445          #endif
   7446          
   7447              if( ssl->state != MBEDTLS_SSL_HANDSHAKE_OVER )
   7448              {
   7449                  if( ( ret = mbedtls_ssl_handshake( ssl ) ) != 0 )
   7450                  {
   7451                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_handshake", ret );
   7452                      return( ret );
   7453                  }
   7454              }
   7455          
   7456          #if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)
   7457              ret = ssl_write_split( ssl, buf, len );
   7458          #else
   7459              ret = ssl_write_real( ssl, buf, len );
   7460          #endif
   7461          
   7462              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write" ) );
   7463          
   7464              return( ret );
   7465          }
   7466          
   7467          /*
   7468           * Notify the peer that the connection is being closed
   7469           */
   7470          int mbedtls_ssl_close_notify( mbedtls_ssl_context *ssl )
   7471          {
   7472              int ret;
   7473          
   7474              if( ssl == NULL || ssl->conf == NULL )
   7475                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   7476          
   7477              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write close notify" ) );
   7478          
   7479              if( ssl->out_left != 0 )
   7480                  return( mbedtls_ssl_flush_output( ssl ) );
   7481          
   7482              if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER )
   7483              {
   7484                  if( ( ret = mbedtls_ssl_send_alert_message( ssl,
   7485                                  MBEDTLS_SSL_ALERT_LEVEL_WARNING,
   7486                                  MBEDTLS_SSL_ALERT_MSG_CLOSE_NOTIFY ) ) != 0 )
   7487                  {
   7488                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_send_alert_message", ret );
   7489                      return( ret );
   7490                  }
   7491              }
   7492          
   7493              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write close notify" ) );
   7494          
   7495              return( 0 );
   7496          }
   7497          
   7498          void mbedtls_ssl_transform_free( mbedtls_ssl_transform *transform )
   7499          {
   7500              if( transform == NULL )
   7501                  return;
   7502          
   7503          #if defined(MBEDTLS_ZLIB_SUPPORT)
   7504              deflateEnd( &transform->ctx_deflate );
   7505              inflateEnd( &transform->ctx_inflate );
   7506          #endif
   7507          
   7508              mbedtls_cipher_free( &transform->cipher_ctx_enc );
   7509              mbedtls_cipher_free( &transform->cipher_ctx_dec );
   7510          
   7511              mbedtls_md_free( &transform->md_ctx_enc );
   7512              mbedtls_md_free( &transform->md_ctx_dec );
   7513          
   7514              mbedtls_zeroize( transform, sizeof( mbedtls_ssl_transform ) );
   7515          }
   7516          
   7517          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   7518          static void ssl_key_cert_free( mbedtls_ssl_key_cert *key_cert )
   7519          {
   7520              mbedtls_ssl_key_cert *cur = key_cert, *next;
   7521          
   7522              while( cur != NULL )
   7523              {
   7524                  next = cur->next;
   7525                  mbedtls_free( cur );
   7526                  cur = next;
   7527              }
   7528          }
   7529          #endif /* MBEDTLS_X509_CRT_PARSE_C */
   7530          
   7531          void mbedtls_ssl_handshake_free( mbedtls_ssl_handshake_params *handshake )
   7532          {
   7533              if( handshake == NULL )
   7534                  return;
   7535          
   7536          #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
   7537              defined(MBEDTLS_SSL_PROTO_TLS1_1)
   7538              mbedtls_md5_free(    &handshake->fin_md5  );
   7539              mbedtls_sha1_free(   &handshake->fin_sha1 );
   7540          #endif
   7541          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   7542          #if defined(MBEDTLS_SHA256_C)
   7543              mbedtls_sha256_free(   &handshake->fin_sha256    );
   7544          #endif
   7545          #if defined(MBEDTLS_SHA512_C)
   7546              mbedtls_sha512_free(   &handshake->fin_sha512    );
   7547          #endif
   7548          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   7549          
   7550          #if defined(MBEDTLS_DHM_C)
   7551              mbedtls_dhm_free( &handshake->dhm_ctx );
   7552          #endif
   7553          #if defined(MBEDTLS_ECDH_C)
   7554              mbedtls_ecdh_free( &handshake->ecdh_ctx );
   7555          #endif
   7556          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   7557              mbedtls_ecjpake_free( &handshake->ecjpake_ctx );
   7558          #if defined(MBEDTLS_SSL_CLI_C)
   7559              mbedtls_free( handshake->ecjpake_cache );
   7560              handshake->ecjpake_cache = NULL;
   7561              handshake->ecjpake_cache_len = 0;
   7562          #endif
   7563          #endif
   7564          
   7565          #if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \
   7566              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   7567              /* explicit void pointer cast for buggy MS compiler */
   7568              mbedtls_free( (void *) handshake->curves );
   7569          #endif
   7570          
   7571          #if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)
   7572              if( handshake->psk != NULL )
   7573              {
   7574                  mbedtls_zeroize( handshake->psk, handshake->psk_len );
   7575                  mbedtls_free( handshake->psk );
   7576              }
   7577          #endif
   7578          
   7579          #if defined(MBEDTLS_X509_CRT_PARSE_C) && \
   7580              defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   7581              /*
   7582               * Free only the linked list wrapper, not the keys themselves
   7583               * since the belong to the SNI callback
   7584               */
   7585              if( handshake->sni_key_cert != NULL )
   7586              {
   7587                  mbedtls_ssl_key_cert *cur = handshake->sni_key_cert, *next;
   7588          
   7589                  while( cur != NULL )
   7590                  {
   7591                      next = cur->next;
   7592                      mbedtls_free( cur );
   7593                      cur = next;
   7594                  }
   7595              }
   7596          #endif /* MBEDTLS_X509_CRT_PARSE_C && MBEDTLS_SSL_SERVER_NAME_INDICATION */
   7597          
   7598          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   7599              mbedtls_free( handshake->verify_cookie );
   7600              mbedtls_free( handshake->hs_msg );
   7601              ssl_flight_free( handshake->flight );
   7602          #endif
   7603          
   7604              mbedtls_zeroize( handshake, sizeof( mbedtls_ssl_handshake_params ) );
   7605          }
   7606          
   7607          void mbedtls_ssl_session_free( mbedtls_ssl_session *session )
   7608          {
   7609              if( session == NULL )
   7610                  return;
   7611          
   7612          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   7613              if( session->peer_cert != NULL )
   7614              {
   7615                  mbedtls_x509_crt_free( session->peer_cert );
   7616                  mbedtls_free( session->peer_cert );
   7617              }
   7618          #endif
   7619          
   7620          #if defined(MBEDTLS_SSL_SESSION_TICKETS) && defined(MBEDTLS_SSL_CLI_C)
   7621              mbedtls_free( session->ticket );
   7622          #endif
   7623          
   7624              mbedtls_zeroize( session, sizeof( mbedtls_ssl_session ) );
   7625          }
   7626          
   7627          /*
   7628           * Free an SSL context
   7629           */
   7630          void mbedtls_ssl_free( mbedtls_ssl_context *ssl )
   7631          {
   7632              if( ssl == NULL )
   7633                  return;
   7634          
   7635              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> free" ) );
   7636          
   7637              if( ssl->out_buf != NULL )
   7638              {
   7639                  mbedtls_zeroize( ssl->out_buf, MBEDTLS_SSL_BUFFER_LEN );
   7640                  mbedtls_free( ssl->out_buf );
   7641              }
   7642          
   7643              if( ssl->in_buf != NULL )
   7644              {
   7645                  mbedtls_zeroize( ssl->in_buf, MBEDTLS_SSL_BUFFER_LEN );
   7646                  mbedtls_free( ssl->in_buf );
   7647              }
   7648          
   7649          #if defined(MBEDTLS_ZLIB_SUPPORT)
   7650              if( ssl->compress_buf != NULL )
   7651              {
   7652                  mbedtls_zeroize( ssl->compress_buf, MBEDTLS_SSL_BUFFER_LEN );
   7653                  mbedtls_free( ssl->compress_buf );
   7654              }
   7655          #endif
   7656          
   7657              if( ssl->transform )
   7658              {
   7659                  mbedtls_ssl_transform_free( ssl->transform );
   7660                  mbedtls_free( ssl->transform );
   7661              }
   7662          
   7663              if( ssl->handshake )
   7664              {
   7665                  mbedtls_ssl_handshake_free( ssl->handshake );
   7666                  mbedtls_ssl_transform_free( ssl->transform_negotiate );
   7667                  mbedtls_ssl_session_free( ssl->session_negotiate );
   7668          
   7669                  mbedtls_free( ssl->handshake );
   7670                  mbedtls_free( ssl->transform_negotiate );
   7671                  mbedtls_free( ssl->session_negotiate );
   7672              }
   7673          
   7674              if( ssl->session )
   7675              {
   7676                  mbedtls_ssl_session_free( ssl->session );
   7677                  mbedtls_free( ssl->session );
   7678              }
   7679          
   7680          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   7681              if( ssl->hostname != NULL )
   7682              {
   7683                  mbedtls_zeroize( ssl->hostname, strlen( ssl->hostname ) );
   7684                  mbedtls_free( ssl->hostname );
   7685              }
   7686          #endif
   7687          
   7688          #if defined(MBEDTLS_SSL_HW_RECORD_ACCEL)
   7689              if( mbedtls_ssl_hw_record_finish != NULL )
   7690              {
   7691                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "going for mbedtls_ssl_hw_record_finish()" ) );
   7692                  mbedtls_ssl_hw_record_finish( ssl );
   7693              }
   7694          #endif
   7695          
   7696          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(MBEDTLS_SSL_SRV_C)
   7697              mbedtls_free( ssl->cli_id );
   7698          #endif
   7699          
   7700              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= free" ) );
   7701          
   7702              /* Actually clear after last debug message */
   7703              mbedtls_zeroize( ssl, sizeof( mbedtls_ssl_context ) );
   7704          }
   7705          
   7706          /*
   7707           * Initialze mbedtls_ssl_config
   7708           */
   7709          void mbedtls_ssl_config_init( mbedtls_ssl_config *conf )
   7710          {
   7711              memset( conf, 0, sizeof( mbedtls_ssl_config ) );
   7712          }
   7713          
   7714          #if defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
   7715          static int ssl_preset_default_hashes[] = {
   7716          #if defined(MBEDTLS_SHA512_C)
   7717              MBEDTLS_MD_SHA512,
   7718              MBEDTLS_MD_SHA384,
   7719          #endif
   7720          #if defined(MBEDTLS_SHA256_C)
   7721              MBEDTLS_MD_SHA256,
   7722              MBEDTLS_MD_SHA224,
   7723          #endif
   7724          #if defined(MBEDTLS_SHA1_C) && defined(MBEDTLS_TLS_DEFAULT_ALLOW_SHA1_IN_KEY_EXCHANGE)
   7725              MBEDTLS_MD_SHA1,
   7726          #endif
   7727              MBEDTLS_MD_NONE
   7728          };
   7729          #endif
   7730          
   7731          static int ssl_preset_suiteb_ciphersuites[] = {
   7732              MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
   7733              MBEDTLS_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
   7734              0
   7735          };
   7736          
   7737          #if defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
   7738          static int ssl_preset_suiteb_hashes[] = {
   7739              MBEDTLS_MD_SHA256,
   7740              MBEDTLS_MD_SHA384,
   7741              MBEDTLS_MD_NONE
   7742          };
   7743          #endif
   7744          
   7745          #if defined(MBEDTLS_ECP_C)
   7746          static mbedtls_ecp_group_id ssl_preset_suiteb_curves[] = {
   7747              MBEDTLS_ECP_DP_SECP256R1,
   7748              MBEDTLS_ECP_DP_SECP384R1,
   7749              MBEDTLS_ECP_DP_NONE
   7750          };
   7751          #endif
   7752          
   7753          /*
   7754           * Load default in mbedtls_ssl_config
   7755           */
   7756          int mbedtls_ssl_config_defaults( mbedtls_ssl_config *conf,
   7757                                           int endpoint, int transport, int preset )
   7758          {
   7759          #if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_SRV_C)
   7760              int ret;
   7761          #endif
   7762          
   7763              /* Use the functions here so that they are covered in tests,
   7764               * but otherwise access member directly for efficiency */
   7765              mbedtls_ssl_conf_endpoint( conf, endpoint );
   7766              mbedtls_ssl_conf_transport( conf, transport );
   7767          
   7768              /*
   7769               * Things that are common to all presets
   7770               */
   7771          #if defined(MBEDTLS_SSL_CLI_C)
   7772              if( endpoint == MBEDTLS_SSL_IS_CLIENT )
   7773              {
   7774                  conf->authmode = MBEDTLS_SSL_VERIFY_REQUIRED;
   7775          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   7776                  conf->session_tickets = MBEDTLS_SSL_SESSION_TICKETS_ENABLED;
   7777          #endif
   7778              }
   7779          #endif
   7780          
   7781          #if defined(MBEDTLS_ARC4_C)
   7782              conf->arc4_disabled = MBEDTLS_SSL_ARC4_DISABLED;
   7783          #endif
   7784          
   7785          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   7786              conf->encrypt_then_mac = MBEDTLS_SSL_ETM_ENABLED;
   7787          #endif
   7788          
   7789          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
   7790              conf->extended_ms = MBEDTLS_SSL_EXTENDED_MS_ENABLED;
   7791          #endif
   7792          
   7793          #if defined(MBEDTLS_SSL_CBC_RECORD_SPLITTING)
   7794              conf->cbc_record_splitting = MBEDTLS_SSL_CBC_RECORD_SPLITTING_ENABLED;
   7795          #endif
   7796          
   7797          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(MBEDTLS_SSL_SRV_C)
   7798              conf->f_cookie_write = ssl_cookie_write_dummy;
   7799              conf->f_cookie_check = ssl_cookie_check_dummy;
   7800          #endif
   7801          
   7802          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   7803              conf->anti_replay = MBEDTLS_SSL_ANTI_REPLAY_ENABLED;
   7804          #endif
   7805          
   7806          #if defined(MBEDTLS_SSL_SRV_C)
   7807              conf->cert_req_ca_list = MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED;
   7808          #endif
   7809          
   7810          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   7811              conf->hs_timeout_min = MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MIN;
   7812              conf->hs_timeout_max = MBEDTLS_SSL_DTLS_TIMEOUT_DFL_MAX;
   7813          #endif
   7814          
   7815          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   7816              conf->renego_max_records = MBEDTLS_SSL_RENEGO_MAX_RECORDS_DEFAULT;
   7817              memset( conf->renego_period,     0x00, 2 );
   7818              memset( conf->renego_period + 2, 0xFF, 6 );
   7819          #endif
   7820          
   7821          #if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_SRV_C)
   7822                      if( endpoint == MBEDTLS_SSL_IS_SERVER )
   7823                      {
   7824                          const unsigned char dhm_p[] =
   7825                              MBEDTLS_DHM_RFC3526_MODP_2048_P_BIN;
   7826                          const unsigned char dhm_g[] =
   7827                              MBEDTLS_DHM_RFC3526_MODP_2048_G_BIN;
   7828          
   7829                          if ( ( ret = mbedtls_ssl_conf_dh_param_bin( conf,
   7830                                                         dhm_p, sizeof( dhm_p ),
   7831                                                         dhm_g, sizeof( dhm_g ) ) ) != 0 )
   7832                          {
   7833                              return( ret );
   7834                          }
   7835                      }
   7836          #endif
   7837          
   7838              /*
   7839               * Preset-specific defaults
   7840               */
   7841              switch( preset )
   7842              {
   7843                  /*
   7844                   * NSA Suite B
   7845                   */
   7846                  case MBEDTLS_SSL_PRESET_SUITEB:
   7847                      conf->min_major_ver = MBEDTLS_SSL_MAJOR_VERSION_3;
   7848                      conf->min_minor_ver = MBEDTLS_SSL_MINOR_VERSION_3; /* TLS 1.2 */
   7849                      conf->max_major_ver = MBEDTLS_SSL_MAX_MAJOR_VERSION;
   7850                      conf->max_minor_ver = MBEDTLS_SSL_MAX_MINOR_VERSION;
   7851          
   7852                      conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_0] =
   7853                      conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_1] =
   7854                      conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_2] =
   7855                      conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_3] =
   7856                                             ssl_preset_suiteb_ciphersuites;
   7857          
   7858          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   7859                      conf->cert_profile = &mbedtls_x509_crt_profile_suiteb;
   7860          #endif
   7861          
   7862          #if defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
   7863                      conf->sig_hashes = ssl_preset_suiteb_hashes;
   7864          #endif
   7865          
   7866          #if defined(MBEDTLS_ECP_C)
   7867                      conf->curve_list = ssl_preset_suiteb_curves;
   7868          #endif
   7869                      break;
   7870          
   7871                  /*
   7872                   * Default
   7873                   */
   7874                  default:
   7875                      conf->min_major_ver = ( MBEDTLS_SSL_MIN_MAJOR_VERSION >
   7876                                              MBEDTLS_SSL_MIN_VALID_MAJOR_VERSION ) ?
   7877                                              MBEDTLS_SSL_MIN_MAJOR_VERSION :
   7878                                              MBEDTLS_SSL_MIN_VALID_MAJOR_VERSION;
   7879                      conf->min_minor_ver = ( MBEDTLS_SSL_MIN_MINOR_VERSION >
   7880                                              MBEDTLS_SSL_MIN_VALID_MINOR_VERSION ) ?
   7881                                              MBEDTLS_SSL_MIN_MINOR_VERSION :
   7882                                              MBEDTLS_SSL_MIN_VALID_MINOR_VERSION;
   7883                      conf->max_major_ver = MBEDTLS_SSL_MAX_MAJOR_VERSION;
   7884                      conf->max_minor_ver = MBEDTLS_SSL_MAX_MINOR_VERSION;
   7885          
   7886          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   7887                      if( transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   7888                          conf->min_minor_ver = MBEDTLS_SSL_MINOR_VERSION_2;
   7889          #endif
   7890          
   7891                      conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_0] =
   7892                      conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_1] =
   7893                      conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_2] =
   7894                      conf->ciphersuite_list[MBEDTLS_SSL_MINOR_VERSION_3] =
   7895                                             mbedtls_ssl_list_ciphersuites();
   7896          
   7897          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   7898                      conf->cert_profile = &mbedtls_x509_crt_profile_default;
   7899          #endif
   7900          
   7901          #if defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
   7902                      conf->sig_hashes = ssl_preset_default_hashes;
   7903          #endif
   7904          
   7905          #if defined(MBEDTLS_ECP_C)
   7906                      conf->curve_list = mbedtls_ecp_grp_id_list();
   7907          #endif
   7908          
   7909          #if defined(MBEDTLS_DHM_C) && defined(MBEDTLS_SSL_CLI_C)
   7910                      conf->dhm_min_bitlen = 1024;
   7911          #endif
   7912              }
   7913          
   7914              return( 0 );
   7915          }
   7916          
   7917          /*
   7918           * Free mbedtls_ssl_config
   7919           */
   7920          void mbedtls_ssl_config_free( mbedtls_ssl_config *conf )
   7921          {
   7922          #if defined(MBEDTLS_DHM_C)
   7923              mbedtls_mpi_free( &conf->dhm_P );
   7924              mbedtls_mpi_free( &conf->dhm_G );
   7925          #endif
   7926          
   7927          #if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)
   7928              if( conf->psk != NULL )
   7929              {
   7930                  mbedtls_zeroize( conf->psk, conf->psk_len );
   7931                  mbedtls_zeroize( conf->psk_identity, conf->psk_identity_len );
   7932                  mbedtls_free( conf->psk );
   7933                  mbedtls_free( conf->psk_identity );
   7934                  conf->psk_len = 0;
   7935                  conf->psk_identity_len = 0;
   7936              }
   7937          #endif
   7938          
   7939          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   7940              ssl_key_cert_free( conf->key_cert );
   7941          #endif
   7942          
   7943              mbedtls_zeroize( conf, sizeof( mbedtls_ssl_config ) );
   7944          }
   7945          
   7946          #if defined(MBEDTLS_PK_C) && \
   7947              ( defined(MBEDTLS_RSA_C) || defined(MBEDTLS_ECDSA_C) )
   7948          /*
   7949           * Convert between MBEDTLS_PK_XXX and SSL_SIG_XXX
   7950           */
   7951          unsigned char mbedtls_ssl_sig_from_pk( mbedtls_pk_context *pk )
   7952          {
   7953          #if defined(MBEDTLS_RSA_C)
   7954              if( mbedtls_pk_can_do( pk, MBEDTLS_PK_RSA ) )
   7955                  return( MBEDTLS_SSL_SIG_RSA );
   7956          #endif
   7957          #if defined(MBEDTLS_ECDSA_C)
   7958              if( mbedtls_pk_can_do( pk, MBEDTLS_PK_ECDSA ) )
   7959                  return( MBEDTLS_SSL_SIG_ECDSA );
   7960          #endif
   7961              return( MBEDTLS_SSL_SIG_ANON );
   7962          }
   7963          
   7964          unsigned char mbedtls_ssl_sig_from_pk_alg( mbedtls_pk_type_t type )
   7965          {
   7966              switch( type ) {
   7967                  case MBEDTLS_PK_RSA:
   7968                      return( MBEDTLS_SSL_SIG_RSA );
   7969                  case MBEDTLS_PK_ECDSA:
   7970                  case MBEDTLS_PK_ECKEY:
   7971                      return( MBEDTLS_SSL_SIG_ECDSA );
   7972                  default:
   7973                      return( MBEDTLS_SSL_SIG_ANON );
   7974              }
   7975          }
   7976          
   7977          mbedtls_pk_type_t mbedtls_ssl_pk_alg_from_sig( unsigned char sig )
   7978          {
   7979              switch( sig )
   7980              {
   7981          #if defined(MBEDTLS_RSA_C)
   7982                  case MBEDTLS_SSL_SIG_RSA:
   7983                      return( MBEDTLS_PK_RSA );
   7984          #endif
   7985          #if defined(MBEDTLS_ECDSA_C)
   7986                  case MBEDTLS_SSL_SIG_ECDSA:
   7987                      return( MBEDTLS_PK_ECDSA );
   7988          #endif
   7989                  default:
   7990                      return( MBEDTLS_PK_NONE );
   7991              }
   7992          }
   7993          #endif /* MBEDTLS_PK_C && ( MBEDTLS_RSA_C || MBEDTLS_ECDSA_C ) */
   7994          
   7995          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
   7996              defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
   7997          
   7998          /* Find an entry in a signature-hash set matching a given hash algorithm. */
   7999          mbedtls_md_type_t mbedtls_ssl_sig_hash_set_find( mbedtls_ssl_sig_hash_set_t *set,
   8000                                                           mbedtls_pk_type_t sig_alg )
   8001          {
   8002              switch( sig_alg )
   8003              {
   8004                  case MBEDTLS_PK_RSA:
   8005                      return( set->rsa );
   8006                  case MBEDTLS_PK_ECDSA:
   8007                      return( set->ecdsa );
   8008                  default:
   8009                      return( MBEDTLS_MD_NONE );
   8010              }
   8011          }
   8012          
   8013          /* Add a signature-hash-pair to a signature-hash set */
   8014          void mbedtls_ssl_sig_hash_set_add( mbedtls_ssl_sig_hash_set_t *set,
   8015                                             mbedtls_pk_type_t sig_alg,
   8016                                             mbedtls_md_type_t md_alg )
   8017          {
   8018              switch( sig_alg )
   8019              {
   8020                  case MBEDTLS_PK_RSA:
   8021                      if( set->rsa == MBEDTLS_MD_NONE )
   8022                          set->rsa = md_alg;
   8023                      break;
   8024          
   8025                  case MBEDTLS_PK_ECDSA:
   8026                      if( set->ecdsa == MBEDTLS_MD_NONE )
   8027                          set->ecdsa = md_alg;
   8028                      break;
   8029          
   8030                  default:
   8031                      break;
   8032              }
   8033          }
   8034          
   8035          /* Allow exactly one hash algorithm for each signature. */
   8036          void mbedtls_ssl_sig_hash_set_const_hash( mbedtls_ssl_sig_hash_set_t *set,
   8037                                                    mbedtls_md_type_t md_alg )
   8038          {
   8039              set->rsa   = md_alg;
   8040              set->ecdsa = md_alg;
   8041          }
   8042          
   8043          #endif /* MBEDTLS_SSL_PROTO_TLS1_2) &&
   8044                    MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
   8045          
   8046          /*
   8047           * Convert from MBEDTLS_SSL_HASH_XXX to MBEDTLS_MD_XXX
   8048           */
   8049          mbedtls_md_type_t mbedtls_ssl_md_alg_from_hash( unsigned char hash )
   8050          {
   8051              switch( hash )
   8052              {
   8053          #if defined(MBEDTLS_MD5_C)
   8054                  case MBEDTLS_SSL_HASH_MD5:
   8055                      return( MBEDTLS_MD_MD5 );
   8056          #endif
   8057          #if defined(MBEDTLS_SHA1_C)
   8058                  case MBEDTLS_SSL_HASH_SHA1:
   8059                      return( MBEDTLS_MD_SHA1 );
   8060          #endif
   8061          #if defined(MBEDTLS_SHA256_C)
   8062                  case MBEDTLS_SSL_HASH_SHA224:
   8063                      return( MBEDTLS_MD_SHA224 );
   8064                  case MBEDTLS_SSL_HASH_SHA256:
   8065                      return( MBEDTLS_MD_SHA256 );
   8066          #endif
   8067          #if defined(MBEDTLS_SHA512_C)
   8068                  case MBEDTLS_SSL_HASH_SHA384:
   8069                      return( MBEDTLS_MD_SHA384 );
   8070                  case MBEDTLS_SSL_HASH_SHA512:
   8071                      return( MBEDTLS_MD_SHA512 );
   8072          #endif
   8073                  default:
   8074                      return( MBEDTLS_MD_NONE );
   8075              }
   8076          }
   8077          
   8078          /*
   8079           * Convert from MBEDTLS_MD_XXX to MBEDTLS_SSL_HASH_XXX
   8080           */
   8081          unsigned char mbedtls_ssl_hash_from_md_alg( int md )
   8082          {
   8083              switch( md )
   8084              {
   8085          #if defined(MBEDTLS_MD5_C)
   8086                  case MBEDTLS_MD_MD5:
   8087                      return( MBEDTLS_SSL_HASH_MD5 );
   8088          #endif
   8089          #if defined(MBEDTLS_SHA1_C)
   8090                  case MBEDTLS_MD_SHA1:
   8091                      return( MBEDTLS_SSL_HASH_SHA1 );
   8092          #endif
   8093          #if defined(MBEDTLS_SHA256_C)
   8094                  case MBEDTLS_MD_SHA224:
   8095                      return( MBEDTLS_SSL_HASH_SHA224 );
   8096                  case MBEDTLS_MD_SHA256:
   8097                      return( MBEDTLS_SSL_HASH_SHA256 );
   8098          #endif
   8099          #if defined(MBEDTLS_SHA512_C)
   8100                  case MBEDTLS_MD_SHA384:
   8101                      return( MBEDTLS_SSL_HASH_SHA384 );
   8102                  case MBEDTLS_MD_SHA512:
   8103                      return( MBEDTLS_SSL_HASH_SHA512 );
   8104          #endif
   8105                  default:
   8106                      return( MBEDTLS_SSL_HASH_NONE );
   8107              }
   8108          }
   8109          
   8110          #if defined(MBEDTLS_ECP_C)
   8111          /*
   8112           * Check if a curve proposed by the peer is in our list.
   8113           * Return 0 if we're willing to use it, -1 otherwise.
   8114           */
   8115          int mbedtls_ssl_check_curve( const mbedtls_ssl_context *ssl, mbedtls_ecp_group_id grp_id )
   8116          {
   8117              const mbedtls_ecp_group_id *gid;
   8118          
   8119              if( ssl->conf->curve_list == NULL )
   8120                  return( -1 );
   8121          
   8122              for( gid = ssl->conf->curve_list; *gid != MBEDTLS_ECP_DP_NONE; gid++ )
   8123                  if( *gid == grp_id )
   8124                      return( 0 );
   8125          
   8126              return( -1 );
   8127          }
   8128          #endif /* MBEDTLS_ECP_C */
   8129          
   8130          #if defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
   8131          /*
   8132           * Check if a hash proposed by the peer is in our list.
   8133           * Return 0 if we're willing to use it, -1 otherwise.
   8134           */
   8135          int mbedtls_ssl_check_sig_hash( const mbedtls_ssl_context *ssl,
   8136                                          mbedtls_md_type_t md )
   8137          {
   8138              const int *cur;
   8139          
   8140              if( ssl->conf->sig_hashes == NULL )
   8141                  return( -1 );
   8142          
   8143              for( cur = ssl->conf->sig_hashes; *cur != MBEDTLS_MD_NONE; cur++ )
   8144                  if( *cur == (int) md )
   8145                      return( 0 );
   8146          
   8147              return( -1 );
   8148          }
   8149          #endif /* MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
   8150          
   8151          #if defined(MBEDTLS_X509_CRT_PARSE_C)
   8152          int mbedtls_ssl_check_cert_usage( const mbedtls_x509_crt *cert,
   8153                                    const mbedtls_ssl_ciphersuite_t *ciphersuite,
   8154                                    int cert_endpoint,
   8155                                    uint32_t *flags )
   8156          {
   8157              int ret = 0;
   8158          #if defined(MBEDTLS_X509_CHECK_KEY_USAGE)
   8159              int usage = 0;
   8160          #endif
   8161          #if defined(MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE)
   8162              const char *ext_oid;
   8163              size_t ext_len;
   8164          #endif
   8165          
   8166          #if !defined(MBEDTLS_X509_CHECK_KEY_USAGE) &&          \
   8167              !defined(MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE)
   8168              ((void) cert);
   8169              ((void) cert_endpoint);
   8170              ((void) flags);
   8171          #endif
   8172          
   8173          #if defined(MBEDTLS_X509_CHECK_KEY_USAGE)
   8174              if( cert_endpoint == MBEDTLS_SSL_IS_SERVER )
   8175              {
   8176                  /* Server part of the key exchange */
   8177                  switch( ciphersuite->key_exchange )
   8178                  {
   8179                      case MBEDTLS_KEY_EXCHANGE_RSA:
   8180                      case MBEDTLS_KEY_EXCHANGE_RSA_PSK:
   8181                          usage = MBEDTLS_X509_KU_KEY_ENCIPHERMENT;
   8182                          break;
   8183          
   8184                      case MBEDTLS_KEY_EXCHANGE_DHE_RSA:
   8185                      case MBEDTLS_KEY_EXCHANGE_ECDHE_RSA:
   8186                      case MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA:
   8187                          usage = MBEDTLS_X509_KU_DIGITAL_SIGNATURE;
   8188                          break;
   8189          
   8190                      case MBEDTLS_KEY_EXCHANGE_ECDH_RSA:
   8191                      case MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA:
   8192                          usage = MBEDTLS_X509_KU_KEY_AGREEMENT;
   8193                          break;
   8194          
   8195                      /* Don't use default: we want warnings when adding new values */
   8196                      case MBEDTLS_KEY_EXCHANGE_NONE:
   8197                      case MBEDTLS_KEY_EXCHANGE_PSK:
   8198                      case MBEDTLS_KEY_EXCHANGE_DHE_PSK:
   8199                      case MBEDTLS_KEY_EXCHANGE_ECDHE_PSK:
   8200                      case MBEDTLS_KEY_EXCHANGE_ECJPAKE:
   8201                          usage = 0;
   8202                  }
   8203              }
   8204              else
   8205              {
   8206                  /* Client auth: we only implement rsa_sign and mbedtls_ecdsa_sign for now */
   8207                  usage = MBEDTLS_X509_KU_DIGITAL_SIGNATURE;
   8208              }
   8209          
   8210              if( mbedtls_x509_crt_check_key_usage( cert, usage ) != 0 )
   8211              {
   8212                  *flags |= MBEDTLS_X509_BADCERT_KEY_USAGE;
   8213                  ret = -1;
   8214              }
   8215          #else
   8216              ((void) ciphersuite);
   8217          #endif /* MBEDTLS_X509_CHECK_KEY_USAGE */
   8218          
   8219          #if defined(MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE)
   8220              if( cert_endpoint == MBEDTLS_SSL_IS_SERVER )
   8221              {
   8222                  ext_oid = MBEDTLS_OID_SERVER_AUTH;
   8223                  ext_len = MBEDTLS_OID_SIZE( MBEDTLS_OID_SERVER_AUTH );
   8224              }
   8225              else
   8226              {
   8227                  ext_oid = MBEDTLS_OID_CLIENT_AUTH;
   8228                  ext_len = MBEDTLS_OID_SIZE( MBEDTLS_OID_CLIENT_AUTH );
   8229              }
   8230          
   8231              if( mbedtls_x509_crt_check_extended_key_usage( cert, ext_oid, ext_len ) != 0 )
   8232              {
   8233                  *flags |= MBEDTLS_X509_BADCERT_EXT_KEY_USAGE;
   8234                  ret = -1;
   8235              }
   8236          #endif /* MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE */
   8237          
   8238              return( ret );
   8239          }
   8240          #endif /* MBEDTLS_X509_CRT_PARSE_C */
   8241          
   8242          /*
   8243           * Convert version numbers to/from wire format
   8244           * and, for DTLS, to/from TLS equivalent.
   8245           *
   8246           * For TLS this is the identity.
   8247           * For DTLS, use 1's complement (v -> 255 - v, and then map as follows:
   8248           * 1.0 <-> 3.2      (DTLS 1.0 is based on TLS 1.1)
   8249           * 1.x <-> 3.x+1    for x != 0 (DTLS 1.2 based on TLS 1.2)
   8250           */
   8251          void mbedtls_ssl_write_version( int major, int minor, int transport,
   8252                                  unsigned char ver[2] )
   8253          {
   8254          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   8255              if( transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   8256              {
   8257                  if( minor == MBEDTLS_SSL_MINOR_VERSION_2 )
   8258                      --minor; /* DTLS 1.0 stored as TLS 1.1 internally */
   8259          
   8260                  ver[0] = (unsigned char)( 255 - ( major - 2 ) );
   8261                  ver[1] = (unsigned char)( 255 - ( minor - 1 ) );
   8262              }
   8263              else
   8264          #else
   8265              ((void) transport);
   8266          #endif
   8267              {
   8268                  ver[0] = (unsigned char) major;
   8269                  ver[1] = (unsigned char) minor;
   8270              }
   8271          }
   8272          
   8273          void mbedtls_ssl_read_version( int *major, int *minor, int transport,
   8274                                 const unsigned char ver[2] )
   8275          {
   8276          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   8277              if( transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   8278              {
   8279                  *major = 255 - ver[0] + 2;
   8280                  *minor = 255 - ver[1] + 1;
   8281          
   8282                  if( *minor == MBEDTLS_SSL_MINOR_VERSION_1 )
   8283                      ++*minor; /* DTLS 1.0 stored as TLS 1.1 internally */
   8284              }
   8285              else
   8286          #else
   8287              ((void) transport);
   8288          #endif
   8289              {
   8290                  *major = ver[0];
   8291                  *minor = ver[1];
   8292              }
   8293          }
   8294          
   8295          int mbedtls_ssl_set_calc_verify_md( mbedtls_ssl_context *ssl, int md )
   8296          {
   8297          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   8298              if( ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_3 )
   8299                  return MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH;
   8300          
   8301              switch( md )
   8302              {
   8303          #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1)
   8304          #if defined(MBEDTLS_MD5_C)
   8305                  case MBEDTLS_SSL_HASH_MD5:
   8306                      return MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH;
   8307          #endif
   8308          #if defined(MBEDTLS_SHA1_C)
   8309                  case MBEDTLS_SSL_HASH_SHA1:
   8310                      ssl->handshake->calc_verify = ssl_calc_verify_tls;
   8311                      break;
   8312          #endif
   8313          #endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 */
   8314          #if defined(MBEDTLS_SHA512_C)
   8315                  case MBEDTLS_SSL_HASH_SHA384:
   8316                      ssl->handshake->calc_verify = ssl_calc_verify_tls_sha384;
   8317                      break;
   8318          #endif
   8319          #if defined(MBEDTLS_SHA256_C)
   8320                  case MBEDTLS_SSL_HASH_SHA256:
   8321                      ssl->handshake->calc_verify = ssl_calc_verify_tls_sha256;
   8322                      break;
   8323          #endif
   8324                  default:
   8325                      return MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH;
   8326              }
   8327          
   8328              return 0;
   8329          #else /* !MBEDTLS_SSL_PROTO_TLS1_2 */
   8330              (void) ssl;
   8331              (void) md;
   8332          
   8333              return MBEDTLS_ERR_SSL_INVALID_VERIFY_HASH;
   8334          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   8335          }
   8336          
   8337          #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
   8338              defined(MBEDTLS_SSL_PROTO_TLS1_1)
   8339          int mbedtls_ssl_get_key_exchange_md_ssl_tls( mbedtls_ssl_context *ssl,
   8340                                                  unsigned char *output,
   8341                                                  unsigned char *data, size_t data_len )
   8342          {
   8343              int ret = 0;
   8344              mbedtls_md5_context mbedtls_md5;
   8345              mbedtls_sha1_context mbedtls_sha1;
   8346          
   8347              mbedtls_md5_init( &mbedtls_md5 );
   8348              mbedtls_sha1_init( &mbedtls_sha1 );
   8349          
   8350              /*
   8351               * digitally-signed struct {
   8352               *     opaque md5_hash[16];
   8353               *     opaque sha_hash[20];
   8354               * };
   8355               *
   8356               * md5_hash
   8357               *     MD5(ClientHello.random + ServerHello.random
   8358               *                            + ServerParams);
   8359               * sha_hash
   8360               *     SHA(ClientHello.random + ServerHello.random
   8361               *                            + ServerParams);
   8362               */
   8363              if( ( ret = mbedtls_md5_starts_ret( &mbedtls_md5 ) ) != 0 )
   8364              {
   8365                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md5_starts_ret", ret );
   8366                  goto exit;
   8367              }
   8368              if( ( ret = mbedtls_md5_update_ret( &mbedtls_md5,
   8369                                                  ssl->handshake->randbytes, 64 ) ) != 0 )
   8370              {
   8371                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md5_update_ret", ret );
   8372                  goto exit;
   8373              }
   8374              if( ( ret = mbedtls_md5_update_ret( &mbedtls_md5, data, data_len ) ) != 0 )
   8375              {
   8376                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md5_update_ret", ret );
   8377                  goto exit;
   8378              }
   8379              if( ( ret = mbedtls_md5_finish_ret( &mbedtls_md5, output ) ) != 0 )
   8380              {
   8381                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md5_finish_ret", ret );
   8382                  goto exit;
   8383              }
   8384          
   8385              if( ( ret = mbedtls_sha1_starts_ret( &mbedtls_sha1 ) ) != 0 )
   8386              {
   8387                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_sha1_starts_ret", ret );
   8388                  goto exit;
   8389              }
   8390              if( ( ret = mbedtls_sha1_update_ret( &mbedtls_sha1,
   8391                                                   ssl->handshake->randbytes, 64 ) ) != 0 )
   8392              {
   8393                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_sha1_update_ret", ret );
   8394                  goto exit;
   8395              }
   8396              if( ( ret = mbedtls_sha1_update_ret( &mbedtls_sha1, data,
   8397                                                   data_len ) ) != 0 )
   8398              {
   8399                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_sha1_update_ret", ret );
   8400                  goto exit;
   8401              }
   8402              if( ( ret = mbedtls_sha1_finish_ret( &mbedtls_sha1,
   8403                                                   output + 16 ) ) != 0 )
   8404              {
   8405                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_sha1_finish_ret", ret );
   8406                  goto exit;
   8407              }
   8408          
   8409          exit:
   8410              mbedtls_md5_free( &mbedtls_md5 );
   8411              mbedtls_sha1_free( &mbedtls_sha1 );
   8412          
   8413              if( ret != 0 )
   8414                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   8415                                                  MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );
   8416          
   8417              return( ret );
   8418          
   8419          }
   8420          #endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \
   8421                    MBEDTLS_SSL_PROTO_TLS1_1 */
   8422          
   8423          #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \
   8424              defined(MBEDTLS_SSL_PROTO_TLS1_2)
   8425          int mbedtls_ssl_get_key_exchange_md_tls1_2( mbedtls_ssl_context *ssl,
   8426                                                 unsigned char *output,
   8427                                                 unsigned char *data, size_t data_len,
   8428                                                 mbedtls_md_type_t md_alg )
   8429          {
   8430              int ret = 0;
   8431              mbedtls_md_context_t ctx;
   8432              const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type( md_alg );
   8433          
   8434              mbedtls_md_init( &ctx );
   8435          
   8436              /*
   8437               * digitally-signed struct {
   8438               *     opaque client_random[32];
   8439               *     opaque server_random[32];
   8440               *     ServerDHParams params;
   8441               * };
   8442               */
   8443              if( ( ret = mbedtls_md_setup( &ctx, md_info, 0 ) ) != 0 )
   8444              {
   8445                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_setup", ret );
   8446                  goto exit;
   8447              }
   8448              if( ( ret = mbedtls_md_starts( &ctx ) ) != 0 )
   8449              {
   8450                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_starts", ret );
   8451                  goto exit;
   8452              }
   8453              if( ( ret = mbedtls_md_update( &ctx, ssl->handshake->randbytes, 64 ) ) != 0 )
   8454              {
   8455                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_update", ret );
   8456                  goto exit;
   8457              }
   8458              if( ( ret = mbedtls_md_update( &ctx, data, data_len ) ) != 0 )
   8459              {
   8460                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_update", ret );
   8461                  goto exit;
   8462              }
   8463              if( ( ret = mbedtls_md_finish( &ctx, output ) ) != 0 )
   8464              {
   8465                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_md_finish", ret );
   8466                  goto exit;
   8467              }
   8468          
   8469          exit:
   8470              mbedtls_md_free( &ctx );
   8471          
   8472              if( ret != 0 )
   8473                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   8474                                                  MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );
   8475          
   8476              return( ret );
   8477          }
   8478          #endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \
   8479                    MBEDTLS_SSL_PROTO_TLS1_2 */
   8480          
   8481          #endif /* MBEDTLS_SSL_TLS_C */


 
 
 0 bytes of memory

Errors: none
Warnings: none
