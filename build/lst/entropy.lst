###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:57
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\entropy.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW6B93.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\entropy.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"entropy.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0
#        -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\entropy.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\entropy.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\entropy.c
      1          /***************************************************************************//**
      2           * # License
      3           *
      4           * The licensor of this software is Silicon Laboratories Inc. Your use of this
      5           * software is governed by the terms of Silicon Labs Master Software License
      6           * Agreement (MSLA) available at
      7           * www.silabs.com/about-us/legal/master-software-license-agreement. This
      8           * software is Third Party Software licensed by Silicon Labs from a third party
      9           * and is governed by the sections of the MSLA applicable to Third Party
     10           * Software and the additional terms set forth below.
     11           *
     12           ******************************************************************************/
     13          /*
     14           *  Entropy accumulator implementation
     15           *
     16           *  Copyright (C) 2006-2016, ARM Limited, All Rights Reserved
     17           *  SPDX-License-Identifier: Apache-2.0
     18           *
     19           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
     20           *  not use this file except in compliance with the License.
     21           *  You may obtain a copy of the License at
     22           *
     23           *  http://www.apache.org/licenses/LICENSE-2.0
     24           *
     25           *  Unless required by applicable law or agreed to in writing, software
     26           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     27           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     28           *  See the License for the specific language governing permissions and
     29           *  limitations under the License.
     30           *
     31           *  This file is part of mbed TLS (https://tls.mbed.org)
     32           */
     33          
     34          #if !defined(MBEDTLS_CONFIG_FILE)
     35          #include "mbedtls/config.h"
     36          #else
     37          #include MBEDTLS_CONFIG_FILE
     38          #endif
     39          
     40          #if defined(MBEDTLS_ENTROPY_C)
     41          
     42          #if defined(MBEDTLS_TEST_NULL_ENTROPY)
     43          #warning "**** WARNING!  MBEDTLS_TEST_NULL_ENTROPY defined! "
     44          #warning "**** THIS BUILD HAS NO DEFINED ENTROPY SOURCES "
     45          #warning "**** THIS BUILD IS *NOT* SUITABLE FOR PRODUCTION USE "
     46          #endif
     47          
     48          #include "mbedtls/entropy.h"
     49          #include "mbedtls/entropy_poll.h"
     50          
     51          #include <string.h>
     52          
     53          #if defined(MBEDTLS_FS_IO)
     54          #include <stdio.h>
     55          #endif
     56          
     57          #if defined(MBEDTLS_ENTROPY_NV_SEED)
     58          #include "mbedtls/platform.h"
     59          #endif
     60          
     61          #if defined(MBEDTLS_SELF_TEST)
     62          #if defined(MBEDTLS_PLATFORM_C)
     63          #include "mbedtls/platform.h"
     64          #else
     65          #include <stdio.h>
     66          #define mbedtls_printf     printf
     67          #endif /* MBEDTLS_PLATFORM_C */
     68          #endif /* MBEDTLS_SELF_TEST */
     69          
     70          #if defined(MBEDTLS_HAVEGE_C)
     71          #include "mbedtls/havege.h"
     72          #endif
     73          
     74          /* Implementation that should never be optimized out by the compiler */
     75          static void mbedtls_zeroize( void *v, size_t n ) {
     76              volatile unsigned char *p = v; while( n-- ) *p++ = 0;
     77          }
     78          
     79          #define ENTROPY_MAX_LOOP    256     /**< Maximum amount to loop before error */
     80          
     81          void mbedtls_entropy_init( mbedtls_entropy_context *ctx )
     82          {
     83              ctx->source_count = 0;
     84              memset( ctx->source, 0, sizeof( ctx->source ) );
     85          
     86          #if defined(MBEDTLS_THREADING_C)
     87              mbedtls_mutex_init( &ctx->mutex );
     88          #endif
     89          
     90              ctx->accumulator_started = 0;
     91          #if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)
     92              mbedtls_sha512_init( &ctx->accumulator );
     93          #else
     94              mbedtls_sha256_init( &ctx->accumulator );
     95          #endif
     96          #if defined(MBEDTLS_HAVEGE_C)
     97              mbedtls_havege_init( &ctx->havege_data );
     98          #endif
     99          
    100              /* Reminder: Update ENTROPY_HAVE_STRONG in the test files
    101               *           when adding more strong entropy sources here. */
    102          
    103          #if defined(MBEDTLS_TEST_NULL_ENTROPY)
    104              mbedtls_entropy_add_source( ctx, mbedtls_null_entropy_poll, NULL,
    105                                          1, MBEDTLS_ENTROPY_SOURCE_STRONG );
    106          #endif
    107          
    108          #if !defined(MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES)
    109          #if !defined(MBEDTLS_NO_PLATFORM_ENTROPY)
    110              mbedtls_entropy_add_source( ctx, mbedtls_platform_entropy_poll, NULL,
    111                                          MBEDTLS_ENTROPY_MIN_PLATFORM,
    112                                          MBEDTLS_ENTROPY_SOURCE_STRONG );
    113          #endif
    114          #if defined(MBEDTLS_TIMING_C)
    115              mbedtls_entropy_add_source( ctx, mbedtls_hardclock_poll, NULL,
    116                                          MBEDTLS_ENTROPY_MIN_HARDCLOCK,
    117                                          MBEDTLS_ENTROPY_SOURCE_WEAK );
    118          #endif
    119          #if defined(MBEDTLS_HAVEGE_C)
    120              mbedtls_entropy_add_source( ctx, mbedtls_havege_poll, &ctx->havege_data,
    121                                          MBEDTLS_ENTROPY_MIN_HAVEGE,
    122                                          MBEDTLS_ENTROPY_SOURCE_STRONG );
    123          #endif
    124          #if defined(MBEDTLS_ENTROPY_HARDWARE_ALT)
    125              mbedtls_entropy_add_source( ctx, mbedtls_hardware_poll, NULL,
    126                                          MBEDTLS_ENTROPY_MIN_HARDWARE,
    127                                          MBEDTLS_ENTROPY_SOURCE_STRONG );
    128          #endif
    129          #if defined(MBEDTLS_ENTROPY_NV_SEED)
    130              mbedtls_entropy_add_source( ctx, mbedtls_nv_seed_poll, NULL,
    131                                          MBEDTLS_ENTROPY_BLOCK_SIZE,
    132                                          MBEDTLS_ENTROPY_SOURCE_STRONG );
    133              ctx->initial_entropy_run = 0;
    134          #endif
    135          #endif /* MBEDTLS_NO_DEFAULT_ENTROPY_SOURCES */
    136          }
    137          
    138          void mbedtls_entropy_free( mbedtls_entropy_context *ctx )
    139          {
    140          #if defined(MBEDTLS_HAVEGE_C)
    141              mbedtls_havege_free( &ctx->havege_data );
    142          #endif
    143          #if defined(MBEDTLS_THREADING_C)
    144              mbedtls_mutex_free( &ctx->mutex );
    145          #endif
    146          #if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)
    147              mbedtls_sha512_free( &ctx->accumulator );
    148          #else
    149              mbedtls_sha256_free( &ctx->accumulator );
    150          #endif
    151          #if defined(MBEDTLS_ENTROPY_NV_SEED)
    152              ctx->initial_entropy_run = 0;
    153          #endif
    154              ctx->source_count = 0;
    155              mbedtls_zeroize( ctx->source, sizeof( ctx->source ) );
    156              ctx->accumulator_started = 0;
    157          }
    158          
    159          int mbedtls_entropy_add_source( mbedtls_entropy_context *ctx,
    160                                  mbedtls_entropy_f_source_ptr f_source, void *p_source,
    161                                  size_t threshold, int strong )
    162          {
    163              int idx, ret = 0;
    164          
    165          #if defined(MBEDTLS_THREADING_C)
    166              if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
    167                  return( ret );
    168          #endif
    169          
    170              idx = ctx->source_count;
    171              if( idx >= MBEDTLS_ENTROPY_MAX_SOURCES )
    172              {
    173                  ret = MBEDTLS_ERR_ENTROPY_MAX_SOURCES;
    174                  goto exit;
    175              }
    176          
    177              ctx->source[idx].f_source  = f_source;
    178              ctx->source[idx].p_source  = p_source;
    179              ctx->source[idx].threshold = threshold;
    180              ctx->source[idx].strong    = strong;
    181          
    182              ctx->source_count++;
    183          
    184          exit:
    185          #if defined(MBEDTLS_THREADING_C)
    186              if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
    187                  return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
    188          #endif
    189          
    190              return( ret );
    191          }
    192          
    193          /*
    194           * Entropy accumulator update
    195           */
    196          static int entropy_update( mbedtls_entropy_context *ctx, unsigned char source_id,
    197                                     const unsigned char *data, size_t len )
    198          {
    199              unsigned char header[2];
    200              unsigned char tmp[MBEDTLS_ENTROPY_BLOCK_SIZE];
    201              size_t use_len = len;
    202              const unsigned char *p = data;
    203              int ret = 0;
    204          
    205              if( use_len > MBEDTLS_ENTROPY_BLOCK_SIZE )
    206              {
    207          #if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)
    208                  if( ( ret = mbedtls_sha512_ret( data, len, tmp, 0 ) ) != 0 )
    209                      goto cleanup;
    210          #else
    211                  if( ( ret = mbedtls_sha256_ret( data, len, tmp, 0 ) ) != 0 )
    212                      goto cleanup;
    213          #endif
    214                  p = tmp;
    215                  use_len = MBEDTLS_ENTROPY_BLOCK_SIZE;
    216              }
    217          
    218              header[0] = source_id;
    219              header[1] = use_len & 0xFF;
    220          
    221              /*
    222               * Start the accumulator if this has not already happened. Note that
    223               * it is sufficient to start the accumulator here only because all calls to
    224               * gather entropy eventually execute this code.
    225               */
    226          #if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)
    227              if( ctx->accumulator_started == 0 &&
    228                  ( ret = mbedtls_sha512_starts_ret( &ctx->accumulator, 0 ) ) != 0 )
    229                  goto cleanup;
    230              else
    231                  ctx->accumulator_started = 1;
    232              if( ( ret = mbedtls_sha512_update_ret( &ctx->accumulator, header, 2 ) ) != 0 )
    233                  goto cleanup;
    234              ret = mbedtls_sha512_update_ret( &ctx->accumulator, p, use_len );
    235          #else
    236              if( ctx->accumulator_started == 0 &&
    237                  ( ret = mbedtls_sha256_starts_ret( &ctx->accumulator, 0 ) ) != 0 )
    238                  goto cleanup;
    239              else
    240                  ctx->accumulator_started = 1;
    241              if( ( ret = mbedtls_sha256_update_ret( &ctx->accumulator, header, 2 ) ) != 0 )
    242                  goto cleanup;
    243              ret = mbedtls_sha256_update_ret( &ctx->accumulator, p, use_len );
    244          #endif
    245          
    246          cleanup:
    247              mbedtls_zeroize( tmp, sizeof( tmp ) );
    248          
    249              return( ret );
    250          }
    251          
    252          int mbedtls_entropy_update_manual( mbedtls_entropy_context *ctx,
    253                                     const unsigned char *data, size_t len )
    254          {
    255              int ret;
    256          
    257          #if defined(MBEDTLS_THREADING_C)
    258              if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
    259                  return( ret );
    260          #endif
    261          
    262              ret = entropy_update( ctx, MBEDTLS_ENTROPY_SOURCE_MANUAL, data, len );
    263          
    264          #if defined(MBEDTLS_THREADING_C)
    265              if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
    266                  return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
    267          #endif
    268          
    269              return( ret );
    270          }
    271          
    272          /*
    273           * Run through the different sources to add entropy to our accumulator
    274           */
    275          static int entropy_gather_internal( mbedtls_entropy_context *ctx )
    276          {
    277              int ret, i, have_one_strong = 0;
    278              unsigned char buf[MBEDTLS_ENTROPY_MAX_GATHER];
    279              size_t olen;
    280          
    281              if( ctx->source_count == 0 )
    282                  return( MBEDTLS_ERR_ENTROPY_NO_SOURCES_DEFINED );
    283          
    284              /*
    285               * Run through our entropy sources
    286               */
    287              for( i = 0; i < ctx->source_count; i++ )
    288              {
    289                  if( ctx->source[i].strong == MBEDTLS_ENTROPY_SOURCE_STRONG )
    290                      have_one_strong = 1;
    291          
    292                  olen = 0;
    293                  if( ( ret = ctx->source[i].f_source( ctx->source[i].p_source,
    294                                  buf, MBEDTLS_ENTROPY_MAX_GATHER, &olen ) ) != 0 )
    295                  {
    296                      goto cleanup;
    297                  }
    298          
    299                  /*
    300                   * Add if we actually gathered something
    301                   */
    302                  if( olen > 0 )
    303                  {
    304                      if( ( ret = entropy_update( ctx, (unsigned char) i,
    305                                                  buf, olen ) ) != 0 )
    306                          return( ret );
    307                      ctx->source[i].size += olen;
    308                  }
    309              }
    310          
    311              if( have_one_strong == 0 )
    312                  ret = MBEDTLS_ERR_ENTROPY_NO_STRONG_SOURCE;
    313          
    314          cleanup:
    315              mbedtls_zeroize( buf, sizeof( buf ) );
    316          
    317              return( ret );
    318          }
    319          
    320          /*
    321           * Thread-safe wrapper for entropy_gather_internal()
    322           */
    323          int mbedtls_entropy_gather( mbedtls_entropy_context *ctx )
    324          {
    325              int ret;
    326          
    327          #if defined(MBEDTLS_THREADING_C)
    328              if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
    329                  return( ret );
    330          #endif
    331          
    332              ret = entropy_gather_internal( ctx );
    333          
    334          #if defined(MBEDTLS_THREADING_C)
    335              if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
    336                  return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
    337          #endif
    338          
    339              return( ret );
    340          }
    341          
    342          int mbedtls_entropy_func( void *data, unsigned char *output, size_t len )
    343          {
    344              int ret, count = 0, i, done;
    345              mbedtls_entropy_context *ctx = (mbedtls_entropy_context *) data;
    346              unsigned char buf[MBEDTLS_ENTROPY_BLOCK_SIZE];
    347          
    348              if( len > MBEDTLS_ENTROPY_BLOCK_SIZE )
    349                  return( MBEDTLS_ERR_ENTROPY_SOURCE_FAILED );
    350          
    351          #if defined(MBEDTLS_ENTROPY_NV_SEED)
    352              /* Update the NV entropy seed before generating any entropy for outside
    353               * use.
    354               */
    355              if( ctx->initial_entropy_run == 0 )
    356              {
    357                  ctx->initial_entropy_run = 1;
    358                  if( ( ret = mbedtls_entropy_update_nv_seed( ctx ) ) != 0 )
    359                      return( ret );
    360              }
    361          #endif
    362          
    363          #if defined(MBEDTLS_THREADING_C)
    364              if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
    365                  return( ret );
    366          #endif
    367          
    368              /*
    369               * Always gather extra entropy before a call
    370               */
    371              do
    372              {
    373                  if( count++ > ENTROPY_MAX_LOOP )
    374                  {
    375                      ret = MBEDTLS_ERR_ENTROPY_SOURCE_FAILED;
    376                      goto exit;
    377                  }
    378          
    379                  if( ( ret = entropy_gather_internal( ctx ) ) != 0 )
    380                      goto exit;
    381          
    382                  done = 1;
    383                  for( i = 0; i < ctx->source_count; i++ )
    384                      if( ctx->source[i].size < ctx->source[i].threshold )
    385                          done = 0;
    386              }
    387              while( ! done );
    388          
    389              memset( buf, 0, MBEDTLS_ENTROPY_BLOCK_SIZE );
    390          
    391          #if defined(MBEDTLS_ENTROPY_SHA512_ACCUMULATOR)
    392              /*
    393               * Note that at this stage it is assumed that the accumulator was started
    394               * in a previous call to entropy_update(). If this is not guaranteed, the
    395               * code below will fail.
    396               */
    397              if( ( ret = mbedtls_sha512_finish_ret( &ctx->accumulator, buf ) ) != 0 )
    398                  goto exit;
    399          
    400              /*
    401               * Reset accumulator and counters and recycle existing entropy
    402               */
    403              mbedtls_sha512_free( &ctx->accumulator );
    404              mbedtls_sha512_init( &ctx->accumulator );
    405              if( ( ret = mbedtls_sha512_starts_ret( &ctx->accumulator, 0 ) ) != 0 )
    406                  goto exit;
    407              if( ( ret = mbedtls_sha512_update_ret( &ctx->accumulator, buf,
    408                                                     MBEDTLS_ENTROPY_BLOCK_SIZE ) ) != 0 )
    409                  goto exit;
    410          
    411              /*
    412               * Perform second SHA-512 on entropy
    413               */
    414              if( ( ret = mbedtls_sha512_ret( buf, MBEDTLS_ENTROPY_BLOCK_SIZE,
    415                                              buf, 0 ) ) != 0 )
    416                  goto exit;
    417          #else /* MBEDTLS_ENTROPY_SHA512_ACCUMULATOR */
    418              if( ( ret = mbedtls_sha256_finish_ret( &ctx->accumulator, buf ) ) != 0 )
    419                  goto exit;
    420          
    421              /*
    422               * Reset accumulator and counters and recycle existing entropy
    423               */
    424              mbedtls_sha256_free( &ctx->accumulator );
    425              mbedtls_sha256_init( &ctx->accumulator );
    426              if( ( ret = mbedtls_sha256_starts_ret( &ctx->accumulator, 0 ) ) != 0 )
    427                  goto exit;
    428              if( ( ret = mbedtls_sha256_update_ret( &ctx->accumulator, buf,
    429                                                     MBEDTLS_ENTROPY_BLOCK_SIZE ) ) != 0 )
    430                  goto exit;
    431          
    432              /*
    433               * Perform second SHA-256 on entropy
    434               */
    435              if( ( ret = mbedtls_sha256_ret( buf, MBEDTLS_ENTROPY_BLOCK_SIZE,
    436                                              buf, 0 ) ) != 0 )
    437                  goto exit;
    438          #endif /* MBEDTLS_ENTROPY_SHA512_ACCUMULATOR */
    439          
    440              for( i = 0; i < ctx->source_count; i++ )
    441                  ctx->source[i].size = 0;
    442          
    443              memcpy( output, buf, len );
    444          
    445              ret = 0;
    446          
    447          exit:
    448              mbedtls_zeroize( buf, sizeof( buf ) );
    449          
    450          #if defined(MBEDTLS_THREADING_C)
    451              if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
    452                  return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
    453          #endif
    454          
    455              return( ret );
    456          }
    457          
    458          #if defined(MBEDTLS_ENTROPY_NV_SEED)
    459          int mbedtls_entropy_update_nv_seed( mbedtls_entropy_context *ctx )
    460          {
    461              int ret = MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR;
    462              unsigned char buf[MBEDTLS_ENTROPY_BLOCK_SIZE];
    463          
    464              /* Read new seed  and write it to NV */
    465              if( ( ret = mbedtls_entropy_func( ctx, buf, MBEDTLS_ENTROPY_BLOCK_SIZE ) ) != 0 )
    466                  return( ret );
    467          
    468              if( mbedtls_nv_seed_write( buf, MBEDTLS_ENTROPY_BLOCK_SIZE ) < 0 )
    469                  return( MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR );
    470          
    471              /* Manually update the remaining stream with a separator value to diverge */
    472              memset( buf, 0, MBEDTLS_ENTROPY_BLOCK_SIZE );
    473              ret = mbedtls_entropy_update_manual( ctx, buf, MBEDTLS_ENTROPY_BLOCK_SIZE );
    474          
    475              return( ret );
    476          }
    477          #endif /* MBEDTLS_ENTROPY_NV_SEED */
    478          
    479          #if defined(MBEDTLS_FS_IO)
    480          int mbedtls_entropy_write_seed_file( mbedtls_entropy_context *ctx, const char *path )
    481          {
    482              int ret = MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR;
    483              FILE *f;
    484              unsigned char buf[MBEDTLS_ENTROPY_BLOCK_SIZE];
    485          
    486              if( ( f = fopen( path, "wb" ) ) == NULL )
    487                  return( MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR );
    488          
    489              if( ( ret = mbedtls_entropy_func( ctx, buf, MBEDTLS_ENTROPY_BLOCK_SIZE ) ) != 0 )
    490                  goto exit;
    491          
    492              if( fwrite( buf, 1, MBEDTLS_ENTROPY_BLOCK_SIZE, f ) != MBEDTLS_ENTROPY_BLOCK_SIZE )
    493              {
    494                  ret = MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR;
    495                  goto exit;
    496              }
    497          
    498              ret = 0;
    499          
    500          exit:
    501              mbedtls_zeroize( buf, sizeof( buf ) );
    502          
    503              fclose( f );
    504              return( ret );
    505          }
    506          
    507          int mbedtls_entropy_update_seed_file( mbedtls_entropy_context *ctx, const char *path )
    508          {
    509              int ret = 0;
    510              FILE *f;
    511              size_t n;
    512              unsigned char buf[ MBEDTLS_ENTROPY_MAX_SEED_SIZE ];
    513          
    514              if( ( f = fopen( path, "rb" ) ) == NULL )
    515                  return( MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR );
    516          
    517              fseek( f, 0, SEEK_END );
    518              n = (size_t) ftell( f );
    519              fseek( f, 0, SEEK_SET );
    520          
    521              if( n > MBEDTLS_ENTROPY_MAX_SEED_SIZE )
    522                  n = MBEDTLS_ENTROPY_MAX_SEED_SIZE;
    523          
    524              if( fread( buf, 1, n, f ) != n )
    525                  ret = MBEDTLS_ERR_ENTROPY_FILE_IO_ERROR;
    526              else
    527                  ret = mbedtls_entropy_update_manual( ctx, buf, n );
    528          
    529              fclose( f );
    530          
    531              mbedtls_zeroize( buf, sizeof( buf ) );
    532          
    533              if( ret != 0 )
    534                  return( ret );
    535          
    536              return( mbedtls_entropy_write_seed_file( ctx, path ) );
    537          }
    538          #endif /* MBEDTLS_FS_IO */
    539          
    540          #if defined(MBEDTLS_SELF_TEST)
    541          #if !defined(MBEDTLS_TEST_NULL_ENTROPY)
    542          /*
    543           * Dummy source function
    544           */
    545          static int entropy_dummy_source( void *data, unsigned char *output,
    546                                           size_t len, size_t *olen )
    547          {
    548              ((void) data);
    549          
    550              memset( output, 0x2a, len );
    551              *olen = len;
    552          
    553              return( 0 );
    554          }
    555          #endif /* !MBEDTLS_TEST_NULL_ENTROPY */
    556          
    557          #if defined(MBEDTLS_ENTROPY_HARDWARE_ALT)
    558          
    559          static int mbedtls_entropy_source_self_test_gather( unsigned char *buf, size_t buf_len )
    560          {
    561              int ret = 0;
    562              size_t entropy_len = 0;
    563              size_t olen = 0;
    564              size_t attempts = buf_len;
    565          
    566              while( attempts > 0 && entropy_len < buf_len )
    567              {
    568                  if( ( ret = mbedtls_hardware_poll( NULL, buf + entropy_len,
    569                      buf_len - entropy_len, &olen ) ) != 0 )
    570                      return( ret );
    571          
    572                  entropy_len += olen;
    573                  attempts--;
    574              }
    575          
    576              if( entropy_len < buf_len )
    577              {
    578                  ret = 1;
    579              }
    580          
    581              return( ret );
    582          }
    583          
    584          
    585          static int mbedtls_entropy_source_self_test_check_bits( const unsigned char *buf,
    586                                                                  size_t buf_len )
    587          {
    588              unsigned char set= 0xFF;
    589              unsigned char unset = 0x00;
    590              size_t i;
    591          
    592              for( i = 0; i < buf_len; i++ )
    593              {
    594                  set &= buf[i];
    595                  unset |= buf[i];
    596              }
    597          
    598              return( set == 0xFF || unset == 0x00 );
    599          }
    600          
    601          /*
    602           * A test to ensure hat the entropy sources are functioning correctly
    603           * and there is no obvious failure. The test performs the following checks:
    604           *  - The entropy source is not providing only 0s (all bits unset) or 1s (all
    605           *    bits set).
    606           *  - The entropy source is not providing values in a pattern. Because the
    607           *    hardware could be providing data in an arbitrary length, this check polls
    608           *    the hardware entropy source twice and compares the result to ensure they
    609           *    are not equal.
    610           *  - The error code returned by the entropy source is not an error.
    611           */
    612          int mbedtls_entropy_source_self_test( int verbose )
    613          {
    614              int ret = 0;
    615              unsigned char buf0[2 * sizeof( unsigned long long int )];
    616              unsigned char buf1[2 * sizeof( unsigned long long int )];
    617          
    618              if( verbose != 0 )
    619                  mbedtls_printf( "  ENTROPY_BIAS test: " );
    620          
    621              memset( buf0, 0x00, sizeof( buf0 ) );
    622              memset( buf1, 0x00, sizeof( buf1 ) );
    623          
    624              if( ( ret = mbedtls_entropy_source_self_test_gather( buf0, sizeof( buf0 ) ) ) != 0 )
    625                  goto cleanup;
    626              if( ( ret = mbedtls_entropy_source_self_test_gather( buf1, sizeof( buf1 ) ) ) != 0 )
    627                  goto cleanup;
    628          
    629              /* Make sure that the returned values are not all 0 or 1 */
    630              if( ( ret = mbedtls_entropy_source_self_test_check_bits( buf0, sizeof( buf0 ) ) ) != 0 )
    631                  goto cleanup;
    632              if( ( ret = mbedtls_entropy_source_self_test_check_bits( buf1, sizeof( buf1 ) ) ) != 0 )
    633                  goto cleanup;
    634          
    635              /* Make sure that the entropy source is not returning values in a
    636               * pattern */
    637              ret = memcmp( buf0, buf1, sizeof( buf0 ) ) == 0;
    638          
    639          cleanup:
    640              if( verbose != 0 )
    641              {
    642                  if( ret != 0 )
    643                      mbedtls_printf( "failed\n" );
    644                  else
    645                      mbedtls_printf( "passed\n" );
    646          
    647                  mbedtls_printf( "\n" );
    648              }
    649          
    650              return( ret != 0 );
    651          }
    652          
    653          #endif /* MBEDTLS_ENTROPY_HARDWARE_ALT */
    654          
    655          /*
    656           * The actual entropy quality is hard to test, but we can at least
    657           * test that the functions don't cause errors and write the correct
    658           * amount of data to buffers.
    659           */
    660          int mbedtls_entropy_self_test( int verbose )
    661          {
    662              int ret = 1;
    663          #if !defined(MBEDTLS_TEST_NULL_ENTROPY)
    664              mbedtls_entropy_context ctx;
    665              unsigned char buf[MBEDTLS_ENTROPY_BLOCK_SIZE] = { 0 };
    666              unsigned char acc[MBEDTLS_ENTROPY_BLOCK_SIZE] = { 0 };
    667              size_t i, j;
    668          #endif /* !MBEDTLS_TEST_NULL_ENTROPY */
    669          
    670              if( verbose != 0 )
    671                  mbedtls_printf( "  ENTROPY test: " );
    672          
    673          #if !defined(MBEDTLS_TEST_NULL_ENTROPY)
    674              mbedtls_entropy_init( &ctx );
    675          
    676              /* First do a gather to make sure we have default sources */
    677              if( ( ret = mbedtls_entropy_gather( &ctx ) ) != 0 )
    678                  goto cleanup;
    679          
    680              ret = mbedtls_entropy_add_source( &ctx, entropy_dummy_source, NULL, 16,
    681                                                MBEDTLS_ENTROPY_SOURCE_WEAK );
    682              if( ret != 0 )
    683                  goto cleanup;
    684          
    685              if( ( ret = mbedtls_entropy_update_manual( &ctx, buf, sizeof buf ) ) != 0 )
    686                  goto cleanup;
    687          
    688              /*
    689               * To test that mbedtls_entropy_func writes correct number of bytes:
    690               * - use the whole buffer and rely on ASan to detect overruns
    691               * - collect entropy 8 times and OR the result in an accumulator:
    692               *   any byte should then be 0 with probably 2^(-64), so requiring
    693               *   each of the 32 or 64 bytes to be non-zero has a false failure rate
    694               *   of at most 2^(-58) which is acceptable.
    695               */
    696              for( i = 0; i < 8; i++ )
    697              {
    698                  if( ( ret = mbedtls_entropy_func( &ctx, buf, sizeof( buf ) ) ) != 0 )
    699                      goto cleanup;
    700          
    701                  for( j = 0; j < sizeof( buf ); j++ )
    702                      acc[j] |= buf[j];
    703              }
    704          
    705              for( j = 0; j < sizeof( buf ); j++ )
    706              {
    707                  if( acc[j] == 0 )
    708                  {
    709                      ret = 1;
    710                      goto cleanup;
    711                  }
    712              }
    713          
    714          #if defined(MBEDTLS_ENTROPY_HARDWARE_ALT)
    715              if( ( ret = mbedtls_entropy_source_self_test( 0 ) ) != 0 )
    716                  goto cleanup;
    717          #endif
    718          
    719          cleanup:
    720              mbedtls_entropy_free( &ctx );
    721          #endif /* !MBEDTLS_TEST_NULL_ENTROPY */
    722          
    723              if( verbose != 0 )
    724              {
    725                  if( ret != 0 )
    726                      mbedtls_printf( "failed\n" );
    727                  else
    728                      mbedtls_printf( "passed\n" );
    729          
    730                  mbedtls_printf( "\n" );
    731              }
    732          
    733              return( ret != 0 );
    734          }
    735          #endif /* MBEDTLS_SELF_TEST */
    736          
    737          #endif /* MBEDTLS_ENTROPY_C */


 
 
 0 bytes of memory

Errors: none
Warnings: none
