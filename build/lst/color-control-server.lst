###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:29
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\protocol\zigbee\app\framework\plugin\color-control-server\color-control-server.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EWF87B.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\protocol\zigbee\app\framework\plugin\color-control-server\color-control-server.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"color-control-server.c\"" -D PSSTORE_SIZE=0 -D
#        LONGTOKEN_SIZE=0 -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\protocol\zigbee\app\framework\plugin\color-control-server\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\color-control-server.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\color-control-server.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\protocol\zigbee\app\framework\plugin\color-control-server\color-control-server.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Routines for the Color Control Server plugin.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc. Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement. This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          
     18          #include "app/framework/include/af.h"
     19          #include "app/framework/util/attribute-storage.h"
     20          
     21          #ifdef EMBER_AF_PLUGIN_REPORTING
     22            #include "app/framework/plugin/reporting/reporting.h"
     23          #endif
     24          
     25          #define COLOR_TEMP_CONTROL emberAfPluginColorControlServerTempTransitionEventControl
     26          #define COLOR_XY_CONTROL   emberAfPluginColorControlServerXyTransitionEventControl
     27          #define COLOR_HSV_CONTROL  emberAfPluginColorControlServerHueSatTransitionEventControl
     28          
     29          // move mode
     30          enum {
     31            MOVE_MODE_STOP     = 0x00,
     32            MOVE_MODE_UP       = 0x01,
     33            MOVE_MODE_DOWN     = 0x03
     34          };
     35          
     36          enum {
     37            COLOR_MODE_HSV         = 0x00,
     38            COLOR_MODE_CIE_XY      = 0x01,
     39            COLOR_MODE_TEMPERATURE = 0x02
     40          };
     41          
     42          enum {
     43            HSV_TO_HSV         = 0x00,
     44            HSV_TO_CIE_XY      = 0x01,
     45            HSV_TO_TEMPERATURE = 0x02,
     46            CIE_XY_TO_HSV         = 0x10,
     47            CIE_XY_TO_CIE_XY      = 0x11,
     48            CIE_XY_TO_TEMPERATURE = 0x12,
     49            TEMPERATURE_TO_HSV         = 0x20,
     50            TEMPERATURE_TO_CIE_XY      = 0x21,
     51            TEMPERATURE_TO_TEMPERATURE = 0x22
     52          };
     53          

   \                                 In section .bss, align 4
     54          EmberEventControl emberAfPluginColorControlServerTempTransitionEventControl;
   \                     emberAfPluginColorControlServerTempTransitionEventControl:
   \        0x0                      DS8 8

   \                                 In section .bss, align 4
     55          EmberEventControl emberAfPluginColorControlServerXyTransitionEventControl;
   \                     emberAfPluginColorControlServerXyTransitionEventControl:
   \        0x0                      DS8 8

   \                                 In section .bss, align 4
     56          EmberEventControl emberAfPluginColorControlServerHueSatTransitionEventControl;
   \                     emberAfPluginColorControlServerHueSatTransitionEventControl:
   \        0x0                      DS8 8
     57          
     58          #define UPDATE_TIME_MS 100
     59          #define TRANSITION_TIME_1S 10
     60          #define MIN_CIE_XY_VALUE 0
     61          // this value comes directly from the ZCL specification table 5.3
     62          #define MAX_CIE_XY_VALUE 0xfeff
     63          #define MIN_TEMPERATURE_VALUE 0
     64          #define MAX_TEMPERATURE_VALUE 0xfeff
     65          #define MIN_HUE_VALUE 0
     66          #define MAX_HUE_VALUE 254
     67          #define MIN_SATURATION_VALUE 0
     68          #define MAX_SATURATION_VALUE 254
     69          #define HALF_MAX_UINT8T 127
     70          
     71          #define MIN_CURRENT_LEVEL 0x01
     72          #define MAX_CURRENT_LEVEL 0xFE
     73          
     74          #define REPORT_FAILED 0xFF
     75          
     76          typedef struct {
     77            uint8_t  initialHue;
     78            uint8_t  currentHue;
     79            uint8_t  finalHue;
     80            uint16_t stepsRemaining;
     81            uint16_t stepsTotal;
     82            uint8_t  endpoint;
     83            bool     up;
     84            bool     repeat;
     85          } ColorHueTransitionState;
     86          

   \                                 In section .bss, align 4
     87          static ColorHueTransitionState colorHueTransitionState;
   \                     colorHueTransitionState:
   \        0x0                      DS8 12
     88          
     89          typedef struct {
     90            uint16_t initialValue;
     91            uint16_t currentValue;
     92            uint16_t finalValue;
     93            uint16_t stepsRemaining;
     94            uint16_t stepsTotal;
     95            uint16_t lowLimit;
     96            uint16_t highLimit;
     97            uint8_t  endpoint;
     98          } Color16uTransitionState;
     99          

   \                                 In section .bss, align 4
    100          static Color16uTransitionState colorXTransitionState;
   \                     colorXTransitionState:
   \        0x0                      DS8 16

   \                                 In section .bss, align 4
    101          static Color16uTransitionState colorYTransitionState;
   \                     colorYTransitionState:
   \        0x0                      DS8 16
    102          

   \                                 In section .bss, align 4
    103          static Color16uTransitionState colorTempTransitionState;
   \                     colorTempTransitionState:
   \        0x0                      DS8 16
    104          

   \                                 In section .bss, align 4
    105          static Color16uTransitionState colorSaturationTransitionState;
   \                     colorSaturationTransitionState:
   \        0x0                      DS8 16
    106          
    107          // Forward declarations:
    108          static bool computeNewColor16uValue(Color16uTransitionState *p);
    109          static void stopAllColorTransitions(void);
    110          static void handleModeSwitch(uint8_t endpoint,
    111                                       uint8_t newColorMode);
    112          static bool shouldExecuteIfOff(uint8_t endpoint,
    113                                         uint8_t optionMask,
    114                                         uint8_t optionOverride);
    115          
    116          #ifdef EMBER_AF_PLUGIN_COLOR_CONTROL_SERVER_HSV
    117          static uint8_t addHue(uint8_t hue1, uint8_t hue2);
    118          static uint8_t subtractHue(uint8_t hue1, uint8_t hue2);
    119          static uint8_t addSaturation(uint8_t saturation1, uint8_t saturation2);
    120          static uint8_t subtractSaturation(uint8_t saturation1, uint8_t saturation2);
    121          static void initHueSat(uint8_t endpoint);
    122          static uint8_t readHue(uint8_t endpoint);
    123          static uint8_t readSaturation(uint8_t endpoint);
    124          #endif
    125          
    126          #ifdef EMBER_AF_PLUGIN_COLOR_CONTROL_SERVER_XY
    127          static uint16_t findNewColorValueFromStep(uint16_t oldValue, int16_t step);
    128          static uint16_t readColorX(uint8_t endpoint);
    129          static uint16_t readColorY(uint8_t endpoint);
    130          #endif
    131          
    132          static uint16_t computeTransitionTimeFromStateAndRate(Color16uTransitionState *p,
    133                                                                uint16_t rate);
    134          
    135          // convenient token handling functions

   \                                 In section .text, align 2, keep-with-next
    136          static uint8_t readColorMode(uint8_t endpoint)
    137          {
   \                     readColorMode: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
    138            uint8_t colorMode;
    139          
    140            assert(EMBER_ZCL_STATUS_SUCCESS
    141                   == emberAfReadServerAttribute(endpoint,
    142                                                 ZCL_COLOR_CONTROL_CLUSTER_ID,
    143                                                 ZCL_COLOR_CONTROL_COLOR_MODE_ATTRIBUTE_ID,
    144                                                 (uint8_t *)&colorMode,
    145                                                 sizeof(uint8_t)));
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x9100             STR      R1,[SP, #+0]
   \        0x6   0xAB01             ADD      R3,SP,#+4
   \        0x8   0x2208             MOVS     R2,#+8
   \        0xA   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_7: (+1)
   \        0xE   0xB110             CBZ.N    R0,??CrossCallReturnLabel_29
   \       0x10   0x2191             MOVS     R1,#+145
   \       0x12   0x....'....        BL       ?Subroutine12
    146          
    147            return colorMode;
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0x16   0x....             B.N      ?Subroutine0
    148          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \        0x4   0xBD0E             POP      {R1-R3,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0xF44F 0x7140      MOV      R1,#+768
   \        0x4   0x....'....        B.W      emberAfReadServerAttribute

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x....'....        LDR.W    R0,??DataTable27_4
   \        0x4   0x....'....        B.W      halInternalAssertFailed
    149          

   \                                 In section .text, align 2, keep-with-next
    150          static uint16_t readColorTemperature(uint8_t endpoint)
    151          {
   \                     readColorTemperature: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
    152            uint16_t colorTemperature;
    153          
    154            assert(EMBER_ZCL_STATUS_SUCCESS
    155                   == emberAfReadServerAttribute(endpoint,
    156                                                 ZCL_COLOR_CONTROL_CLUSTER_ID,
    157                                                 ZCL_COLOR_CONTROL_COLOR_TEMPERATURE_ATTRIBUTE_ID,
    158                                                 (uint8_t *)&colorTemperature,
    159                                                 sizeof(uint16_t)));
   \        0x2   0x....'....        BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_32: (+1)
   \        0x6   0x2207             MOVS     R2,#+7
   \        0x8   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_6: (+1)
   \        0xC   0xB110             CBZ.N    R0,??CrossCallReturnLabel_28
   \        0xE   0x219F             MOVS     R1,#+159
   \       0x10   0x....'....        BL       ?Subroutine12
    160          
    161            return colorTemperature;
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x14   0x....             B.N      ?Subroutine1
    162          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xF8BD 0x0004      LDRH     R0,[SP, #+4]
   \        0x4   0xBD0E             POP      {R1-R3,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0x2102             MOVS     R1,#+2
   \        0x2   0x9100             STR      R1,[SP, #+0]
   \        0x4   0xAB01             ADD      R3,SP,#+4
   \        0x6   0x4770             BX       LR
    163          

   \                                 In section .text, align 2, keep-with-next
    164          static uint16_t readColorTemperatureMin(uint8_t endpoint)
    165          {
   \                     readColorTemperatureMin: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
    166            uint16_t colorTemperatureMin;
    167            EmberStatus status;
    168          
    169            status =
    170              emberAfReadServerAttribute(endpoint,
    171                                         ZCL_COLOR_CONTROL_CLUSTER_ID,
    172                                         ZCL_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MIN_ATTRIBUTE_ID,
    173                                         (uint8_t *)&colorTemperatureMin,
    174                                         sizeof(uint16_t));
    175          
    176            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \        0x2   0x....'....        BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_33: (+1)
   \        0x6   0xF244 0x020B      MOVW     R2,#+16395
   \        0xA   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_5: (+1)
   \        0xE   0xB110             CBZ.N    R0,??readColorTemperatureMin_0
    177              colorTemperatureMin = MIN_TEMPERATURE_VALUE;
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    178            }
    179          
    180            return colorTemperatureMin;
   \                     ??readColorTemperatureMin_0: (+1)
   \       0x16                      REQUIRE ?Subroutine1
   \       0x16                      ;; // Fall through to label ?Subroutine1
    181          }
    182          

   \                                 In section .text, align 2, keep-with-next
    183          static uint16_t readColorTemperatureMax(uint8_t endpoint)
    184          {
   \                     readColorTemperatureMax: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
    185            uint16_t colorTemperatureMax;
    186            EmberStatus status;
    187          
    188            status =
    189              emberAfReadServerAttribute(endpoint,
    190                                         ZCL_COLOR_CONTROL_CLUSTER_ID,
    191                                         ZCL_COLOR_CONTROL_COLOR_TEMP_PHYSICAL_MAX_ATTRIBUTE_ID,
    192                                         (uint8_t *)&colorTemperatureMax,
    193                                         sizeof(uint16_t));
    194          
    195            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \        0x2   0x....'....        BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_34: (+1)
   \        0x6   0xF244 0x020C      MOVW     R2,#+16396
   \        0xA   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_4: (+1)
   \        0xE   0xB118             CBZ.N    R0,??readColorTemperatureMax_0
    196              colorTemperatureMax = MAX_TEMPERATURE_VALUE;
   \       0x10   0xF64F 0x60FF      MOVW     R0,#+65279
   \       0x14   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    197            }
    198          
    199            return colorTemperatureMax;
   \                     ??readColorTemperatureMax_0: (+1)
   \       0x18   0x....             B.N      ?Subroutine1
    200          }
    201          
    202          static uint16_t readColorTemperatureCoupleToLevelMin(uint8_t endpoint)
    203          {
    204            uint16_t colorTemperatureCoupleToLevelMin;
    205            EmberStatus status;
    206          
    207            status =
    208              emberAfReadServerAttribute(endpoint,
    209                                         ZCL_COLOR_CONTROL_CLUSTER_ID,
    210                                         ZCL_COLOR_CONTROL_TEMPERATURE_LEVEL_MIN_MIREDS_ATTRIBUTE_ID,
    211                                         (uint8_t *)&colorTemperatureCoupleToLevelMin,
    212                                         sizeof(uint16_t));
    213          
    214            if (status != EMBER_ZCL_STATUS_SUCCESS) {
    215              // Not less than the physical min.
    216              colorTemperatureCoupleToLevelMin = readColorTemperatureMin(endpoint);
    217            }
    218          
    219            return colorTemperatureCoupleToLevelMin;
    220          }
    221          
    222          static uint8_t readLevelControlCurrentLevel(uint8_t endpoint)
    223          {
    224            uint8_t currentLevel;
    225            EmberStatus status;
    226          
    227            status =
    228              emberAfReadServerAttribute(endpoint,
    229                                         ZCL_LEVEL_CONTROL_CLUSTER_ID,
    230                                         ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    231                                         (uint8_t *)&currentLevel,
    232                                         sizeof(uint8_t));
    233          
    234            if (status != EMBER_ZCL_STATUS_SUCCESS) {
    235              currentLevel = 0x7F; // midpoint of range 0x01-0xFE
    236            }
    237          
    238            return currentLevel;
    239          }
    240          

   \                                 In section .text, align 2, keep-with-next
    241          static void writeRemainingTime(uint8_t endpoint, uint16_t remainingTime)
    242          {
   \                     writeRemainingTime: (+1)
   \        0x0   0xB503             PUSH     {R0,R1,LR}
   \        0x2   0xB081             SUB      SP,SP,#+4
    243            assert(EMBER_ZCL_STATUS_SUCCESS
    244                   == emberAfWriteServerAttribute(endpoint,
    245                                                  ZCL_COLOR_CONTROL_CLUSTER_ID,
    246                                                  ZCL_COLOR_CONTROL_REMAINING_TIME_ATTRIBUTE_ID,
    247                                                  (uint8_t *)&remainingTime,
    248                                                  ZCL_INT16U_ATTRIBUTE_TYPE));
   \        0x4   0x2121             MOVS     R1,#+33
   \        0x6   0x9100             STR      R1,[SP, #+0]
   \        0x8   0xAB02             ADD      R3,SP,#+8
   \        0xA   0x2202             MOVS     R2,#+2
   \        0xC   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x10   0xB110             CBZ.N    R0,??CrossCallReturnLabel_27
   \       0x12   0x21F8             MOVS     R1,#+248
   \       0x14   0x....'....        BL       ?Subroutine12
    249          }
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x18   0xBD07             POP      {R0-R2,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0xF44F 0x7140      MOV      R1,#+768
   \        0x4   0x....'....        B.W      emberAfWriteServerAttribute
    250          
    251          static void writeColorMode(uint8_t endpoint, uint8_t colorMode)
    252          {
    253            assert(EMBER_ZCL_STATUS_SUCCESS
    254                   == emberAfWriteServerAttribute(endpoint,
    255                                                  ZCL_COLOR_CONTROL_CLUSTER_ID,
    256                                                  ZCL_COLOR_CONTROL_ENHANCED_COLOR_MODE_ATTRIBUTE_ID,
    257                                                  (uint8_t *)&colorMode,
    258                                                  ZCL_INT8U_ATTRIBUTE_TYPE));
    259          
    260            assert(EMBER_ZCL_STATUS_SUCCESS
    261                   == emberAfWriteServerAttribute(endpoint,
    262                                                  ZCL_COLOR_CONTROL_CLUSTER_ID,
    263                                                  ZCL_COLOR_CONTROL_COLOR_MODE_ATTRIBUTE_ID,
    264                                                  (uint8_t *)&colorMode,
    265                                                  ZCL_INT8U_ATTRIBUTE_TYPE));
    266          }
    267          
    268          static void writeHue(uint8_t endpoint, uint8_t hue)
    269          {
    270            assert(EMBER_ZCL_STATUS_SUCCESS
    271                   == emberAfWriteServerAttribute(endpoint,
    272                                                  ZCL_COLOR_CONTROL_CLUSTER_ID,
    273                                                  ZCL_COLOR_CONTROL_CURRENT_HUE_ATTRIBUTE_ID,
    274                                                  (uint8_t *)&hue,
    275                                                  ZCL_INT8U_ATTRIBUTE_TYPE));
    276          }
    277          
    278          static void writeSaturation(uint8_t endpoint, uint8_t saturation)
    279          {
    280            assert(EMBER_ZCL_STATUS_SUCCESS
    281                   == emberAfWriteServerAttribute(endpoint,
    282                                                  ZCL_COLOR_CONTROL_CLUSTER_ID,
    283                                                  ZCL_COLOR_CONTROL_CURRENT_SATURATION_ATTRIBUTE_ID,
    284                                                  (uint8_t *)&saturation,
    285                                                  ZCL_INT8U_ATTRIBUTE_TYPE));
    286          }
    287          
    288          static void writeColorX(uint8_t endpoint, uint16_t colorX)
    289          {
    290            assert(EMBER_ZCL_STATUS_SUCCESS
    291                   == emberAfWriteServerAttribute(endpoint,
    292                                                  ZCL_COLOR_CONTROL_CLUSTER_ID,
    293                                                  ZCL_COLOR_CONTROL_CURRENT_X_ATTRIBUTE_ID,
    294                                                  (uint8_t *)&colorX,
    295                                                  ZCL_INT16U_ATTRIBUTE_TYPE));
    296          }
    297          
    298          static void writeColorY(uint8_t endpoint, uint16_t colorY)
    299          {
    300            assert(EMBER_ZCL_STATUS_SUCCESS
    301                   == emberAfWriteServerAttribute(endpoint,
    302                                                  ZCL_COLOR_CONTROL_CLUSTER_ID,
    303                                                  ZCL_COLOR_CONTROL_CURRENT_Y_ATTRIBUTE_ID,
    304                                                  (uint8_t *)&colorY,
    305                                                  ZCL_INT16U_ATTRIBUTE_TYPE));
    306          }
    307          
    308          static void writeColorTemperature(uint8_t endpoint, uint16_t colorTemperature)
    309          {
    310            assert(EMBER_ZCL_STATUS_SUCCESS
    311                   == emberAfWriteServerAttribute(endpoint,
    312                                                  ZCL_COLOR_CONTROL_CLUSTER_ID,
    313                                                  ZCL_COLOR_CONTROL_COLOR_TEMPERATURE_ATTRIBUTE_ID,
    314                                                  (uint8_t *)&colorTemperature,
    315                                                  ZCL_INT16U_ATTRIBUTE_TYPE));
    316          }
    317          
    318          // -------------------------------------------------------------------------
    319          // ****** callback section *******
    320          
    321          #ifdef EMBER_AF_PLUGIN_COLOR_CONTROL_SERVER_HSV
    322          /** @brief Move To Hue And Saturation
    323           *
    324           *
    325           *
    326           * @param hue   Ver.: always
    327           * @param saturation   Ver.: always
    328           * @param transitionTime   Ver.: always
    329           */

   \                                 In section .text, align 2, keep-with-next
    330          bool emberAfColorControlClusterMoveToHueAndSaturationCallback(uint8_t hue,
    331                                                                        uint8_t saturation,
    332                                                                        uint16_t transitionTime,
    333                                                                        uint8_t optionsMask,
    334                                                                        uint8_t optionsOverride)
    335          {
   \                     emberAfColorControlClusterMoveToHueAndSaturationCallback: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x4688             MOV      R8,R1
    336            uint8_t endpoint = emberAfCurrentEndpoint();
   \        0x8   0x....'....        LDR.W    R0,??DataTable27
   \        0xC   0x6801             LDR      R1,[R0, #+0]
   \        0xE   0x4614             MOV      R4,R2
   \       0x10   0x461D             MOV      R5,R3
   \       0x12   0x680A             LDR      R2,[R1, #+0]
   \       0x14   0xF892 0x9005      LDRB     R9,[R2, #+5]
    337            uint8_t currentHue = readHue(endpoint);
   \       0x18   0x4648             MOV      R0,R9
   \       0x1A   0x....'....        BL       readHue
   \       0x1E   0x4606             MOV      R6,R0
    338            bool moveUp;
    339          
    340            if (transitionTime == 0) {
   \       0x20   0x0020             MOVS     R0,R4
   \       0x22   0xBF08             IT       EQ 
   \       0x24   0x2401             MOVEQ    R4,#+1
    341              transitionTime++;
    342            }
    343          
    344            // limit checking:  hue and saturation are 0..254.  Spec dictates we ignore
    345            // this and report a malformed packet.
    346            if (hue > MAX_HUE_VALUE || saturation > MAX_SATURATION_VALUE) {
   \       0x26   0x2FFF             CMP      R7,#+255
   \       0x28   0xBF14             ITE      NE 
   \       0x2A   0xF1B8 0x0FFF      CMPNE    R8,#+255
   \       0x2E   0x2080             MOVEQ    R0,#+128
    347              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_MALFORMED_COMMAND);
   \       0x30   0xD042             BEQ.N    ??emberAfColorControlClusterMoveToHueAndSaturat_0
   \       0x32   0x9A08             LDR      R2,[SP, #+32]
    348              return true;
    349            }
    350          
    351            if (!shouldExecuteIfOff(endpoint, optionsMask, optionsOverride)) {
   \       0x34   0x4629             MOV      R1,R5
   \       0x36   0x4648             MOV      R0,R9
   \       0x38   0x....'....        BL       shouldExecuteIfOff
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xD03B             BEQ.N    ??emberAfColorControlClusterMoveToHueAndSaturat_0
    352              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
    353              return true;
    354            }
    355          
    356            // compute shortest direction
    357            if (hue > currentHue) {
   \       0x40   0x42BE             CMP      R6,R7
   \       0x42   0xDA03             BGE.N    ??emberAfColorControlClusterMoveToHueAndSaturat_1
    358              moveUp = (hue - currentHue) < HALF_MAX_UINT8T;
   \       0x44   0x1BB8             SUBS     R0,R7,R6
   \       0x46   0x287F             CMP      R0,#+127
   \       0x48   0xDA05             BGE.N    ??emberAfColorControlClusterMoveToHueAndSaturat_2
   \       0x4A   0xE002             B.N      ??emberAfColorControlClusterMoveToHueAndSaturat_3
    359            } else {
    360              moveUp = (currentHue - hue) > HALF_MAX_UINT8T;
   \                     ??emberAfColorControlClusterMoveToHueAndSaturat_1: (+1)
   \       0x4C   0x1BF0             SUBS     R0,R6,R7
   \       0x4E   0x287F             CMP      R0,#+127
   \       0x50   0xDD01             BLE.N    ??emberAfColorControlClusterMoveToHueAndSaturat_2
   \                     ??emberAfColorControlClusterMoveToHueAndSaturat_3: (+1)
   \       0x52   0x2501             MOVS     R5,#+1
   \       0x54   0xE000             B.N      ??emberAfColorControlClusterMoveToHueAndSaturat_4
   \                     ??emberAfColorControlClusterMoveToHueAndSaturat_2: (+1)
   \       0x56   0x2500             MOVS     R5,#+0
    361            }
    362          
    363            // New command.  Need to stop any active transitions.
    364            stopAllColorTransitions();
   \                     ??emberAfColorControlClusterMoveToHueAndSaturat_4: (+1)
   \       0x58   0x....'....        BL       stopAllColorTransitions
    365          
    366            // Handle color mode transition, if necessary.
    367            handleModeSwitch(endpoint, COLOR_MODE_HSV);
   \       0x5C   0x2100             MOVS     R1,#+0
   \       0x5E   0x4648             MOV      R0,R9
   \       0x60   0x....'....        BL       handleModeSwitch
    368          
    369            // now, kick off the state machine.
    370            initHueSat(endpoint);
   \       0x64   0x4648             MOV      R0,R9
   \       0x66   0x....'....        BL       initHueSat
    371          
    372            colorHueTransitionState.initialHue = currentHue;
   \       0x6A   0x....'....        LDR.W    R0,??DataTable27_1
   \       0x6E   0x7006             STRB     R6,[R0, #+0]
    373            colorHueTransitionState.currentHue = currentHue;
   \       0x70   0x7046             STRB     R6,[R0, #+1]
    374            colorHueTransitionState.finalHue   = hue;
   \       0x72   0x7087             STRB     R7,[R0, #+2]
    375            colorHueTransitionState.stepsRemaining = transitionTime;
   \       0x74   0x8084             STRH     R4,[R0, #+4]
    376            colorHueTransitionState.stepsTotal     = transitionTime;
   \       0x76   0x80C4             STRH     R4,[R0, #+6]
    377            colorHueTransitionState.endpoint = endpoint;
   \       0x78   0xF880 0x9008      STRB     R9,[R0, #+8]
    378            colorHueTransitionState.up = moveUp;
   \       0x7C   0x7245             STRB     R5,[R0, #+9]
    379            colorHueTransitionState.repeat = false;
   \       0x7E   0x2100             MOVS     R1,#+0
   \       0x80   0x7281             STRB     R1,[R0, #+10]
    380          
    381            colorSaturationTransitionState.initialValue = readSaturation(endpoint);
   \       0x82   0x4648             MOV      R0,R9
   \       0x84   0x....'....        LDR.W    R6,??DataTable27_2
   \       0x88   0x....'....        BL       readSaturation
   \       0x8C   0x8030             STRH     R0,[R6, #+0]
    382            colorSaturationTransitionState.currentValue = readSaturation(endpoint);
   \       0x8E   0x4648             MOV      R0,R9
   \       0x90   0x....'....        BL       readSaturation
   \       0x94   0x8070             STRH     R0,[R6, #+2]
    383            colorSaturationTransitionState.finalValue = saturation;
    384            colorSaturationTransitionState.stepsRemaining = transitionTime;
    385            colorSaturationTransitionState.stepsTotal     = transitionTime;
    386            colorSaturationTransitionState.endpoint       = endpoint;
    387            colorSaturationTransitionState.lowLimit  = MIN_SATURATION_VALUE;
   \       0x96   0x2000             MOVS     R0,#+0
    388            colorSaturationTransitionState.highLimit = MAX_SATURATION_VALUE;
   \       0x98   0x21FE             MOVS     R1,#+254
   \       0x9A   0x8170             STRH     R0,[R6, #+10]
   \       0x9C   0x81B1             STRH     R1,[R6, #+12]
   \       0x9E   0xF8A6 0x8004      STRH     R8,[R6, #+4]
   \       0xA2   0x80F4             STRH     R4,[R6, #+6]
   \       0xA4   0x8134             STRH     R4,[R6, #+8]
   \       0xA6   0xF886 0x900E      STRB     R9,[R6, #+14]
    389          
    390            writeRemainingTime(endpoint, transitionTime);
   \       0xAA   0x4621             MOV      R1,R4
   \       0xAC   0x4648             MOV      R0,R9
   \       0xAE   0x....'....        BL       writeRemainingTime
    391          
    392            // kick off the state machine:
    393            emberEventControlSetDelayMS(COLOR_HSV_CONTROL, UPDATE_TIME_MS);
   \       0xB2   0x....'....        BL       ?Subroutine21
    394          
    395            emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   \                     ??CrossCallReturnLabel_67: (+1)
   \       0xB6   0x2000             MOVS     R0,#+0
   \                     ??emberAfColorControlClusterMoveToHueAndSaturat_0: (+1)
   \       0xB8                      REQUIRE ?Subroutine2
   \       0xB8                      ;; // Fall through to label ?Subroutine2
    396            return true;
    397          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x....'....        BL       emberAfSendImmediateDefaultResponse
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine21: (+1)
   \        0x0   0x2164             MOVS     R1,#+100
   \        0x2   0x....'....        LDR.W    R0,??DataTable27_3
   \        0x6   0x....'....        B.W      emEventControlSetDelayMS
    398          

   \                                 In section .text, align 2, keep-with-next
    399          bool emberAfColorControlClusterMoveHueCallback(uint8_t moveMode,
    400                                                         uint8_t rate,
    401                                                         uint8_t optionsMask,
    402                                                         uint8_t optionsOverride)
    403          {
   \                     emberAfColorControlClusterMoveHueCallback: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4606             MOV      R6,R0
    404            uint8_t endpoint = emberAfCurrentEndpoint();
   \        0x4   0x....'....        BL       ??Subroutine18_0
   \                     ??CrossCallReturnLabel_49: (+1)
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4611             MOV      R1,R2
   \        0xC   0x6827             LDR      R7,[R4, #+0]
    405          
    406            if (!shouldExecuteIfOff(endpoint, optionsMask, optionsOverride)) {
   \        0xE   0x461A             MOV      R2,R3
   \       0x10   0x797C             LDRB     R4,[R7, #+5]
   \       0x12   0x....'....        BL       ??Subroutine20_0
   \                     ??CrossCallReturnLabel_57: (+1)
   \       0x16   0xB118             CBZ.N    R0,??emberAfColorControlClusterMoveHueCallback_0
    407              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
    408              return true;
    409            }
    410          
    411            // New command.  Need to stop any active transitions.
    412            stopAllColorTransitions();
   \       0x18   0x....'....        BL       stopAllColorTransitions
    413          
    414            if (moveMode == EMBER_ZCL_HUE_MOVE_MODE_STOP) {
   \       0x1C   0x0030             MOVS     R0,R6
   \       0x1E   0xD101             BNE.N    ??emberAfColorControlClusterMoveHueCallback_1
    415              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   \                     ??emberAfColorControlClusterMoveHueCallback_0: (+1)
   \       0x20   0x2000             MOVS     R0,#+0
    416              return true;
    417            }
   \                     ??emberAfColorControlClusterMoveHueCallback_2: (+1)
   \       0x22   0x....             B.N      ?Subroutine3
    418          
    419            // Handle color mode transition, if necessary.
    420            handleModeSwitch(endpoint, COLOR_MODE_HSV);
   \                     ??emberAfColorControlClusterMoveHueCallback_1: (+1)
   \       0x24   0x....'....        BL       ?Subroutine24
    421          
    422            // now, kick off the state machine.
    423            initHueSat(endpoint);
   \                     ??CrossCallReturnLabel_79: (+1)
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x....'....        BL       initHueSat
    424          
    425            colorHueTransitionState.initialHue = readHue(endpoint);
   \       0x2E   0x4620             MOV      R0,R4
   \       0x30   0x....'....        LDR.W    R7,??DataTable27_1
   \       0x34   0x....'....        BL       readHue
   \       0x38   0x7038             STRB     R0,[R7, #+0]
    426            colorHueTransitionState.currentHue = readHue(endpoint);
   \       0x3A   0x....'....        BL       ?Subroutine19
   \                     ??CrossCallReturnLabel_54: (+1)
   \       0x3E   0x7078             STRB     R0,[R7, #+1]
    427            if (moveMode == EMBER_ZCL_HUE_MOVE_MODE_UP) {
   \       0x40   0x2E01             CMP      R6,#+1
   \       0x42   0xD118             BNE.N    ??emberAfColorControlClusterMoveHueCallback_3
    428              colorHueTransitionState.finalHue = addHue(readHue(endpoint),
    429                                                        rate);
   \       0x44   0x....'....        BL       ?Subroutine19
   \                     ??CrossCallReturnLabel_53: (+1)
   \       0x48   0x4629             MOV      R1,R5
   \       0x4A   0x....'....        BL       addHue
    430              colorHueTransitionState.up = true;
   \       0x4E   0x2101             MOVS     R1,#+1
   \                     ??emberAfColorControlClusterMoveHueCallback_4: (+1)
   \       0x50   0x70B8             STRB     R0,[R7, #+2]
    431            } else if (moveMode == EMBER_ZCL_HUE_MOVE_MODE_DOWN) {
    432              colorHueTransitionState.finalHue = subtractHue(readHue(endpoint),
    433                                                             rate);
    434              colorHueTransitionState.up = false;
    435            } else {
    436              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_MALFORMED_COMMAND);
    437              return true;
    438            }
    439            colorHueTransitionState.stepsRemaining = TRANSITION_TIME_1S;
   \       0x52   0x200A             MOVS     R0,#+10
   \       0x54   0x80B8             STRH     R0,[R7, #+4]
    440            colorHueTransitionState.stepsTotal     = TRANSITION_TIME_1S;
   \       0x56   0x80F8             STRH     R0,[R7, #+6]
    441            colorHueTransitionState.endpoint = endpoint;
    442            colorHueTransitionState.repeat = true;
   \       0x58   0x2001             MOVS     R0,#+1
   \       0x5A   0x7279             STRB     R1,[R7, #+9]
   \       0x5C   0x72B8             STRB     R0,[R7, #+10]
   \       0x5E   0x723C             STRB     R4,[R7, #+8]
    443            // hue movement can last forever.  Indicate this with a remaining time of
    444            // maxint.
    445            writeRemainingTime(endpoint, MAX_INT16U_VALUE);
   \       0x60   0xF64F 0x71FF      MOVW     R1,#+65535
   \       0x64   0x....'....        BL       ?Subroutine25
    446          
    447            colorSaturationTransitionState.stepsRemaining = 0;
   \                     ??CrossCallReturnLabel_84: (+1)
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0x....'....        LDR.W    R1,??DataTable27_2
   \       0x6E   0x80C8             STRH     R0,[R1, #+6]
    448          
    449            // kick off the state machine:
    450            emberEventControlSetDelayMS(COLOR_HSV_CONTROL, UPDATE_TIME_MS);
   \       0x70   0x....'....        BL       ?Subroutine21
   \                     ??CrossCallReturnLabel_66: (+1)
   \       0x74   0xE7D4             B.N      ??emberAfColorControlClusterMoveHueCallback_0
   \                     ??emberAfColorControlClusterMoveHueCallback_3: (+1)
   \       0x76   0x2E03             CMP      R6,#+3
   \       0x78   0xD106             BNE.N    ??emberAfColorControlClusterMoveHueCallback_5
   \       0x7A   0x....'....        BL       ?Subroutine19
   \                     ??CrossCallReturnLabel_52: (+1)
   \       0x7E   0x4629             MOV      R1,R5
   \       0x80   0x....'....        BL       subtractHue
   \       0x84   0x2100             MOVS     R1,#+0
   \       0x86   0xE7E3             B.N      ??emberAfColorControlClusterMoveHueCallback_4
   \                     ??emberAfColorControlClusterMoveHueCallback_5: (+1)
   \       0x88   0x2080             MOVS     R0,#+128
   \       0x8A   0xE7CA             B.N      ??emberAfColorControlClusterMoveHueCallback_2
    451          
    452            emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
    453            return true;
    454          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x....'....        BL       emberAfSendImmediateDefaultResponse
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0xBDF2             POP      {R1,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine19: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0x....             B.N      readHue

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine25: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0x....             B.N      writeRemainingTime

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine18: (+1)
   \        0x0   0x4607             MOV      R7,R0
   \                     ??Subroutine18_0: (+1)
   \        0x2   0x....'....        LDR.W    R0,??DataTable27
   \        0x6   0x6804             LDR      R4,[R0, #+0]
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine24: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \                     ??Subroutine24_0: (+1)
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x....             B.N      handleModeSwitch

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine20: (+1)
   \        0x0   0x4619             MOV      R1,R3
   \        0x2   0x7944             LDRB     R4,[R0, #+5]
   \                     ??Subroutine20_0: (+1)
   \        0x4   0x4620             MOV      R0,R4
   \        0x6   0x....             B.N      shouldExecuteIfOff
    455          

   \                                 In section .text, align 2, keep-with-next
    456          bool emberAfColorControlClusterMoveSaturationCallback(uint8_t moveMode,
    457                                                                uint8_t rate,
    458                                                                uint8_t optionsMask,
    459                                                                uint8_t optionsOverride)
    460          {
   \                     emberAfColorControlClusterMoveSaturationCallback: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
    461            uint8_t endpoint = emberAfCurrentEndpoint();
   \        0x4   0x....'....        LDR.W    R0,??DataTable27
   \        0x8   0x6806             LDR      R6,[R0, #+0]
   \        0xA   0x460C             MOV      R4,R1
   \        0xC   0x4611             MOV      R1,R2
   \        0xE   0x6837             LDR      R7,[R6, #+0]
    462          
    463            if (!shouldExecuteIfOff(endpoint, optionsMask, optionsOverride)) {
   \       0x10   0x461A             MOV      R2,R3
   \       0x12   0x797E             LDRB     R6,[R7, #+5]
   \       0x14   0x4630             MOV      R0,R6
   \       0x16   0x....'....        BL       shouldExecuteIfOff
   \       0x1A   0xB128             CBZ.N    R0,??emberAfColorControlClusterMoveSaturationCallb_0
    464              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
    465              return true;
    466            }
    467          
    468            uint16_t transitionTime;
    469          
    470            // New command.  Need to stop any active transitions.
    471            stopAllColorTransitions();
   \       0x1C   0x....'....        BL       stopAllColorTransitions
    472          
    473            if (moveMode == EMBER_ZCL_SATURATION_MOVE_MODE_STOP
    474                || rate == 0) {
   \       0x20   0x0028             MOVS     R0,R5
   \       0x22   0xD001             BEQ.N    ??emberAfColorControlClusterMoveSaturationCallb_0
   \       0x24   0x0020             MOVS     R0,R4
   \       0x26   0xD101             BNE.N    ??emberAfColorControlClusterMoveSaturationCallb_1
    475              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   \                     ??emberAfColorControlClusterMoveSaturationCallb_0: (+1)
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x....             B.N      ?Subroutine3
    476              return true;
    477            }
    478          
    479            // Handle color mode transition, if necessary.
    480            handleModeSwitch(endpoint, COLOR_MODE_HSV);
   \                     ??emberAfColorControlClusterMoveSaturationCallb_1: (+1)
   \       0x2C   0x....'....        BL       ?Subroutine26
    481          
    482            // now, kick off the state machine.
    483            initHueSat(endpoint);
   \                     ??CrossCallReturnLabel_87: (+1)
   \       0x30   0x4630             MOV      R0,R6
   \       0x32   0x....'....        BL       initHueSat
    484          
    485            colorHueTransitionState.stepsRemaining = 0;
   \       0x36   0x....'....        BL       ?Subroutine13
    486          
    487            colorSaturationTransitionState.initialValue = readSaturation(endpoint);
   \                     ??CrossCallReturnLabel_31: (+1)
   \       0x3A   0x8038             STRH     R0,[R7, #+0]
    488            colorSaturationTransitionState.currentValue = readSaturation(endpoint);
   \       0x3C   0x4630             MOV      R0,R6
   \       0x3E   0x....'....        BL       readSaturation
    489            if (moveMode == EMBER_ZCL_SATURATION_MOVE_MODE_UP) {
   \       0x42   0x2D01             CMP      R5,#+1
   \       0x44   0x8078             STRH     R0,[R7, #+2]
    490              colorSaturationTransitionState.finalValue = MAX_SATURATION_VALUE;
    491            } else {
    492              colorSaturationTransitionState.finalValue = MIN_SATURATION_VALUE;
    493            }
    494          
    495            transitionTime =
    496              computeTransitionTimeFromStateAndRate(&colorSaturationTransitionState,
    497                                                    rate);
   \       0x46   0x4621             MOV      R1,R4
   \       0x48   0xBF0C             ITE      EQ 
   \       0x4A   0x20FE             MOVEQ    R0,#+254
   \       0x4C   0x2000             MOVNE    R0,#+0
   \       0x4E   0x80B8             STRH     R0,[R7, #+4]
   \       0x50   0x4638             MOV      R0,R7
   \       0x52   0x....'....        BL       computeTransitionTimeFromStateAndRate
    498          
    499            colorSaturationTransitionState.stepsRemaining = transitionTime;
    500            colorSaturationTransitionState.stepsTotal     = transitionTime;
    501            colorSaturationTransitionState.endpoint       = endpoint;
    502            colorSaturationTransitionState.lowLimit  = MIN_SATURATION_VALUE;
   \       0x56   0x2100             MOVS     R1,#+0
   \       0x58   0x8179             STRH     R1,[R7, #+10]
   \       0x5A   0x80F8             STRH     R0,[R7, #+6]
   \       0x5C   0x8138             STRH     R0,[R7, #+8]
    503            colorSaturationTransitionState.highLimit = MAX_SATURATION_VALUE;
   \       0x5E   0x22FE             MOVS     R2,#+254
    504          
    505            writeRemainingTime(endpoint, transitionTime);
   \       0x60   0x4601             MOV      R1,R0
   \       0x62   0x73BE             STRB     R6,[R7, #+14]
   \       0x64   0x81BA             STRH     R2,[R7, #+12]
   \       0x66   0x4630             MOV      R0,R6
   \       0x68   0x....'....        BL       writeRemainingTime
    506          
    507            // kick off the state machine:
    508            emberEventControlSetDelayMS(COLOR_HSV_CONTROL, UPDATE_TIME_MS);
   \       0x6C   0x....'....        BL       ?Subroutine21
   \                     ??CrossCallReturnLabel_65: (+1)
   \       0x70   0xE7DA             B.N      ??emberAfColorControlClusterMoveSaturationCallb_0
    509          
    510            emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
    511            return true;
    512          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine26: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \                     ??Subroutine26_0: (+1)
   \        0x2   0x4630             MOV      R0,R6
   \        0x4   0x....             B.N      handleModeSwitch

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x....'....        LDR.W    R1,??DataTable27_1
   \        0x6   0x8088             STRH     R0,[R1, #+4]
   \        0x8   0x4630             MOV      R0,R6
   \        0xA   0x....'....        LDR.W    R7,??DataTable27_2
   \        0xE   0x....             B.N      readSaturation
    513          

   \                                 In section .text, align 4, keep-with-next
    514          bool emberAfColorControlClusterMoveToHueCallback(uint8_t hue,
    515                                                           uint8_t hueMoveMode,
    516                                                           uint16_t transitionTime,
    517                                                           uint8_t optionsMask,
    518                                                           uint8_t optionsOverride)
    519          {
   \                     emberAfColorControlClusterMoveToHueCallback: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
    520            uint8_t endpoint = emberAfCurrentEndpoint();
   \        0x6   0x....'....        LDR.W    R0,??DataTable27
   \        0xA   0x6800             LDR      R0,[R0, #+0]
   \        0xC   0x4615             MOV      R5,R2
   \        0xE   0x9A06             LDR      R2,[SP, #+24]
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0x460F             MOV      R7,R1
    521          
    522            if (!shouldExecuteIfOff(endpoint, optionsMask, optionsOverride)) {
   \       0x14   0x4619             MOV      R1,R3
   \       0x16   0xF890 0x8005      LDRB     R8,[R0, #+5]
   \       0x1A   0x4640             MOV      R0,R8
   \       0x1C   0x....'....        BL       shouldExecuteIfOff
   \       0x20   0x2800             CMP      R0,#+0
   \       0x22   0xD042             BEQ.N    ??emberAfColorControlClusterMoveToHueCallback_1
    523              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
    524              return true;
    525            }
    526          
    527            uint8_t currentHue = readHue(endpoint);
   \       0x24   0x4640             MOV      R0,R8
   \       0x26   0x....'....        BL       readHue
    528            uint8_t direction;
    529          
    530            if (transitionTime == 0) {
   \       0x2A   0x0029             MOVS     R1,R5
   \       0x2C   0xBF08             IT       EQ 
   \       0x2E   0x2501             MOVEQ    R5,#+1
    531              transitionTime++;
    532            }
    533          
    534            // limit checking:  hue and saturation are 0..254.  Spec dictates we ignore
    535            // this and report a malformed packet.
    536            if (hue > MAX_HUE_VALUE) {
   \       0x30   0x2EFF             CMP      R6,#+255
   \       0x32   0xD02B             BEQ.N    ??emberAfColorControlClusterMoveToHueCallback_2
    537              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_MALFORMED_COMMAND);
    538              return true;
    539            }
    540          
    541            // For move to hue, the move modes are different from the other move commands.
    542            // Need to translate from the move to hue transitions to the internal
    543            // representation.
    544            switch (hueMoveMode) {
   \       0x34   0x1B80             SUBS     R0,R0,R6
   \       0x36   0xB2C0             UXTB     R0,R0
   \       0x38   0x2F03             CMP      R7,#+3
   \       0x3A   0xD827             BHI.N    ??emberAfColorControlClusterMoveToHueCallback_2
   \       0x3C   0xE8DF 0xF007      TBB      [PC, R7]
   \                     ??emberAfColorControlClusterMoveToHueCallback_0:
   \       0x40   0x02 0x06          DC8      0x2,0x6,0x8,0x4
   \              0x08 0x04    
    545              case EMBER_ZCL_HUE_DIRECTION_SHORTEST_DISTANCE:
    546                if ( ((uint8_t) (currentHue - hue)) > HALF_MAX_UINT8T ) {
   \                     ??emberAfColorControlClusterMoveToHueCallback_3: (+1)
   \       0x44   0x2880             CMP      R0,#+128
   \       0x46   0xDA03             BGE.N    ??emberAfColorControlClusterMoveToHueCallback_4
    547                  direction = MOVE_MODE_UP;
    548                } else {
    549                  direction = MOVE_MODE_DOWN;
    550                }
    551                break;
    552              case EMBER_ZCL_HUE_DIRECTION_LONGEST_DISTANCE:
    553                if ( ((uint8_t) (currentHue - hue)) > HALF_MAX_UINT8T ) {
    554                  direction = MOVE_MODE_DOWN;
    555                } else {
    556                  direction = MOVE_MODE_UP;
    557                }
    558                break;
    559                break;
    560              case EMBER_ZCL_HUE_DIRECTION_UP:
    561                direction = MOVE_MODE_UP;
    562                break;
    563              case EMBER_ZCL_HUE_DIRECTION_DOWN:
    564                direction = MOVE_MODE_DOWN;
   \                     ??emberAfColorControlClusterMoveToHueCallback_5: (+1)
   \       0x48   0x2703             MOVS     R7,#+3
    565                break;
   \       0x4A   0xE002             B.N      ??emberAfColorControlClusterMoveToHueCallback_6
   \                     ??emberAfColorControlClusterMoveToHueCallback_7: (+1)
   \       0x4C   0x2880             CMP      R0,#+128
   \       0x4E   0xDAFB             BGE.N    ??emberAfColorControlClusterMoveToHueCallback_5
   \                     ??emberAfColorControlClusterMoveToHueCallback_4: (+1)
   \       0x50   0x2701             MOVS     R7,#+1
    566              default:
    567                emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_MALFORMED_COMMAND);
    568                return true;
    569            }
    570          
    571            // New command.  Need to stop any active transitions.
    572            stopAllColorTransitions();
   \                     ??emberAfColorControlClusterMoveToHueCallback_6: (+1)
   \       0x52   0x....'....        BL       stopAllColorTransitions
    573          
    574            // Handle color mode transition, if necessary.
    575            handleModeSwitch(endpoint, COLOR_MODE_HSV);
   \       0x56   0x2100             MOVS     R1,#+0
   \       0x58   0x4640             MOV      R0,R8
   \       0x5A   0x....'....        BL       handleModeSwitch
    576          
    577            // now, kick off the state machine.
    578            initHueSat(endpoint);
   \       0x5E   0x4640             MOV      R0,R8
   \       0x60   0x....'....        BL       initHueSat
    579          
    580            colorHueTransitionState.initialHue = readHue(endpoint);
   \       0x64   0x4640             MOV      R0,R8
   \       0x66   0x....'....        LDR.W    R4,??DataTable27_1
   \       0x6A   0x....'....        BL       readHue
   \       0x6E   0x7020             STRB     R0,[R4, #+0]
    581            colorHueTransitionState.currentHue = readHue(endpoint);
   \       0x70   0x4640             MOV      R0,R8
   \       0x72   0x....'....        BL       readHue
   \       0x76   0x7060             STRB     R0,[R4, #+1]
    582            colorHueTransitionState.finalHue   = hue;
   \       0x78   0x70A6             STRB     R6,[R4, #+2]
    583            colorHueTransitionState.stepsRemaining = transitionTime;
    584            colorHueTransitionState.stepsTotal     = transitionTime;
    585            colorHueTransitionState.endpoint = endpoint;
    586            colorHueTransitionState.up = (direction == MOVE_MODE_UP);
   \       0x7A   0x2F01             CMP      R7,#+1
   \       0x7C   0x80A5             STRH     R5,[R4, #+4]
   \       0x7E   0x80E5             STRH     R5,[R4, #+6]
   \       0x80   0xF884 0x8008      STRB     R8,[R4, #+8]
   \       0x84   0xBF0C             ITE      EQ 
   \       0x86   0x2001             MOVEQ    R0,#+1
   \       0x88   0x2000             MOVNE    R0,#+0
   \       0x8A   0xE001             B.N      ??emberAfColorControlClusterMoveToHueCallback_8
   \                     ??emberAfColorControlClusterMoveToHueCallback_2: (+1)
   \       0x8C   0x2080             MOVS     R0,#+128
   \       0x8E   0xE00C             B.N      ??emberAfColorControlClusterMoveToHueCallback_1
   \                     ??emberAfColorControlClusterMoveToHueCallback_8: (+1)
   \       0x90   0x7260             STRB     R0,[R4, #+9]
    587            colorHueTransitionState.repeat = false;
   \       0x92   0x2000             MOVS     R0,#+0
   \       0x94   0x72A0             STRB     R0,[R4, #+10]
    588          
    589            colorSaturationTransitionState.stepsRemaining = 0;
   \       0x96   0x....'....        LDR.W    R2,??DataTable27_2
   \       0x9A   0x80D0             STRH     R0,[R2, #+6]
    590          
    591            writeRemainingTime(endpoint, transitionTime);
   \       0x9C   0x4629             MOV      R1,R5
   \       0x9E   0x4640             MOV      R0,R8
   \       0xA0   0x....'....        BL       writeRemainingTime
    592          
    593            // kick off the state machine:
    594            emberEventControlSetDelayMS(COLOR_HSV_CONTROL, UPDATE_TIME_MS);
   \       0xA4   0x....'....        BL       ?Subroutine21
    595          
    596            emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   \                     ??CrossCallReturnLabel_64: (+1)
   \       0xA8   0x2000             MOVS     R0,#+0
   \                     ??emberAfColorControlClusterMoveToHueCallback_1: (+1)
   \       0xAA   0x....             B.N      ??Subroutine4_0
    597            return true;
    598          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \                     ??Subroutine4_0: (+1)
   \        0x2   0x....'....        BL       emberAfSendImmediateDefaultResponse
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    599          

   \                                 In section .text, align 2, keep-with-next
    600          bool emberAfColorControlClusterMoveToSaturationCallback(uint8_t saturation,
    601                                                                  uint16_t transitionTime,
    602                                                                  uint8_t optionsMask,
    603                                                                  uint8_t optionsOverride)
    604          {
   \                     emberAfColorControlClusterMoveToSaturationCallback: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x....'....        BL       ?Subroutine17
    605            uint8_t endpoint = emberAfCurrentEndpoint();
    606          
    607            if (!shouldExecuteIfOff(endpoint, optionsMask, optionsOverride)) {
   \                     ??CrossCallReturnLabel_46: (+1)
   \        0x6   0xB318             CBZ.N    R0,??emberAfColorControlClusterMoveToSaturationCal_0
    608              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
    609              return true;
    610            }
    611          
    612            if (transitionTime == 0) {
   \        0x8   0x0028             MOVS     R0,R5
   \        0xA   0xBF08             IT       EQ 
   \        0xC   0x2501             MOVEQ    R5,#+1
    613              transitionTime++;
    614            }
    615          
    616            // limit checking:  hue and saturation are 0..254.  Spec dictates we ignore
    617            // this and report a malformed packet.
    618            if (saturation > MAX_SATURATION_VALUE) {
   \        0xE   0x2CFF             CMP      R4,#+255
   \       0x10   0xBF08             IT       EQ 
   \       0x12   0x2080             MOVEQ    R0,#+128
    619              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_MALFORMED_COMMAND);
   \       0x14   0xD01C             BEQ.N    ??emberAfColorControlClusterMoveToSaturationCal_0
    620              return true;
    621            }
    622          
    623            // New command.  Need to stop any active transitions.
    624            stopAllColorTransitions();
   \       0x16   0x....'....        BL       stopAllColorTransitions
    625          
    626            // Handle color mode transition, if necessary.
    627            handleModeSwitch(endpoint, COLOR_MODE_HSV);
   \       0x1A   0x....'....        BL       ?Subroutine26
    628          
    629            // now, kick off the state machine.
    630            initHueSat(endpoint);
   \                     ??CrossCallReturnLabel_86: (+1)
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0x....'....        BL       initHueSat
    631          
    632            colorHueTransitionState.stepsRemaining = 0;
   \       0x24   0x....'....        BL       ?Subroutine13
    633          
    634            colorSaturationTransitionState.initialValue = readSaturation(endpoint);
   \                     ??CrossCallReturnLabel_30: (+1)
   \       0x28   0x8038             STRH     R0,[R7, #+0]
    635            colorSaturationTransitionState.currentValue = readSaturation(endpoint);
   \       0x2A   0x4630             MOV      R0,R6
   \       0x2C   0x....'....        BL       readSaturation
   \       0x30   0x8078             STRH     R0,[R7, #+2]
    636            colorSaturationTransitionState.finalValue = saturation;
    637            colorSaturationTransitionState.stepsRemaining = transitionTime;
    638            colorSaturationTransitionState.stepsTotal     = transitionTime;
    639            colorSaturationTransitionState.endpoint       = endpoint;
    640            colorSaturationTransitionState.lowLimit  = MIN_SATURATION_VALUE;
   \       0x32   0x2000             MOVS     R0,#+0
    641            colorSaturationTransitionState.highLimit = MAX_SATURATION_VALUE;
   \       0x34   0x21FE             MOVS     R1,#+254
   \       0x36   0x8178             STRH     R0,[R7, #+10]
   \       0x38   0x81B9             STRH     R1,[R7, #+12]
   \       0x3A   0x80BC             STRH     R4,[R7, #+4]
   \       0x3C   0x80FD             STRH     R5,[R7, #+6]
   \       0x3E   0x813D             STRH     R5,[R7, #+8]
   \       0x40   0x73BE             STRB     R6,[R7, #+14]
    642          
    643            writeRemainingTime(endpoint, transitionTime);
   \       0x42   0x4629             MOV      R1,R5
   \       0x44   0x4630             MOV      R0,R6
   \       0x46   0x....'....        BL       writeRemainingTime
    644          
    645            // kick off the state machine:
    646            emberEventControlSetDelayMS(COLOR_HSV_CONTROL, UPDATE_TIME_MS);
   \       0x4A   0x....'....        BL       ?Subroutine21
    647          
    648            emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   \                     ??CrossCallReturnLabel_63: (+1)
   \       0x4E   0x2000             MOVS     R0,#+0
   \                     ??emberAfColorControlClusterMoveToSaturationCal_0: (+1)
   \       0x50                      REQUIRE ?Subroutine3
   \       0x50                      ;; // Fall through to label ?Subroutine3
    649            return true;
    650          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0x....'....        LDR.W    R0,??DataTable27
   \        0x6   0x6806             LDR      R6,[R0, #+0]
   \        0x8   0x460D             MOV      R5,R1
   \        0xA   0x4611             MOV      R1,R2
   \        0xC   0x6837             LDR      R7,[R6, #+0]
   \        0xE   0x461A             MOV      R2,R3
   \       0x10   0x797E             LDRB     R6,[R7, #+5]
   \       0x12   0x4630             MOV      R0,R6
   \       0x14   0x....             B.N      shouldExecuteIfOff
    651          

   \                                 In section .text, align 2, keep-with-next
    652          bool emberAfColorControlClusterStepHueCallback(uint8_t stepMode,
    653                                                         uint8_t stepSize,
    654                                                         uint8_t transitionTime,
    655                                                         uint8_t optionsMask,
    656                                                         uint8_t optionsOverride)
    657          {
   \                     emberAfColorControlClusterStepHueCallback: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4680             MOV      R8,R0
    658            uint8_t endpoint = emberAfCurrentEndpoint();
   \        0x6   0x....'....        BL       ??Subroutine18_0
   \                     ??CrossCallReturnLabel_50: (+1)
   \        0xA   0x4615             MOV      R5,R2
   \        0xC   0x9A08             LDR      R2,[SP, #+32]
   \        0xE   0x6820             LDR      R0,[R4, #+0]
   \       0x10   0x4689             MOV      R9,R1
    659          
    660            if (!shouldExecuteIfOff(endpoint, optionsMask, optionsOverride)) {
   \       0x12   0x....'....        BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_59: (+1)
   \       0x16   0xB150             CBZ.N    R0,??emberAfColorControlClusterStepHueCallback_0
    661              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
    662              return true;
    663            }
    664          
    665            uint8_t currentHue = readHue(endpoint);
   \       0x18   0x....'....        BL       ?Subroutine19
   \                     ??CrossCallReturnLabel_51: (+1)
   \       0x1C   0x4607             MOV      R7,R0
    666          
    667            if (transitionTime == 0) {
   \       0x1E   0x0028             MOVS     R0,R5
   \       0x20   0xBF08             IT       EQ 
   \       0x22   0x2501             MOVEQ    R5,#+1
    668              transitionTime++;
    669            }
    670          
    671            // New command.  Need to stop any active transitions.
    672            stopAllColorTransitions();
   \       0x24   0x....'....        BL       stopAllColorTransitions
    673          
    674            if (stepMode == MOVE_MODE_STOP) {
   \       0x28   0xEA5F 0x0008      MOVS     R0,R8
   \       0x2C   0xD101             BNE.N    ??emberAfColorControlClusterStepHueCallback_1
    675              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   \                     ??emberAfColorControlClusterStepHueCallback_0: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x....             B.N      ?Subroutine2
    676              return true;
    677            }
    678          
    679            // Handle color mode transition, if necessary.
    680            handleModeSwitch(endpoint, COLOR_MODE_HSV);
   \                     ??emberAfColorControlClusterStepHueCallback_1: (+1)
   \       0x32   0x....'....        BL       ?Subroutine24
    681          
    682            // now, kick off the state machine.
    683            initHueSat(endpoint);
   \                     ??CrossCallReturnLabel_78: (+1)
   \       0x36   0x4620             MOV      R0,R4
   \       0x38   0x....'....        BL       initHueSat
    684          
    685            colorHueTransitionState.initialHue = currentHue;
   \       0x3C   0x....'....        LDR.W    R6,??DataTable27_1
   \       0x40   0x7037             STRB     R7,[R6, #+0]
    686            colorHueTransitionState.currentHue = currentHue;
   \       0x42   0x7077             STRB     R7,[R6, #+1]
    687          
    688            if (stepMode == MOVE_MODE_UP) {
   \       0x44   0xF1B8 0x0F01      CMP      R8,#+1
   \       0x48   0x4649             MOV      R1,R9
   \       0x4A   0x4638             MOV      R0,R7
   \       0x4C   0xD103             BNE.N    ??emberAfColorControlClusterStepHueCallback_2
    689              colorHueTransitionState.finalHue = addHue(currentHue, stepSize);
   \       0x4E   0x....'....        BL       addHue
    690              colorHueTransitionState.up = true;
   \       0x52   0x2101             MOVS     R1,#+1
   \       0x54   0xE002             B.N      ??emberAfColorControlClusterStepHueCallback_3
    691            } else {
    692              colorHueTransitionState.finalHue = subtractHue(currentHue, stepSize);
   \                     ??emberAfColorControlClusterStepHueCallback_2: (+1)
   \       0x56   0x....'....        BL       subtractHue
    693              colorHueTransitionState.up = false;
   \       0x5A   0x2100             MOVS     R1,#+0
   \                     ??emberAfColorControlClusterStepHueCallback_3: (+1)
   \       0x5C   0x7271             STRB     R1,[R6, #+9]
   \       0x5E   0x70B0             STRB     R0,[R6, #+2]
    694            }
    695            colorHueTransitionState.stepsRemaining = transitionTime;
   \       0x60   0x80B5             STRH     R5,[R6, #+4]
    696            colorHueTransitionState.stepsTotal     = transitionTime;
   \       0x62   0x80F5             STRH     R5,[R6, #+6]
    697            colorHueTransitionState.endpoint = endpoint;
   \       0x64   0x7234             STRB     R4,[R6, #+8]
    698            colorHueTransitionState.repeat = false;
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x72B0             STRB     R0,[R6, #+10]
    699          
    700            colorSaturationTransitionState.stepsRemaining = 0;
   \       0x6A   0x....'....        LDR.W    R2,??DataTable27_2
   \       0x6E   0x80D0             STRH     R0,[R2, #+6]
    701          
    702            writeRemainingTime(endpoint, transitionTime);
   \       0x70   0x4629             MOV      R1,R5
   \       0x72   0x....'....        BL       ?Subroutine25
    703          
    704            // kick off the state machine:
    705            emberEventControlSetDelayMS(COLOR_HSV_CONTROL, UPDATE_TIME_MS);
   \                     ??CrossCallReturnLabel_83: (+1)
   \       0x76   0x....'....        BL       ?Subroutine21
   \                     ??CrossCallReturnLabel_62: (+1)
   \       0x7A   0xE7D8             B.N      ??emberAfColorControlClusterStepHueCallback_0
    706          
    707            emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
    708            return true;
    709          }
    710          

   \                                 In section .text, align 2, keep-with-next
    711          bool emberAfColorControlClusterStepSaturationCallback(uint8_t stepMode,
    712                                                                uint8_t stepSize,
    713                                                                uint8_t transitionTime,
    714                                                                uint8_t optionsMask,
    715                                                                uint8_t optionsOverride)
    716          {
   \                     emberAfColorControlClusterStepSaturationCallback: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4680             MOV      R8,R0
    717            uint8_t endpoint = emberAfCurrentEndpoint();
   \        0x6   0x....'....        LDR.W    R0,??DataTable27
   \        0xA   0x6807             LDR      R7,[R0, #+0]
   \        0xC   0x4616             MOV      R6,R2
   \        0xE   0x9A06             LDR      R2,[SP, #+24]
   \       0x10   0x6838             LDR      R0,[R7, #+0]
   \       0x12   0x460D             MOV      R5,R1
    718          
    719            if (!shouldExecuteIfOff(endpoint, optionsMask, optionsOverride)) {
   \       0x14   0x4619             MOV      R1,R3
   \       0x16   0x7947             LDRB     R7,[R0, #+5]
   \       0x18   0x4638             MOV      R0,R7
   \       0x1A   0x....'....        BL       shouldExecuteIfOff
   \       0x1E   0xB158             CBZ.N    R0,??emberAfColorControlClusterStepSaturationCallb_0
    720              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
    721              return true;
    722            }
    723          
    724            uint8_t currentSaturation = readSaturation(endpoint);
   \       0x20   0x4638             MOV      R0,R7
   \       0x22   0x....'....        BL       readSaturation
   \       0x26   0x4604             MOV      R4,R0
    725          
    726            if (transitionTime == 0) {
   \       0x28   0x0030             MOVS     R0,R6
   \       0x2A   0xBF08             IT       EQ 
   \       0x2C   0x2601             MOVEQ    R6,#+1
    727              transitionTime++;
    728            }
    729          
    730            // New command.  Need to stop any active transitions.
    731            stopAllColorTransitions();
   \       0x2E   0x....'....        BL       stopAllColorTransitions
    732          
    733            if (stepMode == MOVE_MODE_STOP) {
   \       0x32   0xEA5F 0x0008      MOVS     R0,R8
   \       0x36   0xD100             BNE.N    ??emberAfColorControlClusterStepSaturationCallb_1
    734              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   \                     ??emberAfColorControlClusterStepSaturationCallb_0: (+1)
   \       0x38   0x....             B.N      ?Subroutine4
    735              return true;
    736            }
    737          
    738            // Handle color mode transition, if necessary.
    739            handleModeSwitch(endpoint, COLOR_MODE_HSV);
   \                     ??emberAfColorControlClusterStepSaturationCallb_1: (+1)
   \       0x3A   0x2100             MOVS     R1,#+0
   \       0x3C   0x4638             MOV      R0,R7
   \       0x3E   0x....'....        BL       handleModeSwitch
    740          
    741            // now, kick off the state machine.
    742            initHueSat(endpoint);
   \       0x42   0x4638             MOV      R0,R7
   \       0x44   0x....'....        BL       initHueSat
    743          
    744            colorHueTransitionState.stepsRemaining = 0;
   \       0x48   0x2000             MOVS     R0,#+0
   \       0x4A   0x....'....        LDR.W    R1,??DataTable27_1
   \       0x4E   0x8088             STRH     R0,[R1, #+4]
    745          
    746            colorSaturationTransitionState.initialValue = currentSaturation;
   \       0x50   0x....'....        LDR.W    R0,??DataTable27_2
   \       0x54   0x8004             STRH     R4,[R0, #+0]
    747            colorSaturationTransitionState.currentValue = currentSaturation;
   \       0x56   0x8044             STRH     R4,[R0, #+2]
    748          
    749            if (stepMode == MOVE_MODE_UP) {
   \       0x58   0xF1B8 0x0F01      CMP      R8,#+1
   \       0x5C   0xD105             BNE.N    ??emberAfColorControlClusterStepSaturationCallb_2
    750              colorSaturationTransitionState.finalValue = addSaturation(currentSaturation,
    751                                                                        stepSize);
   \       0x5E   0x192D             ADDS     R5,R5,R4
   \       0x60   0xB2AD             UXTH     R5,R5
   \       0x62   0x2DFF             CMP      R5,#+255
   \       0x64   0xDB05             BLT.N    ??emberAfColorControlClusterStepSaturationCallb_3
   \       0x66   0x25FE             MOVS     R5,#+254
    752            } else {
   \       0x68   0xE003             B.N      ??emberAfColorControlClusterStepSaturationCallb_3
    753              colorSaturationTransitionState.finalValue =
    754                subtractSaturation(currentSaturation,
    755                                   stepSize);
   \                     ??emberAfColorControlClusterStepSaturationCallb_2: (+1)
   \       0x6A   0x42AC             CMP      R4,R5
   \       0x6C   0xBF34             ITE      CC 
   \       0x6E   0x2500             MOVCC    R5,#+0
   \       0x70   0x1B65             SUBCS    R5,R4,R5
    756            }
   \                     ??emberAfColorControlClusterStepSaturationCallb_3: (+1)
   \       0x72   0xB2ED             UXTB     R5,R5
    757            colorSaturationTransitionState.stepsRemaining = transitionTime;
    758            colorSaturationTransitionState.stepsTotal     = transitionTime;
    759            colorSaturationTransitionState.endpoint       = endpoint;
    760            colorSaturationTransitionState.lowLimit  = MIN_SATURATION_VALUE;
   \       0x74   0x2100             MOVS     R1,#+0
    761            colorSaturationTransitionState.highLimit = MAX_SATURATION_VALUE;
   \       0x76   0x22FE             MOVS     R2,#+254
   \       0x78   0x8085             STRH     R5,[R0, #+4]
   \       0x7A   0x80C6             STRH     R6,[R0, #+6]
   \       0x7C   0x8106             STRH     R6,[R0, #+8]
   \       0x7E   0x7387             STRB     R7,[R0, #+14]
   \       0x80   0x8141             STRH     R1,[R0, #+10]
   \       0x82   0x8182             STRH     R2,[R0, #+12]
    762          
    763            writeRemainingTime(endpoint, transitionTime);
   \       0x84   0x4631             MOV      R1,R6
   \       0x86   0x4638             MOV      R0,R7
   \       0x88   0x....'....        BL       writeRemainingTime
    764          
    765            // kick off the state machine:
    766            emberEventControlSetDelayMS(COLOR_HSV_CONTROL, UPDATE_TIME_MS);
   \       0x8C   0x....'....        BL       ?Subroutine21
   \                     ??CrossCallReturnLabel_61: (+1)
   \       0x90   0xE7D2             B.N      ??emberAfColorControlClusterStepSaturationCallb_0
    767          
    768            emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
    769            return true;
    770          }
    771          
    772          static uint8_t addSaturation(uint8_t saturation1, uint8_t saturation2)
    773          {
    774            uint16_t saturation16;
    775          
    776            saturation16 =  ((uint16_t) saturation1);
    777            saturation16 += ((uint16_t) saturation2);
    778          
    779            if (saturation16 > MAX_SATURATION_VALUE) {
    780              saturation16 = MAX_SATURATION_VALUE;
    781            }
    782          
    783            return ((uint8_t) saturation16);
    784          }
    785          
    786          static uint8_t subtractSaturation(uint8_t saturation1, uint8_t saturation2)
    787          {
    788            if (saturation2 > saturation1) {
    789              return 0;
    790            }
    791          
    792            return saturation1 - saturation2;
    793          }
    794          
    795          // any time we call a hue or saturation transition, we need to assume certain
    796          // things about the hue and saturation data structures.  This function will
    797          // properly initialize them.

   \                                 In section .text, align 2, keep-with-next
    798          static void initHueSat(uint8_t endpoint)
    799          {
   \                     initHueSat: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    800            colorHueTransitionState.stepsRemaining = 0;
   \        0x2   0x....'....        LDR.W    R5,??DataTable27_1
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x4604             MOV      R4,R0
   \        0xA   0x80A9             STRH     R1,[R5, #+4]
    801            colorHueTransitionState.currentHue = readHue(endpoint);
   \        0xC   0x....'....        BL       readHue
   \       0x10   0x7068             STRB     R0,[R5, #+1]
    802            colorHueTransitionState.endpoint   = endpoint;
   \       0x12   0x722C             STRB     R4,[R5, #+8]
    803          
    804            colorSaturationTransitionState.stepsRemaining = 0;
   \       0x14   0x....'....        LDR.W    R5,??DataTable27_2
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x80E8             STRH     R0,[R5, #+6]
    805            colorSaturationTransitionState.currentValue = readSaturation(endpoint);
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x....'....        BL       readSaturation
   \       0x22   0x8068             STRH     R0,[R5, #+2]
    806            colorSaturationTransitionState.endpoint     = endpoint;
   \       0x24   0x73AC             STRB     R4,[R5, #+14]
    807          }
   \       0x26   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    808          

   \                                 In section .text, align 2, keep-with-next
    809          static uint8_t readHue(uint8_t endpoint)
    810          {
   \                     readHue: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
    811            uint8_t hue;
    812          
    813            assert(EMBER_ZCL_STATUS_SUCCESS
    814                   == emberAfReadServerAttribute(endpoint,
    815                                                 ZCL_COLOR_CONTROL_CLUSTER_ID,
    816                                                 ZCL_COLOR_CONTROL_CURRENT_HUE_ATTRIBUTE_ID,
    817                                                 (uint8_t *)&hue,
    818                                                 sizeof(uint8_t)));
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x9100             STR      R1,[SP, #+0]
   \        0x6   0xAB01             ADD      R3,SP,#+4
   \        0x8   0x2200             MOVS     R2,#+0
   \        0xA   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_3: (+1)
   \        0xE   0xB118             CBZ.N    R0,??CrossCallReturnLabel_26
   \       0x10   0xF240 0x3132      MOVW     R1,#+818
   \       0x14   0x....'....        BL       ?Subroutine12
    819          
    820            return hue;
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x18                      REQUIRE ?Subroutine0
   \       0x18                      ;; // Fall through to label ?Subroutine0
    821          }
    822          

   \                                 In section .text, align 2, keep-with-next
    823          static uint8_t readSaturation(uint8_t endpoint)
    824          {
   \                     readSaturation: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
    825            uint8_t saturation;
    826          
    827            assert(EMBER_ZCL_STATUS_SUCCESS
    828                   == emberAfReadServerAttribute(endpoint,
    829                                                 ZCL_COLOR_CONTROL_CLUSTER_ID,
    830                                                 ZCL_COLOR_CONTROL_CURRENT_SATURATION_ATTRIBUTE_ID,
    831                                                 (uint8_t *)&saturation,
    832                                                 sizeof(uint8_t)));
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x9100             STR      R1,[SP, #+0]
   \        0x6   0xAB01             ADD      R3,SP,#+4
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_2: (+1)
   \        0xE   0xB118             CBZ.N    R0,??CrossCallReturnLabel_25
   \       0x10   0xF44F 0x7150      MOV      R1,#+832
   \       0x14   0x....'....        BL       ?Subroutine12
    833          
    834            return saturation;
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0x18   0x....             B.N      ?Subroutine0
    835          }
    836          
    837          #endif  // #ifdef EMBER_AF_PLUGIN_COLOR_CONTROL_SERVER_HSV
    838          
    839          #ifdef EMBER_AF_PLUGIN_COLOR_CONTROL_SERVER_XY
    840          

   \                                 In section .text, align 2, keep-with-next
    841          bool emberAfColorControlClusterMoveToColorCallback(uint16_t colorX,
    842                                                             uint16_t colorY,
    843                                                             uint16_t transitionTime,
    844                                                             uint8_t optionsMask,
    845                                                             uint8_t optionsOverride)
    846          {
   \                     emberAfColorControlClusterMoveToColorCallback: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine18
    847            uint8_t endpoint = emberAfCurrentEndpoint();
   \                     ??CrossCallReturnLabel_47: (+1)
   \        0x8   0x4616             MOV      R6,R2
   \        0xA   0x9A06             LDR      R2,[SP, #+24]
   \        0xC   0x6820             LDR      R0,[R4, #+0]
   \        0xE   0x4688             MOV      R8,R1
    848          
    849            if (!shouldExecuteIfOff(endpoint, optionsMask, optionsOverride)) {
   \       0x10   0x....'....        BL       ?Subroutine20
   \                     ??CrossCallReturnLabel_58: (+1)
   \       0x14   0x2800             CMP      R0,#+0
   \       0x16   0xD02F             BEQ.N    ??emberAfColorControlClusterMoveToColorCallback_0
    850              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
    851              return true;
    852            }
    853          
    854            if (transitionTime == 0) {
   \       0x18   0x0030             MOVS     R0,R6
   \       0x1A   0x....'....        LDR.W    R5,??DataTable27_5
   \       0x1E   0xBF08             IT       EQ 
   \       0x20   0x2601             MOVEQ    R6,#+1
    855              transitionTime++;
    856            }
    857          
    858            // New command.  Need to stop any active transitions.
    859            stopAllColorTransitions();
   \       0x22   0x....'....        BL       stopAllColorTransitions
    860          
    861            // Handle color mode transition, if necessary.
    862            handleModeSwitch(endpoint, COLOR_MODE_CIE_XY);
   \       0x26   0x2101             MOVS     R1,#+1
   \       0x28   0x....'....        BL       ??Subroutine24_0
    863          
    864            // now, kick off the state machine.
    865            colorXTransitionState.initialValue = readColorX(endpoint);
   \                     ??CrossCallReturnLabel_77: (+1)
   \       0x2C   0x4620             MOV      R0,R4
   \       0x2E   0x....'....        BL       readColorX
   \       0x32   0x8028             STRH     R0,[R5, #+0]
    866            colorXTransitionState.currentValue = readColorX(endpoint);
   \       0x34   0x4620             MOV      R0,R4
   \       0x36   0x....'....        BL       readColorX
   \       0x3A   0x8068             STRH     R0,[R5, #+2]
    867            colorXTransitionState.finalValue = colorX;
   \       0x3C   0x80AF             STRH     R7,[R5, #+4]
    868            colorXTransitionState.stepsRemaining = transitionTime;
   \       0x3E   0x80EE             STRH     R6,[R5, #+6]
    869            colorXTransitionState.stepsTotal = transitionTime;
   \       0x40   0x812E             STRH     R6,[R5, #+8]
    870            colorXTransitionState.endpoint = endpoint;
   \       0x42   0x73AC             STRB     R4,[R5, #+14]
    871            colorXTransitionState.lowLimit  = MIN_CIE_XY_VALUE;
   \       0x44   0x....'....        BL       ?Subroutine15
    872            colorXTransitionState.highLimit = MAX_CIE_XY_VALUE;
    873          
    874            colorYTransitionState.initialValue = readColorY(endpoint);
   \                     ??CrossCallReturnLabel_37: (+1)
   \       0x48   0x4620             MOV      R0,R4
   \       0x4A   0x....'....        LDR.W    R5,??DataTable27_6
   \       0x4E   0x....'....        BL       readColorY
   \       0x52   0x8028             STRH     R0,[R5, #+0]
    875            colorYTransitionState.currentValue = readColorY(endpoint);
   \       0x54   0x4620             MOV      R0,R4
   \       0x56   0x....'....        BL       readColorY
   \       0x5A   0x8068             STRH     R0,[R5, #+2]
    876            colorYTransitionState.finalValue = colorY;
   \       0x5C   0xF8A5 0x8004      STRH     R8,[R5, #+4]
    877            colorYTransitionState.stepsRemaining = transitionTime;
   \       0x60   0x80EE             STRH     R6,[R5, #+6]
    878            colorYTransitionState.stepsTotal = transitionTime;
   \       0x62   0x812E             STRH     R6,[R5, #+8]
    879            colorYTransitionState.endpoint = endpoint;
   \       0x64   0x73AC             STRB     R4,[R5, #+14]
    880            colorYTransitionState.lowLimit  = MIN_CIE_XY_VALUE;
   \       0x66   0x2000             MOVS     R0,#+0
   \       0x68   0x8168             STRH     R0,[R5, #+10]
    881            colorYTransitionState.highLimit = MAX_CIE_XY_VALUE;
   \       0x6A   0x81AF             STRH     R7,[R5, #+12]
    882          
    883            writeRemainingTime(endpoint, transitionTime);
   \       0x6C   0x4631             MOV      R1,R6
   \       0x6E   0x....'....        BL       ?Subroutine25
    884          
    885            // kick off the state machine:
    886            emberEventControlSetDelayMS(COLOR_XY_CONTROL, UPDATE_TIME_MS);
   \                     ??CrossCallReturnLabel_82: (+1)
   \       0x72   0x....'....        BL       ?Subroutine22
    887          
    888            emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   \                     ??CrossCallReturnLabel_71: (+1)
   \       0x76   0x2000             MOVS     R0,#+0
   \                     ??emberAfColorControlClusterMoveToColorCallback_0: (+1)
   \       0x78   0x....             B.N      ??Subroutine4_0
    889            return true;
    890          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine22: (+1)
   \        0x0   0x2164             MOVS     R1,#+100
   \        0x2   0x....'....        LDR.W    R0,??DataTable27_7
   \        0x6   0x....'....        B.W      emEventControlSetDelayMS

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x8168             STRH     R0,[R5, #+10]
   \        0x4   0xF64F 0x67FF      MOVW     R7,#+65279
   \        0x8   0x81AF             STRH     R7,[R5, #+12]
   \        0xA   0x4770             BX       LR
    891          

   \                                 In section .text, align 2, keep-with-next
    892          bool emberAfColorControlClusterMoveColorCallback(int16_t rateX,
    893                                                           int16_t rateY,
    894                                                           uint8_t optionsMask,
    895                                                           uint8_t optionsOverride)
    896          {
   \                     emberAfColorControlClusterMoveColorCallback: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine18
    897            uint8_t endpoint = emberAfCurrentEndpoint();
   \                     ??CrossCallReturnLabel_48: (+1)
   \        0x8   0x4688             MOV      R8,R1
   \        0xA   0x4611             MOV      R1,R2
   \        0xC   0x6826             LDR      R6,[R4, #+0]
    898          
    899            if (!shouldExecuteIfOff(endpoint, optionsMask, optionsOverride)) {
   \        0xE   0x461A             MOV      R2,R3
   \       0x10   0x7974             LDRB     R4,[R6, #+5]
   \       0x12   0x....'....        BL       ??Subroutine20_0
   \                     ??CrossCallReturnLabel_56: (+1)
   \       0x16   0xB120             CBZ.N    R0,??emberAfColorControlClusterMoveColorCallback_0
    900              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
    901              return true;
    902            }
    903          
    904            uint16_t transitionTimeX, transitionTimeY;
    905            uint16_t unsignedRate;
    906          
    907            // New command.  Need to stop any active transitions.
    908            stopAllColorTransitions();
   \       0x18   0x....'....        BL       stopAllColorTransitions
    909          
    910            if (rateX == 0 && rateY == 0) {
   \       0x1C   0xEA58 0x0007      ORRS     R0,R8,R7
   \       0x20   0xD100             BNE.N    ??emberAfColorControlClusterMoveColorCallback_1
    911              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   \                     ??emberAfColorControlClusterMoveColorCallback_0: (+1)
   \       0x22   0x....             B.N      ?Subroutine4
    912              return true;
    913            }
    914          
    915            // Handle color mode transition, if necessary.
    916            handleModeSwitch(endpoint, COLOR_MODE_CIE_XY);
   \                     ??emberAfColorControlClusterMoveColorCallback_1: (+1)
   \       0x24   0x2101             MOVS     R1,#+1
   \       0x26   0x....'....        BL       ??Subroutine24_0
    917          
    918            // now, kick off the state machine.
    919            colorXTransitionState.initialValue = readColorX(endpoint);
   \                     ??CrossCallReturnLabel_76: (+1)
   \       0x2A   0x4620             MOV      R0,R4
   \       0x2C   0x....'....        BL       readColorX
   \       0x30   0x....'....        LDR.W    R5,??DataTable27_5
    920            colorXTransitionState.currentValue = colorXTransitionState.initialValue;
    921            if (rateX > 0) {
   \       0x34   0xF64F 0x66FF      MOVW     R6,#+65279
   \       0x38   0x2F01             CMP      R7,#+1
   \       0x3A   0x8028             STRH     R0,[R5, #+0]
   \       0x3C   0x8068             STRH     R0,[R5, #+2]
   \       0x3E   0xBFAE             ITEE     GE 
   \       0x40   0x4630             MOVGE    R0,R6
   \       0x42   0x2000             MOVLT    R0,#+0
   \       0x44   0x427F             RSBLT    R7,R7,#+0
    922              colorXTransitionState.finalValue = MAX_CIE_XY_VALUE;
    923              unsignedRate = (uint16_t) rateX;
    924            } else {
    925              colorXTransitionState.finalValue = MIN_CIE_XY_VALUE;
    926              unsignedRate = (uint16_t) (rateX * -1);
   \       0x46   0x80A8             STRH     R0,[R5, #+4]
    927            }
    928            transitionTimeX =
    929              computeTransitionTimeFromStateAndRate(&colorXTransitionState,
    930                                                    unsignedRate);
   \       0x48   0xB2B9             UXTH     R1,R7
   \       0x4A   0x4628             MOV      R0,R5
   \       0x4C   0x....'....        BL       computeTransitionTimeFromStateAndRate
   \       0x50   0x4607             MOV      R7,R0
    931            colorXTransitionState.stepsRemaining = transitionTimeX;
   \       0x52   0x80EF             STRH     R7,[R5, #+6]
    932            colorXTransitionState.stepsTotal = transitionTimeX;
   \       0x54   0x812F             STRH     R7,[R5, #+8]
    933            colorXTransitionState.endpoint = endpoint;
   \       0x56   0x73AC             STRB     R4,[R5, #+14]
    934            colorXTransitionState.lowLimit  = MIN_CIE_XY_VALUE;
   \       0x58   0x2000             MOVS     R0,#+0
   \       0x5A   0x8168             STRH     R0,[R5, #+10]
    935            colorXTransitionState.highLimit = MAX_CIE_XY_VALUE;
   \       0x5C   0x81AE             STRH     R6,[R5, #+12]
    936          
    937            colorYTransitionState.initialValue = readColorY(endpoint);
   \       0x5E   0x4620             MOV      R0,R4
   \       0x60   0x....'....        BL       readColorY
   \       0x64   0x....'....        LDR.W    R5,??DataTable27_6
    938            colorYTransitionState.currentValue = colorYTransitionState.initialValue;
   \       0x68   0xF1B8 0x0F01      CMP      R8,#+1
   \       0x6C   0x8028             STRH     R0,[R5, #+0]
   \       0x6E   0x8068             STRH     R0,[R5, #+2]
   \       0x70   0xBFAE             ITEE     GE 
   \       0x72   0x4630             MOVGE    R0,R6
   \       0x74   0x2000             MOVLT    R0,#+0
   \       0x76   0xF1C8 0x0800      RSBLT    R8,R8,#+0
    939            if (rateY > 0) {
    940              colorYTransitionState.finalValue = MAX_CIE_XY_VALUE;
    941              unsignedRate = (uint16_t) rateY;
    942            } else {
    943              colorYTransitionState.finalValue = MIN_CIE_XY_VALUE;
    944              unsignedRate = (uint16_t) (rateY * -1);
   \       0x7A   0x80A8             STRH     R0,[R5, #+4]
    945            }
    946            transitionTimeY =
    947              computeTransitionTimeFromStateAndRate(&colorYTransitionState,
    948                                                    unsignedRate);
   \       0x7C   0xFA1F 0xF188      UXTH     R1,R8
   \       0x80   0x4628             MOV      R0,R5
   \       0x82   0x....'....        BL       computeTransitionTimeFromStateAndRate
    949            colorYTransitionState.stepsRemaining = transitionTimeY;
   \       0x86   0x80E8             STRH     R0,[R5, #+6]
    950            colorYTransitionState.stepsTotal = transitionTimeY;
   \       0x88   0x8128             STRH     R0,[R5, #+8]
    951            colorYTransitionState.endpoint = endpoint;
   \       0x8A   0x73AC             STRB     R4,[R5, #+14]
    952            colorYTransitionState.lowLimit  = MIN_CIE_XY_VALUE;
   \       0x8C   0x2100             MOVS     R1,#+0
    953            colorYTransitionState.highLimit = MAX_CIE_XY_VALUE;
    954          
    955            if (transitionTimeX < transitionTimeY) {
   \       0x8E   0x4287             CMP      R7,R0
   \       0x90   0x8169             STRH     R1,[R5, #+10]
   \       0x92   0x81AE             STRH     R6,[R5, #+12]
   \       0x94   0xBF34             ITE      CC 
   \       0x96   0x4639             MOVCC    R1,R7
   \       0x98   0x4601             MOVCS    R1,R0
    956              writeRemainingTime(endpoint, transitionTimeX);
    957            } else {
    958              writeRemainingTime(endpoint, transitionTimeY);
   \       0x9A   0x....'....        BL       ?Subroutine25
    959            }
    960          
    961            // kick off the state machine:
    962            emberEventControlSetDelayMS(COLOR_XY_CONTROL, UPDATE_TIME_MS);
   \                     ??CrossCallReturnLabel_81: (+1)
   \       0x9E   0x....'....        BL       ?Subroutine22
   \                     ??CrossCallReturnLabel_70: (+1)
   \       0xA2   0xE7BE             B.N      ??emberAfColorControlClusterMoveColorCallback_0
    963          
    964            emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
    965            return true;
    966          }
    967          

   \                                 In section .text, align 2, keep-with-next
    968          bool emberAfColorControlClusterStepColorCallback(int16_t stepX,
    969                                                           int16_t stepY,
    970                                                           uint16_t transitionTime,
    971                                                           uint8_t optionsMask,
    972                                                           uint8_t optionsOverride)
    973          {
   \                     emberAfColorControlClusterStepColorCallback: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4607             MOV      R7,R0
    974            uint8_t endpoint = emberAfCurrentEndpoint();
   \        0x6   0x....'....        LDR.W    R0,??DataTable27
   \        0xA   0x6806             LDR      R6,[R0, #+0]
   \        0xC   0x4614             MOV      R4,R2
   \        0xE   0x9A06             LDR      R2,[SP, #+24]
   \       0x10   0x6830             LDR      R0,[R6, #+0]
   \       0x12   0x460D             MOV      R5,R1
    975          
    976            if (!shouldExecuteIfOff(endpoint, optionsMask, optionsOverride)) {
   \       0x14   0x4619             MOV      R1,R3
   \       0x16   0x7946             LDRB     R6,[R0, #+5]
   \       0x18   0x4630             MOV      R0,R6
   \       0x1A   0x....'....        BL       shouldExecuteIfOff
   \       0x1E   0x2800             CMP      R0,#+0
   \       0x20   0xD03E             BEQ.N    ??emberAfColorControlClusterStepColorCallback_0
    977              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
    978              return true;
    979            }
    980          
    981            uint16_t colorX =
    982              findNewColorValueFromStep(readColorX(endpoint), stepX);
   \       0x22   0x4630             MOV      R0,R6
   \       0x24   0x....'....        BL       readColorX
   \       0x28   0x4639             MOV      R1,R7
   \       0x2A   0x....'....        BL       findNewColorValueFromStep
   \       0x2E   0x4607             MOV      R7,R0
    983            uint16_t colorY =
    984              findNewColorValueFromStep(readColorY(endpoint), stepY);
   \       0x30   0x4630             MOV      R0,R6
   \       0x32   0x....'....        BL       readColorY
   \       0x36   0x4629             MOV      R1,R5
   \       0x38   0x....'....        BL       findNewColorValueFromStep
   \       0x3C   0x4680             MOV      R8,R0
    985          
    986            if (transitionTime == 0) {
   \       0x3E   0x0020             MOVS     R0,R4
   \       0x40   0x....'....        LDR.W    R5,??DataTable27_5
   \       0x44   0xBF08             IT       EQ 
   \       0x46   0x2401             MOVEQ    R4,#+1
    987              transitionTime++;
    988            }
    989          
    990            // New command.  Need to stop any active transitions.
    991            stopAllColorTransitions();
   \       0x48   0x....'....        BL       stopAllColorTransitions
    992          
    993            // Handle color mode transition, if necessary.
    994            handleModeSwitch(endpoint, COLOR_MODE_CIE_XY);
   \       0x4C   0x2101             MOVS     R1,#+1
   \       0x4E   0x....'....        BL       ??Subroutine26_0
    995          
    996            // now, kick off the state machine.
    997            colorXTransitionState.initialValue = readColorX(endpoint);
   \                     ??CrossCallReturnLabel_85: (+1)
   \       0x52   0x4630             MOV      R0,R6
   \       0x54   0x....'....        BL       readColorX
   \       0x58   0x8028             STRH     R0,[R5, #+0]
    998            colorXTransitionState.currentValue = readColorX(endpoint);
   \       0x5A   0x4630             MOV      R0,R6
   \       0x5C   0x....'....        BL       readColorX
   \       0x60   0x8068             STRH     R0,[R5, #+2]
    999            colorXTransitionState.finalValue = colorX;
   \       0x62   0x80AF             STRH     R7,[R5, #+4]
   1000            colorXTransitionState.stepsRemaining = transitionTime;
   \       0x64   0x80EC             STRH     R4,[R5, #+6]
   1001            colorXTransitionState.stepsTotal = transitionTime;
   \       0x66   0x812C             STRH     R4,[R5, #+8]
   1002            colorXTransitionState.endpoint = endpoint;
   \       0x68   0x73AE             STRB     R6,[R5, #+14]
   1003            colorXTransitionState.lowLimit  = MIN_CIE_XY_VALUE;
   \       0x6A   0x....'....        BL       ?Subroutine15
   1004            colorXTransitionState.highLimit = MAX_CIE_XY_VALUE;
   1005          
   1006            colorYTransitionState.initialValue = readColorY(endpoint);
   \                     ??CrossCallReturnLabel_38: (+1)
   \       0x6E   0x4630             MOV      R0,R6
   \       0x70   0x....'....        LDR.W    R5,??DataTable27_6
   \       0x74   0x....'....        BL       readColorY
   \       0x78   0x8028             STRH     R0,[R5, #+0]
   1007            colorYTransitionState.currentValue = readColorY(endpoint);
   \       0x7A   0x4630             MOV      R0,R6
   \       0x7C   0x....'....        BL       readColorY
   \       0x80   0x8068             STRH     R0,[R5, #+2]
   1008            colorYTransitionState.finalValue = colorY;
   \       0x82   0xF8A5 0x8004      STRH     R8,[R5, #+4]
   1009            colorYTransitionState.stepsRemaining = transitionTime;
   \       0x86   0x80EC             STRH     R4,[R5, #+6]
   1010            colorYTransitionState.stepsTotal = transitionTime;
   \       0x88   0x812C             STRH     R4,[R5, #+8]
   1011            colorYTransitionState.endpoint = endpoint;
   \       0x8A   0x73AE             STRB     R6,[R5, #+14]
   1012            colorYTransitionState.lowLimit  = MIN_CIE_XY_VALUE;
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0x8168             STRH     R0,[R5, #+10]
   1013            colorYTransitionState.highLimit = MAX_CIE_XY_VALUE;
   \       0x90   0x81AF             STRH     R7,[R5, #+12]
   1014          
   1015            writeRemainingTime(endpoint, transitionTime);
   \       0x92   0x4621             MOV      R1,R4
   \       0x94   0x4630             MOV      R0,R6
   \       0x96   0x....'....        BL       writeRemainingTime
   1016          
   1017            // kick off the state machine:
   1018            emberEventControlSetDelayMS(COLOR_XY_CONTROL, UPDATE_TIME_MS);
   \       0x9A   0x....'....        BL       ?Subroutine22
   1019          
   1020            emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   \                     ??CrossCallReturnLabel_69: (+1)
   \       0x9E   0x2000             MOVS     R0,#+0
   \                     ??emberAfColorControlClusterStepColorCallback_0: (+1)
   \       0xA0   0x....             B.N      ??Subroutine4_0
   1021            return true;
   1022          }
   1023          

   \                                 In section .text, align 2, keep-with-next
   1024          static uint16_t findNewColorValueFromStep(uint16_t oldValue, int16_t step)
   1025          {
   1026            uint16_t newValue;
   1027            int32_t  newValueSigned;
   1028          
   1029            newValueSigned = ((int32_t) oldValue) + ((int32_t) step);
   \                     findNewColorValueFromStep: (+1)
   \        0x0   0x1808             ADDS     R0,R1,R0
   1030          
   1031            if (newValueSigned < 0) {
   \        0x2   0xBF48             IT       MI 
   \        0x4   0x2000             MOVMI    R0,#+0
   1032              newValue = 0;
   \        0x6   0xD404             BMI.N    ??findNewColorValueFromStep_0
   1033            } else if (newValueSigned > MAX_CIE_XY_VALUE) {
   \        0x8   0xF5B0 0x4F7F      CMP      R0,#+65280
   \        0xC   0xBFA8             IT       GE 
   \        0xE   0xF64F 0x60FF      MOVWGE   R0,#+65279
   1034              newValue = MAX_CIE_XY_VALUE;
   1035            } else {
   1036              newValue = (uint16_t) newValueSigned;
   1037            }
   1038          
   1039            return newValue;
   \                     ??findNewColorValueFromStep_0: (+1)
   \       0x12   0xB280             UXTH     R0,R0
   \       0x14   0x4770             BX       LR               ;; return
   1040          }
   1041          

   \                                 In section .text, align 2, keep-with-next
   1042          static uint16_t readColorX(uint8_t endpoint)
   1043          {
   \                     readColorX: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
   1044            uint16_t colorX;
   1045          
   1046            assert(EMBER_ZCL_STATUS_SUCCESS
   1047                   == emberAfReadServerAttribute(endpoint,
   1048                                                 ZCL_COLOR_CONTROL_CLUSTER_ID,
   1049                                                 ZCL_COLOR_CONTROL_CURRENT_X_ATTRIBUTE_ID,
   1050                                                 (uint8_t *)&colorX,
   1051                                                 sizeof(uint16_t)));
   \        0x2   0x....'....        BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_35: (+1)
   \        0x6   0x2203             MOVS     R2,#+3
   \        0x8   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0xC   0xB118             CBZ.N    R0,??CrossCallReturnLabel_24
   \        0xE   0xF240 0x411B      MOVW     R1,#+1051
   \       0x12   0x....'....        BL       ?Subroutine12
   1052          
   1053            return colorX;
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0x16   0x....             B.N      ?Subroutine1
   1054          }
   1055          

   \                                 In section .text, align 2, keep-with-next
   1056          static uint16_t readColorY(uint8_t endpoint)
   1057          {
   \                     readColorY: (+1)
   \        0x0   0xB5E0             PUSH     {R5-R7,LR}
   1058            uint16_t colorY;
   1059          
   1060            assert(EMBER_ZCL_STATUS_SUCCESS
   1061                   == emberAfReadServerAttribute(endpoint,
   1062                                                 ZCL_COLOR_CONTROL_CLUSTER_ID,
   1063                                                 ZCL_COLOR_CONTROL_CURRENT_Y_ATTRIBUTE_ID,
   1064                                                 (uint8_t *)&colorY,
   1065                                                 sizeof(uint16_t)));
   \        0x2   0x....'....        BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_36: (+1)
   \        0x6   0x2204             MOVS     R2,#+4
   \        0x8   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0xC   0xB118             CBZ.N    R0,??CrossCallReturnLabel_23
   \        0xE   0xF240 0x4129      MOVW     R1,#+1065
   \       0x12   0x....'....        BL       ?Subroutine12
   1066          
   1067            return colorY;
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0x16   0x....             B.N      ?Subroutine1
   1068          }
   1069          
   1070          #endif  //#ifdef EMBER_AF_PLUGIN_COLOR_CONTROL_SERVER_XY
   1071          
   1072          #ifdef EMBER_AF_PLUGIN_COLOR_CONTROL_SERVER_TEMP
   1073          

   \                                 In section .text, align 2, keep-with-next
   1074          static void moveToColorTemp(uint8_t endpoint,
   1075                                      uint16_t colorTemperature,
   1076                                      uint16_t transitionTime)
   1077          {
   \                     moveToColorTemp: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4617             MOV      R7,R2
   1078            uint16_t temperatureMin = readColorTemperatureMin(endpoint);
   \        0xA   0x....'....        BL       readColorTemperatureMin
   \        0xE   0x....'....        BL       ?Subroutine27
   1079            uint16_t temperatureMax = readColorTemperatureMax(endpoint);
   \                     ??CrossCallReturnLabel_91: (+1)
   \       0x12   0x4681             MOV      R9,R0
   1080          
   1081            if (transitionTime == 0) {
   \       0x14   0x0038             MOVS     R0,R7
   \       0x16   0x46C8             MOV      R8,R9
   \       0x18   0xBF08             IT       EQ 
   \       0x1A   0x2701             MOVEQ    R7,#+1
   1082              transitionTime++;
   1083            }
   1084          
   1085            // New command.  Need to stop any active transitions.
   1086            stopAllColorTransitions();
   \       0x1C   0x....'....        BL       stopAllColorTransitions
   1087          
   1088            // Handle color mode transition, if necessary.
   1089            handleModeSwitch(endpoint, COLOR_MODE_TEMPERATURE);
   \       0x20   0x2102             MOVS     R1,#+2
   \       0x22   0x....'....        BL       ??Subroutine24_0
   1090          
   1091            if (colorTemperature < temperatureMin) {
   \                     ??CrossCallReturnLabel_75: (+1)
   \       0x26   0x4628             MOV      R0,R5
   \       0x28   0x42B0             CMP      R0,R6
   \       0x2A   0xBF38             IT       CC 
   \       0x2C   0x4630             MOVCC    R0,R6
   1092              colorTemperature = temperatureMin;
   1093            }
   1094          
   1095            if (colorTemperature > temperatureMax) {
   \       0x2E   0x4580             CMP      R8,R0
   1096              colorTemperature = temperatureMax;
   1097            }
   1098          
   1099            // now, kick off the state machine.
   1100            colorTempTransitionState.initialValue = readColorTemperature(endpoint);
   \       0x30   0x....'....        LDR.W    R6,??DataTable27_8
   \       0x34   0xBF88             IT       HI 
   \       0x36   0x4680             MOVHI    R8,R0
   \       0x38   0x4620             MOV      R0,R4
   \       0x3A   0x....'....        BL       readColorTemperature
   \       0x3E   0x8030             STRH     R0,[R6, #+0]
   1101            colorTempTransitionState.currentValue = readColorTemperature(endpoint);
   \       0x40   0x4620             MOV      R0,R4
   \       0x42   0x....'....        BL       readColorTemperature
   \       0x46   0x8070             STRH     R0,[R6, #+2]
   1102            colorTempTransitionState.finalValue   = colorTemperature;
   \       0x48   0xF8A6 0x8004      STRH     R8,[R6, #+4]
   1103            colorTempTransitionState.stepsRemaining = transitionTime;
   \       0x4C   0x80F7             STRH     R7,[R6, #+6]
   1104            colorTempTransitionState.stepsTotal     = transitionTime;
   \       0x4E   0x8137             STRH     R7,[R6, #+8]
   1105            colorTempTransitionState.endpoint  = endpoint;
   \       0x50   0x73B4             STRB     R4,[R6, #+14]
   1106            colorTempTransitionState.lowLimit  = temperatureMin;
   \       0x52   0x8175             STRH     R5,[R6, #+10]
   1107            colorTempTransitionState.highLimit = temperatureMax;
   \       0x54   0xF8A6 0x900C      STRH     R9,[R6, #+12]
   1108          
   1109            // kick off the state machine:
   1110            emberEventControlSetDelayMS(COLOR_TEMP_CONTROL, UPDATE_TIME_MS);
   \       0x58   0x2164             MOVS     R1,#+100
   \       0x5A   0x....'....        LDR.W    R0,??DataTable27_9
   \       0x5E   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \       0x62   0x....'....        B.W      emEventControlSetDelayMS
   1111          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine27: (+1)
   \        0x0   0x4605             MOV      R5,R0
   \                     ??Subroutine27_0: (+1)
   \        0x2   0x4620             MOV      R0,R4
   \        0x4   0x....             B.N      readColorTemperatureMax
   1112          

   \                                 In section .text, align 2, keep-with-next
   1113          bool emberAfColorControlClusterMoveToColorTemperatureCallback(uint16_t colorTemperature,
   1114                                                                        uint16_t transitionTime,
   1115                                                                        uint8_t optionsMask,
   1116                                                                        uint8_t optionsOverride)
   1117          {
   \                     emberAfColorControlClusterMoveToColorTemperatureCallback: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x....'....        BL       ?Subroutine17
   1118            uint8_t endpoint = emberAfCurrentEndpoint();
   1119          
   1120            if (!shouldExecuteIfOff(endpoint, optionsMask, optionsOverride)) {
   \                     ??CrossCallReturnLabel_45: (+1)
   \        0x6   0xB128             CBZ.N    R0,??emberAfColorControlClusterMoveToColorTemperat_0
   1121              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   1122              return true;
   1123            }
   1124          
   1125            moveToColorTemp(endpoint, colorTemperature, transitionTime);
   \        0x8   0x462A             MOV      R2,R5
   \        0xA   0x4621             MOV      R1,R4
   \        0xC   0x4630             MOV      R0,R6
   \        0xE   0x....'....        BL       moveToColorTemp
   1126          
   1127            emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   \       0x12   0x2000             MOVS     R0,#+0
   \                     ??emberAfColorControlClusterMoveToColorTemperat_0: (+1)
   \       0x14   0x....             B.N      ?Subroutine3
   1128            return true;
   1129          }
   1130          

   \                                 In section .text, align 2, keep-with-next
   1131          bool emberAfColorControlClusterMoveColorTemperatureCallback(uint8_t moveMode,
   1132                                                                      uint16_t rate,
   1133                                                                      uint16_t colorTemperatureMinimum,
   1134                                                                      uint16_t colorTemperatureMaximum,
   1135                                                                      uint8_t optionsMask,
   1136                                                                      uint8_t optionsOverride)
   1137          {
   \                     emberAfColorControlClusterMoveColorTemperatureCallback: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x461F             MOV      R7,R3
   1138            uint8_t endpoint = emberAfCurrentEndpoint();
   \        0x8   0x....'....        LDR.W    R0,??DataTable27
   \        0xC   0x6803             LDR      R3,[R0, #+0]
   \        0xE   0x468B             MOV      R11,R1
   \       0x10   0x4615             MOV      R5,R2
   \       0x12   0x681C             LDR      R4,[R3, #+0]
   \       0x14   0x990A             LDR      R1,[SP, #+40]
   \       0x16   0x9A0B             LDR      R2,[SP, #+44]
   \       0x18   0x7964             LDRB     R4,[R4, #+5]
   1139          
   1140            if (!shouldExecuteIfOff(endpoint, optionsMask, optionsOverride)) {
   \       0x1A   0x....'....        BL       ??Subroutine20_0
   \                     ??CrossCallReturnLabel_55: (+1)
   \       0x1E   0xB148             CBZ.N    R0,??emberAfColorControlClusterMoveColorTemperatur_0
   1141              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   1142              return true;
   1143            }
   1144          
   1145            uint16_t tempPhysicalMin = readColorTemperatureMin(endpoint);
   \       0x20   0x4620             MOV      R0,R4
   \       0x22   0x....'....        BL       readColorTemperatureMin
   \       0x26   0x4681             MOV      R9,R0
   1146            uint16_t tempPhysicalMax = readColorTemperatureMax(endpoint);
   \       0x28   0x....'....        BL       ??Subroutine27_0
   \                     ??CrossCallReturnLabel_89: (+1)
   \       0x2C   0x4682             MOV      R10,R0
   1147            uint16_t transitionTime;
   1148          
   1149            // New command.  Need to stop any active transitions.
   1150            stopAllColorTransitions();
   \       0x2E   0x....'....        BL       stopAllColorTransitions
   1151          
   1152            if (moveMode == MOVE_MODE_STOP) {
   \       0x32   0xB92E             CBNZ.N   R6,??emberAfColorControlClusterMoveColorTemperatur_1
   1153              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   \                     ??emberAfColorControlClusterMoveColorTemperatur_0: (+1)
   \       0x34   0x2000             MOVS     R0,#+0
   \                     ??emberAfColorControlClusterMoveColorTemperatur_2: (+1)
   \       0x36   0x....'....        BL       emberAfSendImmediateDefaultResponse
   1154              return true;
   \       0x3A   0x2001             MOVS     R0,#+1
   \       0x3C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1155            }
   1156          
   1157            if (rate == 0) {
   \                     ??emberAfColorControlClusterMoveColorTemperatur_1: (+1)
   \       0x40   0xF1BB 0x0F00      CMP      R11,#+0
   \       0x44   0xBF08             IT       EQ 
   \       0x46   0x2085             MOVEQ    R0,#+133
   1158              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_INVALID_FIELD);
   \       0x48   0xD0F5             BEQ.N    ??emberAfColorControlClusterMoveColorTemperatur_2
   \       0x4A   0x4629             MOV      R1,R5
   1159              return true;
   1160            }
   1161          
   1162            if (colorTemperatureMinimum < tempPhysicalMin) {
   \       0x4C   0x464D             MOV      R5,R9
   \       0x4E   0x428D             CMP      R5,R1
   1163              colorTemperatureMinimum = tempPhysicalMin;
   1164            }
   1165            if (colorTemperatureMaximum > tempPhysicalMax) {
   \       0x50   0x46D0             MOV      R8,R10
   1166              colorTemperatureMaximum = tempPhysicalMax;
   1167            }
   1168          
   1169            // Handle color mode transition, if necessary.
   1170            handleModeSwitch(endpoint, COLOR_MODE_TEMPERATURE);
   \       0x52   0x4620             MOV      R0,R4
   \       0x54   0xBF38             IT       CC 
   \       0x56   0x460D             MOVCC    R5,R1
   \       0x58   0x45B8             CMP      R8,R7
   \       0x5A   0xBF88             IT       HI 
   \       0x5C   0x46B8             MOVHI    R8,R7
   \       0x5E   0x2102             MOVS     R1,#+2
   \       0x60   0x....'....        BL       handleModeSwitch
   1171          
   1172            // now, kick off the state machine.
   1173            colorTempTransitionState.initialValue = readColorTemperature(endpoint);
   \       0x64   0x4620             MOV      R0,R4
   \       0x66   0x....'....        LDR.W    R7,??DataTable27_8
   \       0x6A   0x....'....        BL       readColorTemperature
   \       0x6E   0x8038             STRH     R0,[R7, #+0]
   1174            colorTempTransitionState.currentValue = readColorTemperature(endpoint);
   \       0x70   0x4620             MOV      R0,R4
   \       0x72   0x....'....        BL       readColorTemperature
   \       0x76   0x8078             STRH     R0,[R7, #+2]
   1175            if (moveMode == MOVE_MODE_UP) {
   \       0x78   0x2E01             CMP      R6,#+1
   \       0x7A   0xD104             BNE.N    ??emberAfColorControlClusterMoveColorTemperatur_3
   1176              if (tempPhysicalMax > colorTemperatureMaximum) {
   \       0x7C   0x4640             MOV      R0,R8
   \       0x7E   0x4550             CMP      R0,R10
   \       0x80   0xD905             BLS.N    ??emberAfColorControlClusterMoveColorTemperatur_4
   \       0x82   0x4650             MOV      R0,R10
   \       0x84   0xE003             B.N      ??emberAfColorControlClusterMoveColorTemperatur_4
   1177                colorTempTransitionState.finalValue = colorTemperatureMaximum;
   1178              } else {
   1179                colorTempTransitionState.finalValue = tempPhysicalMax;
   1180              }
   1181            } else {
   1182              if (tempPhysicalMin < colorTemperatureMinimum) {
   \                     ??emberAfColorControlClusterMoveColorTemperatur_3: (+1)
   \       0x86   0x4628             MOV      R0,R5
   \       0x88   0x4548             CMP      R0,R9
   \       0x8A   0xBF38             IT       CC 
   \       0x8C   0x4648             MOVCC    R0,R9
   \                     ??emberAfColorControlClusterMoveColorTemperatur_4: (+1)
   \       0x8E   0x80B8             STRH     R0,[R7, #+4]
   1183                colorTempTransitionState.finalValue = colorTemperatureMinimum;
   1184              } else {
   1185                colorTempTransitionState.finalValue = tempPhysicalMin;
   1186              }
   1187            }
   1188            transitionTime =
   1189              computeTransitionTimeFromStateAndRate(&colorTempTransitionState,
   1190                                                    rate);
   \       0x90   0x4659             MOV      R1,R11
   \       0x92   0x4638             MOV      R0,R7
   \       0x94   0x....'....        BL       computeTransitionTimeFromStateAndRate
   1191            colorTempTransitionState.stepsRemaining = transitionTime;
   \       0x98   0x80F8             STRH     R0,[R7, #+6]
   1192            colorTempTransitionState.stepsTotal     = transitionTime;
   \       0x9A   0x8138             STRH     R0,[R7, #+8]
   1193            colorTempTransitionState.endpoint  = endpoint;
   1194            colorTempTransitionState.lowLimit  = colorTemperatureMinimum;
   1195            colorTempTransitionState.highLimit = colorTemperatureMaximum;
   1196          
   1197            writeRemainingTime(endpoint, transitionTime);
   \       0x9C   0x4601             MOV      R1,R0
   \       0x9E   0x73BC             STRB     R4,[R7, #+14]
   \       0xA0   0x817D             STRH     R5,[R7, #+10]
   \       0xA2   0xF8A7 0x800C      STRH     R8,[R7, #+12]
   \       0xA6   0x....'....        BL       ?Subroutine25
   1198          
   1199            // kick off the state machine:
   1200            emberEventControlSetDelayMS(COLOR_TEMP_CONTROL, UPDATE_TIME_MS);
   \                     ??CrossCallReturnLabel_80: (+1)
   \       0xAA   0x....'....        BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_74: (+1)
   \       0xAE   0xE7C1             B.N      ??emberAfColorControlClusterMoveColorTemperatur_0
   1201          
   1202            emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   1203            return true;
   1204          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine23: (+1)
   \        0x0   0x2164             MOVS     R1,#+100
   \        0x2   0x....'....        LDR.W    R0,??DataTable27_9
   \        0x6   0x....'....        B.W      emEventControlSetDelayMS
   1205          

   \                                 In section .text, align 2, keep-with-next
   1206          bool emberAfColorControlClusterStepColorTemperatureCallback(uint8_t stepMode,
   1207                                                                      uint16_t stepSize,
   1208                                                                      uint16_t transitionTime,
   1209                                                                      uint16_t colorTemperatureMinimum,
   1210                                                                      uint16_t colorTemperatureMaximum,
   1211                                                                      uint8_t optionsMask,
   1212                                                                      uint8_t optionsOverride)
   1213          {
   \                     emberAfColorControlClusterStepColorTemperatureCallback: (+1)
   \        0x0   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \        0x4   0x4681             MOV      R9,R0
   \        0x6   0x461F             MOV      R7,R3
   1214            uint8_t endpoint = emberAfCurrentEndpoint();
   \        0x8   0x....'....        LDR.W    R0,??DataTable27
   \        0xC   0x6803             LDR      R3,[R0, #+0]
   \        0xE   0x460E             MOV      R6,R1
   \       0x10   0x4615             MOV      R5,R2
   \       0x12   0x681C             LDR      R4,[R3, #+0]
   \       0x14   0x9909             LDR      R1,[SP, #+36]
   \       0x16   0x9A0A             LDR      R2,[SP, #+40]
   \       0x18   0xF894 0xA005      LDRB     R10,[R4, #+5]
   1215          
   1216            if (!shouldExecuteIfOff(endpoint, optionsMask, optionsOverride)) {
   \       0x1C   0x4650             MOV      R0,R10
   \       0x1E   0x....'....        BL       shouldExecuteIfOff
   \       0x22   0xB170             CBZ.N    R0,??emberAfColorControlClusterStepColorTemperatur_0
   1217              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   1218              return true;
   1219            }
   1220          
   1221            uint16_t tempPhysicalMin = readColorTemperatureMin(endpoint);
   \       0x24   0x4650             MOV      R0,R10
   \       0x26   0x....'....        BL       readColorTemperatureMin
   \       0x2A   0x4604             MOV      R4,R0
   1222            uint16_t tempPhysicalMax = readColorTemperatureMax(endpoint);
   \       0x2C   0x4650             MOV      R0,R10
   \       0x2E   0x....'....        BL       readColorTemperatureMax
   \       0x32   0x4680             MOV      R8,R0
   1223          
   1224            if (transitionTime == 0) {
   \       0x34   0xB905             CBNZ.N   R5,??emberAfColorControlClusterStepColorTemperatur_1
   1225              transitionTime++;
   \       0x36   0x2501             MOVS     R5,#+1
   1226            }
   1227          
   1228            // New command.  Need to stop any active transitions.
   1229            stopAllColorTransitions();
   \                     ??emberAfColorControlClusterStepColorTemperatur_1: (+1)
   \       0x38   0x....'....        BL       stopAllColorTransitions
   1230          
   1231            if (stepMode == MOVE_MODE_STOP) {
   \       0x3C   0xF1B9 0x0F00      CMP      R9,#+0
   \       0x40   0xD105             BNE.N    ??emberAfColorControlClusterStepColorTemperatur_2
   1232              emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   \                     ??emberAfColorControlClusterStepColorTemperatur_0: (+1)
   \       0x42   0x2000             MOVS     R0,#+0
   \       0x44   0x....'....        BL       emberAfSendImmediateDefaultResponse
   1233              return true;
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1234            }
   1235          
   1236            if (colorTemperatureMinimum < tempPhysicalMin) {
   \                     ??emberAfColorControlClusterStepColorTemperatur_2: (+1)
   \       0x4E   0x42BC             CMP      R4,R7
   \       0x50   0x9808             LDR      R0,[SP, #+32]
   \       0x52   0xBF38             IT       CC 
   \       0x54   0x463C             MOVCC    R4,R7
   1237              colorTemperatureMinimum = tempPhysicalMin;
   1238            }
   1239            if (colorTemperatureMaximum > tempPhysicalMax) {
   1240              colorTemperatureMaximum = tempPhysicalMax;
   1241            }
   1242          
   1243            // Handle color mode transition, if necessary.
   1244            handleModeSwitch(endpoint, COLOR_MODE_TEMPERATURE);
   \       0x56   0x....'....        LDR.W    R7,??DataTable27_8
   \       0x5A   0x4580             CMP      R8,R0
   \       0x5C   0xBF88             IT       HI 
   \       0x5E   0x4680             MOVHI    R8,R0
   \       0x60   0x2102             MOVS     R1,#+2
   \       0x62   0x4650             MOV      R0,R10
   \       0x64   0x....'....        BL       handleModeSwitch
   1245          
   1246            // now, kick off the state machine.
   1247            colorTempTransitionState.initialValue = readColorTemperature(endpoint);
   \       0x68   0x4650             MOV      R0,R10
   \       0x6A   0x....'....        BL       readColorTemperature
   \       0x6E   0x8038             STRH     R0,[R7, #+0]
   1248            colorTempTransitionState.currentValue = readColorTemperature(endpoint);
   \       0x70   0x4650             MOV      R0,R10
   \       0x72   0x....'....        BL       readColorTemperature
   \       0x76   0x8078             STRH     R0,[R7, #+2]
   1249            if (stepMode == MOVE_MODE_UP) {
   \       0x78   0xF1B9 0x0F01      CMP      R9,#+1
   \       0x7C   0x4650             MOV      R0,R10
   \       0x7E   0xD103             BNE.N    ??emberAfColorControlClusterStepColorTemperatur_3
   1250              colorTempTransitionState.finalValue
   1251                = readColorTemperature(endpoint) + stepSize;
   \       0x80   0x....'....        BL       readColorTemperature
   \       0x84   0x1836             ADDS     R6,R6,R0
   \       0x86   0xE002             B.N      ??emberAfColorControlClusterStepColorTemperatur_4
   1252            } else {
   1253              colorTempTransitionState.finalValue
   1254                = readColorTemperature(endpoint) - stepSize;
   \                     ??emberAfColorControlClusterStepColorTemperatur_3: (+1)
   \       0x88   0x....'....        BL       readColorTemperature
   \       0x8C   0x1B86             SUBS     R6,R0,R6
   \                     ??emberAfColorControlClusterStepColorTemperatur_4: (+1)
   \       0x8E   0x80BE             STRH     R6,[R7, #+4]
   1255            }
   1256            colorTempTransitionState.stepsRemaining = transitionTime;
   \       0x90   0x80FD             STRH     R5,[R7, #+6]
   1257            colorTempTransitionState.stepsTotal     = transitionTime;
   \       0x92   0x813D             STRH     R5,[R7, #+8]
   1258            colorTempTransitionState.endpoint  = endpoint;
   \       0x94   0xF887 0xA00E      STRB     R10,[R7, #+14]
   1259            colorTempTransitionState.lowLimit  = colorTemperatureMinimum;
   \       0x98   0x817C             STRH     R4,[R7, #+10]
   1260            colorTempTransitionState.highLimit = colorTemperatureMaximum;
   \       0x9A   0xF8A7 0x800C      STRH     R8,[R7, #+12]
   1261          
   1262            writeRemainingTime(endpoint, transitionTime);
   \       0x9E   0x4629             MOV      R1,R5
   \       0xA0   0x4650             MOV      R0,R10
   \       0xA2   0x....'....        BL       writeRemainingTime
   1263          
   1264            // kick off the state machine:
   1265            emberEventControlSetDelayMS(COLOR_TEMP_CONTROL, UPDATE_TIME_MS);
   \       0xA6   0x....'....        BL       ?Subroutine23
   \                     ??CrossCallReturnLabel_73: (+1)
   \       0xAA   0xE7CA             B.N      ??emberAfColorControlClusterStepColorTemperatur_0
   1266          
   1267            emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   1268            return true;
   1269          }
   1270          

   \                                 In section .text, align 2, keep-with-next
   1271          void emberAfPluginLevelControlCoupledColorTempChangeCallback(uint8_t endpoint)
   1272          {
   \                     emberAfPluginLevelControlCoupledColorTempChangeCallback: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   1273            // ZCL 5.2.2.1.1 Coupling color temperature to Level Control
   1274            //
   1275            // If the Level Control for Lighting cluster identifier 0x0008 is supported
   1276            // on the same endpoint as the Color Control cluster and color temperature is
   1277            // supported, it is possible to couple changes in the current level to the
   1278            // color temperature.
   1279            //
   1280            // The CoupleColorTempToLevel bit of the Options attribute of the Level
   1281            // Control cluster indicates whether the color temperature is to be linked
   1282            // with the CurrentLevel attribute in the Level Control cluster.
   1283            //
   1284            // If the CoupleColorTempToLevel bit of the Options attribute of the Level
   1285            // Control cluster is equal to 1 and the ColorMode or EnhancedColorMode
   1286            // attribute is set to 0x02 (color temperature) then a change in the
   1287            // CurrentLevel attribute SHALL affect the ColorTemperatureMireds attribute.
   1288            // This relationship is manufacturer specific, with the qualification that
   1289            // the maximum value of the CurrentLevel attribute SHALL correspond to a
   1290            // ColorTemperatureMired attribute value equal to the
   1291            // CoupleColorTempToLevelMinMireds attribute. This relationship is one-way so
   1292            // a change to the ColorTemperatureMireds attribute SHALL NOT have any effect
   1293            // on the CurrentLevel attribute.
   1294            //
   1295            // In order to simulate the behavior of an incandescent bulb, a low value of
   1296            // the CurrentLevel attribute SHALL be associated with a high value of the
   1297            // ColorTemperatureMireds attribute (i.e., a low value of color temperature
   1298            // in kelvins).
   1299            //
   1300            // If the CoupleColorTempToLevel bit of the Options attribute of the Level
   1301            // Control cluster is equal to 0, there SHALL be no link between color
   1302            // temperature and current level.
   1303          
   1304            if (!emberAfContainsServer(endpoint, ZCL_COLOR_CONTROL_CLUSTER_ID)) {
   \        0x4   0xF44F 0x7140      MOV      R1,#+768
   \        0x8   0x....'....        BL       emberAfContainsServer
   \        0xC   0x2800             CMP      R0,#+0
   \        0xE   0xD039             BEQ.N    ??emberAfPluginLevelControlCoupledColorTempChan_0
   1305              return;
   1306            }
   1307          
   1308            if (readColorMode(endpoint) == COLOR_MODE_TEMPERATURE) {
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x....'....        BL       readColorMode
   \       0x16   0x2802             CMP      R0,#+2
   \       0x18   0xD134             BNE.N    ??emberAfPluginLevelControlCoupledColorTempChan_0
   1309              uint16_t tempCoupleMin = readColorTemperatureCoupleToLevelMin(endpoint);
   \       0x1A   0x9000             STR      R0,[SP, #+0]
   \       0x1C   0xF10D 0x0306      ADD      R3,SP,#+6
   \       0x20   0xF244 0x020D      MOVW     R2,#+16397
   \       0x24   0xF44F 0x7140      MOV      R1,#+768
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x....'....        BL       emberAfReadServerAttribute
   \       0x2E   0xB120             CBZ.N    R0,??emberAfPluginLevelControlCoupledColorTempChan_1
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x....'....        BL       readColorTemperatureMin
   \       0x36   0xF8AD 0x0006      STRH     R0,[SP, #+6]
   1310              uint16_t tempPhysMax = readColorTemperatureMax(endpoint);
   \                     ??emberAfPluginLevelControlCoupledColorTempChan_1: (+1)
   \       0x3A   0x....'....        BL       ??Subroutine27_0
   \                     ??CrossCallReturnLabel_88: (+1)
   \       0x3E   0x4605             MOV      R5,R0
   1311              uint8_t currentLevel = readLevelControlCurrentLevel(endpoint);
   \       0x40   0x2001             MOVS     R0,#+1
   \       0x42   0x9000             STR      R0,[SP, #+0]
   \       0x44   0xAB01             ADD      R3,SP,#+4
   \       0x46   0x2200             MOVS     R2,#+0
   \       0x48   0x2108             MOVS     R1,#+8
   \       0x4A   0x4620             MOV      R0,R4
   \       0x4C   0x....'....        BL       emberAfReadServerAttribute
   \       0x50   0xB110             CBZ.N    R0,??emberAfPluginLevelControlCoupledColorTempChan_2
   \       0x52   0x207F             MOVS     R0,#+127
   \       0x54   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \                     ??emberAfPluginLevelControlCoupledColorTempChan_2: (+1)
   \       0x58   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   1312          
   1313              // Scale color temp setting between the coupling min and the physical max.
   1314              // Note that mireds varies inversely with level: low level -> high mireds.
   1315              // Peg min/MAX level to MAX/min mireds, otherwise interpolate.
   1316              uint16_t newColorTemp;
   1317              if (currentLevel <= MIN_CURRENT_LEVEL) {
   \       0x5C   0x2802             CMP      R0,#+2
   \       0x5E   0xDB0C             BLT.N    ??emberAfPluginLevelControlCoupledColorTempChan_3
   1318                newColorTemp = tempPhysMax;
   1319              } else if (currentLevel >= MAX_CURRENT_LEVEL) {
   \       0x60   0x28FE             CMP      R0,#+254
   \       0x62   0xBFA8             IT       GE 
   \       0x64   0xF8BD 0x5006      LDRHGE   R5,[SP, #+6]
   1320                newColorTemp = tempCoupleMin;
   \       0x68   0xDA07             BGE.N    ??emberAfPluginLevelControlCoupledColorTempChan_3
   1321              } else {
   1322                uint32_t tempDelta = (((uint32_t)tempPhysMax - (uint32_t)tempCoupleMin)
   1323                                      * currentLevel)
   1324                                     / (uint32_t)(MAX_CURRENT_LEVEL - MIN_CURRENT_LEVEL + 1);
   1325                newColorTemp = (uint16_t)((uint32_t)tempPhysMax - tempDelta);
   \       0x6A   0xF8BD 0x1006      LDRH     R1,[SP, #+6]
   \       0x6E   0x1A6A             SUBS     R2,R5,R1
   \       0x70   0x4350             MULS     R0,R0,R2
   \       0x72   0x22FE             MOVS     R2,#+254
   \       0x74   0xFBB0 0xF0F2      UDIV     R0,R0,R2
   \       0x78   0x1A2D             SUBS     R5,R5,R0
   1326              }
   1327          
   1328              // Apply new color temp.
   1329              moveToColorTemp(endpoint, newColorTemp, 0);
   \                     ??emberAfPluginLevelControlCoupledColorTempChan_3: (+1)
   \       0x7A   0x2200             MOVS     R2,#+0
   \       0x7C   0xB2A9             UXTH     R1,R5
   \       0x7E   0x4620             MOV      R0,R4
   \       0x80   0x....'....        BL       moveToColorTemp
   1330            }
   1331          }
   \                     ??emberAfPluginLevelControlCoupledColorTempChan_0: (+1)
   \       0x84   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
   1332          
   1333          #endif //#ifdef EMBER_AF_PLUGIN_COLOR_CONTROL_SERVER_TEMP
   1334          

   \                                 In section .text, align 2, keep-with-next
   1335          bool emberAfColorControlClusterStopMoveStepCallback(uint8_t optionsMask,
   1336                                                              uint8_t optionsOverride)
   1337          {
   \                     emberAfColorControlClusterStopMoveStepCallback: (+1)
   \        0x0   0x460A             MOV      R2,R1
   1338            // Received a stop command.  This is all we need to do.
   1339            uint8_t endpoint = emberAfCurrentEndpoint();
   1340          
   1341            if (shouldExecuteIfOff(endpoint, optionsMask, optionsOverride)) {
   \        0x2   0x4601             MOV      R1,R0
   \        0x4   0xB510             PUSH     {R4,LR}
   \        0x6   0x....             LDR.N    R0,??DataTable27
   \        0x8   0x6803             LDR      R3,[R0, #+0]
   \        0xA   0x681C             LDR      R4,[R3, #+0]
   \        0xC   0x7960             LDRB     R0,[R4, #+5]
   \        0xE   0x....'....        BL       shouldExecuteIfOff
   \       0x12   0xB108             CBZ.N    R0,??emberAfColorControlClusterStopMoveStepCallbac_0
   1342              stopAllColorTransitions();
   \       0x14   0x....'....        BL       stopAllColorTransitions
   1343            }
   1344          
   1345            emberAfSendImmediateDefaultResponse(EMBER_ZCL_STATUS_SUCCESS);
   \                     ??emberAfColorControlClusterStopMoveStepCallbac_0: (+1)
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x....'....        BL       emberAfSendImmediateDefaultResponse
   1346            return true;
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0xBD10             POP      {R4,PC}          ;; return
   1347          }
   1348          
   1349          // **************** transition state machines ***********
   1350          

   \                                 In section .text, align 2, keep-with-next
   1351          static void stopAllColorTransitions(void)
   1352          {
   1353            emberEventControlSetInactive(COLOR_TEMP_CONTROL);
   \                     stopAllColorTransitions: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x....             LDR.N    R1,??DataTable27_9
   \        0x4   0x7008             STRB     R0,[R1, #+0]
   1354            emberEventControlSetInactive(COLOR_XY_CONTROL);
   \        0x6   0x....             LDR.N    R3,??DataTable27_7
   \        0x8   0x7018             STRB     R0,[R3, #+0]
   1355            emberEventControlSetInactive(COLOR_HSV_CONTROL);
   \        0xA   0x....             LDR.N    R1,??DataTable27_3
   \        0xC   0x7008             STRB     R0,[R1, #+0]
   1356          }
   \        0xE   0x4770             BX       LR               ;; return
   1357          

   \                                 In section .text, align 2, keep-with-next
   1358          void emberAfPluginColorControlServerStopTransition(void)
   1359          {
   1360            stopAllColorTransitions();
   \                     emberAfPluginColorControlServerStopTransition: (+1)
   \        0x0   0x....             B.N      stopAllColorTransitions
   1361          }
   1362          
   1363          // The specification says that if we are transitioning from one color mode
   1364          // into another, we need to compute the new mode's attribute values from the
   1365          // old mode.  However, it also says that if the old mode doesn't translate into
   1366          // the new mode, this must be avoided.
   1367          // I am putting in this function to compute the new attributes based on the old
   1368          // color mode.

   \                                 In section .text, align 2, keep-with-next
   1369          static void handleModeSwitch(uint8_t endpoint,
   1370                                       uint8_t newColorMode)
   1371          {
   \                     handleModeSwitch: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   1372            uint8_t oldColorMode = readColorMode(endpoint);
   \        0x6   0x....'....        BL       readColorMode
   \        0xA   0x4606             MOV      R6,R0
   1373            uint8_t colorModeTransition;
   1374          
   1375            if (oldColorMode == newColorMode) {
   \        0xC   0x42AE             CMP      R6,R5
   \        0xE   0xD031             BEQ.N    ??handleModeSwitch_0
   1376              return;
   1377            } else {
   1378              writeColorMode(endpoint, newColorMode);
   \       0x10   0x2020             MOVS     R0,#+32
   \       0x12   0x9000             STR      R0,[SP, #+0]
   \       0x14   0xF88D 0x5004      STRB     R5,[SP, #+4]
   \       0x18   0xAB01             ADD      R3,SP,#+4
   \       0x1A   0xF244 0x0201      MOVW     R2,#+16385
   \       0x1E   0xF44F 0x7140      MOV      R1,#+768
   \       0x22   0x4620             MOV      R0,R4
   \       0x24   0x....             LDR.N    R7,??DataTable27_4
   \       0x26   0x....'....        BL       emberAfWriteServerAttribute
   \       0x2A   0xB118             CBZ.N    R0,??CrossCallReturnLabel_44
   \       0x2C   0xF44F 0x7181      MOV      R1,#+258
   \       0x30   0x....'....        BL       ?Subroutine16
   \                     ??CrossCallReturnLabel_44: (+1)
   \       0x34   0x2020             MOVS     R0,#+32
   \       0x36   0x9000             STR      R0,[SP, #+0]
   \       0x38   0xAB01             ADD      R3,SP,#+4
   \       0x3A   0x2208             MOVS     R2,#+8
   \       0x3C   0xF44F 0x7140      MOV      R1,#+768
   \       0x40   0x4620             MOV      R0,R4
   \       0x42   0x....'....        BL       emberAfWriteServerAttribute
   \       0x46   0xB118             CBZ.N    R0,??CrossCallReturnLabel_43
   \       0x48   0xF240 0x1109      MOVW     R1,#+265
   \       0x4C   0x....'....        BL       ?Subroutine16
   1379            }
   1380          
   1381            colorModeTransition = (newColorMode << 4) + oldColorMode;
   1382          
   1383            // Note:  It may be OK to not do anything here.
   1384            switch (colorModeTransition) {
   \                     ??CrossCallReturnLabel_43: (+1)
   \       0x50   0xEB06 0x1605      ADD      R6,R6,R5, LSL #+4
   \       0x54   0xB2F6             UXTB     R6,R6
   \       0x56   0x2E01             CMP      R6,#+1
   \       0x58   0xD009             BEQ.N    ??handleModeSwitch_1
   \       0x5A   0x2E02             CMP      R6,#+2
   \       0x5C   0xD00C             BEQ.N    ??handleModeSwitch_2
   \       0x5E   0x2E10             CMP      R6,#+16
   \       0x60   0xD009             BEQ.N    ??handleModeSwitch_3
   \       0x62   0x2E12             CMP      R6,#+18
   \       0x64   0xD008             BEQ.N    ??handleModeSwitch_2
   \       0x66   0x2E20             CMP      R6,#+32
   \       0x68   0xD005             BEQ.N    ??handleModeSwitch_3
   \       0x6A   0x2E21             CMP      R6,#+33
   \       0x6C   0xD102             BNE.N    ??handleModeSwitch_0
   1385              case HSV_TO_CIE_XY:
   1386                emberAfPluginColorControlServerComputePwmFromXyCallback(endpoint);
   1387                break;
   1388              case TEMPERATURE_TO_CIE_XY:
   1389                emberAfPluginColorControlServerComputePwmFromXyCallback(endpoint);
   \                     ??handleModeSwitch_1: (+1)
   \       0x6E   0x4620             MOV      R0,R4
   \       0x70   0x....'....        BL       emberAfPluginColorControlServerComputePwmFromXyCallback
   1390                break;
   1391              case CIE_XY_TO_HSV:
   1392                emberAfPluginColorControlServerComputePwmFromHsvCallback(endpoint);
   1393                break;
   1394              case TEMPERATURE_TO_HSV:
   1395                emberAfPluginColorControlServerComputePwmFromHsvCallback(endpoint);
   1396                break;
   1397              case HSV_TO_TEMPERATURE:
   1398                emberAfPluginColorControlServerComputePwmFromTempCallback(endpoint);
   1399                break;
   1400              case CIE_XY_TO_TEMPERATURE:
   1401                emberAfPluginColorControlServerComputePwmFromTempCallback(endpoint);
   1402                break;
   1403          
   1404              // for the following cases, there is no transition.
   1405              case HSV_TO_HSV:
   1406              case CIE_XY_TO_CIE_XY:
   1407              case TEMPERATURE_TO_TEMPERATURE:
   1408              default:
   1409                return;
   1410            }
   1411          }
   \                     ??handleModeSwitch_0: (+1)
   \       0x74   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
   \                     ??handleModeSwitch_3: (+1)
   \       0x76   0x....             B.N      ?Subroutine5
   \                     ??handleModeSwitch_2: (+1)
   \       0x78   0x4620             MOV      R0,R4
   \       0x7A   0x....'....        BL       emberAfPluginColorControlServerComputePwmFromTempCallback
   \       0x7E   0xBDF7             POP      {R0-R2,R4-R7,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x4620             MOV      R0,R4
   \        0x2   0x....'....        BL       emberAfPluginColorControlServerComputePwmFromHsvCallback
   \        0x6   0xBDF7             POP      {R0-R2,R4-R7,PC}
   1412          

   \                                 In section .text, align 2, keep-with-next
   1413          static uint8_t addHue(uint8_t hue1, uint8_t hue2)
   1414          {
   1415            uint16_t hue16;
   1416          
   1417            hue16 =  ((uint16_t) hue1);
   1418            hue16 += ((uint16_t) hue2);
   \                     addHue: (+1)
   \        0x0   0x1808             ADDS     R0,R1,R0
   \        0x2   0xB280             UXTH     R0,R0
   1419          
   1420            if (hue16 > MAX_HUE_VALUE) {
   \        0x4   0x28FF             CMP      R0,#+255
   \        0x6   0xBFA8             IT       GE 
   \        0x8   0x38FE             SUBGE    R0,R0,#+254
   1421              hue16 -= MAX_HUE_VALUE;
   1422            }
   1423          
   1424            return ((uint8_t) hue16);
   \        0xA   0xB2C0             UXTB     R0,R0
   \        0xC   0x4770             BX       LR               ;; return
   1425          }
   1426          

   \                                 In section .text, align 2, keep-with-next
   1427          static uint8_t subtractHue(uint8_t hue1, uint8_t hue2)
   1428          {
   1429            uint16_t hue16;
   1430          
   1431            hue16 =  ((uint16_t) hue1);
   \                     subtractHue: (+1)
   \        0x0   0x4602             MOV      R2,R0
   1432            if (hue2 > hue1) {
   \        0x2   0x4288             CMP      R0,R1
   \        0x4   0xBF38             IT       CC 
   \        0x6   0x32FE             ADDCC    R2,R2,#+254
   1433              hue16 += MAX_HUE_VALUE;
   1434            }
   1435          
   1436            hue16 -= ((uint16_t) hue2);
   1437          
   1438            return ((uint8_t) hue16);
   \        0x8   0x1A51             SUBS     R1,R2,R1
   \        0xA   0xB2C8             UXTB     R0,R1
   \        0xC   0x4770             BX       LR               ;; return
   1439          }
   1440          

   \                                 In section .text, align 2, keep-with-next
   1441          static bool computeNewHueValue(ColorHueTransitionState *p)
   1442          {
   \                     computeNewHueValue: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
   1443            uint32_t newHue32;
   1444            uint8_t newHue;
   1445          
   1446            // exit with a false if hue is not currently moving
   1447            if (p->stepsRemaining == 0) {
   \        0x4   0x88A0             LDRH     R0,[R4, #+4]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD040             BEQ.N    ??computeNewHueValue_0
   1448              return false;
   1449            }
   1450          
   1451            (p->stepsRemaining)--;
   \        0xA   0x1E41             SUBS     R1,R0,#+1
   1452          
   1453            if (p->repeat == false) {
   \        0xC   0x7AA0             LDRB     R0,[R4, #+10]
   \        0xE   0x80A1             STRH     R1,[R4, #+4]
   \       0x10   0xB918             CBNZ.N   R0,??computeNewHueValue_1
   1454              writeRemainingTime(p->endpoint, p->stepsRemaining);
   \       0x12   0x7A20             LDRB     R0,[R4, #+8]
   \       0x14   0xB289             UXTH     R1,R1
   \       0x16   0x....'....        BL       writeRemainingTime
   1455            }
   1456          
   1457            // are we going up or down?
   1458            if (p->finalHue == p->currentHue) {
   \                     ??computeNewHueValue_1: (+1)
   \       0x1A   0x78A3             LDRB     R3,[R4, #+2]
   \       0x1C   0x7860             LDRB     R0,[R4, #+1]
   \       0x1E   0x4283             CMP      R3,R0
   \       0x20   0xD014             BEQ.N    ??computeNewHueValue_2
   1459              // do nothing
   1460            } else if (p->up) {
   \       0x22   0x7A60             LDRB     R0,[R4, #+9]
   \       0x24   0x7822             LDRB     R2,[R4, #+0]
   \       0x26   0xB140             CBZ.N    R0,??computeNewHueValue_3
   1461              newHue32 = (uint32_t) subtractHue(p->finalHue, p->initialHue);
   \       0x28   0x4611             MOV      R1,R2
   \       0x2A   0x4618             MOV      R0,R3
   \       0x2C   0x....'....        BL       subtractHue
   1462              newHue32 *= ((uint32_t) (p->stepsRemaining));
   1463              newHue32 /= ((uint32_t) (p->stepsTotal));
   1464              p->currentHue = subtractHue((uint8_t) p->finalHue,
   1465                                          (uint8_t) newHue32);
   \       0x30   0x....'....        BL       ?Subroutine29
   1466            } else {
   \                     ??CrossCallReturnLabel_94: (+1)
   \       0x34   0x....'....        BL       subtractHue
   \       0x38   0xE007             B.N      ??computeNewHueValue_4
   1467              newHue32 = (uint32_t) subtractHue(p->initialHue, p->finalHue);
   \                     ??computeNewHueValue_3: (+1)
   \       0x3A   0x4619             MOV      R1,R3
   \       0x3C   0x4610             MOV      R0,R2
   \       0x3E   0x....'....        BL       subtractHue
   1468              newHue32 *= ((uint32_t) (p->stepsRemaining));
   1469              newHue32 /= ((uint32_t) (p->stepsTotal));
   1470          
   1471              p->currentHue = addHue((uint8_t) p->finalHue,
   1472                                     (uint8_t) newHue32);
   \       0x42   0x....'....        BL       ?Subroutine29
   1473            }
   \                     ??CrossCallReturnLabel_95: (+1)
   \       0x46   0x....'....        BL       addHue
   \                     ??computeNewHueValue_4: (+1)
   \       0x4A   0x7060             STRB     R0,[R4, #+1]
   1474          
   1475            if (p->stepsRemaining == 0) {
   \                     ??computeNewHueValue_2: (+1)
   \       0x4C   0x88A0             LDRH     R0,[R4, #+4]
   \       0x4E   0xB9E8             CBNZ.N   R0,??computeNewHueValue_0
   1476              if (p->repeat == false) {
   \       0x50   0x7AA0             LDRB     R0,[R4, #+10]
   \       0x52   0xB908             CBNZ.N   R0,??computeNewHueValue_5
   1477                // we are performing a move to and not a move.
   1478                return true;
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0xBD10             POP      {R4,PC}
   1479              } else {
   1480                // we are performing a Hue move.  Need to compute the new values for the
   1481                // next move period.
   1482                if (p->up) {
   \                     ??computeNewHueValue_5: (+1)
   \       0x58   0x7A60             LDRB     R0,[R4, #+9]
   \       0x5A   0x78A3             LDRB     R3,[R4, #+2]
   \       0x5C   0x7822             LDRB     R2,[R4, #+0]
   \       0x5E   0xB140             CBZ.N    R0,??computeNewHueValue_6
   1483                  newHue = subtractHue(p->finalHue, p->initialHue);
   \       0x60   0x4611             MOV      R1,R2
   \       0x62   0x4618             MOV      R0,R3
   \       0x64   0x....'....        BL       subtractHue
   1484                  newHue = addHue(p->finalHue, newHue);
   \       0x68   0x4601             MOV      R1,R0
   \       0x6A   0x78A0             LDRB     R0,[R4, #+2]
   \       0x6C   0x....'....        BL       addHue
   1485          
   1486                  p->initialHue = p->finalHue;
   \       0x70   0xE007             B.N      ??computeNewHueValue_7
   1487                  p->finalHue = newHue;
   1488                } else {
   1489                  newHue = subtractHue(p->initialHue, p->finalHue);
   \                     ??computeNewHueValue_6: (+1)
   \       0x72   0x4619             MOV      R1,R3
   \       0x74   0x4610             MOV      R0,R2
   \       0x76   0x....'....        BL       subtractHue
   1490                  newHue = subtractHue(p->finalHue, newHue);
   \       0x7A   0x4601             MOV      R1,R0
   \       0x7C   0x78A0             LDRB     R0,[R4, #+2]
   \       0x7E   0x....'....        BL       subtractHue
   1491          
   1492                  p->initialHue = p->finalHue;
   \                     ??computeNewHueValue_7: (+1)
   \       0x82   0x78A1             LDRB     R1,[R4, #+2]
   1493                  p->finalHue = newHue;
   \       0x84   0x70A0             STRB     R0,[R4, #+2]
   1494                }
   1495                p->stepsRemaining = TRANSITION_TIME_1S;
   \       0x86   0x200A             MOVS     R0,#+10
   \       0x88   0x7021             STRB     R1,[R4, #+0]
   \       0x8A   0x80A0             STRH     R0,[R4, #+4]
   1496              }
   1497            }
   1498            return false;
   \                     ??computeNewHueValue_0: (+1)
   \       0x8C   0x2000             MOVS     R0,#+0
   \       0x8E   0xBD10             POP      {R4,PC}          ;; return
   1499          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine29: (+1)
   \        0x0   0x88A1             LDRH     R1,[R4, #+4]
   \        0x2   0x88E2             LDRH     R2,[R4, #+6]
   \        0x4   0x4348             MULS     R0,R1,R0
   \        0x6   0xFBB0 0xF1F2      UDIV     R1,R0,R2
   \        0xA   0x78A0             LDRB     R0,[R4, #+2]
   \        0xC   0xB2C9             UXTB     R1,R1
   \        0xE   0x4770             BX       LR
   1500          

   \                                 In section .text, align 2, keep-with-next
   1501          void emberAfPluginColorControlServerHueSatTransitionEventHandler(void)
   1502          {
   \                     emberAfPluginColorControlServerHueSatTransitionEventHandler: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   1503            uint8_t endpoint = colorHueTransitionState.endpoint;
   \        0x2   0x....             LDR.N    R6,??DataTable27_1
   \        0x4   0x7A34             LDRB     R4,[R6, #+8]
   1504            boolean limitReached1, limitReached2;
   1505          
   1506            limitReached1 = computeNewHueValue(&colorHueTransitionState);
   \        0x6   0x4630             MOV      R0,R6
   \        0x8   0x....'....        BL       computeNewHueValue
   \        0xC   0x4607             MOV      R7,R0
   1507            limitReached2 = computeNewColor16uValue(&colorSaturationTransitionState);
   1508          
   1509            if (limitReached1 || limitReached2) {
   \        0xE   0x....             LDR.N    R5,??DataTable27_2
   \       0x10   0x4628             MOV      R0,R5
   \       0x12   0x....'....        BL       computeNewColor16uValue
   \       0x16   0x4307             ORRS     R7,R0,R7
   \       0x18   0xD002             BEQ.N    ??emberAfPluginColorControlServerHueSatTransiti_0
   1510              stopAllColorTransitions();
   \       0x1A   0x....'....        BL       stopAllColorTransitions
   \       0x1E   0xE001             B.N      ??CrossCallReturnLabel_60
   1511            } else {
   1512              emberEventControlSetDelayMS(COLOR_HSV_CONTROL, UPDATE_TIME_MS);
   \                     ??emberAfPluginColorControlServerHueSatTransiti_0: (+1)
   \       0x20   0x....'....        BL       ?Subroutine21
   1513            }
   1514          
   1515            writeHue(colorHueTransitionState.endpoint,
   1516                     colorHueTransitionState.currentHue);
   \                     ??CrossCallReturnLabel_60: (+1)
   \       0x24   0x7870             LDRB     R0,[R6, #+1]
   \       0x26   0x2120             MOVS     R1,#+32
   \       0x28   0x9100             STR      R1,[SP, #+0]
   \       0x2A   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \       0x2E   0x7A30             LDRB     R0,[R6, #+8]
   \       0x30   0xAB01             ADD      R3,SP,#+4
   \       0x32   0x2200             MOVS     R2,#+0
   \       0x34   0x....'....        BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x38   0xB118             CBZ.N    R0,??CrossCallReturnLabel_42
   \       0x3A   0xF240 0x1113      MOVW     R1,#+275
   \       0x3E   0x....'....        BL       ?Subroutine16
   1517            writeSaturation(colorSaturationTransitionState.endpoint,
   1518                            (uint8_t) colorSaturationTransitionState.currentValue);
   \                     ??CrossCallReturnLabel_42: (+1)
   \       0x42   0x8868             LDRH     R0,[R5, #+2]
   \       0x44   0x2120             MOVS     R1,#+32
   \       0x46   0x9100             STR      R1,[SP, #+0]
   \       0x48   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \       0x4C   0x7BA8             LDRB     R0,[R5, #+14]
   \       0x4E   0xAB01             ADD      R3,SP,#+4
   \       0x50   0x2201             MOVS     R2,#+1
   \       0x52   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x56   0xB118             CBZ.N    R0,??CrossCallReturnLabel_41
   \       0x58   0xF240 0x111D      MOVW     R1,#+285
   \       0x5C   0x....'....        BL       ?Subroutine16
   1519          
   1520            emberAfColorControlClusterPrintln("Hue %d Saturation %d endpoint %d",
   1521                                              colorHueTransitionState.currentHue,
   1522                                              colorSaturationTransitionState.currentValue,
   1523                                              endpoint);
   1524          
   1525            emberAfPluginColorControlServerComputePwmFromHsvCallback(endpoint);
   \                     ??CrossCallReturnLabel_41: (+1)
   \       0x60                      REQUIRE ?Subroutine5
   \       0x60                      ;; // Fall through to label ?Subroutine5
   1526          }
   1527          
   1528          // Return value of true means we need to stop.

   \                                 In section .text, align 2, keep-with-next
   1529          static bool computeNewColor16uValue(Color16uTransitionState *p)
   1530          {
   \                     computeNewColor16uValue: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   1531            uint32_t newValue32u;
   1532          
   1533            if (p->stepsRemaining == 0) {
   \        0x4   0x88E0             LDRH     R0,[R4, #+6]
   \        0x6   0xB1F8             CBZ.N    R0,??computeNewColor16uValue_0
   1534              return false;
   1535            }
   1536          
   1537            (p->stepsRemaining)--;
   \        0x8   0x1E41             SUBS     R1,R0,#+1
   1538          
   1539            writeRemainingTime(p->endpoint, p->stepsRemaining);
   \        0xA   0x7BA0             LDRB     R0,[R4, #+14]
   \        0xC   0x80E1             STRH     R1,[R4, #+6]
   \        0xE   0xB289             UXTH     R1,R1
   \       0x10   0x....'....        BL       writeRemainingTime
   1540          
   1541            // handle sign
   1542            if (p->finalValue == p->currentValue) {
   \       0x14   0x88A2             LDRH     R2,[R4, #+4]
   \       0x16   0x8860             LDRH     R0,[R4, #+2]
   \       0x18   0x88E1             LDRH     R1,[R4, #+6]
   \       0x1A   0x4282             CMP      R2,R0
   \       0x1C   0xD011             BEQ.N    ??computeNewColor16uValue_1
   1543              // do nothing
   1544            } else if (p->finalValue > p->initialValue) {
   \       0x1E   0x8826             LDRH     R6,[R4, #+0]
   \       0x20   0x8920             LDRH     R0,[R4, #+8]
   \       0x22   0x4296             CMP      R6,R2
   \       0x24   0xD206             BCS.N    ??computeNewColor16uValue_2
   1545              newValue32u = ((uint32_t) (p->finalValue - p->initialValue));
   1546              newValue32u *= ((uint32_t) (p->stepsRemaining));
   1547              newValue32u /= ((uint32_t) (p->stepsTotal));
   1548              p->currentValue = p->finalValue - ((uint16_t) (newValue32u));
   \       0x26   0x1B95             SUBS     R5,R2,R6
   \       0x28   0xFB01 0xF305      MUL      R3,R1,R5
   \       0x2C   0xFBB3 0xF0F0      UDIV     R0,R3,R0
   \       0x30   0x1A12             SUBS     R2,R2,R0
   \       0x32   0xE005             B.N      ??computeNewColor16uValue_3
   1549            } else {
   1550              newValue32u = ((uint32_t) (p->initialValue - p->finalValue));
   1551              newValue32u *= ((uint32_t) (p->stepsRemaining));
   1552              newValue32u /= ((uint32_t) (p->stepsTotal));
   1553              p->currentValue = p->finalValue + ((uint16_t) (newValue32u));
   \                     ??computeNewColor16uValue_2: (+1)
   \       0x34   0x1AB5             SUBS     R5,R6,R2
   \       0x36   0xFB01 0xF305      MUL      R3,R1,R5
   \       0x3A   0xFBB3 0xF0F0      UDIV     R0,R3,R0
   \       0x3E   0x1882             ADDS     R2,R0,R2
   \                     ??computeNewColor16uValue_3: (+1)
   \       0x40   0x8062             STRH     R2,[R4, #+2]
   1554            }
   1555          
   1556            if (p->stepsRemaining == 0) {
   \                     ??computeNewColor16uValue_1: (+1)
   \       0x42   0x1E48             SUBS     R0,R1,#+1
   \       0x44   0x4180             SBCS     R0,R0,R0
   \       0x46   0x0FC0             LSRS     R0,R0,#+31
   1557              // we have completed our move.
   1558              return true;
   \                     ??computeNewColor16uValue_0: (+1)
   \       0x48   0xBD70             POP      {R4-R6,PC}       ;; return
   1559            }
   1560          
   1561            return false;
   1562          }
   1563          

   \                                 In section .text, align 2, keep-with-next
   1564          static uint16_t computeTransitionTimeFromStateAndRate(Color16uTransitionState *p,
   1565                                                                uint16_t rate)
   1566          {
   \                     computeTransitionTimeFromStateAndRate: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   1567            uint32_t transitionTime;
   1568            uint16_t max, min;
   1569          
   1570            if (rate == 0) {
   \        0x2   0xF64F 0x72FF      MOVW     R2,#+65535
   \        0x6   0x000B             MOVS     R3,R1
   \        0x8   0xD00E             BEQ.N    ??computeTransitionTimeFromStateAndRate_0
   1571              return MAX_INT16U_VALUE;
   1572            }
   1573          
   1574            if (p->currentValue > p->finalValue) {
   \        0xA   0x8843             LDRH     R3,[R0, #+2]
   \        0xC   0x8880             LDRH     R0,[R0, #+4]
   \        0xE   0x4298             CMP      R0,R3
   \       0x10   0xBF3A             ITTE     CC 
   \       0x12   0x461C             MOVCC    R4,R3
   \       0x14   0x4603             MOVCC    R3,R0
   \       0x16   0x4604             MOVCS    R4,R0
   1575              max = p->currentValue;
   1576              min = p->finalValue;
   1577            } else {
   1578              max = p->finalValue;
   1579              min = p->currentValue;
   1580            }
   1581          
   1582            transitionTime = max - min;
   1583            transitionTime *= 10;
   1584            transitionTime /= rate;
   \       0x18   0x1AE3             SUBS     R3,R4,R3
   \       0x1A   0x200A             MOVS     R0,#+10
   \       0x1C   0x4343             MULS     R3,R0,R3
   \       0x1E   0xFBB3 0xF0F1      UDIV     R0,R3,R1
   1585          
   1586            if (transitionTime > MAX_INT16U_VALUE) {
   \       0x22   0xF5B0 0x3F80      CMP      R0,#+65536
   \       0x26   0xD301             BCC.N    ??computeTransitionTimeFromStateAndRate_1
   1587              return MAX_INT16U_VALUE;
   \                     ??computeTransitionTimeFromStateAndRate_0: (+1)
   \       0x28   0x4610             MOV      R0,R2
   \       0x2A   0xBD10             POP      {R4,PC}
   1588            }
   1589          
   1590            return (uint16_t) transitionTime;
   \                     ??computeTransitionTimeFromStateAndRate_1: (+1)
   \       0x2C   0xB280             UXTH     R0,R0
   \       0x2E   0xBD10             POP      {R4,PC}          ;; return
   1591          }
   1592          

   \                                 In section .text, align 2, keep-with-next
   1593          void emberAfPluginColorControlServerXyTransitionEventHandler(void)
   1594          {
   \                     emberAfPluginColorControlServerXyTransitionEventHandler: (+1)
   \        0x0   0xB5FE             PUSH     {R1-R7,LR}
   1595            uint8_t endpoint = colorXTransitionState.endpoint;
   \        0x2   0x....             LDR.N    R4,??DataTable27_5
   \        0x4   0x7BA5             LDRB     R5,[R4, #+14]
   1596            boolean limitReachedX, limitReachedY;
   1597          
   1598            // compute new values for X and Y.
   1599            limitReachedX = computeNewColor16uValue(&colorXTransitionState);
   \        0x6   0x4620             MOV      R0,R4
   \        0x8   0x....'....        BL       computeNewColor16uValue
   \        0xC   0x4607             MOV      R7,R0
   1600          
   1601            limitReachedY = computeNewColor16uValue(&colorYTransitionState);
   1602          
   1603            if (limitReachedX || limitReachedY) {
   \        0xE   0x....             LDR.N    R6,??DataTable27_6
   \       0x10   0x4630             MOV      R0,R6
   \       0x12   0x....'....        BL       computeNewColor16uValue
   \       0x16   0x4307             ORRS     R7,R0,R7
   \       0x18   0xD002             BEQ.N    ??emberAfPluginColorControlServerXyTransitionEv_0
   1604              stopAllColorTransitions();
   \       0x1A   0x....'....        BL       stopAllColorTransitions
   \       0x1E   0xE001             B.N      ??CrossCallReturnLabel_68
   1605            } else {
   1606              emberEventControlSetDelayMS(COLOR_XY_CONTROL, UPDATE_TIME_MS);
   \                     ??emberAfPluginColorControlServerXyTransitionEv_0: (+1)
   \       0x20   0x....'....        BL       ?Subroutine22
   1607            }
   1608          
   1609            // update the attributes
   1610            writeColorX(colorXTransitionState.endpoint,
   1611                        colorXTransitionState.currentValue);
   \                     ??CrossCallReturnLabel_68: (+1)
   \       0x24   0x....'....        BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x28   0x2203             MOVS     R2,#+3
   \       0x2A   0x....'....        BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x2E   0xB118             CBZ.N    R0,??CrossCallReturnLabel_40
   \       0x30   0xF240 0x1127      MOVW     R1,#+295
   \       0x34   0x....'....        BL       ?Subroutine16
   1612            writeColorY(colorXTransitionState.endpoint,
   1613                        colorYTransitionState.currentValue);
   \                     ??CrossCallReturnLabel_40: (+1)
   \       0x38   0x8870             LDRH     R0,[R6, #+2]
   \       0x3A   0x....'....        BL       ??Subroutine9_0
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x3E   0x2204             MOVS     R2,#+4
   \       0x40   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x44   0xB118             CBZ.N    R0,??CrossCallReturnLabel_39
   \       0x46   0xF240 0x1131      MOVW     R1,#+305
   \       0x4A   0x....'....        BL       ?Subroutine16
   1614          
   1615            emberAfColorControlClusterPrintln("Color X %d Color Y %d",
   1616                                              colorXTransitionState.currentValue,
   1617                                              colorYTransitionState.currentValue);
   1618          
   1619            emberAfPluginColorControlServerComputePwmFromXyCallback(endpoint);
   \                     ??CrossCallReturnLabel_39: (+1)
   \       0x4E   0x4628             MOV      R0,R5
   \       0x50   0x....'....        BL       emberAfPluginColorControlServerComputePwmFromXyCallback
   1620          }
   \       0x54   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x8860             LDRH     R0,[R4, #+2]
   \                     ??Subroutine9_0: (+1)
   \        0x2   0x2121             MOVS     R1,#+33
   \        0x4   0x9100             STR      R1,[SP, #+0]
   \        0x6   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \        0xA   0x7BA0             LDRB     R0,[R4, #+14]
   \        0xC   0xAB01             ADD      R3,SP,#+4
   \        0xE   0x4770             BX       LR
   1621          

   \                                 In section .text, align 2, keep-with-next
   1622          void emberAfPluginColorControlServerTempTransitionEventHandler(void)
   1623          {
   \                     emberAfPluginColorControlServerTempTransitionEventHandler: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   1624            uint8_t endpoint = colorTempTransitionState.endpoint;
   \        0x2   0x....             LDR.N    R4,??DataTable27_8
   \        0x4   0x7BA5             LDRB     R5,[R4, #+14]
   1625            boolean limitReached;
   1626          
   1627            limitReached = computeNewColor16uValue(&colorTempTransitionState);
   1628          
   1629            if (limitReached) {
   \        0x6   0x4620             MOV      R0,R4
   \        0x8   0x....'....        BL       computeNewColor16uValue
   \        0xC   0xB110             CBZ.N    R0,??emberAfPluginColorControlServerTempTransition_0
   1630              stopAllColorTransitions();
   \        0xE   0x....'....        BL       stopAllColorTransitions
   \       0x12   0xE001             B.N      ??CrossCallReturnLabel_72
   1631            } else {
   1632              emberEventControlSetDelayMS(COLOR_TEMP_CONTROL, UPDATE_TIME_MS);
   \                     ??emberAfPluginColorControlServerTempTransition_0: (+1)
   \       0x14   0x....'....        BL       ?Subroutine23
   1633            }
   1634          
   1635            writeColorTemperature(colorTempTransitionState.endpoint,
   1636                                  colorTempTransitionState.currentValue);
   \                     ??CrossCallReturnLabel_72: (+1)
   \       0x18   0x....'....        BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x1C   0x2207             MOVS     R2,#+7
   \       0x1E   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x22   0xB118             CBZ.N    R0,??CrossCallReturnLabel_22
   \       0x24   0xF240 0x113B      MOVW     R1,#+315
   \       0x28   0x....'....        BL       ?Subroutine12
   1637          
   1638            emberAfColorControlClusterPrintln("Color Temperature %d",
   1639                                              colorTempTransitionState.currentValue);
   1640          
   1641            emberAfPluginColorControlServerComputePwmFromTempCallback(endpoint);
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0x....'....        BL       emberAfPluginColorControlServerComputePwmFromTempCallback
   1642          }
   \       0x32   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
   1643          

   \                                 In section .text, align 2, keep-with-next
   1644          static bool shouldExecuteIfOff(uint8_t endpoint,
   1645                                         uint8_t optionMask,
   1646                                         uint8_t optionOverride)
   1647          {
   \                     shouldExecuteIfOff: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x460C             MOV      R4,R1
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x4615             MOV      R5,R2
   1648            // From 5.2.2.2.1.10 of ZCL7 document 14-0129-15f-zcl-ch-5-lighting.docx:
   1649            //   "Command execution SHALL NOT continue beyond the Options processing if
   1650            //    all of these criteria are true:
   1651            //      - The On/Off cluster exists on the same endpoint as this cluster.
   1652            //      - The OnOff attribute of the On/Off cluster, on this endpoint, is 0x00
   1653            //        (FALSE).
   1654            //      - The value of the ExecuteIfOff bit is 0."
   1655          
   1656            if (!emberAfContainsServer(endpoint, ZCL_ON_OFF_CLUSTER_ID)) {
   \        0x8   0x2106             MOVS     R1,#+6
   \        0xA   0x....'....        BL       emberAfContainsServer
   \        0xE   0xB1D8             CBZ.N    R0,??shouldExecuteIfOff_0
   1657              return true;
   1658            }
   1659          
   1660            uint8_t options;
   1661            EmberAfStatus status = emberAfReadServerAttribute(endpoint,
   1662                                                              ZCL_COLOR_CONTROL_CLUSTER_ID,
   1663                                                              ZCL_OPTIONS_ATTRIBUTE_ID,
   1664                                                              &options,
   1665                                                              sizeof(options));
   1666            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \       0x10   0x2001             MOVS     R0,#+1
   \       0x12   0x9000             STR      R0,[SP, #+0]
   \       0x14   0xAB01             ADD      R3,SP,#+4
   \       0x16   0x220F             MOVS     R2,#+15
   \       0x18   0xF44F 0x7140      MOV      R1,#+768
   \       0x1C   0x4630             MOV      R0,R6
   \       0x1E   0x....'....        BL       emberAfReadServerAttribute
   \       0x22   0xB110             CBZ.N    R0,??shouldExecuteIfOff_1
   1667              emberAfColorControlClusterPrintln("Unable to read Options attribute: 0x%X",
   1668                                                status);
   1669              // If we can't read the attribute, then we should just assume that it has
   1670              // its default value.
   1671              options = 0x00;
   \       0x24   0x2000             MOVS     R0,#+0
   \       0x26   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1672            }
   1673          
   1674            bool on;
   1675            status = emberAfReadServerAttribute(endpoint,
   1676                                                ZCL_ON_OFF_CLUSTER_ID,
   1677                                                ZCL_ON_OFF_ATTRIBUTE_ID,
   1678                                                (uint8_t *)&on,
   1679                                                sizeof(on));
   1680            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \                     ??shouldExecuteIfOff_1: (+1)
   \       0x2A   0x2101             MOVS     R1,#+1
   \       0x2C   0x9100             STR      R1,[SP, #+0]
   \       0x2E   0xF10D 0x0305      ADD      R3,SP,#+5
   \       0x32   0x2200             MOVS     R2,#+0
   \       0x34   0x2106             MOVS     R1,#+6
   \       0x36   0x4630             MOV      R0,R6
   \       0x38   0x....'....        BL       emberAfReadServerAttribute
   \       0x3C   0x2800             CMP      R0,#+0
   \       0x3E   0xBF04             ITT      EQ 
   \       0x40   0xF89D 0x0005      LDRBEQ   R0,[SP, #+5]
   \       0x44   0x2800             CMPEQ    R0,#+0
   1681              emberAfColorControlClusterPrintln("Unable to read OnOff attribute: 0x%X",
   1682                                                status);
   1683              return true;
   1684            }
   1685            // The device is on - hence ExecuteIfOff does not matter
   1686            if (on) {
   \       0x46   0xD001             BEQ.N    ??shouldExecuteIfOff_2
   1687              return true;
   \                     ??shouldExecuteIfOff_0: (+1)
   \       0x48   0x2001             MOVS     R0,#+1
   \       0x4A   0xBD76             POP      {R1,R2,R4-R6,PC}
   1688            }
   1689            // The OptionsMask & OptionsOverride fields SHALL both be present or both
   1690            // omitted in the command. A temporary Options bitmap SHALL be created from
   1691            // the Options attribute, using the OptionsMask & OptionsOverride fields, if
   1692            // present. Each bit of the temporary Options bitmap SHALL be determined as
   1693            // follows:
   1694            // Each bit in the Options attribute SHALL determine the corresponding bit in
   1695            // the temporary Options bitmap, unless the OptionsMask field is present and
   1696            // has the corresponding bit set to 1, in which case the corresponding bit in
   1697            // the OptionsOverride field SHALL determine the corresponding bit in the
   1698            // temporary Options bitmap.
   1699            //The resulting temporary Options bitmap SHALL then be processed as defined
   1700            // in section 5.2.2.2.1.10.
   1701          
   1702            // ---------- The following order is important in decision making -------
   1703            // -----------more readable ----------
   1704            //
   1705            if (optionMask == 0xFF && optionOverride == 0xFF) {
   \                     ??shouldExecuteIfOff_2: (+1)
   \       0x4C   0x2CFF             CMP      R4,#+255
   \       0x4E   0xBF08             IT       EQ 
   \       0x50   0x2DFF             CMPEQ    R5,#+255
   \       0x52   0xD004             BEQ.N    ??shouldExecuteIfOff_3
   1706              // 0xFF are the default values passed to the command handler when
   1707              // the payload is not present - in that case there is use of option
   1708              // attribute to decide execution of the command
   1709              return READBITS(options, EMBER_ZCL_COLOR_CONTROL_OPTIONS_EXECUTE_IF_OFF);
   1710            }
   1711            // ---------- The above is to distinguish if the payload is present or not
   1712          
   1713            if (READBITS(optionMask, EMBER_ZCL_COLOR_CONTROL_OPTIONS_EXECUTE_IF_OFF)) {
   \       0x54   0x07E0             LSLS     R0,R4,#+31
   \       0x56   0xD502             BPL.N    ??shouldExecuteIfOff_3
   1714              // Mask is present and set in the command payload, this indicates
   1715              // use the override as temporary option
   1716              return READBITS(optionOverride, EMBER_ZCL_COLOR_CONTROL_OPTIONS_EXECUTE_IF_OFF);
   \       0x58   0xF005 0x0001      AND      R0,R5,#0x1
   \       0x5C   0xBD76             POP      {R1,R2,R4-R6,PC}
   1717            }
   1718            // if we are here - use the option attribute bits
   1719            return (READBITS(options, EMBER_ZCL_COLOR_CONTROL_OPTIONS_EXECUTE_IF_OFF));
   \                     ??shouldExecuteIfOff_3: (+1)
   \       0x5E   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x62   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x66   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   1720          }
   1721          

   \                                 In section .text, align 2, keep-with-next
   1722          void emberAfColorControlClusterServerInitCallback(uint8_t endpoint)
   1723          {
   \                     emberAfColorControlClusterServerInitCallback: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
   1724          #ifdef EMBER_AF_PLUGIN_COLOR_CONTROL_SERVER_TEMP
   1725            // 07-5123-07 (i.e. ZCL 7) 5.2.2.2.1.22 StartUpColorTemperatureMireds Attribute
   1726            // The StartUpColorTemperatureMireds attribute SHALL define the desired startup color
   1727            // temperature values a lamp SHAL use when it is supplied with power and this value SHALL
   1728            // be reflected in the ColorTemperatureMireds attribute. In addition, the ColorMode and
   1729            // EnhancedColorMode attributes SHALL be set to 0x02 (color temperature). The values of
   1730            // the StartUpColorTemperatureMireds attribute are listed in the table below.
   1731            // Value                Action on power up
   1732            // 0x0000-0xffef        Set the ColorTemperatureMireds attribute to this value.
   1733            // 0xffff               Set the ColorTemperatureMireds attribue to its previous value.
   1734          
   1735            // Initialize startUpColorTempMireds to "maintain previous value" value 0xFFFF
   1736            uint16_t startUpColorTemp = 0xFFFF;
   \        0x4   0xF64F 0x70FF      MOVW     R0,#+65535
   1737            EmberAfStatus status = emberAfReadAttribute(endpoint,
   1738                                                        ZCL_COLOR_CONTROL_CLUSTER_ID,
   1739                                                        ZCL_START_UP_COLOR_TEMPERATURE_MIREDS_ATTRIBUTE_ID,
   1740                                                        CLUSTER_MASK_SERVER,
   1741                                                        (uint8_t *)&startUpColorTemp,
   1742                                                        sizeof(startUpColorTemp),
   1743                                                        NULL);
   1744            if (status == EMBER_ZCL_STATUS_SUCCESS) {
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   \        0xE   0x9102             STR      R1,[SP, #+8]
   \       0x10   0x2502             MOVS     R5,#+2
   \       0x12   0xAE03             ADD      R6,SP,#+12
   \       0x14   0x9501             STR      R5,[SP, #+4]
   \       0x16   0x9600             STR      R6,[SP, #+0]
   \       0x18   0x2340             MOVS     R3,#+64
   \       0x1A   0xF244 0x0210      MOVW     R2,#+16400
   \       0x1E   0x....'....        BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xD131             BNE.N    ??CrossCallReturnLabel_12
   1745              uint16_t updatedColorTemp = MAX_TEMPERATURE_VALUE;
   \       0x26   0xF64F 0x60FF      MOVW     R0,#+65279
   \       0x2A   0xF8AD 0x000E      STRH     R0,[SP, #+14]
   1746              status = emberAfReadAttribute(endpoint,
   1747                                            ZCL_COLOR_CONTROL_CLUSTER_ID,
   1748                                            ZCL_COLOR_CONTROL_COLOR_TEMPERATURE_ATTRIBUTE_ID,
   1749                                            CLUSTER_MASK_SERVER,
   1750                                            (uint8_t *)&updatedColorTemp,
   1751                                            sizeof(updatedColorTemp),
   1752                                            NULL);
   1753              if (status == EMBER_ZCL_STATUS_SUCCESS) {
   \       0x2E   0x2100             MOVS     R1,#+0
   \       0x30   0xF10D 0x000E      ADD      R0,SP,#+14
   \       0x34   0x9102             STR      R1,[SP, #+8]
   \       0x36   0x9000             STR      R0,[SP, #+0]
   \       0x38   0x9501             STR      R5,[SP, #+4]
   \       0x3A   0x2340             MOVS     R3,#+64
   \       0x3C   0x2207             MOVS     R2,#+7
   \       0x3E   0x....'....        BL       ?Subroutine11
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD121             BNE.N    ??CrossCallReturnLabel_12
   1754                uint16_t tempPhysicalMin = readColorTemperatureMin(endpoint);
   \       0x46   0x4620             MOV      R0,R4
   \       0x48   0x....'....        BL       readColorTemperatureMin
   \       0x4C   0x....'....        BL       ?Subroutine27
   1755                uint16_t tempPhysicalMax = readColorTemperatureMax(endpoint);
   1756                if (tempPhysicalMin <= startUpColorTemp && startUpColorTemp <= tempPhysicalMax) {
   \                     ??CrossCallReturnLabel_90: (+1)
   \       0x50   0xF8BD 0x100C      LDRH     R1,[SP, #+12]
   \       0x54   0x42A9             CMP      R1,R5
   \       0x56   0xBF28             IT       CS 
   \       0x58   0x4288             CMPCS    R0,R1
   \       0x5A   0xD316             BCC.N    ??CrossCallReturnLabel_12
   1757                  // Apply valid startup color temp value that is within physical limits of device.
   1758                  // Otherwise, the startup value is outside the device's supported range, and the
   1759                  // existing setting of ColorTemp attribute will be left unchanged (i.e., treated as
   1760                  // if startup color temp was set to 0xFFFF).
   1761                  updatedColorTemp = startUpColorTemp;
   \       0x5C   0xF8AD 0x100E      STRH     R1,[SP, #+14]
   1762                  status = emberAfWriteAttribute(endpoint,
   1763                                                 ZCL_COLOR_CONTROL_CLUSTER_ID,
   1764                                                 ZCL_COLOR_CONTROL_COLOR_TEMPERATURE_ATTRIBUTE_ID,
   1765                                                 CLUSTER_MASK_SERVER,
   1766                                                 (uint8_t *)&updatedColorTemp,
   1767                                                 ZCL_INT16U_ATTRIBUTE_TYPE);
   1768                  if (status == EMBER_ZCL_STATUS_SUCCESS) {
   \       0x60   0x2121             MOVS     R1,#+33
   \       0x62   0xF10D 0x020E      ADD      R2,SP,#+14
   \       0x66   0x9101             STR      R1,[SP, #+4]
   \       0x68   0x9200             STR      R2,[SP, #+0]
   \       0x6A   0x2340             MOVS     R3,#+64
   \       0x6C   0x2207             MOVS     R2,#+7
   \       0x6E   0x....'....        BL       ?Subroutine8
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x72   0xB950             CBNZ.N   R0,??CrossCallReturnLabel_12
   1769                    // Set ColorMode attributes to reflect ColorTemperature.
   1770                    uint8_t updateColorMode = EMBER_ZCL_COLOR_MODE_COLOR_TEMPERATURE;
   \       0x74   0x....'....        BL       ?Subroutine28
   1771                    status = emberAfWriteAttribute(endpoint,
   1772                                                   ZCL_COLOR_CONTROL_CLUSTER_ID,
   1773                                                   ZCL_COLOR_CONTROL_COLOR_MODE_ATTRIBUTE_ID,
   1774                                                   CLUSTER_MASK_SERVER,
   1775                                                   &updateColorMode,
   1776                                                   ZCL_ENUM8_ATTRIBUTE_TYPE);
   \                     ??CrossCallReturnLabel_92: (+1)
   \       0x78   0x2208             MOVS     R2,#+8
   \       0x7A   0x....'....        BL       ?Subroutine8
   1777                    updateColorMode = EMBER_ZCL_ENHANCED_COLOR_MODE_COLOR_TEMPERATURE;
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x7E   0x....'....        BL       ?Subroutine28
   1778                    status = emberAfWriteAttribute(endpoint,
   1779                                                   ZCL_COLOR_CONTROL_CLUSTER_ID,
   1780                                                   ZCL_COLOR_CONTROL_ENHANCED_COLOR_MODE_ATTRIBUTE_ID,
   1781                                                   CLUSTER_MASK_SERVER,
   1782                                                   &updateColorMode,
   1783                                                   ZCL_ENUM8_ATTRIBUTE_TYPE);
   1784                  }
   1785                }
   1786              }
   1787            }
   \                     ??CrossCallReturnLabel_93: (+1)
   \       0x82   0xF244 0x0201      MOVW     R2,#+16385
   \       0x86   0x....'....        BL       ?Subroutine8
   1788          #endif
   1789          }
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x8A   0xBD7F             POP      {R0-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine28: (+1)
   \        0x0   0x2002             MOVS     R0,#+2
   \        0x2   0x2130             MOVS     R1,#+48
   \        0x4   0xAA02             ADD      R2,SP,#+8
   \        0x6   0xF88D 0x0008      STRB     R0,[SP, #+8]
   \        0xA   0x9101             STR      R1,[SP, #+4]
   \        0xC   0x9200             STR      R2,[SP, #+0]
   \        0xE   0x2340             MOVS     R3,#+64
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0xF44F 0x7140      MOV      R1,#+768
   \        0x4   0x4620             MOV      R0,R4
   \        0x6   0x....'....        B.W      emberAfReadAttribute

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0xF44F 0x7140      MOV      R1,#+768
   \        0x4   0x4620             MOV      R0,R4
   \        0x6   0x....'....        B.W      emberAfWriteAttribute

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \        0x0   0x4638             MOV      R0,R7
   \        0x2   0x....'....        B.W      halInternalAssertFailed

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0xF44F 0x7140      MOV      R1,#+768
   \        0x4   0x....             LDR.N    R7,??DataTable27_4
   \        0x6   0x....'....        B.W      emberAfWriteServerAttribute

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \        0x0   0x....'....        DC32     emAfCurrentCommand

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \        0x0   0x....'....        DC32     colorHueTransitionState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_2:
   \        0x0   0x....'....        DC32     colorSaturationTransitionState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_3:
   \        0x0   0x....'....        DC32     emberAfPluginColorControlServerHueSatTransitionEventControl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_4:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_5:
   \        0x0   0x....'....        DC32     colorXTransitionState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_6:
   \        0x0   0x....'....        DC32     colorYTransitionState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_7:
   \        0x0   0x....'....        DC32     emberAfPluginColorControlServerXyTransitionEventControl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_8:
   \        0x0   0x....'....        DC32     colorTempTransitionState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_9:
   \        0x0   0x....'....        DC32     emberAfPluginColorControlServerTempTransitionEventControl

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x63 0x6F          DC8 "color-control-server.c"
   \              0x6C 0x6F    
   \              0x72 0x2D    
   \              0x63 0x6F    
   \              0x6E 0x74    
   \              0x72 0x6F    
   \              0x6C 0x2D    
   \              0x73 0x65    
   \              0x72 0x76    
   \              0x65 0x72    
   \              0x2E 0x63    
   \              0x00         
   \       0x17   0x00               DC8 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   addHue
      16   computeNewColor16uValue
        16   -> writeRemainingTime
       8   computeNewHueValue
         8   -> addHue
         8   -> subtractHue
         8   -> writeRemainingTime
       8   computeTransitionTimeFromStateAndRate
      24   emberAfColorControlClusterMoveColorCallback
        24   -> computeTransitionTimeFromStateAndRate
        24   -> emEventControlSetDelayMS
        24   -> emberAfSendImmediateDefaultResponse
        24   -> handleModeSwitch
        24   -> readColorX
        24   -> readColorY
        24   -> shouldExecuteIfOff
        24   -> stopAllColorTransitions
        24   -> writeRemainingTime
      40   emberAfColorControlClusterMoveColorTemperatureCallback
        40   -> computeTransitionTimeFromStateAndRate
        40   -> emEventControlSetDelayMS
        40   -> emberAfSendImmediateDefaultResponse
        40   -> handleModeSwitch
        40   -> readColorTemperature
        40   -> readColorTemperatureMax
        40   -> readColorTemperatureMin
        40   -> shouldExecuteIfOff
        40   -> stopAllColorTransitions
        40   -> writeRemainingTime
      24   emberAfColorControlClusterMoveHueCallback
        24   -> addHue
        24   -> emEventControlSetDelayMS
        24   -> emberAfSendImmediateDefaultResponse
        24   -> handleModeSwitch
        24   -> initHueSat
        24   -> readHue
        24   -> shouldExecuteIfOff
        24   -> stopAllColorTransitions
        24   -> subtractHue
        24   -> writeRemainingTime
      24   emberAfColorControlClusterMoveSaturationCallback
        24   -> computeTransitionTimeFromStateAndRate
        24   -> emEventControlSetDelayMS
        24   -> emberAfSendImmediateDefaultResponse
        24   -> handleModeSwitch
        24   -> initHueSat
        24   -> readSaturation
        24   -> shouldExecuteIfOff
        24   -> stopAllColorTransitions
        24   -> writeRemainingTime
      24   emberAfColorControlClusterMoveToColorCallback
        24   -> emEventControlSetDelayMS
        24   -> emberAfSendImmediateDefaultResponse
        24   -> handleModeSwitch
        24   -> readColorX
        24   -> readColorY
        24   -> shouldExecuteIfOff
        24   -> stopAllColorTransitions
        24   -> writeRemainingTime
      24   emberAfColorControlClusterMoveToColorTemperatureCallback
        24   -> emberAfSendImmediateDefaultResponse
        24   -> moveToColorTemp
        24   -> shouldExecuteIfOff
      32   emberAfColorControlClusterMoveToHueAndSaturationCallback
        32   -> emEventControlSetDelayMS
        32   -> emberAfSendImmediateDefaultResponse
        32   -> handleModeSwitch
        32   -> initHueSat
        32   -> readHue
        32   -> readSaturation
        32   -> shouldExecuteIfOff
        32   -> stopAllColorTransitions
        32   -> writeRemainingTime
      24   emberAfColorControlClusterMoveToHueCallback
        24   -> emEventControlSetDelayMS
        24   -> emberAfSendImmediateDefaultResponse
        24   -> handleModeSwitch
        24   -> initHueSat
        24   -> readHue
        24   -> shouldExecuteIfOff
        24   -> stopAllColorTransitions
        24   -> writeRemainingTime
      24   emberAfColorControlClusterMoveToSaturationCallback
        24   -> emEventControlSetDelayMS
        24   -> emberAfSendImmediateDefaultResponse
        24   -> handleModeSwitch
        24   -> initHueSat
        24   -> readSaturation
        24   -> shouldExecuteIfOff
        24   -> stopAllColorTransitions
        24   -> writeRemainingTime
      32   emberAfColorControlClusterServerInitCallback
        32   -> emberAfReadAttribute
        32   -> emberAfWriteAttribute
        32   -> readColorTemperatureMax
        32   -> readColorTemperatureMin
      24   emberAfColorControlClusterStepColorCallback
        24   -> emEventControlSetDelayMS
        24   -> emberAfSendImmediateDefaultResponse
        24   -> findNewColorValueFromStep
        24   -> handleModeSwitch
        24   -> readColorX
        24   -> readColorY
        24   -> shouldExecuteIfOff
        24   -> stopAllColorTransitions
        24   -> writeRemainingTime
      32   emberAfColorControlClusterStepColorTemperatureCallback
        32   -> emEventControlSetDelayMS
        32   -> emberAfSendImmediateDefaultResponse
        32   -> handleModeSwitch
        32   -> readColorTemperature
        32   -> readColorTemperatureMax
        32   -> readColorTemperatureMin
        32   -> shouldExecuteIfOff
        32   -> stopAllColorTransitions
        32   -> writeRemainingTime
      32   emberAfColorControlClusterStepHueCallback
        32   -> addHue
        32   -> emEventControlSetDelayMS
        32   -> emberAfSendImmediateDefaultResponse
        32   -> handleModeSwitch
        32   -> initHueSat
        32   -> readHue
        32   -> shouldExecuteIfOff
        32   -> stopAllColorTransitions
        32   -> subtractHue
        32   -> writeRemainingTime
      24   emberAfColorControlClusterStepSaturationCallback
        24   -> emEventControlSetDelayMS
        24   -> emberAfSendImmediateDefaultResponse
        24   -> handleModeSwitch
        24   -> initHueSat
        24   -> readSaturation
        24   -> shouldExecuteIfOff
        24   -> stopAllColorTransitions
        24   -> writeRemainingTime
       8   emberAfColorControlClusterStopMoveStepCallback
         8   -> emberAfSendImmediateDefaultResponse
         8   -> shouldExecuteIfOff
         8   -> stopAllColorTransitions
      32   emberAfPluginColorControlServerHueSatTransitionEventHandler
        32   -> computeNewColor16uValue
        32   -> computeNewHueValue
        32   -> emEventControlSetDelayMS
        32   -> emberAfPluginColorControlServerComputePwmFromHsvCallback
        32   -> emberAfWriteServerAttribute
        32   -> halInternalAssertFailed
        32   -> stopAllColorTransitions
       0   emberAfPluginColorControlServerStopTransition
         0   -> stopAllColorTransitions
      24   emberAfPluginColorControlServerTempTransitionEventHandler
        24   -> computeNewColor16uValue
        24   -> emEventControlSetDelayMS
        24   -> emberAfPluginColorControlServerComputePwmFromTempCallback
        24   -> emberAfWriteServerAttribute
        24   -> halInternalAssertFailed
        24   -> stopAllColorTransitions
      32   emberAfPluginColorControlServerXyTransitionEventHandler
        32   -> computeNewColor16uValue
        32   -> emEventControlSetDelayMS
        32   -> emberAfPluginColorControlServerComputePwmFromXyCallback
        32   -> emberAfWriteServerAttribute
        32   -> halInternalAssertFailed
        32   -> stopAllColorTransitions
      24   emberAfPluginLevelControlCoupledColorTempChangeCallback
        24   -> emberAfContainsServer
        24   -> emberAfReadServerAttribute
        24   -> moveToColorTemp
        24   -> readColorMode
        24   -> readColorTemperatureMax
        24   -> readColorTemperatureMin
       0   findNewColorValueFromStep
      32   handleModeSwitch
        32   -> emberAfPluginColorControlServerComputePwmFromHsvCallback
        32   -> emberAfPluginColorControlServerComputePwmFromTempCallback
        32   -> emberAfPluginColorControlServerComputePwmFromXyCallback
        32   -> emberAfWriteServerAttribute
        32   -> halInternalAssertFailed
        32   -> readColorMode
      16   initHueSat
        16   -> readHue
        16   -> readSaturation
      32   moveToColorTemp
         0   -> emEventControlSetDelayMS
        32   -> handleModeSwitch
        32   -> readColorTemperature
        32   -> readColorTemperatureMax
        32   -> readColorTemperatureMin
        32   -> stopAllColorTransitions
      16   readColorMode
        16   -> emberAfReadServerAttribute
        16   -> halInternalAssertFailed
      16   readColorTemperature
        16   -> emberAfReadServerAttribute
        16   -> halInternalAssertFailed
      16   readColorTemperatureMax
        16   -> emberAfReadServerAttribute
      16   readColorTemperatureMin
        16   -> emberAfReadServerAttribute
      16   readColorX
        16   -> emberAfReadServerAttribute
        16   -> halInternalAssertFailed
      16   readColorY
        16   -> emberAfReadServerAttribute
        16   -> halInternalAssertFailed
      16   readHue
        16   -> emberAfReadServerAttribute
        16   -> halInternalAssertFailed
      16   readSaturation
        16   -> emberAfReadServerAttribute
        16   -> halInternalAssertFailed
      24   shouldExecuteIfOff
        24   -> emberAfContainsServer
        24   -> emberAfReadServerAttribute
       0   stopAllColorTransitions
       0   subtractHue
      16   writeRemainingTime
        16   -> emberAfWriteServerAttribute
        16   -> halInternalAssertFailed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable27_4
       4  ??DataTable27_5
       4  ??DataTable27_6
       4  ??DataTable27_7
       4  ??DataTable27_8
       4  ??DataTable27_9
       6  ?Subroutine0
       6  ?Subroutine1
      10  ?Subroutine10
      10  ?Subroutine11
       8  ?Subroutine12
      16  ?Subroutine13
       8  ?Subroutine14
      12  ?Subroutine15
       6  ?Subroutine16
      22  ?Subroutine17
      10  ?Subroutine18
       4  ?Subroutine19
      10  ?Subroutine2
       8  ?Subroutine20
      10  ?Subroutine21
      10  ?Subroutine22
      10  ?Subroutine23
       6  ?Subroutine24
       4  ?Subroutine25
       6  ?Subroutine26
       6  ?Subroutine27
      18  ?Subroutine28
      16  ?Subroutine29
       8  ?Subroutine3
      12  ?Subroutine4
       8  ?Subroutine5
       8  ?Subroutine6
       8  ?Subroutine7
      10  ?Subroutine8
      16  ?Subroutine9
      24  ?_0
      14  addHue
      12  colorHueTransitionState
      16  colorSaturationTransitionState
      16  colorTempTransitionState
      16  colorXTransitionState
      16  colorYTransitionState
      74  computeNewColor16uValue
     144  computeNewHueValue
      48  computeTransitionTimeFromStateAndRate
     164  emberAfColorControlClusterMoveColorCallback
     176  emberAfColorControlClusterMoveColorTemperatureCallback
     140  emberAfColorControlClusterMoveHueCallback
     114  emberAfColorControlClusterMoveSaturationCallback
     122  emberAfColorControlClusterMoveToColorCallback
      22  emberAfColorControlClusterMoveToColorTemperatureCallback
     184  emberAfColorControlClusterMoveToHueAndSaturationCallback
     172  emberAfColorControlClusterMoveToHueCallback
      80  emberAfColorControlClusterMoveToSaturationCallback
     140  emberAfColorControlClusterServerInitCallback
     162  emberAfColorControlClusterStepColorCallback
     172  emberAfColorControlClusterStepColorTemperatureCallback
     124  emberAfColorControlClusterStepHueCallback
     146  emberAfColorControlClusterStepSaturationCallback
      34  emberAfColorControlClusterStopMoveStepCallback
       8  emberAfPluginColorControlServerHueSatTransitionEventControl
      96  emberAfPluginColorControlServerHueSatTransitionEventHandler
       2  emberAfPluginColorControlServerStopTransition
       8  emberAfPluginColorControlServerTempTransitionEventControl
      52  emberAfPluginColorControlServerTempTransitionEventHandler
       8  emberAfPluginColorControlServerXyTransitionEventControl
      86  emberAfPluginColorControlServerXyTransitionEventHandler
     134  emberAfPluginLevelControlCoupledColorTempChangeCallback
      22  findNewColorValueFromStep
     128  handleModeSwitch
      40  initHueSat
     102  moveToColorTemp
      24  readColorMode
      22  readColorTemperature
      26  readColorTemperatureMax
      22  readColorTemperatureMin
      24  readColorX
      24  readColorY
      24  readHue
      26  readSaturation
     104  shouldExecuteIfOff
      16  stopAllColorTransitions
      14  subtractHue
      26  writeRemainingTime

 
   100 bytes in section .bss
    24 bytes in section .rodata
 3 578 bytes in section .text
 
 3 578 bytes of CODE  memory
    24 bytes of CONST memory
   100 bytes of DATA  memory

Errors: none
Warnings: none
