###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:20:00
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emdrv\uartdrv\src\uartdrv.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW5EBB.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emdrv\uartdrv\src\uartdrv.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"uartdrv.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0
#        -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emdrv\uartdrv\src\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\uartdrv.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\uartdrv.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emdrv\uartdrv\src\uartdrv.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief UARTDRV API implementation.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc.  Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement.  This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          #include <string.h>
     18          
     19          #include "uartdrv.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void GPIO_PinOutClear(GPIO_Port_TypeDef, unsigned int)
   \                     GPIO_PinOutClear: (+1)
   \        0x0   0x2230             MOVS     R2,#+48
   \        0x2   0x4350             MULS     R0,R2,R0
   \        0x4   0xB510             PUSH     {R4,LR}
   \        0x6   0x2301             MOVS     R3,#+1
   \        0x8   0x....'....        LDR.W    R4,??DataTable22  ;; 0x4003e000
   \        0xC   0x....             B.N      ?Subroutine0

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xFA03 0xF101      LSL      R1,R3,R1
   \        0x4   0x4420             ADD      R0,R4,R0
   \        0x6   0x6101             STR      R1,[R0, #+16]
   \        0x8   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void GPIO_PinOutSet(GPIO_Port_TypeDef, unsigned int)
   \                     GPIO_PinOutSet: (+1)
   \        0x0   0x2230             MOVS     R2,#+48
   \        0x2   0x4350             MULS     R0,R2,R0
   \        0x4   0xB510             PUSH     {R4,LR}
   \        0x6   0x2301             MOVS     R3,#+1
   \        0x8   0x....'....        LDR.W    R4,??DataTable21  ;; 0x4003d000
   \        0xC                      REQUIRE ?Subroutine0
   \        0xC                      ;; // Fall through to label ?Subroutine0

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void GPIO_IntConfig(GPIO_Port_TypeDef, unsigned int, bool, bool, bool)
   \                     GPIO_IntConfig: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x9C04             LDR      R4,[SP, #+16]
   \        0x4   0x9300             STR      R3,[SP, #+0]
   \        0x6   0x4613             MOV      R3,R2
   \        0x8   0x9401             STR      R4,[SP, #+4]
   \        0xA   0x460A             MOV      R2,R1
   \        0xC   0x....'....        BL       GPIO_ExtIntConfig
   \       0x10   0xBD13             POP      {R0,R1,R4,PC}    ;; return
     20          
     21          #include "em_device.h"
     22          #include "em_emu.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void EMU_EnterEM1(void)
   \                     EMU_EnterEM1: (+1)
   \        0x0   0x....'....        LDR.W    R0,??DataTable22_1  ;; 0xe000ed10
   \        0x4   0x6801             LDR      R1,[R0, #+0]
   \        0x6   0xF021 0x0104      BIC      R1,R1,#0x4
   \        0xA   0x6001             STR      R1,[R0, #+0]
   \        0xC   0xBF30             WFI      
   \        0xE   0x4770             BX       LR               ;; return
     23          #include "em_gpio.h"
     24          #include "em_core.h"
     25          #if (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE)
     26          #include "gpiointerrupt.h"
     27          #endif
     28          
     29          #if (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE) && defined(_USART_ROUTEPEN_CTSPEN_MASK)
     30          #define UART_HW_FLOW_CONTROL_SUPPORT
     31          #elif (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE) && defined(USART_CTRLX_CTSEN)
     32          #define UART_HW_FLOW_CONTROL_SUPPORT
     33          #endif
     34          
     35          /// @cond DO_NOT_INCLUDE_WITH_DOXYGEN
     36          
     37          #if defined(DMA_PRESENT) && (DMA_COUNT == 1)
     38          #define UART_DMA_IRQ          DMA_IRQn
     39          #define UART_DMA_IRQHANDLER() DMA_IRQHandler()
     40          #elif defined(LDMA_PRESENT) && (LDMA_COUNT == 1)
     41          #define UART_DMA_IRQ          LDMA_IRQn
     42          #define UART_DMA_IRQHANDLER() LDMA_IRQHandler()
     43          #else
     44          #error "No valid UARTDRV DMA engine defined."
     45          #endif
     46          
     47          #if (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE)

   \                                 In section .bss, align 1
     48          static bool uartdrvHandleIsInitialized = false;
   \                     uartdrvHandleIsInitialized:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
     49          static UARTDRV_Handle_t uartdrvHandle[EMDRV_UARTDRV_MAX_DRIVER_INSTANCES];
   \                     uartdrvHandle:
   \        0x0                      DS8 16
     50          #endif
     51          
     52          static bool ReceiveDmaComplete(unsigned int channel,
     53                                         unsigned int sequenceNo,
     54                                         void *userParam);
     55          static bool TransmitDmaComplete(unsigned int channel,
     56                                          unsigned int sequenceNo,
     57                                          void *userParam);
     58          
     59          /***************************************************************************//**
     60           * @brief Get UARTDRV_Handle_t from GPIO pin number (HW FC CTS pin interrupt).
     61           ******************************************************************************/
     62          #if (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE)
     63          static UARTDRV_Handle_t HwFcCtsIrqGetDrvHandle(uint32_t gpioPinNo)
     64          {
     65            uint32_t i;
     66          
     67            for (i = 0; i < EMDRV_UARTDRV_MAX_DRIVER_INSTANCES; i++) {
     68              if (uartdrvHandle[i]->ctsPin == gpioPinNo) {
     69                return uartdrvHandle[i];
     70              }
     71            }
     72            return NULL;
     73          }
     74          
     75          /***************************************************************************//**
     76           * @brief Get CTS pin state.
     77           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     78          static UARTDRV_FlowControlState_t HwFcGetClearToSendPin(UARTDRV_Handle_t handle)
     79          {
     80            if (handle->fcType == uartdrvFlowControlHw) {
   \                     HwFcGetClearToSendPin: (+1)
   \        0x0   0xF100 0x011D      ADD      R1,R0,#+29
   \        0x4   0x7D08             LDRB     R0,[R1, #+20]
   \        0x6   0x2802             CMP      R0,#+2
   \        0x8   0xD10B             BNE.N    ??HwFcGetClearToSendPin_0
     81              return (UARTDRV_FlowControlState_t)GPIO_PinInGet(handle->ctsPort, handle->ctsPin);
   \        0xA   0x780B             LDRB     R3,[R1, #+0]
   \        0xC   0x2030             MOVS     R0,#+48
   \        0xE   0x....'....        LDR.W    R2,??DataTable22_2  ;; 0x4003c000
   \       0x12   0x4343             MULS     R3,R0,R3
   \       0x14   0x18D0             ADDS     R0,R2,R3
   \       0x16   0x6940             LDR      R0,[R0, #+20]
     82            } else {
   \       0x18   0x7909             LDRB     R1,[R1, #+4]
   \       0x1A   0x40C8             LSRS     R0,R0,R1
   \       0x1C   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x20   0x4770             BX       LR
     83              return uartdrvFlowControlOn;
   \                     ??HwFcGetClearToSendPin_0: (+1)
   \       0x22   0x2000             MOVS     R0,#+0
   \       0x24   0x4770             BX       LR               ;; return
     84            }
     85          }
     86          
     87          /***************************************************************************//**
     88           * @brief Manage CTS pin change.
     89           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     90          static void HwFcManageClearToSend(uint8_t gpioPinNo)
     91          {
   \                     HwFcManageClearToSend: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4601             MOV      R1,R0
     92            UARTDRV_Handle_t handle = HwFcCtsIrqGetDrvHandle(gpioPinNo);
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x....'....        LDR.W    R3,??DataTable22_3
   \                     ??HwFcManageClearToSend_0: (+1)
   \        0xA   0xF853 0x0022      LDR      R0,[R3, R2, LSL #+2]
   \        0xE   0xF890 0x4021      LDRB     R4,[R0, #+33]
   \       0x12   0x428C             CMP      R4,R1
   \       0x14   0xD00B             BEQ.N    ??HwFcManageClearToSend_1
   \       0x16   0x1C52             ADDS     R2,R2,#+1
   \       0x18   0x2A04             CMP      R2,#+4
   \       0x1A   0xD3F6             BCC.N    ??HwFcManageClearToSend_0
   \       0x1C   0xBD31             POP      {R0,R4,R5,PC}
     93          
     94            if (handle && handle->fcType == uartdrvFlowControlHw) {
     95              // If not auto mode, assign the CTS pin state to the self state
     96              // If auto mode, also control UART Tx enable
     97              handle->fcSelfState = HwFcGetClearToSendPin(handle);
     98              // Only manage DMA if not already paused by SW
     99              if (handle->fcSelfCfg == uartdrvFlowControlAuto && (handle->txDmaPaused == 0)) {
    100                bool active = false;
    101                Ecode_t status = DMADRV_TransferActive(handle->txDmaCh, &active);
    102                if ((handle->fcSelfState == uartdrvFlowControlOn) || handle->IgnoreRestrain) {
    103                  handle->IgnoreRestrain = false;
    104                  DMADRV_ResumeTransfer(handle->txDmaCh);
    105                }
    106                // Only pause DMA if currently active
    107                else if ((status == ECODE_EMDRV_DMADRV_OK) && active) {
   \                     ??HwFcManageClearToSend_2: (+1)
   \       0x1E   0xB928             CBNZ.N   R0,??HwFcManageClearToSend_3
   \       0x20   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \       0x24   0xB111             CBZ.N    R1,??HwFcManageClearToSend_3
    108                  DMADRV_PauseTransfer(handle->txDmaCh);
   \       0x26   0x6820             LDR      R0,[R4, #+0]
   \       0x28   0x....'....        BL       DMADRV_PauseTransfer
    109                }
    110              }
    111            }
    112          }
   \                     ??HwFcManageClearToSend_3: (+1)
   \       0x2C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??HwFcManageClearToSend_1: (+1)
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD0FC             BEQ.N    ??HwFcManageClearToSend_3
   \       0x32   0xF100 0x052E      ADD      R5,R0,#+46
   \       0x36   0x78E9             LDRB     R1,[R5, #+3]
   \       0x38   0x2902             CMP      R1,#+2
   \       0x3A   0xD1F7             BNE.N    ??HwFcManageClearToSend_3
   \       0x3C   0xF100 0x0408      ADD      R4,R0,#+8
   \       0x40   0x....'....        BL       HwFcGetClearToSendPin
   \       0x44   0x7C61             LDRB     R1,[R4, #+17]
   \       0x46   0x7420             STRB     R0,[R4, #+16]
   \       0x48   0x2902             CMP      R1,#+2
   \       0x4A   0xBF04             ITT      EQ 
   \       0x4C   0x7828             LDRBEQ   R0,[R5, #+0]
   \       0x4E   0x2800             CMPEQ    R0,#+0
   \       0x50   0xD1EC             BNE.N    ??HwFcManageClearToSend_3
   \       0x52   0x2100             MOVS     R1,#+0
   \       0x54   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \       0x58   0x6820             LDR      R0,[R4, #+0]
   \       0x5A   0x4669             MOV      R1,SP
   \       0x5C   0x....'....        BL       DMADRV_TransferActive
   \       0x60   0x7C21             LDRB     R1,[R4, #+16]
   \       0x62   0xB111             CBZ.N    R1,??HwFcManageClearToSend_4
   \       0x64   0x7869             LDRB     R1,[R5, #+1]
   \       0x66   0x2900             CMP      R1,#+0
   \       0x68   0xD0D9             BEQ.N    ??HwFcManageClearToSend_2
   \                     ??HwFcManageClearToSend_4: (+1)
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0x7068             STRB     R0,[R5, #+1]
   \       0x6E   0x6820             LDR      R0,[R4, #+0]
   \       0x70   0x....'....        BL       DMADRV_ResumeTransfer
   \       0x74   0xBD31             POP      {R0,R4,R5,PC}
    113          

   \                                 In section .text, align 2, keep-with-next
    114          static Ecode_t FcApplyState(UARTDRV_Handle_t handle)
    115          {
   \                     FcApplyState: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    116            uint8_t fcSwCode;
    117          
    118            if (handle->fcType == uartdrvFlowControlHw) {
   \        0x4   0xF104 0x0122      ADD      R1,R4,#+34
   \        0x8   0x7BC8             LDRB     R0,[R1, #+15]
   \        0xA   0x2802             CMP      R0,#+2
   \        0xC   0xD10F             BNE.N    ??FcApplyState_0
    119              if (handle->fcSelfCfg == uartdrvFlowControlOn) {
   \        0xE   0x7E60             LDRB     R0,[R4, #+25]
   \       0x10   0xB118             CBZ.N    R0,??FcApplyState_1
    120                // Assert nRTS (application control)
    121                GPIO_PinOutClear(handle->rtsPort, handle->rtsPin);
    122              } else if (handle->fcSelfCfg == uartdrvFlowControlOff) {
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD006             BEQ.N    ??FcApplyState_2
    123                // Deassert nRTS (application control)
    124                GPIO_PinOutSet(handle->rtsPort, handle->rtsPin);
    125              } else { // Auto mode
    126                if (handle->fcSelfState == uartdrvFlowControlOn) {
   \       0x16   0x7E20             LDRB     R0,[R4, #+24]
   \       0x18   0xB920             CBNZ.N   R0,??FcApplyState_2
    127                  // Assert nRTS
    128                  GPIO_PinOutClear(handle->rtsPort, handle->rtsPin);
   \                     ??FcApplyState_1: (+1)
   \       0x1A   0x7809             LDRB     R1,[R1, #+0]
   \       0x1C   0x7FA0             LDRB     R0,[R4, #+30]
   \       0x1E   0x....'....        BL       GPIO_PinOutClear
   \       0x22   0xE01A             B.N      ??FcApplyState_3
    129                } else { // Off
    130                         // Deassert nRTS
    131                  GPIO_PinOutSet(handle->rtsPort, handle->rtsPin);
   \                     ??FcApplyState_2: (+1)
   \       0x24   0x7809             LDRB     R1,[R1, #+0]
   \       0x26   0x7FA0             LDRB     R0,[R4, #+30]
   \       0x28   0x....'....        BL       GPIO_PinOutSet
   \       0x2C   0xE015             B.N      ??FcApplyState_3
    132                }
    133              }
    134            } else if (handle->fcType == uartdrvFlowControlSw) {
   \                     ??FcApplyState_0: (+1)
   \       0x2E   0x2801             CMP      R0,#+1
   \       0x30   0xD113             BNE.N    ??FcApplyState_3
    135              if (handle->fcSelfState == uartdrvFlowControlOn) {
   \       0x32   0x7E20             LDRB     R0,[R4, #+24]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xBF07             ITTEE    EQ 
   \       0x38   0x2111             MOVEQ    R1,#+17
   \       0x3A   0xF88D 0x1000      STRBEQ   R1,[SP, #+0]
   \       0x3E   0x2013             MOVNE    R0,#+19
   \       0x40   0xF88D 0x0000      STRBNE   R0,[SP, #+0]
    136                fcSwCode = UARTDRV_FC_SW_XON;
    137                // Pause transmit to ensure XON transmits immediately
    138                UARTDRV_PauseTransmit(handle);
    139                UARTDRV_ForceTransmit(handle, &fcSwCode, 1);
    140                UARTDRV_ResumeTransmit(handle);
    141              } else {
    142                fcSwCode = UARTDRV_FC_SW_XOFF;
    143                // Pause transmit to ensure XOFF transmits immediately
    144                UARTDRV_PauseTransmit(handle);
   \       0x44   0x4620             MOV      R0,R4
   \       0x46   0x....'....        BL       UARTDRV_PauseTransmit
    145                UARTDRV_ForceTransmit(handle, &fcSwCode, 1);
   \       0x4A   0x2201             MOVS     R2,#+1
   \       0x4C   0x4669             MOV      R1,SP
   \       0x4E   0x4620             MOV      R0,R4
   \       0x50   0x....'....        BL       UARTDRV_ForceTransmit
    146                UARTDRV_ResumeTransmit(handle);
   \       0x54   0x4620             MOV      R0,R4
   \       0x56   0x....'....        BL       UARTDRV_ResumeTransmit
    147              }
    148            }
    149            return ECODE_EMDRV_UARTDRV_OK;
   \                     ??FcApplyState_3: (+1)
   \       0x5A   0x2000             MOVS     R0,#+0
   \       0x5C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    150          }
    151          #else
    152          // CTS pin should always read as uartdrvFlowControlOn when HW FC is disabled
    153          #define HwFcGetClearToSendPin(x) uartdrvFlowControlOn
    154          #endif /* EMDRV_UARTDRV_FLOW_CONTROL_ENABLE */
    155          
    156          /***************************************************************************//**
    157           * @brief Enqueue UART transfer buffer.
    158           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    159          static Ecode_t EnqueueBuffer(UARTDRV_Buffer_FifoQueue_t *queue,
    160                                       UARTDRV_Buffer_t *inputBuffer,
    161                                       UARTDRV_Buffer_t **queueBuffer)
    162          {
   \                     EnqueueBuffer: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4616             MOV      R6,R2
    163            CORE_DECLARE_IRQ_STATE;
    164          
    165            CORE_ENTER_ATOMIC();
   \        0xA   0x....'....        BL       CORE_EnterAtomic
   \        0xE   0x4605             MOV      R5,R0
    166            if (queue->used >= queue->size) {
   \       0x10   0x88A0             LDRH     R0,[R4, #+4]
   \       0x12   0x88E1             LDRH     R1,[R4, #+6]
   \       0x14   0x4288             CMP      R0,R1
   \       0x16   0xD307             BCC.N    ??EnqueueBuffer_0
    167              *queueBuffer = NULL;
   \       0x18   0x2000             MOVS     R0,#+0
   \       0x1A   0x6030             STR      R0,[R6, #+0]
    168              CORE_EXIT_ATOMIC();
   \       0x1C   0x4628             MOV      R0,R5
   \       0x1E   0x....'....        BL       CORE_ExitAtomic
    169              return ECODE_EMDRV_UARTDRV_QUEUE_FULL;
   \       0x22   0x....'....        LDR.W    R0,??DataTable22_4  ;; 0xf000700a
   \       0x26   0xE01E             B.N      ??EnqueueBuffer_1
    170            }
    171            memcpy((void *)&queue->fifo[queue->head],
    172                   (const void *)inputBuffer,
    173                   sizeof(UARTDRV_Buffer_t));
   \                     ??EnqueueBuffer_0: (+1)
   \       0x28   0x8820             LDRH     R0,[R4, #+0]
   \       0x2A   0x2714             MOVS     R7,#+20
   \       0x2C   0xF104 0x0308      ADD      R3,R4,#+8
   \       0x30   0x4378             MULS     R0,R7,R0
   \       0x32   0x2214             MOVS     R2,#+20
   \       0x34   0x4641             MOV      R1,R8
   \       0x36   0x4418             ADD      R0,R3,R0
   \       0x38   0x....'....        BL       __aeabi_memcpy
    174            *queueBuffer = &queue->fifo[queue->head];
   \       0x3C   0x8821             LDRH     R1,[R4, #+0]
   \       0x3E   0xF104 0x0008      ADD      R0,R4,#+8
   \       0x42   0x434F             MULS     R7,R7,R1
   \       0x44   0x19C1             ADDS     R1,R0,R7
   \       0x46   0x6031             STR      R1,[R6, #+0]
    175            queue->head = (queue->head + 1) % queue->size;
   \       0x48   0x8820             LDRH     R0,[R4, #+0]
   \       0x4A   0x88E1             LDRH     R1,[R4, #+6]
   \       0x4C   0x1C40             ADDS     R0,R0,#+1
   \       0x4E   0xFB90 0xF2F1      SDIV     R2,R0,R1
   \       0x52   0xFB01 0x0012      MLS      R0,R1,R2,R0
   \       0x56   0x8020             STRH     R0,[R4, #+0]
    176            queue->used++;
   \       0x58   0x88A0             LDRH     R0,[R4, #+4]
   \       0x5A   0x1C40             ADDS     R0,R0,#+1
   \       0x5C   0x80A0             STRH     R0,[R4, #+4]
    177            CORE_EXIT_ATOMIC();
   \       0x5E   0x4628             MOV      R0,R5
   \       0x60   0x....'....        BL       CORE_ExitAtomic
    178          
    179            return ECODE_EMDRV_UARTDRV_OK;
   \       0x64   0x2000             MOVS     R0,#+0
   \                     ??EnqueueBuffer_1: (+1)
   \       0x66   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    180          }
    181          
    182          /***************************************************************************//**
    183           * @brief Dequeue UART transfer buffer.
    184           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    185          static Ecode_t DequeueBuffer(UARTDRV_Buffer_FifoQueue_t *queue,
    186                                       UARTDRV_Buffer_t **buffer)
    187          {
   \                     DequeueBuffer: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    188            CORE_DECLARE_IRQ_STATE;
    189          
    190            CORE_ENTER_ATOMIC();
   \        0x6   0x....'....        BL       CORE_EnterAtomic
    191            if (queue->used == 0) {
   \        0xA   0x88A1             LDRH     R1,[R4, #+4]
   \        0xC   0xB911             CBNZ.N   R1,??DequeueBuffer_0
    192              *buffer = NULL;
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x602A             STR      R2,[R5, #+0]
    193              CORE_EXIT_ATOMIC();
   \       0x12   0x....             B.N      ?Subroutine3
    194              return ECODE_EMDRV_UARTDRV_QUEUE_EMPTY;
    195            }
    196            *buffer = &queue->fifo[queue->tail];
   \                     ??DequeueBuffer_0: (+1)
   \       0x14   0x8862             LDRH     R2,[R4, #+2]
   \       0x16   0x2114             MOVS     R1,#+20
   \       0x18   0x434A             MULS     R2,R1,R2
   \       0x1A   0x18A1             ADDS     R1,R4,R2
   \       0x1C   0xF101 0x0308      ADD      R3,R1,#+8
   \       0x20   0x602B             STR      R3,[R5, #+0]
    197            queue->tail = (queue->tail + 1) % queue->size;
   \       0x22   0x8861             LDRH     R1,[R4, #+2]
   \       0x24   0x88E2             LDRH     R2,[R4, #+6]
   \       0x26   0x1C49             ADDS     R1,R1,#+1
   \       0x28   0xFB91 0xF3F2      SDIV     R3,R1,R2
   \       0x2C   0xFB02 0x1113      MLS      R1,R2,R3,R1
   \       0x30   0x8061             STRH     R1,[R4, #+2]
    198            queue->used--;
   \       0x32   0x88A1             LDRH     R1,[R4, #+4]
   \       0x34   0x1E4A             SUBS     R2,R1,#+1
   \       0x36   0x80A2             STRH     R2,[R4, #+4]
    199            CORE_EXIT_ATOMIC();
   \       0x38   0x....             B.N      ?Subroutine4
    200          
    201            return ECODE_EMDRV_UARTDRV_OK;
    202          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x....'....        BL       CORE_ExitAtomic
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xBD32             POP      {R1,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x....'....        BL       CORE_ExitAtomic
   \        0x4   0x....'....        LDR.W    R0,??DataTable22_5  ;; 0xf000700b
   \        0x8   0xBD32             POP      {R1,R4,R5,PC}
    203          
    204          /***************************************************************************//**
    205           * @brief Get tail UART transfer buffer.
    206           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    207          static Ecode_t GetTailBuffer(UARTDRV_Buffer_FifoQueue_t *queue,
    208                                       UARTDRV_Buffer_t **buffer)
    209          {
   \                     GetTailBuffer: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460C             MOV      R4,R1
    210            CORE_DECLARE_IRQ_STATE;
    211          
    212            CORE_ENTER_ATOMIC();
   \        0x6   0x....'....        BL       CORE_EnterAtomic
    213            if (queue->used == 0) {
   \        0xA   0x88A9             LDRH     R1,[R5, #+4]
   \        0xC   0xB911             CBNZ.N   R1,??GetTailBuffer_0
    214              *buffer = NULL;
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x6022             STR      R2,[R4, #+0]
    215              CORE_EXIT_ATOMIC();
   \       0x12   0x....             B.N      ?Subroutine3
    216              return ECODE_EMDRV_UARTDRV_QUEUE_EMPTY;
    217            }
    218            *buffer = &queue->fifo[queue->tail];
   \                     ??GetTailBuffer_0: (+1)
   \       0x14   0x886A             LDRH     R2,[R5, #+2]
   \       0x16   0x2114             MOVS     R1,#+20
   \       0x18   0x434A             MULS     R2,R1,R2
   \       0x1A   0x18A9             ADDS     R1,R5,R2
   \       0x1C   0xF101 0x0308      ADD      R3,R1,#+8
   \       0x20   0x6023             STR      R3,[R4, #+0]
    219          
    220            CORE_EXIT_ATOMIC();
   \       0x22                      REQUIRE ?Subroutine4
   \       0x22                      ;; // Fall through to label ?Subroutine4
    221            return ECODE_EMDRV_UARTDRV_OK;
    222          }
    223          
    224          /***************************************************************************//**
    225           * @brief Enable UART transmitter.
    226           ******************************************************************************/
    227          static void EnableTransmitter(UARTDRV_Handle_t handle)
    228          {
    229          #if (defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)) \
    230            || (defined(EUART_COUNT) && (EUART_COUNT > 0) )
    231            if (handle->type == uartdrvUartTypeUart)
    232          #endif
    233            {
    234              // Enable Tx
    235              handle->peripheral.uart->CMD = USART_CMD_TXEN;
    236              // Wait for Tx to be enabled
    237              while (!(handle->peripheral.uart->STATUS & USART_STATUS_TXENS)) {
    238              }
    239          
    240              // Enable Tx route
    241          #if defined(USART_ROUTEPEN_TXPEN)
    242              handle->peripheral.uart->ROUTEPEN |= USART_ROUTEPEN_TXPEN;
    243          #elif defined(USART_ROUTE_TXPEN)
    244              handle->peripheral.uart->ROUTE |= USART_ROUTE_TXPEN;
    245          #elif defined(GPIO_USART_ROUTEEN_TXPEN)
    246              GPIO->USARTROUTE_SET[handle->uartNum].ROUTEEN = GPIO_USART_ROUTEEN_TXPEN;
    247          #endif
    248            }
    249          #if defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)
    250            else if (handle->type == uartdrvUartTypeLeuart) {
    251              // Wait for previous register writes to sync
    252              while ((handle->peripheral.leuart->SYNCBUSY & LEUART_SYNCBUSY_CMD) != 0U) {
    253              }
    254          
    255              // Enable Tx
    256              handle->peripheral.leuart->CMD = LEUART_CMD_TXEN;
    257              // Wait for Tx to be enabled
    258              while (!(handle->peripheral.leuart->STATUS & LEUART_STATUS_TXENS)) {
    259              }
    260          
    261              // Enable Tx route
    262          #if defined(LEUART_ROUTEPEN_TXPEN)
    263              handle->peripheral.leuart->ROUTEPEN |= LEUART_ROUTEPEN_TXPEN;
    264          #else
    265              handle->peripheral.leuart->ROUTE |= LEUART_ROUTE_TXPEN;
    266          #endif
    267            }
    268          #elif defined(EUART_COUNT) && (EUART_COUNT > 0)
    269            else if (handle->type == uartdrvUartTypeEuart) {
    270              if (EUSART_StatusGet(handle->peripheral.euart) &  EUSART_STATUS_RXENS) {
    271                EUSART_Enable(handle->peripheral.euart, eusartEnable);
    272              } else {
    273                EUSART_Enable(handle->peripheral.euart, eusartEnableTx);
    274              }
    275              GPIO->EUARTROUTE_SET->ROUTEEN = GPIO_EUART_ROUTEEN_TXPEN;
    276            }
    277          #endif
    278          }
    279          
    280          /***************************************************************************//**
    281           * @brief Disable UART transmitter.
    282           ******************************************************************************/
    283          static void DisableTransmitter(UARTDRV_Handle_t handle)
    284          {
    285          #if (defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)) \
    286            || (defined(EUART_COUNT) && (EUART_COUNT > 0) )
    287            if (handle->type == uartdrvUartTypeUart)
    288          #endif
    289            {
    290              // Disable Tx route
    291          #if defined(USART_ROUTEPEN_TXPEN)
    292              handle->peripheral.uart->ROUTEPEN &= ~USART_ROUTEPEN_TXPEN;
    293          #elif defined(USART_ROUTE_TXPEN)
    294              handle->peripheral.uart->ROUTE &= ~USART_ROUTE_TXPEN;
    295          #elif defined(GPIO_USART_ROUTEEN_TXPEN)
    296              GPIO->USARTROUTE_CLR[handle->uartNum].ROUTEEN = GPIO_USART_ROUTEEN_TXPEN;
    297          #endif
    298              // Disable Tx
    299              handle->peripheral.uart->CMD = USART_CMD_TXDIS;
    300            }
    301          #if defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)
    302            else if (handle->type == uartdrvUartTypeLeuart) {
    303              // Wait for previous register writes to sync
    304              while ((handle->peripheral.leuart->SYNCBUSY & LEUART_SYNCBUSY_CMD) != 0U) {
    305              }
    306          
    307              // Disable Tx route
    308          #if defined(LEUART_ROUTEPEN_TXPEN)
    309              handle->peripheral.leuart->ROUTEPEN &= ~LEUART_ROUTEPEN_TXPEN;
    310          #else
    311              handle->peripheral.leuart->ROUTE &= ~LEUART_ROUTE_TXPEN;
    312          #endif
    313              // Disable Tx
    314              handle->peripheral.leuart->CMD = LEUART_CMD_TXDIS;
    315            }
    316          #elif defined(EUART_COUNT) && (EUART_COUNT > 0)
    317            else if (handle->type == uartdrvUartTypeEuart) {
    318              if (EUSART_StatusGet(handle->peripheral.euart) &  EUSART_STATUS_RXENS) {
    319                EUSART_Enable(handle->peripheral.euart, eusartEnableRx);
    320              } else {
    321                EUSART_Enable(handle->peripheral.euart, eusartEnable);
    322              }
    323              GPIO->EUARTROUTE_CLR->ROUTEEN = GPIO_EUART_ROUTEEN_TXPEN;
    324            }
    325          #endif
    326          }
    327          
    328          /***************************************************************************//**
    329           * @brief Enable UART receiver.
    330           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    331          static void EnableReceiver(UARTDRV_Handle_t handle)
    332          {
    333          #if (defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)) \
    334            || (defined(EUART_COUNT) && (EUART_COUNT > 0) )
    335            if (handle->type == uartdrvUartTypeUart)
    336          #endif
    337            {
    338              // Enable Rx
    339              handle->peripheral.uart->CMD = USART_CMD_RXEN;
   \                     EnableReceiver: (+1)
   \        0x0   0x6802             LDR      R2,[R0, #+0]
   \        0x2   0x2101             MOVS     R1,#+1
   \        0x4   0x6151             STR      R1,[R2, #+20]
    340              // Wait for Rx to be enabled
    341              while (!(handle->peripheral.uart->STATUS & USART_STATUS_RXENS)) {
   \                     ??EnableReceiver_0: (+1)
   \        0x6   0x6801             LDR      R1,[R0, #+0]
   \        0x8   0x698A             LDR      R2,[R1, #+24]
   \        0xA   0x07D1             LSLS     R1,R2,#+31
   \        0xC   0xD5FB             BPL.N    ??EnableReceiver_0
    342              }
    343          
    344              // Enable Rx route
    345          #if defined(USART_ROUTEPEN_RXPEN)
    346              handle->peripheral.uart->ROUTEPEN |= USART_ROUTEPEN_RXPEN;
    347          #elif defined(USART_ROUTE_RXPEN)
    348              handle->peripheral.uart->ROUTE |= USART_ROUTE_RXPEN;
    349          #elif defined(GPIO_USART_ROUTEEN_RXPEN)
    350              GPIO->USARTROUTE_SET[handle->uartNum].ROUTEEN = GPIO_USART_ROUTEEN_RXPEN;
   \        0xE   0x7900             LDRB     R0,[R0, #+4]
   \       0x10   0x2204             MOVS     R2,#+4
   \       0x12   0x....'....        LDR.W    R3,??DataTable22_6  ;; 0x4003d5ac
   \       0x16   0x0140             LSLS     R0,R0,#+5
   \       0x18   0x501A             STR      R2,[R3, R0]
    351          #endif
    352            }
    353          #if defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)
    354            else if (handle->type == uartdrvUartTypeLeuart) {
    355              // Wait for previous register writes to sync
    356              while ((handle->peripheral.leuart->SYNCBUSY & LEUART_SYNCBUSY_CMD) != 0U) {
    357              }
    358          
    359              // Enable Rx
    360              handle->peripheral.leuart->CMD = LEUART_CMD_RXEN;
    361              // Wait for Rx to be enabled
    362              while (!(handle->peripheral.leuart->STATUS & LEUART_STATUS_RXENS)) {
    363              }
    364          
    365              // Enable Rx route
    366          #if defined(LEUART_ROUTEPEN_RXPEN)
    367              handle->peripheral.leuart->ROUTEPEN |= LEUART_ROUTEPEN_RXPEN;
    368          #else
    369              handle->peripheral.leuart->ROUTE |= LEUART_ROUTE_RXPEN;
    370          #endif
    371            }
    372          #elif defined(EUART_COUNT) && (EUART_COUNT > 0)
    373            else if (handle->type == uartdrvUartTypeEuart) {
    374              if (EUSART_StatusGet(handle->peripheral.euart) &  EUSART_STATUS_TXENS) {
    375                EUSART_Enable(handle->peripheral.euart, eusartEnable);
    376              } else {
    377                EUSART_Enable(handle->peripheral.euart, eusartEnableRx);
    378              }
    379            }
    380          #endif
    381          }
   \       0x1A   0x4770             BX       LR               ;; return
    382          
    383          /***************************************************************************//**
    384           * @brief Disable UART receiver.
    385           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    386          static void DisableReceiver(UARTDRV_Handle_t handle)
    387          {
    388          #if (defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)) \
    389            || (defined(EUART_COUNT) && (EUART_COUNT > 0) )
    390            if (handle->type == uartdrvUartTypeUart)
    391          #endif
    392            {
    393              // Disable Rx route
    394          #if defined(USART_ROUTEPEN_RXPEN)
    395              handle->peripheral.uart->ROUTEPEN &= ~USART_ROUTEPEN_RXPEN;
    396          #elif defined(USART_ROUTE_RXPEN)
    397              handle->peripheral.uart->ROUTE &= ~USART_ROUTE_RXPEN;
    398          #elif defined(GPIO_USART_ROUTEEN_RXPEN)
    399              GPIO->USARTROUTE_CLR[handle->uartNum].ROUTEEN = GPIO_USART_ROUTEEN_RXPEN;
   \                     DisableReceiver: (+1)
   \        0x0   0x7903             LDRB     R3,[R0, #+4]
   \        0x2   0x2104             MOVS     R1,#+4
   \        0x4   0x....'....        LDR.W    R2,??DataTable22_7  ;; 0x4003e5ac
   \        0x8   0x015B             LSLS     R3,R3,#+5
   \        0xA   0x50D1             STR      R1,[R2, R3]
    400          #endif
    401              // Disable Rx
    402              handle->peripheral.uart->CMD = USART_CMD_RXDIS;
   \        0xC   0x6800             LDR      R0,[R0, #+0]
   \        0xE   0x2102             MOVS     R1,#+2
   \       0x10   0x6141             STR      R1,[R0, #+20]
    403            }
    404          #if defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)
    405            else if (handle->type == uartdrvUartTypeLeuart) {
    406              // Wait for prevous register writes to sync
    407              while ((handle->peripheral.leuart->SYNCBUSY & LEUART_SYNCBUSY_CMD) != 0U) {
    408              }
    409          
    410              // Disable Rx route
    411          #if defined(LEUART_ROUTEPEN_RXPEN)
    412              handle->peripheral.leuart->ROUTEPEN &= ~LEUART_ROUTEPEN_RXPEN;
    413          #else
    414              handle->peripheral.leuart->ROUTE &= ~LEUART_ROUTE_RXPEN;
    415          #endif
    416              // Disable Rx
    417              handle->peripheral.leuart->CMD = LEUART_CMD_RXDIS;
    418            }
    419          #elif defined(EUART_COUNT) && (EUART_COUNT > 0)
    420            else if (handle->type == uartdrvUartTypeEuart) {
    421              if (EUSART_StatusGet(handle->peripheral.euart) &  EUSART_STATUS_TXENS) {
    422                EUSART_Enable(handle->peripheral.euart, eusartEnableTx);
    423              } else {
    424                EUSART_Enable(handle->peripheral.euart, eusartDisable);
    425              }
    426            }
    427          #endif
    428          }
   \       0x12   0x4770             BX       LR               ;; return
    429          
    430          /***************************************************************************//**
    431           * @brief Start a UART DMA receive operation.
    432           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    433          static void StartReceiveDma(UARTDRV_Handle_t handle,
    434                                      UARTDRV_Buffer_t *buffer)
    435          {
   \                     StartReceiveDma: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
    436            void *rxPort = NULL;
    437          
    438            handle->rxDmaActive = true;
   \        0x4   0xF100 0x032C      ADD      R3,R0,#+44
   \        0x8   0x2401             MOVS     R4,#+1
   \        0xA   0x701C             STRB     R4,[R3, #+0]
    439          
    440            if (handle->type == uartdrvUartTypeUart) {
   \        0xC   0x799A             LDRB     R2,[R3, #+6]
   \        0xE   0xB962             CBNZ.N   R2,??StartReceiveDma_0
    441              rxPort = (void *)&(handle->peripheral.uart->RXDATA);
    442          #if defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)
    443            } else if (handle->type == uartdrvUartTypeLeuart) {
    444              rxPort = (void *)&(handle->peripheral.leuart->RXDATA);
    445          #elif defined(EUART_COUNT) && (EUART_COUNT > 0)
    446            } else if (handle->type == uartdrvUartTypeEuart) {
    447              rxPort = (void *)&(handle->peripheral.euart->RXDATA);
    448          #endif
    449            } else {
    450              handle->rxDmaActive = false;
    451              return;
    452            }
    453          
    454            DMADRV_PeripheralMemory(handle->rxDmaCh,
    455                                    handle->rxDmaSignal,
    456                                    buffer->data,
    457                                    rxPort,
    458                                    true,
    459                                    buffer->transferCount,
    460                                    dmadrvDataSize1,
    461                                    ReceiveDmaComplete,
    462                                    handle);
   \       0x10   0x....'....        ADR.W    R3,ReceiveDmaComplete
   \       0x14   0x....'....        BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0x18   0x6802             LDR      R2,[R0, #+0]
   \       0x1A   0xF102 0x0324      ADD      R3,R2,#+36
   \       0x1E   0x680A             LDR      R2,[R1, #+0]
   \       0x20   0x6941             LDR      R1,[R0, #+20]
   \       0x22   0x68C0             LDR      R0,[R0, #+12]
   \       0x24   0x....'....        BL       DMADRV_PeripheralMemory
    463          }
   \       0x28   0xE001             B.N      ??StartReceiveDma_1
   \                     ??StartReceiveDma_0: (+1)
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0x7019             STRB     R1,[R3, #+0]
   \                     ??StartReceiveDma_1: (+1)
   \       0x2E   0xB005             ADD      SP,SP,#+20
   \       0x30   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0x9004             STR      R0,[SP, #+16]
   \        0x2   0x9303             STR      R3,[SP, #+12]
   \        0x4   0x9202             STR      R2,[SP, #+8]
   \        0x6   0x684C             LDR      R4,[R1, #+4]
   \        0x8   0x2501             MOVS     R5,#+1
   \        0xA   0x9500             STR      R5,[SP, #+0]
   \        0xC   0x9401             STR      R4,[SP, #+4]
   \        0xE   0x4770             BX       LR
    464          
    465          /***************************************************************************//**
    466           * @brief Start a UART DMA transmit operation.
    467           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    468          static void StartTransmitDma(UARTDRV_Handle_t handle,
    469                                       UARTDRV_Buffer_t *buffer)
    470          {
   \                     StartTransmitDma: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
    471            void *txPort = NULL;
    472          
    473            handle->txDmaActive = true;
   \        0x4   0xF100 0x032D      ADD      R3,R0,#+45
   \        0x8   0x2401             MOVS     R4,#+1
   \        0xA   0x701C             STRB     R4,[R3, #+0]
    474          
    475            if (handle->type == uartdrvUartTypeUart) {
   \        0xC   0x795A             LDRB     R2,[R3, #+5]
   \        0xE   0xB95A             CBNZ.N   R2,??StartTransmitDma_0
    476              txPort = (void *)&(handle->peripheral.uart->TXDATA);
    477          #if defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)
    478            } else if (handle->type == uartdrvUartTypeLeuart) {
    479              txPort = (void *)&(handle->peripheral.leuart->TXDATA);
    480          #elif defined(EUART_COUNT) && (EUART_COUNT > 0)
    481            } else if (handle->type == uartdrvUartTypeEuart) {
    482              txPort = (void *)&(handle->peripheral.euart->TXDATA);
    483          #endif
    484            } else {
    485              handle->txDmaActive = false;
    486              return;
    487            }
    488          
    489            DMADRV_MemoryPeripheral(handle->txDmaCh,
    490                                    handle->txDmaSignal,
    491                                    txPort,
    492                                    buffer->data,
    493                                    true,
    494                                    buffer->transferCount,
    495                                    dmadrvDataSize1,
    496                                    TransmitDmaComplete,
    497                                    handle);
   \       0x10   0x....'....        ADR.W    R3,TransmitDmaComplete
   \       0x14   0x....'....        BL       ?Subroutine13
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x18   0x680B             LDR      R3,[R1, #+0]
   \       0x1A   0x6802             LDR      R2,[R0, #+0]
   \       0x1C   0x6901             LDR      R1,[R0, #+16]
   \       0x1E   0x6880             LDR      R0,[R0, #+8]
   \       0x20   0x323C             ADDS     R2,R2,#+60
   \       0x22   0x....'....        BL       DMADRV_MemoryPeripheral
    498          }
   \       0x26   0xE001             B.N      ??StartTransmitDma_1
   \                     ??StartTransmitDma_0: (+1)
   \       0x28   0x2100             MOVS     R1,#+0
   \       0x2A   0x7019             STRB     R1,[R3, #+0]
   \                     ??StartTransmitDma_1: (+1)
   \       0x2C   0xB005             ADD      SP,SP,#+20
   \       0x2E   0xBD30             POP      {R4,R5,PC}       ;; return
    499          
    500          /***************************************************************************//**
    501           * @brief DMA transfer completion callback. Called by the DMA interrupt handler.
    502           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    503          static bool ReceiveDmaComplete(unsigned int channel,
    504                                         unsigned int sequenceNo,
    505                                         void *userParam)
    506          {
   \                     ReceiveDmaComplete: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4615             MOV      R5,R2
    507            CORE_DECLARE_IRQ_STATE;
    508            UARTDRV_Handle_t handle;
    509            UARTDRV_Buffer_t *buffer;
    510            Ecode_t status;
    511            (void)channel;
    512            (void)sequenceNo;
    513            handle = (UARTDRV_Handle_t)userParam;
    514            status = GetTailBuffer(handle->rxQueue, &buffer);
    515          
    516            // If an abort was in progress when DMA completed, the ISR could be deferred
    517            // until after the critical section. In this case, the buffers no longer
    518            // exist, even though the DMA complete callback was called.
    519            if (status == ECODE_EMDRV_UARTDRV_QUEUE_EMPTY) {
   \        0x4   0x6A68             LDR      R0,[R5, #+36]
   \        0x6   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_9: (+1)
   \        0xA   0x....'....        LDR.W    R1,??DataTable22_5  ;; 0xf000700b
   \        0xE   0x4288             CMP      R0,R1
   \       0x10   0xD054             BEQ.N    ??ReceiveDmaComplete_0
    520              return true;
    521            }
    522          
    523            EFM_ASSERT(buffer != NULL);
    524          
    525          #if defined(USART_IF_FERR)
    526            if (handle->type == uartdrvUartTypeUart
    527                && (handle->peripheral.uart->IF & USART_IF_FERR)) {
   \       0x12   0xF105 0x062C      ADD      R6,R5,#+44
   \       0x16   0x79B0             LDRB     R0,[R6, #+6]
   \       0x18   0xF242 0x0148      MOVW     R1,#+8264
   \       0x1C   0xBB00             CBNZ.N   R0,??ReceiveDmaComplete_1
   \       0x1E   0x682A             LDR      R2,[R5, #+0]
   \       0x20   0x6C93             LDR      R3,[R2, #+72]
   \       0x22   0x059A             LSLS     R2,R3,#+22
   \       0x24   0xD50B             BPL.N    ??ReceiveDmaComplete_2
    528              buffer->transferStatus = ECODE_EMDRV_UARTDRV_FRAME_ERROR;
   \       0x26   0x9A00             LDR      R2,[SP, #+0]
   \       0x28   0x....'....        LDR.W    R0,??DataTable22_8  ;; 0xf000700d
   \       0x2C   0x6110             STR      R0,[R2, #+16]
    529              buffer->itemsRemaining = 0;
   \       0x2E   0x9A00             LDR      R2,[SP, #+0]
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x6090             STR      R0,[R2, #+8]
    530          #if defined(USART_HAS_SET_CLEAR)
    531              handle->peripheral.uart->IF_CLR = USART_IF_FERR;
   \       0x34   0x682B             LDR      R3,[R5, #+0]
   \       0x36   0xF44F 0x7000      MOV      R0,#+512
   \       0x3A   0x5058             STR      R0,[R3, R1]
   \       0x3C   0xE012             B.N      ??CrossCallReturnLabel_24
    532          #else
    533              handle->peripheral.uart->IFC = USART_IFC_FERR;
    534          #endif
    535            } else
    536          #endif
    537          #if defined(USART_IF_PERR)
    538            if (handle->type == uartdrvUartTypeUart
    539                && (handle->peripheral.uart->IF & USART_IF_PERR)) {
   \                     ??ReceiveDmaComplete_2: (+1)
   \       0x3E   0xB978             CBNZ.N   R0,??ReceiveDmaComplete_1
   \       0x40   0x6828             LDR      R0,[R5, #+0]
   \       0x42   0x6C82             LDR      R2,[R0, #+72]
   \       0x44   0x05D0             LSLS     R0,R2,#+23
   \       0x46   0xD50B             BPL.N    ??ReceiveDmaComplete_1
    540              buffer->transferStatus = ECODE_EMDRV_UARTDRV_PARITY_ERROR;
   \       0x48   0x9800             LDR      R0,[SP, #+0]
   \       0x4A   0x....'....        LDR.W    R2,??DataTable22_9  ;; 0xf000700c
   \       0x4E   0x6102             STR      R2,[R0, #+16]
    541              buffer->itemsRemaining = 0;
   \       0x50   0x9800             LDR      R0,[SP, #+0]
   \       0x52   0x2200             MOVS     R2,#+0
   \       0x54   0x6082             STR      R2,[R0, #+8]
    542          #if defined(USART_HAS_SET_CLEAR)
    543              handle->peripheral.uart->IF_CLR = USART_IF_PERR;
   \       0x56   0x682B             LDR      R3,[R5, #+0]
   \       0x58   0xF44F 0x7280      MOV      R2,#+256
   \       0x5C   0x505A             STR      R2,[R3, R1]
   \       0x5E   0xE001             B.N      ??CrossCallReturnLabel_24
    544          #else
    545              handle->peripheral.uart->IFC = USART_IFC_PERR;
    546          #endif
    547            } else
    548          #endif
    549          #if defined(LEUART_IF_FERR)
    550            if (handle->type == uartdrvUartTypeLeuart
    551                && (handle->peripheral.leuart->IF & LEUART_IF_FERR)) {
    552              buffer->transferStatus = ECODE_EMDRV_UARTDRV_FRAME_ERROR;
    553              buffer->itemsRemaining = 0;
    554              handle->peripheral.leuart->IFC = LEUART_IFC_FERR;
    555            } else
    556          #endif
    557          #if defined(LEUART_IF_PERR)
    558            if (handle->type == uartdrvUartTypeLeuart
    559                && (handle->peripheral.leuart->IF & LEUART_IF_PERR)) {
    560              buffer->transferStatus = ECODE_EMDRV_UARTDRV_PARITY_ERROR;
    561              buffer->itemsRemaining = 0;
    562              handle->peripheral.leuart->IFC = LEUART_IFC_PERR;
    563            } else
    564          #endif
    565            {
    566              buffer->transferStatus = ECODE_EMDRV_UARTDRV_OK;
   \                     ??ReceiveDmaComplete_1: (+1)
   \       0x60   0x....'....        BL       ?Subroutine15
    567              buffer->itemsRemaining = 0;
    568            }
    569          
    570            CORE_ENTER_ATOMIC();
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0x64   0x....'....        BL       CORE_EnterAtomic
   \       0x68   0x4607             MOV      R7,R0
    571          
    572            if (buffer->callback != NULL) {
   \       0x6A   0x9800             LDR      R0,[SP, #+0]
   \       0x6C   0x68C4             LDR      R4,[R0, #+12]
   \       0x6E   0xB13C             CBZ.N    R4,??ReceiveDmaComplete_3
    573              buffer->callback(handle, buffer->transferStatus, buffer->data, buffer->transferCount - buffer->itemsRemaining);
   \       0x70   0x6843             LDR      R3,[R0, #+4]
   \       0x72   0x4601             MOV      R1,R0
   \       0x74   0x6888             LDR      R0,[R1, #+8]
   \       0x76   0x680A             LDR      R2,[R1, #+0]
   \       0x78   0x6909             LDR      R1,[R1, #+16]
   \       0x7A   0x1A1B             SUBS     R3,R3,R0
   \       0x7C   0x4628             MOV      R0,R5
   \       0x7E   0x47A0             BLX      R4
    574            }
    575            // Dequeue the current tail Rx operation, check if more in queue
    576            DequeueBuffer(handle->rxQueue, &buffer);
   \                     ??ReceiveDmaComplete_3: (+1)
   \       0x80   0x6A68             LDR      R0,[R5, #+36]
   \       0x82   0x4669             MOV      R1,SP
   \       0x84   0x....'....        BL       DequeueBuffer
    577          
    578            if (handle->rxQueue->used > 0) {
   \       0x88   0x6A68             LDR      R0,[R5, #+36]
   \       0x8A   0x8881             LDRH     R1,[R0, #+4]
   \       0x8C   0xB131             CBZ.N    R1,??ReceiveDmaComplete_4
    579              GetTailBuffer(handle->rxQueue, &buffer);
   \       0x8E   0x....'....        BL       ?Subroutine7
    580              StartReceiveDma(handle, buffer);
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x92   0x9900             LDR      R1,[SP, #+0]
   \       0x94   0x4628             MOV      R0,R5
   \       0x96   0x....'....        BL       StartReceiveDma
   \       0x9A   0xE00C             B.N      ??ReceiveDmaComplete_5
    581            } else {
    582          #if EMDRV_UARTDRV_FLOW_CONTROL_ENABLE
    583              handle->fcSelfState = uartdrvFlowControlOff;
   \                     ??ReceiveDmaComplete_4: (+1)
   \       0x9C   0x2001             MOVS     R0,#+1
   \       0x9E   0x7628             STRB     R0,[R5, #+24]
    584              FcApplyState(handle);
   \       0xA0   0x4628             MOV      R0,R5
   \       0xA2   0x....'....        BL       FcApplyState
    585          #endif
    586              handle->rxDmaActive = false;
   \       0xA6   0x2000             MOVS     R0,#+0
   \       0xA8   0x7030             STRB     R0,[R6, #+0]
    587          
    588              if (handle->fcType != uartdrvFlowControlHwUart) {
   \       0xAA   0x7971             LDRB     R1,[R6, #+5]
   \       0xAC   0x2903             CMP      R1,#+3
   \       0xAE   0xBF1C             ITT      NE 
    589                DisableReceiver(handle);
   \       0xB0   0x4628             MOVNE    R0,R5
   \       0xB2   0x....'....        BLNE     DisableReceiver
    590              }
    591            }
    592            CORE_EXIT_ATOMIC();
   \                     ??ReceiveDmaComplete_5: (+1)
   \       0xB6   0x4638             MOV      R0,R7
   \       0xB8   0x....'....        BL       CORE_ExitAtomic
    593            return true;
   \                     ??ReceiveDmaComplete_0: (+1)
   \       0xBC   0x2001             MOVS     R0,#+1
   \       0xBE   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    594          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \        0x0   0x9900             LDR      R1,[SP, #+0]
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0x6108             STR      R0,[R1, #+16]
   \        0x6   0x9900             LDR      R1,[SP, #+0]
   \        0x8   0x6088             STR      R0,[R1, #+8]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x4669             MOV      R1,SP
   \        0x2   0x....             B.N      GetTailBuffer
    595          
    596          /***************************************************************************//**
    597           * @brief DMA transfer completion callback. Called by the DMA interrupt handler.
    598           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    599          static bool TransmitDmaComplete(unsigned int channel,
    600                                          unsigned int sequenceNo,
    601                                          void *userParam)
    602          {
   \                     TransmitDmaComplete: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4615             MOV      R5,R2
    603            CORE_DECLARE_IRQ_STATE;
    604            UARTDRV_Handle_t handle;
    605            UARTDRV_Buffer_t *buffer;
    606            Ecode_t status;
    607            (void)channel;
    608            (void)sequenceNo;
    609          
    610            handle = (UARTDRV_Handle_t)userParam;
    611            status = GetTailBuffer(handle->txQueue, &buffer);
    612          
    613            // If an abort was in progress when DMA completed, the ISR could be deferred
    614            // until after the critical section. In this case, the buffers no longer
    615            // exist, even though the DMA complete callback was called.
    616            if (status == ECODE_EMDRV_UARTDRV_QUEUE_EMPTY) {
   \        0x4   0xF105 0x0628      ADD      R6,R5,#+40
   \        0x8   0x6830             LDR      R0,[R6, #+0]
   \        0xA   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_7: (+1)
   \        0xE   0x....'....        LDR.W    R1,??DataTable22_5  ;; 0xf000700b
   \       0x12   0x4288             CMP      R0,R1
   \       0x14   0xD01F             BEQ.N    ??TransmitDmaComplete_0
    617              return true;
    618            }
    619          
    620            EFM_ASSERT(buffer != NULL);
    621          
    622            buffer->transferStatus = ECODE_EMDRV_UARTDRV_OK;
   \       0x16   0x....'....        BL       ?Subroutine15
    623            buffer->itemsRemaining = 0;
    624          
    625            CORE_ENTER_ATOMIC();
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0x1A   0x....'....        BL       CORE_EnterAtomic
   \       0x1E   0x4607             MOV      R7,R0
    626          
    627            if (buffer->callback != NULL) {
   \       0x20   0x9800             LDR      R0,[SP, #+0]
   \       0x22   0x68C4             LDR      R4,[R0, #+12]
   \       0x24   0xB124             CBZ.N    R4,??TransmitDmaComplete_1
    628              buffer->callback(handle, ECODE_EMDRV_UARTDRV_OK, buffer->data, buffer->transferCount);
   \       0x26   0x6843             LDR      R3,[R0, #+4]
   \       0x28   0x6802             LDR      R2,[R0, #+0]
   \       0x2A   0x2100             MOVS     R1,#+0
   \       0x2C   0x4628             MOV      R0,R5
   \       0x2E   0x47A0             BLX      R4
    629            }
    630            // Dequeue the current tail Tx operation, check if more in queue
    631            DequeueBuffer(handle->txQueue, &buffer);
   \                     ??TransmitDmaComplete_1: (+1)
   \       0x30   0x6830             LDR      R0,[R6, #+0]
   \       0x32   0x4669             MOV      R1,SP
   \       0x34   0x....'....        BL       DequeueBuffer
    632          
    633            if (handle->txQueue->used > 0) {
   \       0x38   0x6830             LDR      R0,[R6, #+0]
   \       0x3A   0x8881             LDRH     R1,[R0, #+4]
   \       0x3C   0xB131             CBZ.N    R1,??TransmitDmaComplete_2
    634              GetTailBuffer(handle->txQueue, &buffer);
   \       0x3E   0x....'....        BL       ?Subroutine7
    635              StartTransmitDma(handle, buffer);
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x42   0x9900             LDR      R1,[SP, #+0]
   \       0x44   0x4628             MOV      R0,R5
   \       0x46   0x....'....        BL       StartTransmitDma
   \       0x4A   0xE001             B.N      ??TransmitDmaComplete_3
    636            } else {
    637              handle->txDmaActive = false;
   \                     ??TransmitDmaComplete_2: (+1)
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0x7170             STRB     R0,[R6, #+5]
    638            }
    639            CORE_EXIT_ATOMIC();
   \                     ??TransmitDmaComplete_3: (+1)
   \       0x50   0x4638             MOV      R0,R7
   \       0x52   0x....'....        BL       CORE_ExitAtomic
    640            return true;
   \                     ??TransmitDmaComplete_0: (+1)
   \       0x56   0x2001             MOVS     R0,#+1
   \       0x58   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    641          }
    642          
    643          /***************************************************************************//**
    644           * @brief Parameter checking function for blocking transfer API functions.
    645           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    646          static Ecode_t CheckParams(UARTDRV_Handle_t handle, void *data, uint32_t count)
    647          {
    648            if (handle == NULL) {
   \                     CheckParams: (+1)
   \        0x0   0xB910             CBNZ.N   R0,??CheckParams_0
    649              return ECODE_EMDRV_UARTDRV_ILLEGAL_HANDLE;
   \        0x2   0x....'....        LDR.W    R0,??DataTable22_10  ;; 0xf0007002
   \        0x6   0x4770             BX       LR
    650            }
    651            if ((data == NULL) || (count == 0) || (count > DMADRV_MAX_XFER_COUNT)) {
   \                     ??CheckParams_0: (+1)
   \        0x8   0x2900             CMP      R1,#+0
   \        0xA   0xBF18             IT       NE 
   \        0xC   0x2A00             CMPNE    R2,#+0
   \        0xE   0xD003             BEQ.N    ??CheckParams_1
   \       0x10   0xF640 0x0001      MOVW     R0,#+2049
   \       0x14   0x4282             CMP      R2,R0
   \       0x16   0xD302             BCC.N    ??CheckParams_2
    652              return ECODE_EMDRV_UARTDRV_PARAM_ERROR;
   \                     ??CheckParams_1: (+1)
   \       0x18   0x....'....        LDR.W    R0,??DataTable22_11  ;; 0xf0007003
   \       0x1C   0x4770             BX       LR
    653            }
    654            return ECODE_EMDRV_UARTDRV_OK;
   \                     ??CheckParams_2: (+1)
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0x4770             BX       LR               ;; return
    655          }
    656          
    657          /***************************************************************************//**
    658           * @brief Store U(S)ART GPIO pins into handle.
    659           ******************************************************************************/
    660          static Ecode_t SetupGpioUart(UARTDRV_Handle_t handle,
    661                                       const UARTDRV_InitUart_t * initData)
    662          {
    663          #if defined(_USART_ROUTELOC0_MASK)
    664            if (false) {
    665          #if defined(USARTRF0)
    666            } else if (handle->peripheral.uart == USARTRF0) {
    667              handle->txPort = (GPIO_Port_TypeDef)AF_USARTRF0_TX_PORT(initData->portLocationTx);
    668              handle->rxPort = (GPIO_Port_TypeDef)AF_USARTRF0_RX_PORT(initData->portLocationRx);
    669              handle->txPin  = AF_USARTRF0_TX_PIN(initData->portLocationTx);
    670              handle->rxPin  = AF_USARTRF0_RX_PIN(initData->portLocationRx);
    671          #endif
    672          #if defined(USARTRF1)
    673            } else if (handle->peripheral.uart == USARTRF1) {
    674              handle->txPort = (GPIO_Port_TypeDef)AF_USARTRF1_TX_PORT(initData->portLocationTx);
    675              handle->rxPort = (GPIO_Port_TypeDef)AF_USARTRF1_RX_PORT(initData->portLocationRx);
    676              handle->txPin  = AF_USARTRF1_TX_PIN(initData->portLocationTx);
    677              handle->rxPin  = AF_USARTRF1_RX_PIN(initData->portLocationRx);
    678          #endif
    679          #if defined(USART0)
    680            } else if (handle->peripheral.uart == USART0) {
    681              handle->txPort = (GPIO_Port_TypeDef)AF_USART0_TX_PORT(initData->portLocationTx);
    682              handle->rxPort = (GPIO_Port_TypeDef)AF_USART0_RX_PORT(initData->portLocationRx);
    683              handle->txPin  = AF_USART0_TX_PIN(initData->portLocationTx);
    684              handle->rxPin  = AF_USART0_RX_PIN(initData->portLocationRx);
    685          #endif
    686          #if defined(USART1)
    687            } else if (handle->peripheral.uart == USART1) {
    688              handle->txPort = (GPIO_Port_TypeDef)AF_USART1_TX_PORT(initData->portLocationTx);
    689              handle->rxPort = (GPIO_Port_TypeDef)AF_USART1_RX_PORT(initData->portLocationRx);
    690              handle->txPin  = AF_USART1_TX_PIN(initData->portLocationTx);
    691              handle->rxPin  = AF_USART1_RX_PIN(initData->portLocationRx);
    692          #endif
    693          #if defined(USART2)
    694            } else if (handle->peripheral.uart == USART2) {
    695              handle->txPort = (GPIO_Port_TypeDef)AF_USART2_TX_PORT(initData->portLocationTx);
    696              handle->rxPort = (GPIO_Port_TypeDef)AF_USART2_RX_PORT(initData->portLocationRx);
    697              handle->txPin  = AF_USART2_TX_PIN(initData->portLocationTx);
    698              handle->rxPin  = AF_USART2_RX_PIN(initData->portLocationRx);
    699          #endif
    700          #if defined(USART3)
    701            } else if (handle->peripheral.uart == USART3) {
    702              handle->txPort = (GPIO_Port_TypeDef)AF_USART3_TX_PORT(initData->portLocationTx);
    703              handle->rxPort = (GPIO_Port_TypeDef)AF_USART3_RX_PORT(initData->portLocationRx);
    704              handle->txPin  = AF_USART3_TX_PIN(initData->portLocationTx);
    705              handle->rxPin  = AF_USART3_RX_PIN(initData->portLocationRx);
    706          #endif
    707          #if defined(USART4)
    708            } else if (handle->peripheral.uart == USART4) {
    709              handle->txPort = (GPIO_Port_TypeDef)AF_USART4_TX_PORT(initData->portLocationTx);
    710              handle->rxPort = (GPIO_Port_TypeDef)AF_USART4_RX_PORT(initData->portLocationRx);
    711              handle->txPin  = AF_USART4_TX_PIN(initData->portLocationTx);
    712              handle->rxPin  = AF_USART4_RX_PIN(initData->portLocationRx);
    713          #endif
    714          #if defined(USART5)
    715            } else if (handle->peripheral.uart == USART5) {
    716              handle->txPort = (GPIO_Port_TypeDef)AF_USART5_TX_PORT(initData->portLocationTx);
    717              handle->rxPort = (GPIO_Port_TypeDef)AF_USART5_RX_PORT(initData->portLocationRx);
    718              handle->txPin  = AF_USART5_TX_PIN(initData->portLocationTx);
    719              handle->rxPin  = AF_USART5_RX_PIN(initData->portLocationRx);
    720          #endif
    721          #if defined(UART0)
    722            } else if (handle->peripheral.uart == UART0) {
    723              handle->txPort = (GPIO_Port_TypeDef)AF_UART0_TX_PORT(initData->portLocationTx);
    724              handle->rxPort = (GPIO_Port_TypeDef)AF_UART0_RX_PORT(initData->portLocationRx);
    725              handle->txPin  = AF_UART0_TX_PIN(initData->portLocationTx);
    726              handle->rxPin  = AF_UART0_RX_PIN(initData->portLocationRx);
    727          #endif
    728          #if defined(UART1)
    729            } else if (handle->peripheral.uart == UART1) {
    730              handle->txPort = (GPIO_Port_TypeDef)AF_UART1_TX_PORT(initData->portLocationTx);
    731              handle->rxPort = (GPIO_Port_TypeDef)AF_UART1_RX_PORT(initData->portLocationRx);
    732              handle->txPin  = AF_UART1_TX_PIN(initData->portLocationTx);
    733              handle->rxPin  = AF_UART1_RX_PIN(initData->portLocationRx);
    734          #endif
    735          #if defined(UART2)
    736            } else if (handle->peripheral.uart == UART2) {
    737              handle->txPort = (GPIO_Port_TypeDef)AF_UART2_TX_PORT(initData->portLocationTx);
    738              handle->rxPort = (GPIO_Port_TypeDef)AF_UART2_RX_PORT(initData->portLocationRx);
    739              handle->txPin  = AF_UART2_TX_PIN(initData->portLocationTx);
    740              handle->rxPin  = AF_UART2_RX_PIN(initData->portLocationRx);
    741          #endif
    742            } else {
    743              return ECODE_EMDRV_UARTDRV_PARAM_ERROR;
    744            }
    745          
    746          #elif defined(_USART_ROUTE_MASK)
    747            if (false) {
    748          #if defined(USARTRF0)
    749            } else if (handle->peripheral.uart == USARTRF0) {
    750              handle->txPort = (GPIO_Port_TypeDef)AF_USARTRF0_TX_PORT(initData->portLocation);
    751              handle->rxPort = (GPIO_Port_TypeDef)AF_USARTRF0_RX_PORT(initData->portLocation);
    752              handle->txPin  = AF_USARTRF0_TX_PIN(initData->portLocation);
    753              handle->rxPin  = AF_USARTRF0_RX_PIN(initData->portLocation);
    754          #endif
    755          #if defined(USARTRF1)
    756            } else if (handle->peripheral.uart == USARTRF1) {
    757              handle->txPort = (GPIO_Port_TypeDef)AF_USARTRF1_TX_PORT(initData->portLocation);
    758              handle->rxPort = (GPIO_Port_TypeDef)AF_USARTRF1_RX_PORT(initData->portLocation);
    759              handle->txPin  = AF_USARTRF1_TX_PIN(initData->portLocation);
    760              handle->rxPin  = AF_USARTRF1_RX_PIN(initData->portLocation);
    761          #endif
    762          #if defined(USART0)
    763            } else if (handle->peripheral.uart == USART0) {
    764              handle->txPort  = (GPIO_Port_TypeDef)AF_USART0_TX_PORT(initData->portLocation);
    765              handle->rxPort  = (GPIO_Port_TypeDef)AF_USART0_RX_PORT(initData->portLocation);
    766              handle->txPin   = AF_USART0_TX_PIN(initData->portLocation);
    767              handle->rxPin   = AF_USART0_RX_PIN(initData->portLocation);
    768          #endif
    769          #if defined(USART1)
    770            } else if (handle->peripheral.uart == USART1) {
    771              handle->txPort  = (GPIO_Port_TypeDef)AF_USART1_TX_PORT(initData->portLocation);
    772              handle->rxPort  = (GPIO_Port_TypeDef)AF_USART1_RX_PORT(initData->portLocation);
    773              handle->txPin   = AF_USART1_TX_PIN(initData->portLocation);
    774              handle->rxPin   = AF_USART1_RX_PIN(initData->portLocation);
    775          #endif
    776          #if defined(USART2)
    777            } else if (handle->peripheral.uart == USART2) {
    778              handle->txPort  = (GPIO_Port_TypeDef)AF_USART2_TX_PORT(initData->portLocation);
    779              handle->rxPort  = (GPIO_Port_TypeDef)AF_USART2_RX_PORT(initData->portLocation);
    780              handle->txPin   = AF_USART2_TX_PIN(initData->portLocation);
    781              handle->rxPin   = AF_USART2_RX_PIN(initData->portLocation);
    782          #endif
    783          #if defined(UART0)
    784            } else if (handle->peripheral.uart == UART0) {
    785              handle->txPort  = (GPIO_Port_TypeDef)AF_UART0_TX_PORT(initData->portLocation);
    786              handle->rxPort  = (GPIO_Port_TypeDef)AF_UART0_RX_PORT(initData->portLocation);
    787              handle->txPin   = AF_UART0_TX_PIN(initData->portLocation);
    788              handle->rxPin   = AF_UART0_RX_PIN(initData->portLocation);
    789          #endif
    790          #if defined(UART1)
    791            } else if (handle->peripheral.uart == UART1) {
    792              handle->txPort  = (GPIO_Port_TypeDef)AF_UART1_TX_PORT(initData->portLocation);
    793              handle->rxPort  = (GPIO_Port_TypeDef)AF_UART1_RX_PORT(initData->portLocation);
    794              handle->txPin   = AF_UART1_TX_PIN(initData->portLocation);
    795              handle->rxPin   = AF_UART1_RX_PIN(initData->portLocation);
    796          #endif
    797            } else {
    798              return ECODE_EMDRV_UARTDRV_PARAM_ERROR;
    799            }
    800          
    801          #elif defined(_GPIO_USART_ROUTEEN_MASK)
    802            handle->txPort  = initData->txPort;
    803            handle->txPin   = initData->txPin;
    804            handle->rxPort  = initData->rxPort;
    805            handle->rxPin   = initData->rxPin;
    806          #endif
    807          
    808            handle->ctsPort = initData->ctsPort;
    809            handle->ctsPin  = initData->ctsPin;
    810            handle->rtsPort = initData->rtsPort;
    811            handle->rtsPin  = initData->rtsPin;
    812          
    813            return ECODE_EMDRV_UARTDRV_OK;
    814          }
    815          
    816          #if defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)
    817          /***************************************************************************//**
    818           * @brief Store LEUART GPIO pins into handle.
    819           ******************************************************************************/
    820          static Ecode_t SetupGpioLeuart(UARTDRV_Handle_t handle,
    821                                         const UARTDRV_InitLeuart_t * initData)
    822          {
    823          #if defined(_LEUART_ROUTELOC0_MASK)
    824            if (false) {
    825          #if defined(LEUART0)
    826            } else if (handle->peripheral.leuart == LEUART0) {
    827              handle->txPort  = (GPIO_Port_TypeDef)AF_LEUART0_TX_PORT(initData->portLocationTx);
    828              handle->rxPort  = (GPIO_Port_TypeDef)AF_LEUART0_RX_PORT(initData->portLocationRx);
    829              handle->txPin   = AF_LEUART0_TX_PIN(initData->portLocationTx);
    830              handle->rxPin   = AF_LEUART0_RX_PIN(initData->portLocationRx);
    831          #endif
    832          #if defined(LEUART1)
    833            } else if (handle->peripheral.leuart == LEUART1) {
    834              handle->txPort  = (GPIO_Port_TypeDef)AF_LEUART1_TX_PORT(initData->portLocationTx);
    835              handle->rxPort  = (GPIO_Port_TypeDef)AF_LEUART1_RX_PORT(initData->portLocationRx);
    836              handle->txPin   = AF_LEUART1_TX_PIN(initData->portLocationTx);
    837              handle->rxPin   = AF_LEUART1_RX_PIN(initData->portLocationRx);
    838          #endif
    839            } else {
    840              return ECODE_EMDRV_UARTDRV_PARAM_ERROR;
    841            }
    842          
    843          #elif defined(_USART_ROUTE_MASK)
    844            if (false) {
    845          #if defined(LEUART0)
    846            } else if (handle->peripheral.leuart == LEUART0) {
    847              handle->txPort  = (GPIO_Port_TypeDef)AF_LEUART0_TX_PORT(initData->portLocation);
    848              handle->rxPort  = (GPIO_Port_TypeDef)AF_LEUART0_RX_PORT(initData->portLocation);
    849              handle->txPin   = AF_LEUART0_TX_PIN(initData->portLocation);
    850              handle->rxPin   = AF_LEUART0_RX_PIN(initData->portLocation);
    851          #endif
    852          #if defined(LEUART1)
    853            } else if (handle->peripheral.leuart == LEUART1) {
    854              handle->txPort  = (GPIO_Port_TypeDef)AF_LEUART1_TX_PORT(initData->portLocation);
    855              handle->rxPort  = (GPIO_Port_TypeDef)AF_LEUART1_RX_PORT(initData->portLocation);
    856              handle->txPin   = AF_LEUART1_TX_PIN(initData->portLocation);
    857              handle->rxPin   = AF_LEUART1_RX_PIN(initData->portLocation);
    858          #endif
    859            } else {
    860              return ECODE_EMDRV_UARTDRV_PARAM_ERROR;
    861            }
    862          
    863          #elif defined(_GPIO_USART_ROUTEEN_MASK)
    864            handle->txPort  = initData->txPort;
    865            handle->txPin   = initData->txPin;
    866            handle->rxPort  = initData->rxPort;
    867            handle->rxPin   = initData->rxPin;
    868          #endif
    869          
    870            handle->ctsPort = initData->ctsPort;
    871            handle->ctsPin  = initData->ctsPin;
    872            handle->rtsPort = initData->rtsPort;
    873            handle->rtsPin  = initData->rtsPin;
    874          
    875            return ECODE_EMDRV_UARTDRV_OK;
    876          }
    877          #endif
    878          
    879          #if defined(EUART_COUNT) && (EUART_COUNT > 0)
    880          /***************************************************************************//**
    881           * @brief Store EUART GPIO pins into handle.
    882           ******************************************************************************/
    883          static Ecode_t SetupGpioEuart(UARTDRV_Handle_t handle,
    884                                        const UARTDRV_InitEuart_t * initData)
    885          {
    886            handle->txPort  = initData->txPort;
    887            handle->txPin   = initData->txPin;
    888            handle->rxPort  = initData->rxPort;
    889            handle->rxPin   = initData->rxPin;
    890          
    891            handle->ctsPort = initData->ctsPort;
    892            handle->ctsPin  = initData->ctsPin;
    893            handle->rtsPort = initData->rtsPort;
    894            handle->rtsPin  = initData->rtsPin;
    895          
    896            return ECODE_EMDRV_UARTDRV_OK;
    897          }
    898          #endif
    899          
    900          /***************************************************************************//**
    901           * @brief Configure/deconfigure U(S)ART GPIO pins.
    902           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    903          static Ecode_t ConfigGpio(UARTDRV_Handle_t handle, bool enable)
    904          {
   \                     ConfigGpio: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x000A             MOVS     R2,R1
    905            if (enable) {
   \        0x6   0x7FE1             LDRB     R1,[R4, #+31]
   \        0x8   0x7EE0             LDRB     R0,[R4, #+27]
   \        0xA   0xF104 0x0521      ADD      R5,R4,#+33
   \        0xE   0xD01E             BEQ.N    ??ConfigGpio_0
    906              GPIO_PinModeSet(handle->txPort, handle->txPin, gpioModePushPull, 1);
   \       0x10   0x2301             MOVS     R3,#+1
   \       0x12   0x2204             MOVS     R2,#+4
   \       0x14   0x....'....        BL       GPIO_PinModeSet
    907              GPIO_PinModeSet(handle->rxPort, handle->rxPin, gpioModeInputPull, 1);
   \       0x18   0xF894 0x1020      LDRB     R1,[R4, #+32]
   \       0x1C   0x7F20             LDRB     R0,[R4, #+28]
   \       0x1E   0x2301             MOVS     R3,#+1
   \       0x20   0x2202             MOVS     R2,#+2
   \       0x22   0x....'....        BL       GPIO_PinModeSet
    908          #if (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE)
    909              if (handle->fcType == uartdrvFlowControlHw) {
   \       0x26   0x7C28             LDRB     R0,[R5, #+16]
   \       0x28   0x2802             CMP      R0,#+2
   \       0x2A   0xD109             BNE.N    ??ConfigGpio_1
    910                GPIO_PinModeSet(handle->ctsPort, handle->ctsPin, gpioModeInput, 0);
   \       0x2C   0x....'....        BL       ?Subroutine17
    911                GPIO_PinModeSet(handle->rtsPort, handle->rtsPin, gpioModePushPull, 0);
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0x30   0x7869             LDRB     R1,[R5, #+1]
   \       0x32   0x7FA0             LDRB     R0,[R4, #+30]
   \       0x34   0x2300             MOVS     R3,#+0
   \       0x36   0x2204             MOVS     R2,#+4
   \       0x38   0x....'....        BL       GPIO_PinModeSet
    912                GPIO_IntConfig(handle->ctsPort, handle->ctsPin, true, true, true);
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0xE018             B.N      ??ConfigGpio_2
    913              } else if (handle->fcType == uartdrvFlowControlHwUart) {
   \                     ??ConfigGpio_1: (+1)
   \       0x40   0x2803             CMP      R0,#+3
   \       0x42   0xD128             BNE.N    ??ConfigGpio_3
    914                GPIO_PinModeSet(handle->ctsPort, handle->ctsPin, gpioModeInput, 0);
   \       0x44   0x....'....        BL       ?Subroutine17
    915                GPIO_PinModeSet(handle->rtsPort, handle->rtsPin, gpioModePushPull, 0);
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x48   0x2300             MOVS     R3,#+0
   \       0x4A   0x2204             MOVS     R2,#+4
   \       0x4C   0xE01F             B.N      ??ConfigGpio_4
    916              }
    917          #endif
    918            } else {
    919              GPIO_PinModeSet(handle->txPort, handle->txPin, gpioModeDisabled, 0);
   \                     ??ConfigGpio_0: (+1)
   \       0x4E   0x2300             MOVS     R3,#+0
   \       0x50   0x....'....        BL       GPIO_PinModeSet
    920              GPIO_PinModeSet(handle->rxPort, handle->rxPin, gpioModeDisabled, 0);
   \       0x54   0xF894 0x1020      LDRB     R1,[R4, #+32]
   \       0x58   0x7F20             LDRB     R0,[R4, #+28]
   \       0x5A   0x....'....        BL       ??Subroutine6_0
    921          #if (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE)
    922              if (handle->fcType == uartdrvFlowControlHw) {
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x5E   0x7C28             LDRB     R0,[R5, #+16]
   \       0x60   0x2802             CMP      R0,#+2
   \       0x62   0xD10E             BNE.N    ??ConfigGpio_5
    923                GPIO_PinModeSet(handle->ctsPort, handle->ctsPin, gpioModeDisabled, 0);
   \       0x64   0x....'....        BL       ?Subroutine6
    924                GPIO_PinModeSet(handle->rtsPort, handle->rtsPin, gpioModeDisabled, 0);
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x68   0x7869             LDRB     R1,[R5, #+1]
   \       0x6A   0x7FA0             LDRB     R0,[R4, #+30]
   \       0x6C   0x....'....        BL       ??Subroutine6_0
    925                GPIO_IntConfig(handle->ctsPort, handle->ctsPin, true, true, false);
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x70   0x2000             MOVS     R0,#+0
   \                     ??ConfigGpio_2: (+1)
   \       0x72   0x9000             STR      R0,[SP, #+0]
   \       0x74   0x2301             MOVS     R3,#+1
   \       0x76   0x2201             MOVS     R2,#+1
   \       0x78   0x7829             LDRB     R1,[R5, #+0]
   \       0x7A   0x7F60             LDRB     R0,[R4, #+29]
   \       0x7C   0x....'....        BL       GPIO_IntConfig
   \       0x80   0xE009             B.N      ??ConfigGpio_3
    926              } else if (handle->fcType == uartdrvFlowControlHwUart) {
   \                     ??ConfigGpio_5: (+1)
   \       0x82   0x2803             CMP      R0,#+3
   \       0x84   0xD107             BNE.N    ??ConfigGpio_3
    927                GPIO_PinModeSet(handle->ctsPort, handle->ctsPin, gpioModeDisabled, 0);
   \       0x86   0x....'....        BL       ?Subroutine6
    928                GPIO_PinModeSet(handle->rtsPort, handle->rtsPin, gpioModeDisabled, 0);
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x8A   0x2300             MOVS     R3,#+0
   \       0x8C   0x2200             MOVS     R2,#+0
   \                     ??ConfigGpio_4: (+1)
   \       0x8E   0x7869             LDRB     R1,[R5, #+1]
   \       0x90   0x7FA0             LDRB     R0,[R4, #+30]
   \       0x92   0x....'....        BL       GPIO_PinModeSet
    929              }
    930          #endif
    931            }
    932            return ECODE_EMDRV_UARTDRV_OK;
   \                     ??ConfigGpio_3: (+1)
   \       0x96   0x2000             MOVS     R0,#+0
   \       0x98   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    933          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine17: (+1)
   \        0x0   0x7829             LDRB     R1,[R5, #+0]
   \        0x2   0x7F60             LDRB     R0,[R4, #+29]
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x2201             MOVS     R2,#+1
   \        0x8   0x....'....        B.W      GPIO_PinModeSet

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x7829             LDRB     R1,[R5, #+0]
   \        0x2   0x7F60             LDRB     R0,[R4, #+29]
   \                     ??Subroutine6_0: (+1)
   \        0x4   0x2300             MOVS     R3,#+0
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x....'....        B.W      GPIO_PinModeSet
    934          
    935          #if (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE)
    936          /***************************************************************************//**
    937           * @brief Set index into handle pointer array.
    938           ******************************************************************************/
    939          static Ecode_t SetHandleIndex(UARTDRV_Handle_t handle)
    940          {
    941            bool handleIsSet;
    942            uint32_t handleIdx;
    943          
    944            // Set handler pointer in handler array
    945            if (!uartdrvHandleIsInitialized) {
    946              for (handleIdx = 0; handleIdx < EMDRV_UARTDRV_MAX_DRIVER_INSTANCES; handleIdx++) {
    947                uartdrvHandle[handleIdx] = NULL;
    948              }
    949              uartdrvHandleIsInitialized = true;
    950            }
    951          
    952            handleIsSet = false;
    953            for (handleIdx = 0; handleIdx < EMDRV_UARTDRV_MAX_DRIVER_INSTANCES; handleIdx++) {
    954              if ((uartdrvHandle[handleIdx] == NULL) || (uartdrvHandle[handleIdx] == handle)) {
    955                uartdrvHandle[handleIdx] = handle;
    956                handleIsSet = true;
    957                break;
    958              }
    959            }
    960          
    961            if (!handleIsSet) {
    962              return ECODE_EMDRV_UARTDRV_ILLEGAL_HANDLE;
    963            }
    964          
    965            return ECODE_EMDRV_UARTDRV_OK;
    966          }
    967          #endif
    968          
    969          /***************************************************************************//**
    970           * @brief Initialize FIFO queues for a handle.
    971           ******************************************************************************/
    972          static void InitializeQueues(UARTDRV_Handle_t handle,
    973                                       UARTDRV_Buffer_FifoQueue_t * rxQueue,
    974                                       UARTDRV_Buffer_FifoQueue_t * txQueue)
    975          {
    976            handle->rxQueue = rxQueue;
    977            handle->rxQueue->head = 0;
    978            handle->rxQueue->tail = 0;
    979            handle->rxQueue->used = 0;
    980            handle->rxDmaActive = false;
    981          
    982            handle->txQueue = txQueue;
    983            handle->txQueue->head = 0;
    984            handle->txQueue->tail = 0;
    985            handle->txQueue->used = 0;
    986            handle->txDmaActive = false;
    987          
    988            handle->IgnoreRestrain = false;
    989          }
    990          
    991          #if (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE)
    992          /***************************************************************************//**
    993           * @brief Initialize GPIO-driven flow control.
    994           ******************************************************************************/
    995          static void InitializeGpioFlowControl(UARTDRV_Handle_t handle)
    996          {
    997            GPIOINT_CallbackRegister(handle->ctsPin, HwFcManageClearToSend);
    998            GPIOINT_Init();
    999            handle->fcPeerState = uartdrvFlowControlOn;
   1000            handle->fcSelfState = uartdrvFlowControlOn;
   1001            handle->fcSelfCfg = uartdrvFlowControlAuto;
   1002            FcApplyState(handle);
   1003          }
   1004          #endif
   1005          
   1006          /***************************************************************************//**
   1007           * @brief Initialize DMA channels for a handle.
   1008           ******************************************************************************/
   1009          static Ecode_t InitializeDma(UARTDRV_Handle_t handle)
   1010          {
   1011            // Initialize DMA.
   1012            DMADRV_Init();
   1013          
   1014            if (DMADRV_AllocateChannel(&handle->txDmaCh, NULL) != ECODE_EMDRV_DMADRV_OK) {
   1015              return ECODE_EMDRV_UARTDRV_DMA_ALLOC_ERROR;
   1016            }
   1017          
   1018            if (DMADRV_AllocateChannel(&handle->rxDmaCh, NULL) != ECODE_EMDRV_DMADRV_OK) {
   1019              return ECODE_EMDRV_UARTDRV_DMA_ALLOC_ERROR;
   1020            }
   1021          
   1022            return ECODE_EMDRV_UARTDRV_OK;
   1023          }
   1024          /// @endcond
   1025          
   1026          /***************************************************************************//**
   1027           * @brief
   1028           *    Initialize a U(S)ART driver instance.
   1029           *
   1030           * @param[out] handle  Pointer to a UARTDRV handle, refer to @ref
   1031           *                     UARTDRV_Handle_t.
   1032           *
   1033           * @param[in] initData Pointer to an initialization data structure,
   1034           *                     refer to @ref UARTDRV_InitUart_t.
   1035           *
   1036           * @return
   1037           *    @ref ECODE_EMDRV_UARTDRV_OK on success. On failure an appropriate
   1038           *    UARTDRV @ref Ecode_t is returned.
   1039           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1040          Ecode_t UARTDRV_InitUart(UARTDRV_Handle_t handle,
   1041                                   const UARTDRV_InitUart_t *initData)
   1042          {
   \                     UARTDRV_InitUart: (+1)
   \        0x0   0xE92D 0x41F8      PUSH     {R3-R8,LR}
   \        0x4   0xB087             SUB      SP,SP,#+28
   \        0x6   0x4605             MOV      R5,R0
   \        0x8   0x460C             MOV      R4,R1
   1043            Ecode_t retVal;
   1044            CORE_DECLARE_IRQ_STATE;
   1045            USART_InitAsync_TypeDef usartInit = USART_INITASYNC_DEFAULT;
   \        0xA   0x4668             MOV      R0,SP
   \        0xC   0x....'....        LDR.W    R1,??DataTable22_12
   \       0x10   0x221C             MOVS     R2,#+28
   \       0x12   0x....'....        BL       __aeabi_memcpy4
   1046          
   1047            if (handle == NULL) {
   \       0x16   0xB1ED             CBZ.N    R5,??UARTDRV_InitUart_0
   1048              return ECODE_EMDRV_UARTDRV_ILLEGAL_HANDLE;
   1049            }
   1050            if (initData == NULL) {
   \       0x18   0x2C00             CMP      R4,#+0
   \       0x1A   0xD036             BEQ.N    ??UARTDRV_InitUart_1
   1051              return ECODE_EMDRV_UARTDRV_PARAM_ERROR;
   1052            }
   1053          
   1054            memset(handle, 0, sizeof(UARTDRV_HandleData_t));
   \       0x1C   0x2134             MOVS     R1,#+52
   \       0x1E   0x4628             MOV      R0,R5
   \       0x20   0x....'....        BL       __aeabi_memclr4
   1055          
   1056          #if (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE)
   1057            retVal = SetHandleIndex(handle);
   \       0x24   0x....'....        LDR.W    R2,??DataTable22_13
   \       0x28   0x7810             LDRB     R0,[R2, #+0]
   \       0x2A   0x....'....        LDR.W    R1,??DataTable22_3
   \       0x2E   0xB938             CBNZ.N   R0,??UARTDRV_InitUart_2
   \       0x30   0x2300             MOVS     R3,#+0
   \                     ??UARTDRV_InitUart_3: (+1)
   \       0x32   0xF841 0x3020      STR      R3,[R1, R0, LSL #+2]
   \       0x36   0x1C40             ADDS     R0,R0,#+1
   \       0x38   0x2804             CMP      R0,#+4
   \       0x3A   0xD3FA             BCC.N    ??UARTDRV_InitUart_3
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0x7010             STRB     R0,[R2, #+0]
   \                     ??UARTDRV_InitUart_2: (+1)
   \       0x40   0x2200             MOVS     R2,#+0
   \                     ??UARTDRV_InitUart_4: (+1)
   \       0x42   0xF851 0x0022      LDR      R0,[R1, R2, LSL #+2]
   \       0x46   0x2800             CMP      R0,#+0
   \       0x48   0xBF18             IT       NE 
   \       0x4A   0x42A8             CMPNE    R0,R5
   \       0x4C   0xD07C             BEQ.N    ??UARTDRV_InitUart_5
   \       0x4E   0x1C52             ADDS     R2,R2,#+1
   \       0x50   0x2A04             CMP      R2,#+4
   \       0x52   0xD3F6             BCC.N    ??UARTDRV_InitUart_4
   1058            if (retVal != ECODE_EMDRV_UARTDRV_OK) {
   1059              return retVal;
   \                     ??UARTDRV_InitUart_0: (+1)
   \       0x54   0x....'....        LDR.W    R0,??DataTable22_10  ;; 0xf0007002
   \       0x58   0xE073             B.N      ??UARTDRV_InitUart_6
   1060            }
   1061            handle->fcType = initData->fcType;
   1062          #else
   1063            // Force init data to uartdrvFlowControlNone if flow control is excluded by EMDRV_UARTDRV_FLOW_CONTROL_ENABLE
   1064            handle->fcType = uartdrvFlowControlNone;
   1065          #endif
   1066          
   1067            handle->peripheral.uart = initData->port;
   1068            handle->type = uartdrvUartTypeUart;
   1069          #if defined(_GPIO_USART_ROUTEEN_MASK)
   1070            handle->uartNum = initData->uartNum;
   1071          #endif
   1072          
   1073            // Set clocks and DMA requests according to available peripherals
   1074            if (false) {
   1075          #if defined(USART0)
   1076            } else if (initData->port == USART0) {
   1077              handle->uartClock   = cmuClock_USART0;
   1078              handle->txDmaSignal = dmadrvPeripheralSignal_USART0_TXBL;
   1079              handle->rxDmaSignal = dmadrvPeripheralSignal_USART0_RXDATAV;
   1080          #endif
   1081          #if defined(USART1)
   1082            } else if (initData->port == USART1) {
   \                     ??UARTDRV_InitUart_7: (+1)
   \       0x5A   0x....'....        LDR.W    R2,??DataTable22_14  ;; 0x4005c000
   \       0x5E   0x4290             CMP      R0,R2
   \       0x60   0xD107             BNE.N    ??UARTDRV_InitUart_8
   1083              handle->uartClock   = cmuClock_USART1;
   \       0x62   0x2321             MOVS     R3,#+33
   \       0x64   0x70BB             STRB     R3,[R7, #+2]
   1084              handle->txDmaSignal = dmadrvPeripheralSignal_USART1_TXBL;
   \       0x66   0x....'....        LDR.W    R2,??DataTable22_15  ;; 0x50002
   \       0x6A   0x6132             STR      R2,[R6, #+16]
   1085              handle->rxDmaSignal = dmadrvPeripheralSignal_USART1_RXDATAV;
   \       0x6C   0xF44F 0x23A0      MOV      R3,#+327680
   \       0x70   0xE086             B.N      ??UARTDRV_InitUart_9
   1086          #endif
   1087          #if defined(USART2)
   1088            } else if (initData->port == USART2) {
   \                     ??UARTDRV_InitUart_8: (+1)
   \       0x72   0x....'....        LDR.W    R2,??DataTable22_16  ;; 0x40060000
   \       0x76   0x4290             CMP      R0,R2
   \       0x78   0xD107             BNE.N    ??UARTDRV_InitUart_1
   1089              handle->uartClock   = cmuClock_USART2;
   \       0x7A   0x2322             MOVS     R3,#+34
   \       0x7C   0x70BB             STRB     R3,[R7, #+2]
   1090              handle->txDmaSignal = dmadrvPeripheralSignal_USART2_TXBL;
   \       0x7E   0x....'....        LDR.W    R2,??DataTable22_17  ;; 0x60002
   \       0x82   0x6132             STR      R2,[R6, #+16]
   1091              handle->rxDmaSignal = dmadrvPeripheralSignal_USART2_RXDATAV;
   \       0x84   0xF44F 0x23C0      MOV      R3,#+393216
   \       0x88   0xE07A             B.N      ??UARTDRV_InitUart_9
   1092          #endif
   1093          #if defined(USART3)
   1094            } else if (initData->port == USART3) {
   1095              handle->uartClock   = cmuClock_USART3;
   1096              handle->txDmaSignal = dmadrvPeripheralSignal_USART3_TXBL;
   1097              handle->rxDmaSignal = dmadrvPeripheralSignal_USART3_RXDATAV;
   1098          #endif
   1099          #if defined(USART4)
   1100            } else if (initData->port == USART4) {
   1101              handle->uartClock   = cmuClock_USART4;
   1102              handle->txDmaSignal = dmadrvPeripheralSignal_USART4_TXBL;
   1103              handle->rxDmaSignal = dmadrvPeripheralSignal_USART4_RXDATAV;
   1104          #endif
   1105          #if defined(USART5)
   1106            } else if (initData->port == USART5) {
   1107              handle->uartClock   = cmuClock_USART5;
   1108              handle->txDmaSignal = dmadrvPeripheralSignal_USART5_TXBL;
   1109              handle->rxDmaSignal = dmadrvPeripheralSignal_USART5_RXDATAV;
   1110          #endif
   1111          #if defined(UART0) && !defined(_SILICON_LABS_32B_SERIES_2)
   1112            } else if (initData->port == UART0) {
   1113              handle->uartClock   = cmuClock_UART0;
   1114              handle->txDmaSignal = dmadrvPeripheralSignal_UART0_TXBL;
   1115              handle->rxDmaSignal = dmadrvPeripheralSignal_UART0_RXDATAV;
   1116          #endif
   1117          #if defined(UART1)
   1118            } else if (initData->port == UART1) {
   1119              handle->uartClock   = cmuClock_UART1;
   1120              handle->txDmaSignal = dmadrvPeripheralSignal_UART1_TXBL;
   1121              handle->rxDmaSignal = dmadrvPeripheralSignal_UART1_RXDATAV;
   1122          #endif
   1123          #if defined(UART2)
   1124            } else if (initData->port == UART2) {
   1125              handle->uartClock   = cmuClock_UART2;
   1126              handle->txDmaSignal = dmadrvPeripheralSignal_UART2_TXBL;
   1127              handle->rxDmaSignal = dmadrvPeripheralSignal_UART2_RXDATAV;
   1128          #endif
   1129            } else {
   1130              return ECODE_EMDRV_UARTDRV_PARAM_ERROR;
   \                     ??UARTDRV_InitUart_1: (+1)
   \       0x8A   0x....'....        LDR.W    R0,??DataTable22_11  ;; 0xf0007003
   \       0x8E   0xE058             B.N      ??UARTDRV_InitUart_6
   1131            }
   1132          
   1133            InitializeQueues(handle, initData->rxQueue, initData->txQueue);
   1134          
   1135            usartInit.baudrate = initData->baudRate;
   1136            usartInit.stopbits = initData->stopBits;
   1137            usartInit.parity = initData->parity;
   1138            usartInit.oversampling = initData->oversampling;
   1139          #if defined(USART_CTRL_MVDIS)
   1140            usartInit.mvdis = initData->mvdis;
   1141          #endif
   1142          
   1143            // UARTDRV is fixed at 8 bit frames.
   1144            usartInit.databits = (USART_Databits_TypeDef)USART_FRAME_DATABITS_EIGHT;
   1145          
   1146            // Enable clocks
   1147          #if defined(_CMU_HFPERCLKEN0_MASK)
   1148            CMU_ClockEnable(cmuClock_HFPER, true);
   1149          #endif
   1150            CMU_ClockEnable(cmuClock_GPIO, true);
   1151            CMU_ClockEnable(handle->uartClock, true);
   1152          
   1153            // Init U(S)ART to default async config.
   1154            // Rx/Tx enable is done on demand
   1155            usartInit.enable = usartDisable;
   1156            USART_InitAsync(initData->port, &usartInit);
   1157          
   1158          #if defined(USART_ROUTEPEN_TXPEN)
   1159            initData->port->ROUTELOC0 = (initData->port->ROUTELOC0
   1160                                         & ~(_USART_ROUTELOC0_TXLOC_MASK
   1161                                             | _USART_ROUTELOC0_RXLOC_MASK))
   1162                                        | (initData->portLocationTx
   1163                                           << _USART_ROUTELOC0_TXLOC_SHIFT)
   1164                                        | (initData->portLocationRx
   1165                                           << _USART_ROUTELOC0_RXLOC_SHIFT);
   1166          
   1167            initData->port->ROUTEPEN = USART_ROUTEPEN_TXPEN
   1168                                       | USART_ROUTEPEN_RXPEN;
   1169          #elif defined(USART_ROUTE_TXPEN)
   1170            initData->port->ROUTE = USART_ROUTE_TXPEN
   1171                                    | USART_ROUTE_RXPEN
   1172                                    | (initData->portLocation
   1173                                       << _USART_ROUTE_LOCATION_SHIFT);
   1174          #elif defined(GPIO_USART_ROUTEEN_TXPEN)
   1175            GPIO->USARTROUTE[initData->uartNum].ROUTEEN = GPIO_USART_ROUTEEN_TXPEN
   1176                                                          | GPIO_USART_ROUTEEN_RXPEN;
   1177            GPIO->USARTROUTE[initData->uartNum].TXROUTE =
   1178              (initData->txPort << _GPIO_USART_TXROUTE_PORT_SHIFT)
   1179              | (initData->txPin << _GPIO_USART_TXROUTE_PIN_SHIFT);
   1180            GPIO->USARTROUTE[initData->uartNum].RXROUTE =
   1181              (initData->rxPort << _GPIO_USART_RXROUTE_PORT_SHIFT)
   1182              | (initData->rxPin << _GPIO_USART_RXROUTE_PIN_SHIFT);
   1183          #endif
   1184          
   1185            if ((retVal = SetupGpioUart(handle, initData)) != ECODE_EMDRV_UARTDRV_OK) {
   1186              return retVal;
   1187            }
   1188            if ((retVal = ConfigGpio(handle, true)) != ECODE_EMDRV_UARTDRV_OK) {
   1189              return retVal;
   1190            }
   1191          
   1192            CORE_ENTER_ATOMIC();
   \                     ??UARTDRV_InitUart_10: (+1)
   \       0x90   0x....'....        BL       CORE_EnterAtomic
   \       0x94   0x4680             MOV      R8,R0
   1193          
   1194            // Configure hardware flow control pins and interrupt vectors
   1195          #if (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE)
   1196            if (initData->fcType == uartdrvFlowControlHwUart) {
   \       0x96   0x7D20             LDRB     R0,[R4, #+20]
   \       0x98   0x2803             CMP      R0,#+3
   \       0x9A   0xD119             BNE.N    ??UARTDRV_InitUart_11
   1197          #if defined(UART_HW_FLOW_CONTROL_SUPPORT)
   1198          #if defined(_USART_ROUTEPEN_RTSPEN_MASK) && defined(_USART_ROUTEPEN_CTSPEN_MASK)
   1199              initData->port->ROUTELOC1 = (initData->portLocationCts << _USART_ROUTELOC1_CTSLOC_SHIFT)
   1200                                          | (initData->portLocationRts << _USART_ROUTELOC1_RTSLOC_SHIFT);
   1201              initData->port->CTRLX    |= USART_CTRLX_CTSEN;
   1202              initData->port->ROUTEPEN |= USART_ROUTEPEN_CTSPEN | USART_ROUTEPEN_RTSPEN;
   1203          #elif defined(USART_CTRLX_CTSEN)
   1204              GPIO->USARTROUTE_SET[initData->uartNum].ROUTEEN = GPIO_USART_ROUTEEN_RTSPEN;
   \       0x9C   0x7B22             LDRB     R2,[R4, #+12]
   \       0x9E   0x....'....        LDR.W    R0,??DataTable22_6  ;; 0x4003d5ac
   \       0xA2   0x2102             MOVS     R1,#+2
   \       0xA4   0x0152             LSLS     R2,R2,#+5
   \       0xA6   0x5081             STR      R1,[R0, R2]
   1205              initData->port->CTRLX_SET = USART_CTRLX_CTSEN;
   \       0xA8   0x6823             LDR      R3,[R4, #+0]
   \       0xAA   0x2104             MOVS     R1,#+4
   \       0xAC   0xF241 0x025C      MOVW     R2,#+4188
   \       0xB0   0x5099             STR      R1,[R3, R2]
   1206              GPIO->USARTROUTE_SET[initData->uartNum].RTSROUTE =
   1207                (initData->rtsPort << _GPIO_USART_RTSROUTE_PORT_SHIFT)
   1208                | (initData->rtsPin << _GPIO_USART_RTSROUTE_PIN_SHIFT);
   \       0xB2   0x7DE2             LDRB     R2,[R4, #+23]
   \       0xB4   0x7E23             LDRB     R3,[R4, #+24]
   \       0xB6   0x7B21             LDRB     R1,[R4, #+12]
   \       0xB8   0xF100 0x070C      ADD      R7,R0,#+12
   \       0xBC   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \       0xC0   0x0149             LSLS     R1,R1,#+5
   1209              GPIO->USARTROUTE_SET[initData->uartNum].CTSROUTE =
   1210                (initData->ctsPort << _GPIO_USART_CTSROUTE_PORT_SHIFT)
   1211                | (initData->ctsPin << _GPIO_USART_CTSROUTE_PIN_SHIFT);
   \       0xC2   0x3008             ADDS     R0,R0,#+8
   \       0xC4   0x507A             STR      R2,[R7, R1]
   \       0xC6   0x7D62             LDRB     R2,[R4, #+21]
   \       0xC8   0x7DA3             LDRB     R3,[R4, #+22]
   \       0xCA   0x....'....        BL       ?Subroutine18
   1212          #endif
   1213          #else
   1214              // Attempting to use USART hardware flow control on a device that does not
   1215              // support it.
   1216              return ECODE_EMDRV_UARTDRV_PARAM_ERROR;
   1217          #endif
   1218            } else if (initData->fcType == uartdrvFlowControlHw) {
   \                     ??CrossCallReturnLabel_30: (+1)
   \       0xCE   0xE00F             B.N      ??UARTDRV_InitUart_12
   \                     ??UARTDRV_InitUart_11: (+1)
   \       0xD0   0x2802             CMP      R0,#+2
   \       0xD2   0xD10D             BNE.N    ??UARTDRV_InitUart_12
   1219              InitializeGpioFlowControl(handle);
   \       0xD4   0x7838             LDRB     R0,[R7, #+0]
   \       0xD6   0x....'....        LDR.W    R1,??DataTable22_18
   \       0xDA   0x....'....        BL       GPIOINT_CallbackRegister
   \       0xDE   0x....'....        BL       GPIOINT_Init
   \       0xE2   0x2002             MOVS     R0,#+2
   \       0xE4   0x7670             STRB     R0,[R6, #+25]
   \       0xE6   0x76B5             STRB     R5,[R6, #+26]
   \       0xE8   0x7635             STRB     R5,[R6, #+24]
   \       0xEA   0x4630             MOV      R0,R6
   \       0xEC   0x....'....        BL       FcApplyState
   1220            }
   1221          #endif
   1222          
   1223            // Clear any false IRQ/DMA request
   1224            USART_IntClear(initData->port, ~0x0);
   \                     ??UARTDRV_InitUart_12: (+1)
   \       0xF0   0x6820             LDR      R0,[R4, #+0]
   \       0xF2   0xF04F 0x31FF      MOV      R1,#-1
   \       0xF6   0xF242 0x0248      MOVW     R2,#+8264
   \       0xFA   0x5081             STR      R1,[R0, R2]
   1225          
   1226            // Enable Tx permanently as the Tx circuit consumes very little energy.
   1227            // Rx is enabled on demand as the Rx circuit consumes some energy due to
   1228            // continuous (over)sampling.
   1229            if (initData->fcType == uartdrvFlowControlHwUart) {
   \       0xFC   0x7D23             LDRB     R3,[R4, #+20]
   \       0xFE   0x2B03             CMP      R3,#+3
   \      0x100   0xBF0C             ITE      EQ 
   \      0x102   0x2105             MOVEQ    R1,#+5
   \      0x104   0x2104             MOVNE    R1,#+4
   1230              // Rx must be enabled permanently when using USART hw flow control
   1231              USART_Enable(initData->port, usartEnable);
   1232            } else {
   1233              USART_Enable(initData->port, usartEnableTx);
   \      0x106   0x....'....        BL       USART_Enable
   1234            }
   1235          
   1236            // Discard false frames and/or IRQs
   1237            initData->port->CMD = USART_CMD_CLEARRX | USART_CMD_CLEARTX;
   \      0x10A   0x6821             LDR      R1,[R4, #+0]
   \      0x10C   0xF44F 0x6040      MOV      R0,#+3072
   \      0x110   0x....'....        LDR.W    R4,??DataTable22_19  ;; 0xf000700e
   \      0x114   0x6148             STR      R0,[R1, #+20]
   1238          
   1239            // Initialize DMA.
   1240            retVal = InitializeDma(handle);
   \      0x116   0x....'....        BL       DMADRV_Init
   \      0x11A   0x2100             MOVS     R1,#+0
   \      0x11C   0xF106 0x0008      ADD      R0,R6,#+8
   \      0x120   0x....'....        BL       DMADRV_AllocateChannel
   \      0x124   0xB928             CBNZ.N   R0,??UARTDRV_InitUart_13
   \      0x126   0x2100             MOVS     R1,#+0
   \      0x128   0xF106 0x000C      ADD      R0,R6,#+12
   \      0x12C   0x....'....        BL       DMADRV_AllocateChannel
   \      0x130   0xB100             CBZ.N    R0,??UARTDRV_InitUart_14
   \                     ??UARTDRV_InitUart_13: (+1)
   \      0x132   0x4625             MOV      R5,R4
   1241          
   1242            CORE_EXIT_ATOMIC();
   \                     ??UARTDRV_InitUart_14: (+1)
   \      0x134   0x4640             MOV      R0,R8
   \      0x136   0x....'....        BL       CORE_ExitAtomic
   1243          
   1244            if (retVal != ECODE_EMDRV_UARTDRV_OK) {
   \      0x13A   0x2D00             CMP      R5,#+0
   \      0x13C   0xBF14             ITE      NE 
   \      0x13E   0x4628             MOVNE    R0,R5
   \      0x140   0x2000             MOVEQ    R0,#+0
   1245              return retVal;
   1246            }
   1247          
   1248            return ECODE_EMDRV_UARTDRV_OK;
   \                     ??UARTDRV_InitUart_6: (+1)
   \      0x142   0xB008             ADD      SP,SP,#+32
   \      0x144   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??UARTDRV_InitUart_5: (+1)
   \      0x148   0x462E             MOV      R6,R5
   \      0x14A   0xF841 0x6022      STR      R6,[R1, R2, LSL #+2]
   \      0x14E   0x7D20             LDRB     R0,[R4, #+20]
   \      0x150   0xF106 0x0124      ADD      R1,R6,#+36
   \      0x154   0x2500             MOVS     R5,#+0
   \      0x156   0x7348             STRB     R0,[R1, #+13]
   \      0x158   0x6822             LDR      R2,[R4, #+0]
   \      0x15A   0xF106 0x0721      ADD      R7,R6,#+33
   \      0x15E   0x6032             STR      R2,[R6, #+0]
   \      0x160   0x738D             STRB     R5,[R1, #+14]
   \      0x162   0x7B20             LDRB     R0,[R4, #+12]
   \      0x164   0x....'....        LDR.W    R2,??DataTable22_20  ;; 0x40058000
   \      0x168   0x7130             STRB     R0,[R6, #+4]
   \      0x16A   0x6820             LDR      R0,[R4, #+0]
   \      0x16C   0x4290             CMP      R0,R2
   \      0x16E   0xF47F 0xAF74      BNE.W    ??UARTDRV_InitUart_7
   \      0x172   0x2320             MOVS     R3,#+32
   \      0x174   0x70BB             STRB     R3,[R7, #+2]
   \      0x176   0x....'....        LDR.W    R2,??DataTable22_21  ;; 0x40002
   \      0x17A   0x6132             STR      R2,[R6, #+16]
   \      0x17C   0xF44F 0x2380      MOV      R3,#+262144
   \                     ??UARTDRV_InitUart_9: (+1)
   \      0x180   0x6173             STR      R3,[R6, #+20]
   \      0x182   0x69E3             LDR      R3,[R4, #+28]
   \      0x184   0x6A22             LDR      R2,[R4, #+32]
   \      0x186   0x600B             STR      R3,[R1, #+0]
   \      0x188   0x801D             STRH     R5,[R3, #+0]
   \      0x18A   0x680B             LDR      R3,[R1, #+0]
   \      0x18C   0x805D             STRH     R5,[R3, #+2]
   \      0x18E   0x680B             LDR      R3,[R1, #+0]
   \      0x190   0x809D             STRH     R5,[R3, #+4]
   \      0x192   0x720D             STRB     R5,[R1, #+8]
   \      0x194   0x604A             STR      R2,[R1, #+4]
   \      0x196   0x8015             STRH     R5,[R2, #+0]
   \      0x198   0x684A             LDR      R2,[R1, #+4]
   \      0x19A   0x8055             STRH     R5,[R2, #+2]
   \      0x19C   0x684B             LDR      R3,[R1, #+4]
   \      0x19E   0x2205             MOVS     R2,#+5
   \      0x1A0   0x809D             STRH     R5,[R3, #+4]
   \      0x1A2   0x724D             STRB     R5,[R1, #+9]
   \      0x1A4   0x72CD             STRB     R5,[R1, #+11]
   \      0x1A6   0x6861             LDR      R1,[R4, #+4]
   \      0x1A8   0x9102             STR      R1,[SP, #+8]
   \      0x1AA   0x89E1             LDRH     R1,[R4, #+14]
   \      0x1AC   0xF8AD 0x1010      STRH     R1,[SP, #+16]
   \      0x1B0   0x8A21             LDRH     R1,[R4, #+16]
   \      0x1B2   0xF8AD 0x100E      STRH     R1,[SP, #+14]
   \      0x1B6   0x7CA1             LDRB     R1,[R4, #+18]
   \      0x1B8   0xF88D 0x100C      STRB     R1,[SP, #+12]
   \      0x1BC   0x7CE1             LDRB     R1,[R4, #+19]
   \      0x1BE   0xF88D 0x200D      STRB     R2,[SP, #+13]
   \      0x1C2   0xF88D 0x5000      STRB     R5,[SP, #+0]
   \      0x1C6   0xF88D 0x1012      STRB     R1,[SP, #+18]
   \      0x1CA   0x4669             MOV      R1,SP
   \      0x1CC   0x....'....        BL       USART_InitAsync
   \      0x1D0   0x7B22             LDRB     R2,[R4, #+12]
   \      0x1D2   0x....'....        LDR.W    R0,??DataTable22_22  ;; 0x4003c5ac
   \      0x1D6   0x2114             MOVS     R1,#+20
   \      0x1D8   0x0152             LSLS     R2,R2,#+5
   \      0x1DA   0x5081             STR      R1,[R0, R2]
   \      0x1DC   0x7A23             LDRB     R3,[R4, #+8]
   \      0x1DE   0xF894 0xC00A      LDRB     R12,[R4, #+10]
   \      0x1E2   0x7B22             LDRB     R2,[R4, #+12]
   \      0x1E4   0xF100 0x0118      ADD      R1,R0,#+24
   \      0x1E8   0xEA43 0x430C      ORR      R3,R3,R12, LSL #+16
   \      0x1EC   0x0152             LSLS     R2,R2,#+5
   \      0x1EE   0x3010             ADDS     R0,R0,#+16
   \      0x1F0   0x508B             STR      R3,[R1, R2]
   \      0x1F2   0x7A62             LDRB     R2,[R4, #+9]
   \      0x1F4   0x7AE3             LDRB     R3,[R4, #+11]
   \      0x1F6   0x....'....        BL       ?Subroutine18
   \                     ??CrossCallReturnLabel_31: (+1)
   \      0x1FA   0x7A20             LDRB     R0,[R4, #+8]
   \      0x1FC   0x76F0             STRB     R0,[R6, #+27]
   \      0x1FE   0x7AA1             LDRB     R1,[R4, #+10]
   \      0x200   0x77F1             STRB     R1,[R6, #+31]
   \      0x202   0x7A60             LDRB     R0,[R4, #+9]
   \      0x204   0x7730             STRB     R0,[R6, #+28]
   \      0x206   0x7AE1             LDRB     R1,[R4, #+11]
   \      0x208   0xF886 0x1020      STRB     R1,[R6, #+32]
   \      0x20C   0x7D60             LDRB     R0,[R4, #+21]
   \      0x20E   0x7770             STRB     R0,[R6, #+29]
   \      0x210   0x7DA1             LDRB     R1,[R4, #+22]
   \      0x212   0x7039             STRB     R1,[R7, #+0]
   \      0x214   0x7DE0             LDRB     R0,[R4, #+23]
   \      0x216   0x77B0             STRB     R0,[R6, #+30]
   \      0x218   0x7E21             LDRB     R1,[R4, #+24]
   \      0x21A   0x4630             MOV      R0,R6
   \      0x21C   0x7079             STRB     R1,[R7, #+1]
   \      0x21E   0x2101             MOVS     R1,#+1
   \      0x220   0x....'....        BL       ConfigGpio
   \      0x224   0x2800             CMP      R0,#+0
   \      0x226   0xF43F 0xAF33      BEQ.W    ??UARTDRV_InitUart_10
   \      0x22A   0xE78A             B.N      ??UARTDRV_InitUart_6
   1249          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine18: (+1)
   \        0x0   0x7B21             LDRB     R1,[R4, #+12]
   \        0x2   0xEA42 0x4203      ORR      R2,R2,R3, LSL #+16
   \        0x6   0x0149             LSLS     R1,R1,#+5
   \        0x8   0x5042             STR      R2,[R0, R1]
   \        0xA   0x4770             BX       LR
   1250          
   1251          #if defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)
   1252          /***************************************************************************//**
   1253           * @brief
   1254           *    Initialize a LEUART driver instance.
   1255           *
   1256           * @param[out] handle  Pointer to a UARTDRV handle, refer to @ref
   1257           *                     UARTDRV_Handle_t.
   1258           *
   1259           * @param[in] initData Pointer to an initialization data structure,
   1260           *                     refer to @ref UARTDRV_InitLeuart_t.
   1261           *
   1262           * @return
   1263           *    @ref ECODE_EMDRV_UARTDRV_OK on success. On failure, an appropriate
   1264           *    UARTDRV @ref Ecode_t is returned.
   1265           ******************************************************************************/
   1266          Ecode_t UARTDRV_InitLeuart(UARTDRV_Handle_t handle,
   1267                                     const UARTDRV_InitLeuart_t *initData)
   1268          {
   1269            Ecode_t retVal;
   1270            CORE_DECLARE_IRQ_STATE;
   1271            LEUART_Init_TypeDef leuartInit = LEUART_INIT_DEFAULT;
   1272          
   1273            if (handle == NULL) {
   1274              return ECODE_EMDRV_UARTDRV_ILLEGAL_HANDLE;
   1275            }
   1276            if (initData == NULL) {
   1277              return ECODE_EMDRV_UARTDRV_PARAM_ERROR;
   1278            }
   1279            if (initData->fcType == uartdrvFlowControlHwUart) {
   1280              // LEUART doesn't support peripheral hw flow control
   1281              return ECODE_EMDRV_UARTDRV_PARAM_ERROR;
   1282            }
   1283          
   1284            memset(handle, 0, sizeof(UARTDRV_HandleData_t));
   1285          
   1286          #if (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE)
   1287            retVal = SetHandleIndex(handle);
   1288            if (retVal != ECODE_EMDRV_UARTDRV_OK) {
   1289              return retVal;
   1290            }
   1291            handle->fcType = initData->fcType;
   1292          #else
   1293            // Force init data to uartdrvFlowControlNone if flow control is excluded by EMDRV_UARTDRV_FLOW_CONTROL_ENABLE
   1294            handle->fcType = uartdrvFlowControlNone;
   1295          #endif
   1296          
   1297            handle->peripheral.leuart = initData->port;
   1298            handle->type = uartdrvUartTypeLeuart;
   1299          #if defined(_GPIO_USART_ROUTEEN_MASK)
   1300            handle->uartNum = initData->uartNum;
   1301          #endif
   1302          
   1303            // Set clocks and DMA requests according to available peripherals
   1304            if (false) {
   1305          #if defined(LEUART0)
   1306            } else if (initData->port == LEUART0) {
   1307              handle->uartClock   = cmuClock_LEUART0;
   1308              handle->txDmaSignal = dmadrvPeripheralSignal_LEUART0_TXBL;
   1309              handle->rxDmaSignal = dmadrvPeripheralSignal_LEUART0_RXDATAV;
   1310          #endif
   1311          #if defined(LEUART1)
   1312            } else if (initData->port == LEUART1) {
   1313              handle->uartClock   = cmuClock_LEUART1;
   1314              handle->txDmaSignal = dmadrvPeripheralSignal_LEUART1_TXBL;
   1315              handle->rxDmaSignal = dmadrvPeripheralSignal_LEUART1_RXDATAV;
   1316          #endif
   1317            } else {
   1318              return ECODE_EMDRV_UARTDRV_PARAM_ERROR;
   1319            }
   1320          
   1321            InitializeQueues(handle, initData->rxQueue, initData->txQueue);
   1322          
   1323            leuartInit.baudrate   = initData->baudRate;
   1324            leuartInit.stopbits   = initData->stopBits;
   1325            leuartInit.parity     = initData->parity;
   1326          
   1327            // UARTDRV is fixed at 8 bit frames.
   1328            leuartInit.databits = (LEUART_Databits_TypeDef)LEUART_CTRL_DATABITS_EIGHT;
   1329          
   1330            // Enable clocks
   1331          #if defined(_CMU_HFPERCLKEN0_MASK)
   1332            CMU_ClockEnable(cmuClock_HFPER, true);
   1333          #endif
   1334            CMU_ClockEnable(cmuClock_GPIO, true);
   1335          #if defined(_CMU_HFBUSCLKEN0_MASK) || defined(CMU_HFCORECLKEN0_LE)
   1336            CMU_ClockEnable(cmuClock_HFLE, true);
   1337          #endif
   1338          
   1339            // Only try to use LF clock if LFXO is enabled and requested baudrate is low
   1340            if (CMU->STATUS & CMU_STATUS_LFXOENS
   1341                && (leuartInit.baudrate <= SystemLFXOClockGet())) {
   1342              CMU_ClockSelectSet(cmuClock_LFB, cmuSelect_LFXO);
   1343            } else {
   1344              // Try to figure out the prescaler that will give us the best stability
   1345              CMU_ClockSelectSet(cmuClock_LFB, cmuSelect_HFCLKLE);
   1346          
   1347          #if defined(_SILICON_LABS_32B_SERIES_0)
   1348              // Attainable baudrate lies between refclk and refclk/128. For maximum
   1349              // accuracy, we want the reference clock to be as high as possible.
   1350              uint32_t refclk = CMU_ClockFreqGet(cmuClock_LFB);
   1351              uint8_t divisor = 0;
   1352          
   1353              while (leuartInit.baudrate <= (refclk >> (divisor + 7))) {
   1354                divisor++;
   1355              }
   1356          
   1357              // If we ran out of stretch on the clock division, error out.
   1358              if (divisor > (_CMU_LFBPRESC0_LEUART0_MASK >> _CMU_LFBPRESC0_LEUART0_SHIFT)) {
   1359                return ECODE_EMDRV_UARTDRV_CLOCK_ERROR;
   1360              }
   1361              CMU_ClockDivSet(handle->uartClock, (CMU_ClkDiv_TypeDef) (1 << divisor));
   1362          #elif defined(_SILICON_LABS_32B_SERIES_1)
   1363              // Clock divider in LEUARTn is large enough for any baudrate.
   1364          #endif
   1365            }
   1366          
   1367            CMU_ClockEnable(handle->uartClock, true);
   1368          
   1369            // Init LEUART to default async config.
   1370            // Rx/Tx enable is done on demand
   1371            leuartInit.enable = leuartDisable;
   1372            LEUART_Init(initData->port, &leuartInit);
   1373          
   1374          #if defined(LEUART_ROUTEPEN_TXPEN)
   1375            initData->port->ROUTELOC0 = (initData->port->ROUTELOC0
   1376                                         & ~(_LEUART_ROUTELOC0_TXLOC_MASK
   1377                                             | _LEUART_ROUTELOC0_RXLOC_MASK))
   1378                                        | (initData->portLocationTx
   1379                                           << _LEUART_ROUTELOC0_TXLOC_SHIFT)
   1380                                        | (initData->portLocationRx
   1381                                           << _LEUART_ROUTELOC0_RXLOC_SHIFT);
   1382          
   1383            initData->port->ROUTEPEN = LEUART_ROUTEPEN_TXPEN
   1384                                       | LEUART_ROUTEPEN_RXPEN;
   1385          #else
   1386            initData->port->ROUTE = LEUART_ROUTE_TXPEN
   1387                                    | LEUART_ROUTE_RXPEN
   1388                                    | (initData->portLocation
   1389                                       << _LEUART_ROUTE_LOCATION_SHIFT);
   1390          #endif
   1391          
   1392            if ((retVal = SetupGpioLeuart(handle, initData)) != ECODE_EMDRV_UARTDRV_OK) {
   1393              return retVal;
   1394            }
   1395            if ((retVal = ConfigGpio(handle, true)) != ECODE_EMDRV_UARTDRV_OK) {
   1396              return retVal;
   1397            }
   1398          
   1399            CORE_ENTER_ATOMIC();
   1400          
   1401            // Configure hardware flow control pins and interrupt vectors
   1402          #if (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE)
   1403            if (initData->fcType == uartdrvFlowControlHw) {
   1404              InitializeGpioFlowControl(handle);
   1405            }
   1406          #endif
   1407          
   1408            // Clear any false IRQ/DMA request
   1409            LEUART_IntClear(initData->port, ~0x0);
   1410          
   1411            // Enable Tx permanently as the Tx circuit consumes very little energy.
   1412            // Rx is enabled on demand as the Rx circuit consumes some energy due to
   1413            // continuous (over)sampling.
   1414            LEUART_Enable(initData->port, leuartEnableTx);
   1415          
   1416            // Wait for previous write (TXEN) to sync before clearing FIFOs
   1417            while ((initData->port->SYNCBUSY & LEUART_SYNCBUSY_CMD) != 0U) {
   1418            }
   1419          
   1420            // Discard false frames and/or IRQs
   1421            initData->port->CMD = LEUART_CMD_CLEARRX | LEUART_CMD_CLEARTX;
   1422          
   1423            // Initialize DMA.
   1424            retVal = InitializeDma(handle);
   1425          
   1426            CORE_EXIT_ATOMIC();
   1427          
   1428            if (retVal != ECODE_EMDRV_UARTDRV_OK) {
   1429              return retVal;
   1430            }
   1431          
   1432            // Wait for everything to be synchronized
   1433            while (initData->port->SYNCBUSY != 0U) {
   1434            }
   1435            return ECODE_EMDRV_UARTDRV_OK;
   1436          }
   1437          #endif
   1438          
   1439          #if defined(EUART_COUNT) && (EUART_COUNT > 0)
   1440          /***************************************************************************//**
   1441           * @brief
   1442           *    Initialize a EUART driver instance.
   1443           *
   1444           * @param[out] handle  Pointer to a UARTDRV handle, refer to @ref
   1445           *                     UARTDRV_Handle_t.
   1446           *
   1447           * @param[in] initData Pointer to an initialization data structure,
   1448           *                     refer to @ref UARTDRV_InitEuart_t.
   1449           *
   1450           * @return
   1451           *    @ref ECODE_EMDRV_UARTDRV_OK on success. On failure an appropriate
   1452           *    UARTDRV @ref Ecode_t is returned.
   1453           ******************************************************************************/
   1454          Ecode_t UARTDRV_InitEuart(UARTDRV_Handle_t handle,
   1455                                    const UARTDRV_InitEuart_t *initData)
   1456          {
   1457            Ecode_t retVal;
   1458            CORE_DECLARE_IRQ_STATE;
   1459            EUSART_Init_TypeDef uartInit = EUSART_INIT_DEFAULT_HF;
   1460            EUSART_AdvancedInit_TypeDef uartAdvancedInit = EUSART_ADVANCED_INIT_DEFAULT;
   1461          
   1462            if (handle == NULL) {
   1463              return ECODE_EMDRV_UARTDRV_ILLEGAL_HANDLE;
   1464            }
   1465            if (initData == NULL) {
   1466              return ECODE_EMDRV_UARTDRV_PARAM_ERROR;
   1467            }
   1468          
   1469            memset(handle, 0, sizeof(UARTDRV_HandleData_t));
   1470          
   1471            handle->peripheral.euart = initData->port;
   1472            handle->type = uartdrvUartTypeEuart;
   1473            handle->uartNum = initData->uartNum;
   1474          
   1475          #if (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE)
   1476            retVal = SetHandleIndex(handle);
   1477            if (retVal != ECODE_EMDRV_UARTDRV_OK) {
   1478              return retVal;
   1479            }
   1480            handle->fcType = initData->fcType;
   1481          #else
   1482            // Force init data to uartdrvFlowControlNone if flow control is excluded by EMDRV_UARTDRV_FLOW_CONTROL_ENABLE
   1483            handle->fcType = uartdrvFlowControlNone;
   1484          #endif
   1485          
   1486            // Set clocks and DMA requests according to available peripherals
   1487            if (false) {
   1488          #if defined(EUART0)
   1489            } else if (initData->port == EUART0) {
   1490              handle->uartClock   = cmuClock_EUART0;
   1491              handle->txDmaSignal = dmadrvPeripheralSignal_EUART0_TXBL;
   1492              handle->rxDmaSignal = dmadrvPeripheralSignal_EUART0_RXDATAV;
   1493              uartAdvancedInit.dmaWakeUpOnRx = true;
   1494              uartAdvancedInit.dmaWakeUpOnTx = true;
   1495              handle->txDmaActive = false;
   1496              handle->rxDmaActive = false;
   1497          #endif
   1498            } else {
   1499              return ECODE_EMDRV_UARTDRV_PARAM_ERROR;
   1500            }
   1501          
   1502            InitializeQueues(handle, initData->rxQueue, initData->txQueue);
   1503          
   1504            // UARTDRV is fixed at 8 bit frames.
   1505            uartInit.databits = (EUSART_Databits_TypeDef)eusartDataBits8;
   1506          
   1507            uartInit.baudrate = initData->baudRate;
   1508            uartInit.stopbits = initData->stopBits;
   1509            uartInit.parity = initData->parity;
   1510            uartInit.oversampling = initData->oversampling;
   1511            uartInit.majorityVote = initData->mvdis;
   1512          
   1513            uartInit.advancedSettings = &uartAdvancedInit;
   1514          
   1515            // Enable clocks.
   1516            CMU_ClockEnable(cmuClock_GPIO, true);
   1517            CMU_ClockEnable(handle->uartClock, true);
   1518            if (initData->useLowFrequencyMode) {
   1519              CMU_ClockEnable(cmuClock_LFRCO, true);
   1520              CMU_ClockEnable(cmuClock_EM23GRPACLK, true);
   1521              CMU_ClockSelectSet(cmuClock_EM23GRPACLK, cmuSelect_LFRCO);
   1522              CMU_ClockSelectSet(handle->uartClock, cmuSelect_EM23GRPACLK);
   1523            } else {
   1524              CMU_ClockEnable(cmuClock_EM01GRPACLK, true);
   1525              CMU_ClockSelectSet(handle->uartClock, cmuSelect_EM01GRPACLK);
   1526            }
   1527          
   1528          #if defined(EUART_COUNT) && (EUART_COUNT > 0)
   1529            GPIO->EUARTROUTE->ROUTEEN = GPIO_EUART_ROUTEEN_TXPEN;
   1530            GPIO->EUARTROUTE->TXROUTE = (initData->txPort
   1531                                         << _GPIO_EUART_TXROUTE_PORT_SHIFT)
   1532                                        | (initData->txPin << _GPIO_USART_TXROUTE_PIN_SHIFT);
   1533            GPIO->EUARTROUTE->RXROUTE = (initData->rxPort
   1534                                         << _GPIO_EUART_RXROUTE_PORT_SHIFT)
   1535                                        | (initData->rxPin << _GPIO_EUART_RXROUTE_PIN_SHIFT);
   1536          #endif
   1537          
   1538            if ((retVal = SetupGpioEuart(handle, initData)) != ECODE_EMDRV_UARTDRV_OK) {
   1539              return retVal;
   1540            }
   1541            if ((retVal = ConfigGpio(handle, true)) != ECODE_EMDRV_UARTDRV_OK) {
   1542              return retVal;
   1543            }
   1544          
   1545            CORE_ENTER_ATOMIC();
   1546          
   1547          #if (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE)
   1548            if (initData->fcType == uartdrvFlowControlHwUart) {
   1549              GPIO->EUARTROUTE_SET->ROUTEEN = GPIO_EUART_ROUTEEN_RTSPEN;
   1550              GPIO->EUARTROUTE_SET->RTSROUTE =
   1551                (initData->rtsPort << _GPIO_EUART_RTSROUTE_PORT_SHIFT)
   1552                | (initData->rtsPin << _GPIO_EUART_RTSROUTE_PIN_SHIFT);
   1553              GPIO->EUARTROUTE_SET->CTSROUTE =
   1554                (initData->ctsPort << _GPIO_EUART_CTSROUTE_PORT_SHIFT)
   1555                | (initData->ctsPin << _GPIO_EUART_CTSROUTE_PIN_SHIFT);
   1556          
   1557              uartAdvancedInit.hwFlowControl = eusartHwFlowControlCtsAndRts;
   1558            } else if (initData->fcType == uartdrvFlowControlHw) {
   1559              InitializeGpioFlowControl(handle);
   1560            }
   1561          #endif
   1562          
   1563            // Set Tx enable to follow USART implementation.
   1564            uartInit.enable = eusartEnableTx;
   1565          
   1566            if (initData->useLowFrequencyMode) {
   1567              EUSART_InitLf(initData->port, &uartInit);
   1568            } else {
   1569              EUSART_InitHf(initData->port, &uartInit);
   1570            }
   1571          
   1572            // Initialize DMA.
   1573            retVal = InitializeDma(handle);
   1574          
   1575            CORE_EXIT_ATOMIC();
   1576          
   1577            if (retVal != ECODE_EMDRV_UARTDRV_OK) {
   1578              return retVal;
   1579            }
   1580          
   1581            return ECODE_EMDRV_UARTDRV_OK;
   1582          }
   1583          #endif
   1584          
   1585          /***************************************************************************//**
   1586           * @brief
   1587           *    Deinitialize a UART driver instance.
   1588           *
   1589           * @param[in] handle Pointer to a UART driver handle.
   1590           *
   1591           * @return
   1592           *    @ref ECODE_EMDRV_UARTDRV_OK on success. On failure, an appropriate
   1593           *    UARTDRV @ref Ecode_t is returned.
   1594           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1595          Ecode_t UARTDRV_DeInit(UARTDRV_Handle_t handle)
   1596          {
   \                     UARTDRV_DeInit: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x0004             MOVS     R4,R0
   1597            if (handle == NULL) {
   \        0x4   0xD102             BNE.N    ??UARTDRV_DeInit_0
   1598              return ECODE_EMDRV_UARTDRV_ILLEGAL_HANDLE;
   \        0x6   0x....'....        LDR.W    R0,??DataTable22_10  ;; 0xf0007002
   \        0xA   0xBD32             POP      {R1,R4,R5,PC}
   1599            }
   1600            // Stop DMA transfers.
   1601            UARTDRV_Abort(handle, uartdrvAbortAll);
   \                     ??UARTDRV_DeInit_0: (+1)
   \        0xC   0x2103             MOVS     R1,#+3
   \        0xE   0x....'....        BL       UARTDRV_Abort
   1602          
   1603            // Do not leave any peer restrained on DeInit
   1604            UARTDRV_FlowControlSet(handle, uartdrvFlowControlOn);
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x....'....        BL       UARTDRV_FlowControlSet
   1605          
   1606            ConfigGpio(handle, false);
   \       0x1A   0x2100             MOVS     R1,#+0
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0x....'....        BL       ConfigGpio
   1607          
   1608            if (handle->type == uartdrvUartTypeUart) {
   \       0x22   0xF104 0x0524      ADD      R5,R4,#+36
   \       0x26   0x7BA8             LDRB     R0,[R5, #+14]
   \       0x28   0xB910             CBNZ.N   R0,??UARTDRV_DeInit_1
   1609              handle->peripheral.uart->CMD = USART_CMD_RXDIS | USART_CMD_TXDIS;
   \       0x2A   0x6820             LDR      R0,[R4, #+0]
   \       0x2C   0x210A             MOVS     R1,#+10
   \       0x2E   0x6141             STR      R1,[R0, #+20]
   1610          
   1611          #if defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)
   1612            } else if (handle->type == uartdrvUartTypeLeuart) {
   1613              LEUART_Reset(handle->peripheral.leuart);
   1614              while ((handle->peripheral.leuart->SYNCBUSY & LEUART_SYNCBUSY_CMD) != 0U) {
   1615              }
   1616              handle->peripheral.leuart->CMD = LEUART_CMD_RXDIS | LEUART_CMD_TXDIS;
   1617          
   1618          #elif defined(EUART_COUNT) && (EUART_COUNT > 0)
   1619            } else if (handle->type == uartdrvUartTypeEuart) {
   1620              EUSART_Enable(handle->peripheral.euart, eusartDisable);
   1621              EUSART_Reset(handle->peripheral.euart);
   1622          #endif
   1623            }
   1624          
   1625            CMU_ClockEnable(handle->uartClock, false);
   1626          
   1627          #if (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE)
   1628            if (handle->fcType != uartdrvFlowControlHwUart) {
   \                     ??UARTDRV_DeInit_1: (+1)
   \       0x30   0x7B68             LDRB     R0,[R5, #+13]
   \       0x32   0x2803             CMP      R0,#+3
   \       0x34   0xD004             BEQ.N    ??UARTDRV_DeInit_2
   1629              GPIOINT_CallbackRegister(handle->ctsPin, NULL);
   \       0x36   0xF894 0x0021      LDRB     R0,[R4, #+33]
   \       0x3A   0x2100             MOVS     R1,#+0
   \       0x3C   0x....'....        BL       GPIOINT_CallbackRegister
   1630            }
   1631          #endif
   1632          
   1633            DMADRV_FreeChannel(handle->txDmaCh);
   \                     ??UARTDRV_DeInit_2: (+1)
   \       0x40   0x68A0             LDR      R0,[R4, #+8]
   \       0x42   0x....'....        BL       DMADRV_FreeChannel
   1634            DMADRV_FreeChannel(handle->rxDmaCh);
   \       0x46   0x68E0             LDR      R0,[R4, #+12]
   \       0x48   0x....'....        BL       DMADRV_FreeChannel
   1635            DMADRV_DeInit();
   \       0x4C   0x....'....        BL       DMADRV_DeInit
   1636          
   1637            handle->rxQueue->head = 0;
   \       0x50   0x6828             LDR      R0,[R5, #+0]
   \       0x52   0x2100             MOVS     R1,#+0
   \       0x54   0x8001             STRH     R1,[R0, #+0]
   1638            handle->rxQueue->tail = 0;
   \       0x56   0x8041             STRH     R1,[R0, #+2]
   1639            handle->rxQueue->used = 0;
   \       0x58   0x8081             STRH     R1,[R0, #+4]
   1640          
   1641            handle->txQueue->head = 0;
   \       0x5A   0x6868             LDR      R0,[R5, #+4]
   \       0x5C   0x8001             STRH     R1,[R0, #+0]
   1642            handle->txQueue->tail = 0;
   \       0x5E   0x8041             STRH     R1,[R0, #+2]
   1643            handle->txQueue->used = 0;
   \       0x60   0x8081             STRH     R1,[R0, #+4]
   1644          
   1645            return ECODE_EMDRV_UARTDRV_OK;
   \       0x62   0x2000             MOVS     R0,#+0
   \       0x64   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1646          }
   1647          
   1648          /***************************************************************************//**
   1649           * @brief
   1650           *    Abort ongoing UART transfers.
   1651           *
   1652           * @details
   1653           *    All ongoing or queued operations of the given abort type will be aborted.
   1654           *
   1655           * @param[in] handle Pointer to a UART driver handle.
   1656           *
   1657           * @param[in] type   Abort type -- whether to abort only Tx, only Rx, or both.
   1658           *
   1659           * @return
   1660           *    @ref ECODE_EMDRV_UARTDRV_OK on success, @ref ECODE_EMDRV_UARTDRV_IDLE if
   1661           *    the UART is idle. On failure, an appropriate UARTDRV @ref Ecode_t is returned.
   1662           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1663          Ecode_t UARTDRV_Abort(UARTDRV_Handle_t handle, UARTDRV_AbortType_t type)
   1664          {
   \                     UARTDRV_Abort: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x0005             MOVS     R5,R0
   \        0x6   0x460E             MOV      R6,R1
   1665            UARTDRV_Buffer_t *rxBuffer, *txBuffer;
   1666            CORE_DECLARE_IRQ_STATE;
   1667          
   1668            if (handle == NULL) {
   \        0x8   0xBF08             IT       EQ 
   \        0xA   0x....'....        LDREQ.W  R0,??DataTable22_10  ;; 0xf0007002
   1669              return ECODE_EMDRV_UARTDRV_ILLEGAL_HANDLE;
   \        0xE   0xD079             BEQ.N    ??UARTDRV_Abort_0
   1670            }
   1671          
   1672            CORE_ENTER_ATOMIC();
   \       0x10   0x....'....        BL       CORE_EnterAtomic
   \       0x14   0x4681             MOV      R9,R0
   1673            if ((type == uartdrvAbortTransmit) && (handle->txQueue->used == 0)) {
   \       0x16   0xF105 0x072C      ADD      R7,R5,#+44
   \       0x1A   0x....'....        LDR.W    R8,??DataTable22_23  ;; 0xf0007009
   \       0x1E   0x2E01             CMP      R6,#+1
   \       0x20   0xD118             BNE.N    ??UARTDRV_Abort_1
   \       0x22   0x6AA9             LDR      R1,[R5, #+40]
   \       0x24   0x8888             LDRH     R0,[R1, #+4]
   \       0x26   0xB328             CBZ.N    R0,??UARTDRV_Abort_2
   1674              CORE_EXIT_ATOMIC();
   1675              return ECODE_EMDRV_UARTDRV_IDLE;
   1676            } else if ((type == uartdrvAbortReceive) && (handle->rxQueue->used == 0)) {
   1677              CORE_EXIT_ATOMIC();
   1678              return ECODE_EMDRV_UARTDRV_IDLE;
   1679            } else if ((type == uartdrvAbortAll)
   1680                       && (handle->txQueue->used == 0)
   1681                       && (handle->rxQueue->used == 0)) {
   1682              CORE_EXIT_ATOMIC();
   1683              return ECODE_EMDRV_UARTDRV_IDLE;
   1684            }
   1685          
   1686            // Stop DMA transfers.
   1687            if ((type == uartdrvAbortTransmit) || (type == uartdrvAbortAll)) {
   1688              // Stop the current transfer
   1689              DMADRV_StopTransfer(handle->txDmaCh);
   \                     ??UARTDRV_Abort_3: (+1)
   \       0x28   0x68A8             LDR      R0,[R5, #+8]
   \       0x2A   0x....'....        BL       DMADRV_StopTransfer
   1690              handle->txDmaActive = false;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0x7078             STRB     R0,[R7, #+1]
   1691          
   1692              if (handle->txQueue->used > 0) {
   \       0x32   0x6AAA             LDR      R2,[R5, #+40]
   \       0x34   0x8890             LDRH     R0,[R2, #+4]
   \       0x36   0xB380             CBZ.N    R0,??UARTDRV_Abort_4
   1693                // Update the transfer status of the active transfer
   1694                GetTailBuffer(handle->txQueue, &txBuffer);
   \       0x38   0x4669             MOV      R1,SP
   \       0x3A   0x4610             MOV      R0,R2
   \       0x3C   0x....'....        BL       GetTailBuffer
   1695                DMADRV_TransferRemainingCount(handle->txDmaCh,
   1696                                              (int*)&txBuffer->itemsRemaining);
   \       0x40   0x9800             LDR      R0,[SP, #+0]
   \       0x42   0xF100 0x0108      ADD      R1,R0,#+8
   \       0x46   0x68A8             LDR      R0,[R5, #+8]
   \       0x48   0x....'....        BL       DMADRV_TransferRemainingCount
   1697                txBuffer->transferStatus = ECODE_EMDRV_UARTDRV_ABORTED;
   \       0x4C   0x9800             LDR      R0,[SP, #+0]
   \       0x4E   0xF8C0 0x8010      STR      R8,[R0, #+16]
   \       0x52   0xE01E             B.N      ??CrossCallReturnLabel_27
   \                     ??UARTDRV_Abort_1: (+1)
   \       0x54   0x2E02             CMP      R6,#+2
   \       0x56   0xD103             BNE.N    ??UARTDRV_Abort_5
   \       0x58   0x6A69             LDR      R1,[R5, #+36]
   \       0x5A   0x8888             LDRH     R0,[R1, #+4]
   \       0x5C   0xBB28             CBNZ.N   R0,??UARTDRV_Abort_6
   \       0x5E   0xE009             B.N      ??UARTDRV_Abort_2
   \                     ??UARTDRV_Abort_5: (+1)
   \       0x60   0x2E03             CMP      R6,#+3
   \       0x62   0xD120             BNE.N    ??UARTDRV_Abort_7
   \       0x64   0x6AA9             LDR      R1,[R5, #+40]
   \       0x66   0x8888             LDRH     R0,[R1, #+4]
   \       0x68   0x2800             CMP      R0,#+0
   \       0x6A   0xBF02             ITTT     EQ 
   \       0x6C   0x6A69             LDREQ    R1,[R5, #+36]
   \       0x6E   0x8888             LDRHEQ   R0,[R1, #+4]
   \       0x70   0x2800             CMPEQ    R0,#+0
   \       0x72   0xD1D9             BNE.N    ??UARTDRV_Abort_3
   \                     ??UARTDRV_Abort_2: (+1)
   \       0x74   0x4648             MOV      R0,R9
   \       0x76   0x....'....        BL       CORE_ExitAtomic
   \       0x7A   0x....'....        LDR.W    R0,??DataTable22_24  ;; 0xf0007008
   \       0x7E   0xE041             B.N      ??UARTDRV_Abort_0
   1698          
   1699                // Dequeue all transfers and call callback
   1700                while (handle->txQueue->used > 0) {
   1701                  DequeueBuffer(handle->txQueue, &txBuffer);
   \                     ??UARTDRV_Abort_8: (+1)
   \       0x80   0x4669             MOV      R1,SP
   \       0x82   0x4610             MOV      R0,R2
   \       0x84   0x....'....        BL       DequeueBuffer
   1702          
   1703                  // Call the callback with ABORTED error code
   1704                  if (txBuffer->callback != NULL) {
   \       0x88   0x9800             LDR      R0,[SP, #+0]
   \       0x8A   0x68C4             LDR      R4,[R0, #+12]
   \       0x8C   0xB10C             CBZ.N    R4,??CrossCallReturnLabel_27
   1705                    txBuffer->callback(handle,
   1706                                       ECODE_EMDRV_UARTDRV_ABORTED,
   1707                                       NULL,
   1708                                       txBuffer->itemsRemaining);
   \       0x8E   0x....'....        BL       ?Subroutine16
   1709                  }
   1710                }
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x92   0x6AAA             LDR      R2,[R5, #+40]
   \       0x94   0x8890             LDRH     R0,[R2, #+4]
   \       0x96   0x2800             CMP      R0,#+0
   \       0x98   0xD1F2             BNE.N    ??UARTDRV_Abort_8
   1711              }
   1712          
   1713              // Wait for peripheral to finish cleaning up, to prevent framing errors
   1714              // on subsequent transfers
   1715              while (!(UARTDRV_GetPeripheralStatus(handle) & UARTDRV_STATUS_TXIDLE)) {
   \                     ??UARTDRV_Abort_4: (+1)
   \       0x9A   0x6829             LDR      R1,[R5, #+0]
   \       0x9C   0x6988             LDR      R0,[R1, #+24]
   1716              }
   1717            }
   \       0x9E   0x0480             LSLS     R0,R0,#+18
   \       0xA0   0xD5FB             BPL.N    ??UARTDRV_Abort_4
   1718            if ((type == uartdrvAbortReceive) || (type == uartdrvAbortAll)) {
   \       0xA2   0x2E02             CMP      R6,#+2
   \       0xA4   0xD001             BEQ.N    ??UARTDRV_Abort_6
   \                     ??UARTDRV_Abort_7: (+1)
   \       0xA6   0x2E03             CMP      R6,#+3
   \       0xA8   0xD128             BNE.N    ??UARTDRV_Abort_9
   1719              // Stop the current transfer
   1720              DMADRV_StopTransfer(handle->rxDmaCh);
   \                     ??UARTDRV_Abort_6: (+1)
   \       0xAA   0x68E8             LDR      R0,[R5, #+12]
   \       0xAC   0x....'....        BL       DMADRV_StopTransfer
   1721              handle->rxDmaActive = false;
   \       0xB0   0x2000             MOVS     R0,#+0
   \       0xB2   0x7038             STRB     R0,[R7, #+0]
   1722          
   1723              if (handle->rxQueue->used > 0) {
   \       0xB4   0x6A6A             LDR      R2,[R5, #+36]
   \       0xB6   0x8890             LDRH     R0,[R2, #+4]
   \       0xB8   0xB1D0             CBZ.N    R0,??UARTDRV_Abort_10
   1724                // Update the transfer status of the active transfer
   1725                GetTailBuffer(handle->rxQueue, &rxBuffer);
   \       0xBA   0xA901             ADD      R1,SP,#+4
   \       0xBC   0x4610             MOV      R0,R2
   \       0xBE   0x....'....        BL       GetTailBuffer
   1726                DMADRV_TransferRemainingCount(handle->rxDmaCh,
   1727                                              (int*)&rxBuffer->itemsRemaining);
   \       0xC2   0x9801             LDR      R0,[SP, #+4]
   \       0xC4   0xF100 0x0108      ADD      R1,R0,#+8
   \       0xC8   0x68E8             LDR      R0,[R5, #+12]
   \       0xCA   0x....'....        BL       DMADRV_TransferRemainingCount
   1728                rxBuffer->transferStatus = ECODE_EMDRV_UARTDRV_ABORTED;
   \       0xCE   0x9801             LDR      R0,[SP, #+4]
   \       0xD0   0xF8C0 0x8010      STR      R8,[R0, #+16]
   \       0xD4   0xE008             B.N      ??CrossCallReturnLabel_26
   1729          
   1730                // Dequeue all transfers and call callback
   1731                while (handle->rxQueue->used > 0) {
   1732                  DequeueBuffer(handle->rxQueue, &rxBuffer);
   \                     ??UARTDRV_Abort_11: (+1)
   \       0xD6   0xA901             ADD      R1,SP,#+4
   \       0xD8   0x4610             MOV      R0,R2
   \       0xDA   0x....'....        BL       DequeueBuffer
   1733          
   1734                  // Call the callback with ABORTED error code
   1735                  if (rxBuffer->callback != NULL) {
   \       0xDE   0x9801             LDR      R0,[SP, #+4]
   \       0xE0   0x68C4             LDR      R4,[R0, #+12]
   \       0xE2   0xB10C             CBZ.N    R4,??CrossCallReturnLabel_26
   1736                    rxBuffer->callback(handle,
   1737                                       ECODE_EMDRV_UARTDRV_ABORTED,
   1738                                       NULL,
   1739                                       rxBuffer->itemsRemaining);
   \       0xE4   0x....'....        BL       ?Subroutine16
   1740                  }
   1741                }
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0xE8   0x6A6A             LDR      R2,[R5, #+36]
   \       0xEA   0x8890             LDRH     R0,[R2, #+4]
   \       0xEC   0x2800             CMP      R0,#+0
   \       0xEE   0xD1F2             BNE.N    ??UARTDRV_Abort_11
   1742              }
   1743          
   1744              // Disable the receiver
   1745              if (handle->fcType != uartdrvFlowControlHwUart) {
   \                     ??UARTDRV_Abort_10: (+1)
   \       0xF0   0x7978             LDRB     R0,[R7, #+5]
   \       0xF2   0x2803             CMP      R0,#+3
   \       0xF4   0xBF1C             ITT      NE 
   1746                DisableReceiver(handle);
   \       0xF6   0x4628             MOVNE    R0,R5
   \       0xF8   0x....'....        BLNE     DisableReceiver
   1747              }
   1748            }
   1749            CORE_EXIT_ATOMIC();
   \                     ??UARTDRV_Abort_9: (+1)
   \       0xFC   0x4648             MOV      R0,R9
   \       0xFE   0x....'....        BL       CORE_ExitAtomic
   1750          
   1751            return ECODE_EMDRV_UARTDRV_OK;
   \      0x102   0x2000             MOVS     R0,#+0
   \                     ??UARTDRV_Abort_0: (+1)
   \      0x104   0xE8BD 0x83FE      POP      {R1-R9,PC}       ;; return
   1752          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine16: (+1)
   \        0x0   0x6883             LDR      R3,[R0, #+8]
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x4641             MOV      R1,R8
   \        0x6   0x4628             MOV      R0,R5
   \        0x8   0x4720             BX       R4
   1753          
   1754          /***************************************************************************//**
   1755           * @brief
   1756           *    Return the status of the UART peripheral associated with a given handle.
   1757           *
   1758           * @param[in] handle Pointer to a UART driver handle.
   1759           *
   1760           * @return
   1761           *    UART status value
   1762           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1763          UARTDRV_Status_t UARTDRV_GetPeripheralStatus(UARTDRV_Handle_t handle)
   1764          {
   1765            UARTDRV_Status_t status = 0;
   1766          
   1767          #if defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)
   1768            if (handle->type == uartdrvUartTypeUart) {
   1769              status = handle->peripheral.uart->STATUS;
   1770            } else if (handle->type == uartdrvUartTypeLeuart) {
   1771              uint32_t reg = handle->peripheral.leuart->STATUS;
   1772              if (reg & LEUART_STATUS_TXENS) {
   1773                status |= UARTDRV_STATUS_TXEN;
   1774              }
   1775              if (reg & LEUART_STATUS_RXENS) {
   1776                status |= UARTDRV_STATUS_RXEN;
   1777              }
   1778              if (reg & LEUART_STATUS_RXBLOCK) {
   1779                status |= UARTDRV_STATUS_RXBLOCK;
   1780              }
   1781              if (reg & LEUART_STATUS_TXC) {
   1782                status |= UARTDRV_STATUS_TXC;
   1783              }
   1784              if (reg & LEUART_STATUS_TXBL) {
   1785                status |= UARTDRV_STATUS_TXBL;
   1786              }
   1787              if (reg & LEUART_STATUS_RXDATAV) {
   1788                status |= UARTDRV_STATUS_RXDATAV;
   1789              }
   1790          #if defined(LEUART_STATUS_TXIDLE)
   1791              if (reg & LEUART_STATUS_TXIDLE) {
   1792                status |= UARTDRV_STATUS_TXIDLE;
   1793              }
   1794          #endif
   1795            }
   1796          #elif defined(EUART_COUNT) && (EUART_COUNT > 0)
   1797            if (handle->type == uartdrvUartTypeUart) {
   1798              status = handle->peripheral.uart->STATUS;
   1799            } else if ((handle->type == uartdrvUartTypeEuart)) {
   1800              status = EUSART_StatusGet(handle->peripheral.euart);
   1801            }
   1802          #else
   1803            status = handle->peripheral.uart->STATUS;
   \                     UARTDRV_GetPeripheralStatus: (+1)
   \        0x0   0x6800             LDR      R0,[R0, #+0]
   \        0x2   0x6980             LDR      R0,[R0, #+24]
   1804          #endif
   1805          
   1806          #if defined(_SILICON_LABS_32B_SERIES_0)
   1807            // Series 0 devices does not have the TXIDLE flag, so we emulate it
   1808            if ((status & UARTDRV_STATUS_TXC) || !(handle->hasTransmitted)) {
   1809              status |= UARTDRV_STATUS_TXIDLE;
   1810            }
   1811          #endif
   1812          
   1813            return status;
   \        0x4   0x4770             BX       LR               ;; return
   1814          }
   1815          
   1816          /***************************************************************************//**
   1817           * @brief
   1818           *    Return the number of queued receive operations.
   1819           *
   1820           * @param[in] handle Pointer to a UART driver handle.
   1821           *
   1822           * @return
   1823           *    The number of queued operations.
   1824           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1825          uint8_t UARTDRV_GetReceiveDepth(UARTDRV_Handle_t handle)
   1826          {
   1827            return (uint8_t)handle->rxQueue->used;
   \                     UARTDRV_GetReceiveDepth: (+1)
   \        0x0   0x6A40             LDR      R0,[R0, #+36]
   \        0x2   0x....             B.N      ?Subroutine2
   1828          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x8880             LDRH     R0,[R0, #+4]
   \        0x2   0xB2C0             UXTB     R0,R0
   \        0x4   0x4770             BX       LR               ;; return
   1829          
   1830          /***************************************************************************//**
   1831           * @brief
   1832           *    Check the status of the UART and gather information about any ongoing
   1833           *    receive operations.
   1834           *
   1835           * @param[in] handle Pointer to a UART driver handle.
   1836           *
   1837           * @param[out] buffer Pointer to the current data buffer.
   1838           *
   1839           * @param[out] itemsReceived Current bytes received count.
   1840           *
   1841           * @param[out] itemsRemaining Current bytes remaining count.
   1842           *
   1843           * @return
   1844           *    UART status.
   1845           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1846          UARTDRV_Status_t UARTDRV_GetReceiveStatus(UARTDRV_Handle_t handle,
   1847                                                    uint8_t **buffer,
   1848                                                    UARTDRV_Count_t *itemsReceived,
   1849                                                    UARTDRV_Count_t *itemsRemaining)
   1850          {
   \                     UARTDRV_GetReceiveStatus: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine12
   1851            UARTDRV_Buffer_t *rxBuffer = NULL;
   1852            Ecode_t retVal = ECODE_EMDRV_UARTDRV_OK;
   1853            uint32_t remaining = 0;
   1854          
   1855            if (handle->rxQueue->used > 0) {
   \                     ??CrossCallReturnLabel_18: (+1)
   \        0x8   0x6A68             LDR      R0,[R5, #+36]
   \        0xA   0x4617             MOV      R7,R2
   \        0xC   0x461E             MOV      R6,R3
   \        0xE   0x8882             LDRH     R2,[R0, #+4]
   \       0x10   0xB162             CBZ.N    R2,??UARTDRV_GetReceiveStatus_0
   1856              retVal = GetTailBuffer(handle->rxQueue, &rxBuffer);
   \       0x12   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x16   0x4604             MOV      R4,R0
   1857              DMADRV_TransferRemainingCount(handle->rxDmaCh,
   1858                                            (int*)&remaining);
   \       0x18   0x68E8             LDR      R0,[R5, #+12]
   \       0x1A   0xA901             ADD      R1,SP,#+4
   \       0x1C   0x....'....        BL       DMADRV_TransferRemainingCount
   1859            }
   1860          
   1861            if (rxBuffer && (retVal == ECODE_EMDRV_UARTDRV_OK)) {
   \       0x20   0x9800             LDR      R0,[SP, #+0]
   \       0x22   0xB118             CBZ.N    R0,??UARTDRV_GetReceiveStatus_0
   \       0x24   0xB914             CBNZ.N   R4,??UARTDRV_GetReceiveStatus_0
   1862              *itemsReceived = rxBuffer->transferCount - remaining;
   \       0x26   0x....'....        BL       ?Subroutine19
   1863              *itemsRemaining = remaining;
   1864              *buffer = rxBuffer->data;
   1865            } else {
   \                     ??CrossCallReturnLabel_32: (+1)
   \       0x2A   0xE003             B.N      ??UARTDRV_GetReceiveStatus_1
   1866              *itemsRemaining = 0;
   \                     ??UARTDRV_GetReceiveStatus_0: (+1)
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x6031             STR      R1,[R6, #+0]
   1867              *itemsReceived = 0;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x6038             STR      R0,[R7, #+0]
   1868              *buffer = NULL;
   1869            }
   \                     ??UARTDRV_GetReceiveStatus_1: (+1)
   \       0x34   0x....             B.N      ?Subroutine5
   1870          
   1871            return UARTDRV_GetPeripheralStatus(handle);
   1872          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0xF8C8 0x0000      STR      R0,[R8, #+0]
   \        0x4   0x6829             LDR      R1,[R5, #+0]
   \        0x6   0x6988             LDR      R0,[R1, #+24]
   \        0x8   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine19: (+1)
   \        0x0   0x6841             LDR      R1,[R0, #+4]
   \        0x2   0x9801             LDR      R0,[SP, #+4]
   \        0x4   0x1A09             SUBS     R1,R1,R0
   \        0x6   0x6039             STR      R1,[R7, #+0]
   \        0x8   0x9901             LDR      R1,[SP, #+4]
   \        0xA   0x6031             STR      R1,[R6, #+0]
   \        0xC   0x9800             LDR      R0,[SP, #+0]
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x4688             MOV      R8,R1
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x9100             STR      R1,[SP, #+0]
   \        0x8   0x9101             STR      R1,[SP, #+4]
   \        0xA   0x4770             BX       LR
   1873          
   1874          /***************************************************************************//**
   1875           * @brief
   1876           *    Returns the number of queued transmit operations.
   1877           *
   1878           * @param[in] handle Pointer to a UART driver handle.
   1879           *
   1880           * @return
   1881           *    The number of queued operations.
   1882           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1883          uint8_t UARTDRV_GetTransmitDepth(UARTDRV_Handle_t handle)
   1884          {
   1885            return (uint8_t)handle->txQueue->used;
   \                     UARTDRV_GetTransmitDepth: (+1)
   \        0x0   0x6A80             LDR      R0,[R0, #+40]
   \        0x2                      REQUIRE ?Subroutine2
   \        0x2                      ;; // Fall through to label ?Subroutine2
   1886          }
   1887          
   1888          /***************************************************************************//**
   1889           * @brief
   1890           *    Check the status of the UART and gather information about any ongoing
   1891           *    transmit operations.
   1892           *
   1893           * @param[in] handle Pointer to a UART driver handle.
   1894           *
   1895           * @param[out] buffer Pointer to the current data buffer.
   1896           *
   1897           * @param[out] itemsSent Current bytes sent count.
   1898           *
   1899           * @param[out] itemsRemaining Current bytes remaining count.
   1900           *
   1901           * @return
   1902           *    UART status.
   1903           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1904          UARTDRV_Status_t UARTDRV_GetTransmitStatus(UARTDRV_Handle_t handle,
   1905                                                     uint8_t **buffer,
   1906                                                     UARTDRV_Count_t *itemsSent,
   1907                                                     UARTDRV_Count_t *itemsRemaining)
   1908          {
   \                     UARTDRV_GetTransmitStatus: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x....'....        BL       ?Subroutine12
   1909            UARTDRV_Buffer_t *txBuffer = NULL;
   1910            Ecode_t retVal = ECODE_EMDRV_UARTDRV_OK;
   1911            uint32_t remaining = 0;
   1912          
   1913            if (handle->txQueue->used > 0) {
   \                     ??CrossCallReturnLabel_19: (+1)
   \        0x8   0x6AA8             LDR      R0,[R5, #+40]
   \        0xA   0x4617             MOV      R7,R2
   \        0xC   0x461E             MOV      R6,R3
   \        0xE   0x8882             LDRH     R2,[R0, #+4]
   \       0x10   0xB162             CBZ.N    R2,??UARTDRV_GetTransmitStatus_0
   1914              retVal = GetTailBuffer(handle->txQueue, &txBuffer);
   \       0x12   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x16   0x4604             MOV      R4,R0
   1915              DMADRV_TransferRemainingCount(handle->txDmaCh,
   1916                                            (int*)&remaining);
   \       0x18   0x68A8             LDR      R0,[R5, #+8]
   \       0x1A   0xA901             ADD      R1,SP,#+4
   \       0x1C   0x....'....        BL       DMADRV_TransferRemainingCount
   1917            }
   1918          
   1919            if (txBuffer && (retVal == ECODE_EMDRV_UARTDRV_OK)) {
   \       0x20   0x9800             LDR      R0,[SP, #+0]
   \       0x22   0xB118             CBZ.N    R0,??UARTDRV_GetTransmitStatus_0
   \       0x24   0xB914             CBNZ.N   R4,??UARTDRV_GetTransmitStatus_0
   1920              *itemsSent = txBuffer->transferCount - remaining;
   \       0x26   0x....'....        BL       ?Subroutine19
   1921              *itemsRemaining = remaining;
   1922              *buffer = txBuffer->data;
   1923            } else {
   \                     ??CrossCallReturnLabel_33: (+1)
   \       0x2A   0xE003             B.N      ??UARTDRV_GetTransmitStatus_1
   1924              *itemsRemaining = 0;
   \                     ??UARTDRV_GetTransmitStatus_0: (+1)
   \       0x2C   0x2100             MOVS     R1,#+0
   \       0x2E   0x6031             STR      R1,[R6, #+0]
   1925              *itemsSent = 0;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x6038             STR      R0,[R7, #+0]
   1926              *buffer = NULL;
   1927            }
   \                     ??UARTDRV_GetTransmitStatus_1: (+1)
   \       0x34                      REQUIRE ?Subroutine5
   \       0x34                      ;; // Fall through to label ?Subroutine5
   1928          
   1929            return UARTDRV_GetPeripheralStatus(handle);
   1930          }
   1931          
   1932          /***************************************************************************//**
   1933           * @brief
   1934           *    Set UART flow control state. Set nRTS pin if hardware flow control
   1935           *    is enabled. Send XON/XOFF if software flow control is enabled.
   1936           *
   1937           * @param[in] handle Pointer to a UART driver handle.
   1938           *
   1939           * @param[in] state Flow control state.
   1940           *
   1941           * @return
   1942           *    @ref ECODE_EMDRV_UARTDRV_OK on success.
   1943           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1944          Ecode_t UARTDRV_FlowControlSet(UARTDRV_Handle_t handle, UARTDRV_FlowControlState_t state)
   1945          {
   1946          #if (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE)
   1947            if (handle->fcType == uartdrvFlowControlHwUart) {
   \                     UARTDRV_FlowControlSet: (+1)
   \        0x0   0xF890 0x2031      LDRB     R2,[R0, #+49]
   \        0x4   0x2A03             CMP      R2,#+3
   \        0x6   0xD102             BNE.N    ??UARTDRV_FlowControlSet_0
   1948              return ECODE_EMDRV_UARTDRV_ILLEGAL_OPERATION;
   \        0x8   0x....'....        LDR.W    R0,??DataTable22_25  ;; 0xf0007005
   \        0xC   0x4770             BX       LR
   1949            }
   1950            handle->fcSelfCfg = state;
   1951            if (state != uartdrvFlowControlAuto) {
   \                     ??UARTDRV_FlowControlSet_0: (+1)
   \        0xE   0x2902             CMP      R1,#+2
   \       0x10   0x7641             STRB     R1,[R0, #+25]
   \       0x12   0xBF18             IT       NE 
   \       0x14   0x7601             STRBNE   R1,[R0, #+24]
   1952              handle->fcSelfState = state;
   1953            }
   1954            return FcApplyState(handle);
   \       0x16   0x....'....        B.W      FcApplyState
   1955          #else
   1956            (void) handle;
   1957            (void) state;
   1958            return ECODE_EMDRV_UARTDRV_OK;
   1959          #endif
   1960          }
   1961          
   1962          /***************************************************************************//**
   1963           * @brief
   1964           *    Set peer UART flow control state. Pause/resume transmit accordingly.
   1965           *    Only for manual software flow control.
   1966           *
   1967           * @param[in] handle Pointer to a UART driver handle.
   1968           *
   1969           * @param[in] state Flow control state.
   1970           *
   1971           * @return
   1972           *    @ref ECODE_EMDRV_UARTDRV_OK on success.
   1973           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1974          Ecode_t UARTDRV_FlowControlSetPeerStatus(UARTDRV_Handle_t handle, UARTDRV_FlowControlState_t state)
   1975          {
   \                     UARTDRV_FlowControlSetPeerStatus: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1976            if ( (handle->fcType != uartdrvFlowControlSw)
   1977                 || (state == uartdrvFlowControlAuto) ) {
   \        0x2   0xF100 0x021A      ADD      R2,R0,#+26
   \        0x6   0x7DD3             LDRB     R3,[R2, #+23]
   \        0x8   0x2B01             CMP      R3,#+1
   \        0xA   0xD101             BNE.N    ??UARTDRV_FlowControlSetPeerStatus_0
   \        0xC   0x2902             CMP      R1,#+2
   \        0xE   0xD102             BNE.N    ??UARTDRV_FlowControlSetPeerStatus_1
   1978              return ECODE_EMDRV_UARTDRV_ILLEGAL_OPERATION;
   \                     ??UARTDRV_FlowControlSetPeerStatus_0: (+1)
   \       0x10   0x....'....        LDR.W    R0,??DataTable22_25  ;; 0xf0007005
   \       0x14   0xBD02             POP      {R1,PC}
   1979            }
   1980          
   1981            if (handle->fcPeerState != state) {
   \                     ??UARTDRV_FlowControlSetPeerStatus_1: (+1)
   \       0x16   0x7813             LDRB     R3,[R2, #+0]
   \       0x18   0x428B             CMP      R3,R1
   \       0x1A   0xD009             BEQ.N    ??UARTDRV_FlowControlSetPeerStatus_2
   1982              handle->fcPeerState = state;
   \       0x1C   0x7011             STRB     R1,[R2, #+0]
   1983              if (state == uartdrvFlowControlOn) {
   \       0x1E   0x000A             MOVS     R2,R1
   \       0x20   0xD102             BNE.N    ??UARTDRV_FlowControlSetPeerStatus_3
   1984                UARTDRV_ResumeTransmit(handle);
   \       0x22   0x....'....        BL       UARTDRV_ResumeTransmit
   \       0x26   0xE003             B.N      ??UARTDRV_FlowControlSetPeerStatus_2
   1985              } else if (state == uartdrvFlowControlOff) {
   \                     ??UARTDRV_FlowControlSetPeerStatus_3: (+1)
   \       0x28   0x2901             CMP      R1,#+1
   \       0x2A   0xBF08             IT       EQ 
   1986                UARTDRV_PauseTransmit(handle);
   \       0x2C   0x....'....        BLEQ     UARTDRV_PauseTransmit
   1987              }
   1988            }
   1989          
   1990            return ECODE_EMDRV_UARTDRV_OK;
   \                     ??UARTDRV_FlowControlSetPeerStatus_2: (+1)
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0xBD02             POP      {R1,PC}          ;; return
   1991          }
   1992          
   1993          /***************************************************************************//**
   1994           * @brief
   1995           *    Check the peer's flow control status.
   1996           *
   1997           * @param[in] handle Pointer to a UART driver handle.
   1998           *
   1999           * @return
   2000           *    Returns uartdrvFlowControlOn if clear to send.
   2001           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2002          UARTDRV_FlowControlState_t UARTDRV_FlowControlGetPeerStatus(UARTDRV_Handle_t handle)
   2003          {
   2004            return handle->fcPeerState;
   \                     UARTDRV_FlowControlGetPeerStatus: (+1)
   \        0x0   0x7E80             LDRB     R0,[R0, #+26]
   \        0x2   0x4770             BX       LR               ;; return
   2005          }
   2006          
   2007          /***************************************************************************//**
   2008           * @brief
   2009           *    Check the self flow control status.
   2010           *
   2011           * @param[in] handle Pointer to a UART driver handle.
   2012           *
   2013           * @return
   2014           *    Returns uartdrvFlowControlOn if requesting to send.
   2015           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2016          UARTDRV_FlowControlState_t UARTDRV_FlowControlGetSelfStatus(UARTDRV_Handle_t handle)
   2017          {
   2018            return handle->fcSelfState;
   \                     UARTDRV_FlowControlGetSelfStatus: (+1)
   \        0x0   0x7E00             LDRB     R0,[R0, #+24]
   \        0x2   0x4770             BX       LR               ;; return
   2019          }
   2020          
   2021          /***************************************************************************//**
   2022           * @brief
   2023           *    Enable transmission when restrained by flow control.
   2024           *
   2025           * @param[in] handle Pointer to a UART driver handle.
   2026           *
   2027           * @return
   2028           *    @ref ECODE_EMDRV_UARTDRV_OK on success.
   2029           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2030          Ecode_t UARTDRV_FlowControlIgnoreRestrain(UARTDRV_Handle_t handle)
   2031          {
   2032            handle->IgnoreRestrain = true;
   \                     UARTDRV_FlowControlIgnoreRestrain: (+1)
   \        0x0   0x2101             MOVS     R1,#+1
   \        0x2   0xF880 0x102F      STRB     R1,[R0, #+47]
   2033          
   2034            return ECODE_EMDRV_UARTDRV_OK;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x4770             BX       LR               ;; return
   2035          }
   2036          
   2037          /***************************************************************************//**
   2038           * @brief
   2039           *    Direct receive without interrupts or callback. This is a blocking function.
   2040           *
   2041           * @param[in] handle Pointer to a UART driver handle.
   2042           *
   2043           * @param[in] data pointer to buffer.
   2044           *
   2045           * @param[in] maxCount Maximum number of bytes to receive.
   2046           *
   2047           * @return
   2048           *    Number of bytes received.
   2049           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2050          UARTDRV_Count_t UARTDRV_ForceReceive(UARTDRV_Handle_t handle,
   2051                                               uint8_t *data,
   2052                                               UARTDRV_Count_t maxCount)
   2053          {
   \                     UARTDRV_ForceReceive: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4606             MOV      R6,R0
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0x4690             MOV      R8,R2
   2054            Ecode_t retVal;
   2055            uint32_t rxState;
   2056            UARTDRV_Count_t i = 0;
   \        0xA   0x2700             MOVS     R7,#+0
   2057          
   2058            retVal = CheckParams(handle, data, maxCount);
   2059            if (retVal != ECODE_EMDRV_UARTDRV_OK) {
   \        0xC   0x....'....        BL       CheckParams
   \       0x10   0x2800             CMP      R0,#+0
   \       0x12   0x6A71             LDR      R1,[R6, #+36]
   \       0x14   0xD118             BNE.N    ??UARTDRV_ForceReceive_0
   2060              return 0;
   2061            }
   2062          
   2063            // Wait for DMA receive to complete and clear
   2064            while (handle->rxQueue->used > 0) {
   \                     ??UARTDRV_ForceReceive_1: (+1)
   \       0x16   0x8888             LDRH     R0,[R1, #+4]
   \       0x18   0x2800             CMP      R0,#+0
   \       0x1A   0xD1FC             BNE.N    ??UARTDRV_ForceReceive_1
   2065            }
   2066          
   2067          #if defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)
   2068            if (handle->type == uartdrvUartTypeUart) {
   2069              rxState = (handle->peripheral.uart->STATUS & USART_STATUS_RXENS);
   2070            } else if (handle->type == uartdrvUartTypeLeuart) {
   2071              rxState = (handle->peripheral.leuart->STATUS & LEUART_STATUS_RXENS);
   2072            } else {
   2073              EFM_ASSERT(false);
   2074              rxState = 0;
   2075            }
   2076          #else
   2077            rxState = (handle->peripheral.uart->STATUS & USART_STATUS_RXENS);
   \       0x1C   0x6831             LDR      R1,[R6, #+0]
   \       0x1E   0x698C             LDR      R4,[R1, #+24]
   \       0x20   0xF014 0x0401      ANDS     R4,R4,#0x1
   2078          #endif
   2079          
   2080            if (!rxState) {
   \       0x24   0xBF04             ITT      EQ 
   2081              EnableReceiver(handle);
   \       0x26   0x4630             MOVEQ    R0,R6
   \       0x28   0x....'....        BLEQ     EnableReceiver
   2082            }
   2083          
   2084          #if defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)
   2085            if (handle->type == uartdrvUartTypeUart)
   2086          #endif
   2087            {
   2088              while ((handle->peripheral.uart->STATUS & USART_STATUS_RXDATAV) != 0U) {
   \                     ??UARTDRV_ForceReceive_2: (+1)
   \       0x2C   0x6830             LDR      R0,[R6, #+0]
   \       0x2E   0x6981             LDR      R1,[R0, #+24]
   \       0x30   0x060A             LSLS     R2,R1,#+24
   \       0x32   0xD505             BPL.N    ??UARTDRV_ForceReceive_3
   2089                *data = (uint8_t)handle->peripheral.uart->RXDATA;
   \       0x34   0x6A40             LDR      R0,[R0, #+36]
   2090                data++;
   2091                i++;
   \       0x36   0x1C7F             ADDS     R7,R7,#+1
   2092                if (i >= maxCount) {
   \       0x38   0x4547             CMP      R7,R8
   \       0x3A   0xF805 0x0B01      STRB     R0,[R5], #+1
   \       0x3E   0xD3F5             BCC.N    ??UARTDRV_ForceReceive_2
   2093                  break;
   2094                }
   2095              }
   2096            }
   2097          #if defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)
   2098            else if (handle->type == uartdrvUartTypeLeuart) {
   2099              while ((handle->peripheral.leuart->STATUS & LEUART_STATUS_RXDATAV) != 0U) {
   2100                *data = (uint8_t)handle->peripheral.leuart->RXDATA;
   2101                data++;
   2102                i++;
   2103                if (i >= maxCount) {
   2104                  break;
   2105                }
   2106              }
   2107            }
   2108          #endif
   2109            data -= i;
   2110          
   2111            if (!rxState) {
   \                     ??UARTDRV_ForceReceive_3: (+1)
   \       0x40   0xB914             CBNZ.N   R4,??UARTDRV_ForceReceive_0
   2112              DisableReceiver(handle);
   \       0x42   0x4630             MOV      R0,R6
   \       0x44   0x....'....        BL       DisableReceiver
   2113            }
   2114            return i;
   \                     ??UARTDRV_ForceReceive_0: (+1)
   \       0x48   0x4638             MOV      R0,R7
   \       0x4A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2115          }
   2116          
   2117          /***************************************************************************//**
   2118           * @brief
   2119           *    Direct transmit without interrupts or callback. This is a blocking function.
   2120           *    that ignores flow control if enabled.
   2121           *
   2122           * @param[in] handle Pointer to a UART driver handle.
   2123           *
   2124           * @param[in] data Pointer to the buffer.
   2125           *
   2126           * @param[in] count A number of bytes to transmit.
   2127           *
   2128           * @return
   2129           *    @ref ECODE_EMDRV_UARTDRV_OK on success.
   2130           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2131          Ecode_t  UARTDRV_ForceTransmit(UARTDRV_Handle_t handle,
   2132                                         uint8_t *data,
   2133                                         UARTDRV_Count_t count)
   2134          {
   \                     UARTDRV_ForceTransmit: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x4688             MOV      R8,R1
   \        0x8   0x4616             MOV      R6,R2
   2135            Ecode_t retVal;
   2136            uint32_t txState;
   2137            bool callDmaIrqHandler;
   2138          
   2139            retVal = CheckParams(handle, data, count);
   \        0xA   0x....'....        BL       CheckParams
   2140            if (retVal != ECODE_EMDRV_UARTDRV_OK) {
   \        0xE   0x2800             CMP      R0,#+0
   \       0x10   0xD13B             BNE.N    ??UARTDRV_ForceTransmit_0
   2141              return retVal;
   2142            }
   2143          
   2144            // Wait for DMA transmit to complete and clear
   2145            callDmaIrqHandler = CORE_IrqIsBlocked(UART_DMA_IRQ); // Loop invariant
   \       0x12   0x2015             MOVS     R0,#+21
   \       0x14   0x....'....        BL       CORE_IrqIsBlocked
   \       0x18   0x4604             MOV      R4,R0
   \       0x1A   0xF107 0x052E      ADD      R5,R7,#+46
   \       0x1E   0xE002             B.N      ??UARTDRV_ForceTransmit_1
   2146            while ((handle->txQueue->used > 0) && (!handle->txDmaPaused)) {
   2147              if (callDmaIrqHandler) {
   \                     ??UARTDRV_ForceTransmit_2: (+1)
   \       0x20   0xB10C             CBZ.N    R4,??UARTDRV_ForceTransmit_1
   2148                UART_DMA_IRQHANDLER();
   \       0x22   0x....'....        BL       LDMA_IRQHandler
   2149              }
   2150            }
   \                     ??UARTDRV_ForceTransmit_1: (+1)
   \       0x26   0x6AB8             LDR      R0,[R7, #+40]
   \       0x28   0x8881             LDRH     R1,[R0, #+4]
   \       0x2A   0xB111             CBZ.N    R1,??UARTDRV_ForceTransmit_3
   \       0x2C   0x7828             LDRB     R0,[R5, #+0]
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD0F6             BEQ.N    ??UARTDRV_ForceTransmit_2
   2151          
   2152          #if defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)
   2153            if (handle->type == uartdrvUartTypeUart) {
   2154              txState = (handle->peripheral.uart->STATUS & USART_STATUS_TXENS);
   2155            } else if (handle->type == uartdrvUartTypeLeuart) {
   2156              txState = (handle->peripheral.leuart->STATUS & LEUART_STATUS_TXENS);
   2157            } else {
   2158              EFM_ASSERT(false);
   2159              txState = 0;
   2160            }
   2161          #elif defined(EUART_COUNT) && (EUART_COUNT > 0)
   2162            if (handle->type == uartdrvUartTypeUart) {
   2163              txState = (handle->peripheral.uart->STATUS & USART_STATUS_TXENS);
   2164            } else if (handle->type == uartdrvUartTypeEuart) {
   2165              txState = EUSART_StatusGet(handle->peripheral.euart) & EUSART_STATUS_TXENS;
   2166            } else {
   2167              EFM_ASSERT(false);
   2168              txState = 0;
   2169            }
   2170          #else
   2171            txState = (handle->peripheral.uart->STATUS & USART_STATUS_TXENS);
   \                     ??UARTDRV_ForceTransmit_3: (+1)
   \       0x32   0x6838             LDR      R0,[R7, #+0]
   \       0x34   0x6984             LDR      R4,[R0, #+24]
   \       0x36   0xF014 0x0402      ANDS     R4,R4,#0x2
   2172          #endif
   2173          
   2174            if (!txState) {
   \       0x3A   0xD10A             BNE.N    ??UARTDRV_ForceTransmit_4
   2175              EnableTransmitter(handle);
   \       0x3C   0x2104             MOVS     R1,#+4
   \       0x3E   0x6141             STR      R1,[R0, #+20]
   \                     ??UARTDRV_ForceTransmit_5: (+1)
   \       0x40   0x6838             LDR      R0,[R7, #+0]
   \       0x42   0x6981             LDR      R1,[R0, #+24]
   \       0x44   0x0788             LSLS     R0,R1,#+30
   \       0x46   0xD5FB             BPL.N    ??UARTDRV_ForceTransmit_5
   \       0x48   0x7938             LDRB     R0,[R7, #+4]
   \       0x4A   0x2110             MOVS     R1,#+16
   \       0x4C   0x....             LDR.N    R2,??DataTable22_6  ;; 0x4003d5ac
   \       0x4E   0x0140             LSLS     R0,R0,#+5
   \       0x50   0x5011             STR      R1,[R2, R0]
   2176            }
   2177          
   2178            handle->hasTransmitted = true;
   \                     ??UARTDRV_ForceTransmit_4: (+1)
   \       0x52   0x2101             MOVS     R1,#+1
   \       0x54   0x70A9             STRB     R1,[R5, #+2]
   2179          
   2180            if (handle->type == uartdrvUartTypeUart) {
   \       0x56   0x7928             LDRB     R0,[R5, #+4]
   \       0x58   0xB968             CBNZ.N   R0,??UARTDRV_ForceTransmit_6
   \       0x5A   0xE004             B.N      ??UARTDRV_ForceTransmit_7
   2181              while (count-- != 0U) {
   2182                USART_Tx(handle->peripheral.uart, *data++);
   \                     ??UARTDRV_ForceTransmit_8: (+1)
   \       0x5C   0xF818 0x1B01      LDRB     R1,[R8], #+1
   \       0x60   0x4610             MOV      R0,R2
   \       0x62   0x....'....        BL       USART_Tx
   2183              }
   \                     ??UARTDRV_ForceTransmit_7: (+1)
   \       0x66   0x4630             MOV      R0,R6
   \       0x68   0x1E46             SUBS     R6,R0,#+1
   \       0x6A   0x683A             LDR      R2,[R7, #+0]
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD1F5             BNE.N    ??UARTDRV_ForceTransmit_8
   2184              // Wait for Tx completion
   2185              while (!(handle->peripheral.uart->STATUS & USART_STATUS_TXC)) {
   \                     ??UARTDRV_ForceTransmit_9: (+1)
   \       0x70   0x6990             LDR      R0,[R2, #+24]
   \       0x72   0x0681             LSLS     R1,R0,#+26
   \       0x74   0xD5FC             BPL.N    ??UARTDRV_ForceTransmit_9
   2186              }
   2187            }
   2188          #if defined(LEUART_COUNT) && (LEUART_COUNT > 0) && !defined(_SILICON_LABS_32B_SERIES_2)
   2189            else if (handle->type == uartdrvUartTypeLeuart) {
   2190              while (count-- != 0U) {
   2191                LEUART_Tx(handle->peripheral.leuart, *data++);
   2192              }
   2193              // Wait for Tx completion
   2194              while (!(handle->peripheral.leuart->STATUS & LEUART_STATUS_TXC)) {
   2195              }
   2196            }
   2197          #elif defined(EUART_COUNT) && (EUART_COUNT > 0)
   2198            else if (handle->type == uartdrvUartTypeEuart) {
   2199              while (count-- != 0U) {
   2200                EUSART_Tx(handle->peripheral.euart, *data++);
   2201              }
   2202              while (~EUSART_StatusGet(handle->peripheral.euart) & (EUSART_STATUS_TXC | EUSART_STATUS_TXIDLE)) {
   2203              }
   2204            }
   2205          #endif
   2206          
   2207            if (!txState) {
   \                     ??UARTDRV_ForceTransmit_6: (+1)
   \       0x76   0xB93C             CBNZ.N   R4,??UARTDRV_ForceTransmit_10
   2208              DisableTransmitter(handle);
   \       0x78   0x793A             LDRB     R2,[R7, #+4]
   \       0x7A   0x2010             MOVS     R0,#+16
   \       0x7C   0x....             LDR.N    R1,??DataTable22_7  ;; 0x4003e5ac
   \       0x7E   0x0152             LSLS     R2,R2,#+5
   \       0x80   0x5088             STR      R0,[R1, R2]
   \       0x82   0x6839             LDR      R1,[R7, #+0]
   \       0x84   0x2008             MOVS     R0,#+8
   \       0x86   0x6148             STR      R0,[R1, #+20]
   2209            }
   2210          
   2211            return ECODE_EMDRV_UARTDRV_OK;
   \                     ??UARTDRV_ForceTransmit_10: (+1)
   \       0x88   0x2000             MOVS     R0,#+0
   \                     ??UARTDRV_ForceTransmit_0: (+1)
   \       0x8A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   2212          }
   2213          
   2214          /***************************************************************************//**
   2215           * @brief
   2216           *  Pause an ongoing transmit operation.
   2217           *
   2218           * @param[in] handle Pointer to a UART driver handle.
   2219           *
   2220           * @return
   2221           *  @ref ECODE_EMDRV_UARTDRV_OK on success. On failure, an appropriate
   2222           *  UARTDRV @ref Ecode_t is returned.
   2223           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2224          Ecode_t UARTDRV_PauseTransmit(UARTDRV_Handle_t handle)
   2225          {
   \                     UARTDRV_PauseTransmit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2226            if (handle == NULL) {
   \        0x4   0xD100             BNE.N    ??UARTDRV_PauseTransmit_0
   2227              return ECODE_EMDRV_UARTDRV_ILLEGAL_HANDLE;
   \        0x6   0x....             B.N      ?Subroutine1
   2228            }
   2229            // Pause the transfer if 1) pause counter is 0
   2230            //                       2) HW flow control hasn't already paused the DMA
   2231            if ( (handle->txDmaPaused == 0) && (HwFcGetClearToSendPin(handle) == uartdrvFlowControlOn) ) {
   \                     ??UARTDRV_PauseTransmit_0: (+1)
   \        0x8   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \        0xC   0xB930             CBNZ.N   R0,??UARTDRV_PauseTransmit_1
   \        0xE   0x4620             MOV      R0,R4
   \       0x10   0x....'....        BL       HwFcGetClearToSendPin
   \       0x14   0xB910             CBNZ.N   R0,??UARTDRV_PauseTransmit_1
   2232              DMADRV_PauseTransfer(handle->txDmaCh);
   \       0x16   0x68A0             LDR      R0,[R4, #+8]
   \       0x18   0x....'....        BL       DMADRV_PauseTransfer
   2233            }
   2234            // Increment counter to allow nested calls
   2235            handle->txDmaPaused++;
   \                     ??UARTDRV_PauseTransmit_1: (+1)
   \       0x1C   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \       0x20   0x1C40             ADDS     R0,R0,#+1
   \       0x22   0xF884 0x002E      STRB     R0,[R4, #+46]
   2236            return ECODE_EMDRV_UARTDRV_OK;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xBD10             POP      {R4,PC}          ;; return
   2237          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable22_10  ;; 0xf0007002
   \        0x2   0xBD10             POP      {R4,PC}
   2238          
   2239          /***************************************************************************//**
   2240           * @brief
   2241           *    Start a non-blocking receive.
   2242           *
   2243           * @param[in] handle Pointer to a UART driver handle.
   2244           *
   2245           * @param[in] data A receive data buffer.
   2246           *
   2247           * @param[in] count A number of bytes received.
   2248           *
   2249           * @param[in]  callback A transfer completion callback.
   2250           *
   2251           * @return
   2252           *    @ref ECODE_EMDRV_UARTDRV_OK on success.
   2253           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2254          Ecode_t UARTDRV_Receive(UARTDRV_Handle_t handle,
   2255                                  uint8_t *data,
   2256                                  UARTDRV_Count_t count,
   2257                                  UARTDRV_Callback_t callback)
   2258          {
   \                     UARTDRV_Receive: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x....'....        BL       ?Subroutine10
   2259            Ecode_t retVal;
   2260            UARTDRV_Buffer_t outputBuffer;
   2261            UARTDRV_Buffer_t *queueBuffer;
   2262          
   2263            retVal = CheckParams(handle, data, count);
   2264            if (retVal != ECODE_EMDRV_UARTDRV_OK) {
   \                     ??CrossCallReturnLabel_15: (+1)
   \        0x8   0xB9C8             CBNZ.N   R0,??UARTDRV_Receive_0
   2265              return retVal;
   2266            }
   2267            outputBuffer.data = data;
   \        0xA   0x9601             STR      R6,[SP, #+4]
   2268            outputBuffer.transferCount = count;
   \        0xC   0x9702             STR      R7,[SP, #+8]
   2269            outputBuffer.itemsRemaining = count;
   \        0xE   0x9703             STR      R7,[SP, #+12]
   2270            outputBuffer.callback = callback;
   \       0x10   0x9504             STR      R5,[SP, #+16]
   2271            outputBuffer.transferStatus = ECODE_EMDRV_UARTDRV_WAITING;
   \       0x12   0x....             LDR.N    R1,??DataTable22_26  ;; 0xf0007001
   \       0x14   0x9105             STR      R1,[SP, #+20]
   2272          
   2273            retVal = EnqueueBuffer(handle->rxQueue, &outputBuffer, &queueBuffer);
   \       0x16   0x....'....        BL       ?Subroutine20
   2274            if (retVal != ECODE_EMDRV_UARTDRV_OK) {
   \                     ??CrossCallReturnLabel_35: (+1)
   \       0x1A   0xB980             CBNZ.N   R0,??UARTDRV_Receive_0
   2275              return retVal;
   2276            }
   2277            if (!(handle->rxDmaActive)) {
   \       0x1C   0xF104 0x052C      ADD      R5,R4,#+44
   \       0x20   0x7828             LDRB     R0,[R5, #+0]
   \       0x22   0xB958             CBNZ.N   R0,??CrossCallReturnLabel_11
   2278              EnableReceiver(handle);
   \       0x24   0x4620             MOV      R0,R4
   \       0x26   0x....'....        BL       EnableReceiver
   2279              StartReceiveDma(handle, queueBuffer);
   \       0x2A   0x9900             LDR      R1,[SP, #+0]
   \       0x2C   0x4620             MOV      R0,R4
   \       0x2E   0x....'....        BL       StartReceiveDma
   2280          #if (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE)
   2281              if (handle->fcType != uartdrvFlowControlHwUart) {
   \       0x32   0x7968             LDRB     R0,[R5, #+5]
   \       0x34   0x2803             CMP      R0,#+3
   \       0x36   0xD001             BEQ.N    ??CrossCallReturnLabel_11
   2282                handle->fcSelfState = uartdrvFlowControlOn;
   \       0x38   0x....'....        BL       ?Subroutine8
   2283                FcApplyState(handle);
   2284              }
   2285          #endif
   2286            } // else: started by ReceiveDmaComplete
   2287          
   2288            return ECODE_EMDRV_UARTDRV_OK;
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x3C   0x2000             MOVS     R0,#+0
   \                     ??UARTDRV_Receive_0: (+1)
   \       0x3E   0xB007             ADD      SP,SP,#+28
   \       0x40   0xBDF0             POP      {R4-R7,PC}       ;; return
   2289          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine20: (+1)
   \        0x0   0x6A60             LDR      R0,[R4, #+36]
   \        0x2   0x466A             MOV      R2,SP
   \        0x4   0xA901             ADD      R1,SP,#+4
   \        0x6   0x....'....        B.W      EnqueueBuffer

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x7621             STRB     R1,[R4, #+24]
   \        0x4   0x4620             MOV      R0,R4
   \        0x6   0x....'....        B.W      FcApplyState

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0x460E             MOV      R6,R1
   \        0x4   0x4617             MOV      R7,R2
   \        0x6   0x461D             MOV      R5,R3
   \        0x8   0x....'....        B.W      CheckParams
   2290          
   2291          /***************************************************************************//**
   2292           * @brief
   2293           *    Start a blocking receive.
   2294           *
   2295           * @param[in] handle Pointer to a UART driver handle.
   2296           *
   2297           * @param[in] data A receive data buffer.
   2298           *
   2299           * @param[in] count A number of bytes received.
   2300           *
   2301           * @return
   2302           *    @ref ECODE_EMDRV_UARTDRV_OK on success.
   2303           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2304          Ecode_t UARTDRV_ReceiveB(UARTDRV_Handle_t handle,
   2305                                   uint8_t *data,
   2306                                   UARTDRV_Count_t count)
   2307          {
   \                     UARTDRV_ReceiveB: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x....'....        BL       ?Subroutine11
   2308            Ecode_t retVal;
   2309            UARTDRV_Buffer_t inputBuffer;
   2310            UARTDRV_Buffer_t *queueBuffer;
   2311          
   2312            retVal = CheckParams(handle, data, count);
   2313            if (retVal != ECODE_EMDRV_UARTDRV_OK) {
   \                     ??CrossCallReturnLabel_17: (+1)
   \        0x8   0xBB18             CBNZ.N   R0,??UARTDRV_ReceiveB_0
   2314              return retVal;
   2315            }
   2316            inputBuffer.data = data;
   \        0xA   0x9501             STR      R5,[SP, #+4]
   2317            inputBuffer.transferCount = count;
   \        0xC   0x9602             STR      R6,[SP, #+8]
   2318            inputBuffer.itemsRemaining = count;
   \        0xE   0x....'....        BL       ?Subroutine9
   2319            inputBuffer.callback = NULL;
   2320            inputBuffer.transferStatus = ECODE_EMDRV_UARTDRV_WAITING;
   2321          
   2322            retVal = EnqueueBuffer(handle->rxQueue, &inputBuffer, &queueBuffer);
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x12   0x....'....        BL       ?Subroutine20
   2323            if (retVal != ECODE_EMDRV_UARTDRV_OK) {
   \                     ??CrossCallReturnLabel_34: (+1)
   \       0x16   0xB110             CBZ.N    R0,??UARTDRV_ReceiveB_1
   2324              return retVal;
   \       0x18   0xE01B             B.N      ??UARTDRV_ReceiveB_0
   2325            }
   2326            while (handle->rxQueue->used > 1) {
   2327              EMU_EnterEM1();
   \                     ??UARTDRV_ReceiveB_2: (+1)
   \       0x1A   0x....'....        BL       EMU_EnterEM1
   2328            }
   \                     ??UARTDRV_ReceiveB_1: (+1)
   \       0x1E   0x6A60             LDR      R0,[R4, #+36]
   \       0x20   0x8881             LDRH     R1,[R0, #+4]
   \       0x22   0x2902             CMP      R1,#+2
   \       0x24   0xDAF9             BGE.N    ??UARTDRV_ReceiveB_2
   2329            EnableReceiver(handle);
   \       0x26   0x4620             MOV      R0,R4
   \       0x28   0x....'....        BL       EnableReceiver
   2330          #if (EMDRV_UARTDRV_FLOW_CONTROL_ENABLE)
   2331            if (handle->fcType != uartdrvFlowControlHwUart) {
   \       0x2C   0xF104 0x052C      ADD      R5,R4,#+44
   \       0x30   0x7968             LDRB     R0,[R5, #+5]
   \       0x32   0x2803             CMP      R0,#+3
   \       0x34   0xD001             BEQ.N    ??CrossCallReturnLabel_10
   2332              handle->fcSelfState = uartdrvFlowControlOn;
   \       0x36   0x....'....        BL       ?Subroutine8
   2333              FcApplyState(handle);
   2334            }
   2335          #endif
   2336            StartReceiveDma(handle, queueBuffer);
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x3A   0x9900             LDR      R1,[SP, #+0]
   \       0x3C   0x4620             MOV      R0,R4
   \       0x3E   0x....'....        BL       StartReceiveDma
   \       0x42   0xE001             B.N      ??UARTDRV_ReceiveB_3
   2337            while (handle->rxDmaActive) {
   2338              EMU_EnterEM1();
   \                     ??UARTDRV_ReceiveB_4: (+1)
   \       0x44   0x....'....        BL       EMU_EnterEM1
   2339            }
   \                     ??UARTDRV_ReceiveB_3: (+1)
   \       0x48   0x7828             LDRB     R0,[R5, #+0]
   \       0x4A   0x2800             CMP      R0,#+0
   \       0x4C   0xD1FA             BNE.N    ??UARTDRV_ReceiveB_4
   2340            return queueBuffer->transferStatus;
   \       0x4E   0x9800             LDR      R0,[SP, #+0]
   \       0x50   0x6900             LDR      R0,[R0, #+16]
   \                     ??UARTDRV_ReceiveB_0: (+1)
   \       0x52   0xB006             ADD      SP,SP,#+24
   \       0x54   0xBD70             POP      {R4-R6,PC}       ;; return
   2341          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x4604             MOV      R4,R0
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4616             MOV      R6,R2
   \        0x6   0x....'....        B.W      CheckParams

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x9603             STR      R6,[SP, #+12]
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x....             LDR.N    R2,??DataTable22_26  ;; 0xf0007001
   \        0x6   0x9104             STR      R1,[SP, #+16]
   \        0x8   0x9205             STR      R2,[SP, #+20]
   \        0xA   0x4770             BX       LR
   2342          
   2343          /***************************************************************************//**
   2344           * @brief
   2345           *  Resume a paused transmit operation.
   2346           *
   2347           * @param[in] handle Pointer to a UART driver handle.
   2348           *
   2349           * @return
   2350           *  @ref ECODE_EMDRV_UARTDRV_OK on success. On failure, an appropriate
   2351           *  UARTDRV @ref Ecode_t is returned.
   2352           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2353          Ecode_t UARTDRV_ResumeTransmit(UARTDRV_Handle_t handle)
   2354          {
   \                     UARTDRV_ResumeTransmit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x0004             MOVS     R4,R0
   2355            if (handle == NULL) {
   \        0x4   0xD100             BNE.N    ??UARTDRV_ResumeTransmit_0
   2356              return ECODE_EMDRV_UARTDRV_ILLEGAL_HANDLE;
   \        0x6   0x....             B.N      ?Subroutine1
   2357            }
   2358          
   2359            if (handle->txDmaPaused > 0) {
   \                     ??UARTDRV_ResumeTransmit_0: (+1)
   \        0x8   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \        0xC   0xB188             CBZ.N    R0,??UARTDRV_ResumeTransmit_1
   2360              // Resume the transfer if 1) pause counter is 1
   2361              //                        2) HW flow control doesn't need to pause the DMA
   2362              if ( (handle->txDmaPaused == 1) && (HwFcGetClearToSendPin(handle) == uartdrvFlowControlOn) ) {
   \        0xE   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \       0x12   0x2801             CMP      R0,#+1
   \       0x14   0xD106             BNE.N    ??UARTDRV_ResumeTransmit_2
   \       0x16   0x4620             MOV      R0,R4
   \       0x18   0x....'....        BL       HwFcGetClearToSendPin
   \       0x1C   0xB910             CBNZ.N   R0,??UARTDRV_ResumeTransmit_2
   2363                DMADRV_ResumeTransfer(handle->txDmaCh);
   \       0x1E   0x68A0             LDR      R0,[R4, #+8]
   \       0x20   0x....'....        BL       DMADRV_ResumeTransfer
   2364              }
   2365              handle->txDmaPaused--;
   \                     ??UARTDRV_ResumeTransmit_2: (+1)
   \       0x24   0xF894 0x002E      LDRB     R0,[R4, #+46]
   \       0x28   0x1E41             SUBS     R1,R0,#+1
   \       0x2A   0xF884 0x102E      STRB     R1,[R4, #+46]
   2366            } else {
   2367              return ECODE_EMDRV_UARTDRV_ILLEGAL_OPERATION;
   2368            }
   2369            return ECODE_EMDRV_UARTDRV_OK;
   \       0x2E   0x2000             MOVS     R0,#+0
   \       0x30   0xBD10             POP      {R4,PC}
   \                     ??UARTDRV_ResumeTransmit_1: (+1)
   \       0x32   0x....             LDR.N    R0,??DataTable22_25  ;; 0xf0007005
   \       0x34   0xBD10             POP      {R4,PC}          ;; return
   2370          }
   2371          
   2372          /***************************************************************************//**
   2373           * @brief
   2374           *    Start a non-blocking transmit.
   2375           *
   2376           * @param[in] handle Pointer to a UART driver handle.
   2377           *
   2378           * @param[in] data A transmit data buffer.
   2379           *
   2380           * @param[in] count A number of bytes to transmit.
   2381           *
   2382           * @param[in]  callback A transfer completion callback.
   2383           *
   2384           * @return
   2385           *    @ref ECODE_EMDRV_UARTDRV_OK on success.
   2386           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2387          Ecode_t UARTDRV_Transmit(UARTDRV_Handle_t handle,
   2388                                   uint8_t *data,
   2389                                   UARTDRV_Count_t count,
   2390                                   UARTDRV_Callback_t callback)
   2391          {
   \                     UARTDRV_Transmit: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x....'....        BL       ?Subroutine10
   2392            Ecode_t retVal;
   2393            UARTDRV_Buffer_t inputBuffer;
   2394            UARTDRV_Buffer_t *queueBuffer;
   2395          
   2396            retVal = CheckParams(handle, data, count);
   2397            if (retVal != ECODE_EMDRV_UARTDRV_OK) {
   \                     ??CrossCallReturnLabel_14: (+1)
   \        0x8   0xB9E0             CBNZ.N   R0,??UARTDRV_Transmit_0
   2398              return retVal;
   2399            }
   2400            inputBuffer.data = data;
   \        0xA   0x9601             STR      R6,[SP, #+4]
   2401            inputBuffer.transferCount = count;
   \        0xC   0x9702             STR      R7,[SP, #+8]
   2402            inputBuffer.itemsRemaining = count;
   \        0xE   0x9703             STR      R7,[SP, #+12]
   2403            inputBuffer.callback = callback;
   \       0x10   0x9504             STR      R5,[SP, #+16]
   2404            inputBuffer.transferStatus = ECODE_EMDRV_UARTDRV_WAITING;
   2405          
   2406            retVal = EnqueueBuffer(handle->txQueue, &inputBuffer, &queueBuffer);
   \       0x12   0xF104 0x0528      ADD      R5,R4,#+40
   \       0x16   0x....             LDR.N    R1,??DataTable22_26  ;; 0xf0007001
   \       0x18   0x9105             STR      R1,[SP, #+20]
   \       0x1A   0x....'....        BL       ?Subroutine14
   2407            if (retVal != ECODE_EMDRV_UARTDRV_OK) {
   \                     ??CrossCallReturnLabel_23: (+1)
   \       0x1E   0xB988             CBNZ.N   R0,??UARTDRV_Transmit_0
   2408              return retVal;
   2409            }
   2410            if (!(handle->txDmaActive)) {
   \       0x20   0x7968             LDRB     R0,[R5, #+5]
   \       0x22   0xB970             CBNZ.N   R0,??UARTDRV_Transmit_1
   2411              CORE_ATOMIC_SECTION(
   2412                if (handle->txQueue->used > 0) {
   2413                StartTransmitDma(handle, queueBuffer);
   2414                handle->hasTransmitted = true;
   2415              }
   2416                )
   \       0x24   0x....'....        BL       CORE_EnterAtomic
   \       0x28   0x6829             LDR      R1,[R5, #+0]
   \       0x2A   0x4606             MOV      R6,R0
   \       0x2C   0x8888             LDRH     R0,[R1, #+4]
   \       0x2E   0xB128             CBZ.N    R0,??UARTDRV_Transmit_2
   \       0x30   0x9900             LDR      R1,[SP, #+0]
   \       0x32   0x4620             MOV      R0,R4
   \       0x34   0x....'....        BL       StartTransmitDma
   \       0x38   0x2001             MOVS     R0,#+1
   \       0x3A   0x7228             STRB     R0,[R5, #+8]
   \                     ??UARTDRV_Transmit_2: (+1)
   \       0x3C   0x4630             MOV      R0,R6
   \       0x3E   0x....'....        BL       CORE_ExitAtomic
   2417            } // else: started by TransmitDmaComplete
   2418          
   2419            return ECODE_EMDRV_UARTDRV_OK;
   \                     ??UARTDRV_Transmit_1: (+1)
   \       0x42   0x2000             MOVS     R0,#+0
   \                     ??UARTDRV_Transmit_0: (+1)
   \       0x44   0xB007             ADD      SP,SP,#+28
   \       0x46   0xBDF0             POP      {R4-R7,PC}       ;; return
   2420          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0x6828             LDR      R0,[R5, #+0]
   \        0x2   0x466A             MOV      R2,SP
   \        0x4   0xA901             ADD      R1,SP,#+4
   \        0x6   0x....'....        B.W      EnqueueBuffer
   2421          
   2422          /***************************************************************************//**
   2423           * @brief
   2424           *    Start a blocking transmit.
   2425           *
   2426           * @param[in] handle Pointer to a UART driver handle.
   2427           *
   2428           * @param[in] data A transmit data buffer.
   2429           *
   2430           * @param[in] count A number of bytes to transmit.
   2431           *
   2432           * @return
   2433           *    @ref ECODE_EMDRV_UARTDRV_OK on success.
   2434           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2435          Ecode_t UARTDRV_TransmitB(UARTDRV_Handle_t handle,
   2436                                    uint8_t *data,
   2437                                    UARTDRV_Count_t count)
   2438          {
   \                     UARTDRV_TransmitB: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
   \        0x4   0x....'....        BL       ?Subroutine11
   2439            Ecode_t retVal;
   2440            UARTDRV_Buffer_t outputBuffer;
   2441            UARTDRV_Buffer_t *queueBuffer;
   2442          
   2443            retVal = CheckParams(handle, data, count);
   2444            if (retVal != ECODE_EMDRV_UARTDRV_OK) {
   \                     ??CrossCallReturnLabel_16: (+1)
   \        0x8   0xB9E8             CBNZ.N   R0,??UARTDRV_TransmitB_0
   2445              return retVal;
   2446            }
   2447            outputBuffer.data = data;
   \        0xA   0x9501             STR      R5,[SP, #+4]
   2448            outputBuffer.transferCount = count;
   \        0xC   0x9602             STR      R6,[SP, #+8]
   2449            outputBuffer.itemsRemaining = count;
   2450            outputBuffer.callback = NULL;
   2451            outputBuffer.transferStatus = ECODE_EMDRV_UARTDRV_WAITING;
   2452          
   2453            retVal = EnqueueBuffer(handle->txQueue, &outputBuffer, &queueBuffer);
   \        0xE   0xF104 0x0528      ADD      R5,R4,#+40
   \       0x12   0x....'....        BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x16   0x....'....        BL       ?Subroutine14
   2454            if (retVal != ECODE_EMDRV_UARTDRV_OK) {
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0x1A   0xB110             CBZ.N    R0,??UARTDRV_TransmitB_1
   2455              return retVal;
   \       0x1C   0xE013             B.N      ??UARTDRV_TransmitB_0
   2456            }
   2457            while (handle->txQueue->used > 1) {
   2458              EMU_EnterEM1();
   \                     ??UARTDRV_TransmitB_2: (+1)
   \       0x1E   0x....'....        BL       EMU_EnterEM1
   2459            }
   \                     ??UARTDRV_TransmitB_1: (+1)
   \       0x22   0x6828             LDR      R0,[R5, #+0]
   \       0x24   0x8881             LDRH     R1,[R0, #+4]
   \       0x26   0x2902             CMP      R1,#+2
   \       0x28   0xDAF9             BGE.N    ??UARTDRV_TransmitB_2
   2460            StartTransmitDma(handle, queueBuffer);
   \       0x2A   0x9900             LDR      R1,[SP, #+0]
   \       0x2C   0x4620             MOV      R0,R4
   \       0x2E   0x....'....        BL       StartTransmitDma
   2461            handle->hasTransmitted = true;
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0x7228             STRB     R0,[R5, #+8]
   \       0x36   0xE001             B.N      ??UARTDRV_TransmitB_3
   2462            while (handle->txDmaActive) {
   2463              EMU_EnterEM1();
   \                     ??UARTDRV_TransmitB_4: (+1)
   \       0x38   0x....'....        BL       EMU_EnterEM1
   2464            }
   \                     ??UARTDRV_TransmitB_3: (+1)
   \       0x3C   0x7968             LDRB     R0,[R5, #+5]
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xD1FA             BNE.N    ??UARTDRV_TransmitB_4
   2465            return queueBuffer->transferStatus;
   \       0x42   0x9800             LDR      R0,[SP, #+0]
   \       0x44   0x6900             LDR      R0,[R0, #+16]
   \                     ??UARTDRV_TransmitB_0: (+1)
   \       0x46   0xB006             ADD      SP,SP,#+24
   \       0x48   0xBD70             POP      {R4-R6,PC}       ;; return
   2466          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \        0x0   0x4003'D000        DC32     0x4003d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0x4003'E000        DC32     0x4003e000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \        0x0   0xE000'ED10        DC32     0xe000ed10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \        0x0   0x4003'C000        DC32     0x4003c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \        0x0   0x....'....        DC32     uartdrvHandle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \        0x0   0xF000'700A        DC32     0xf000700a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_5:
   \        0x0   0xF000'700B        DC32     0xf000700b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_6:
   \        0x0   0x4003'D5AC        DC32     0x4003d5ac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_7:
   \        0x0   0x4003'E5AC        DC32     0x4003e5ac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_8:
   \        0x0   0xF000'700D        DC32     0xf000700d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_9:
   \        0x0   0xF000'700C        DC32     0xf000700c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_10:
   \        0x0   0xF000'7002        DC32     0xf0007002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_11:
   \        0x0   0xF000'7003        DC32     0xf0007003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_12:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_13:
   \        0x0   0x....'....        DC32     uartdrvHandleIsInitialized

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_14:
   \        0x0   0x4005'C000        DC32     0x4005c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_15:
   \        0x0   0x0005'0002        DC32     0x50002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_16:
   \        0x0   0x4006'0000        DC32     0x40060000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_17:
   \        0x0   0x0006'0002        DC32     0x60002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_18:
   \        0x0   0x....'....        DC32     HwFcManageClearToSend

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_19:
   \        0x0   0xF000'700E        DC32     0xf000700e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_20:
   \        0x0   0x4005'8000        DC32     0x40058000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_21:
   \        0x0   0x0004'0002        DC32     0x40002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_22:
   \        0x0   0x4003'C5AC        DC32     0x4003c5ac

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_23:
   \        0x0   0xF000'7009        DC32     0xf0007009

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_24:
   \        0x0   0xF000'7008        DC32     0xf0007008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_25:
   \        0x0   0xF000'7005        DC32     0xf0007005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_26:
   \        0x0   0xF000'7001        DC32     0xf0007001

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x05 0x00          DC8 5, 0, 0, 0
   \              0x00 0x00    
   \        0x4   0x0000'0000        DC32 0, 115200
   \              0x0001'C200  
   \        0xC   0x00 0x05          DC8 0, 5
   \        0xE   0x0000 0x1000      DC16 0, 4096
   \       0x12   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   2467          
   2468          /* *INDENT-OFF* */
   2469          /******** THE REST OF THE FILE IS DOCUMENTATION ONLY !**********************//**
   2470           * @addtogroup emdrv
   2471           * @{
   2472           * @addtogroup UARTDRV
   2473           * @brief UARTDRV Universal Asynchronous Receiver/Transmitter Driver
   2474           * @{
   2475          
   2476          @details
   2477            The source files for the UART driver library, uartdrv.c and uartdrv.h, are in the
   2478            emdrv/uartdrv folder.
   2479          
   2480            @li @ref uartdrv_intro
   2481            @li @ref uartdrv_conf
   2482            @li @ref uartdrv_api
   2483            @li @ref uartdrv_fc
   2484            @li @ref uartdrv_example
   2485          
   2486          @n @section uartdrv_intro Introduction
   2487            The UART driver supports the UART capabilities of the USART, UART, and LEUART
   2488            peripherals. The driver is fully reentrant and supports multiple driver instances.
   2489            The driver does not buffer or queue data. However, it queues UART transmit
   2490            and receive operations. Both blocking and non-blocking transfer functions are
   2491            available. Non-blocking transfer functions report transfer completion with
   2492            callback functions. Transfers are done using DMA. Simple direct/forced
   2493            transmit and receive functions are also available. Note that these functions
   2494            are blocking and not suitable for low energy applications because they use CPU
   2495            polling.
   2496          
   2497            UART hardware flow control (CTS/RTS) is fully supported by the driver. UART
   2498            software flow control (XON/XOFF) is partially supported by the driver. For
   2499            more information about flow control support, see @ref uartdrv_fc.
   2500          
   2501            @note Transfer completion callback functions are called from within the DMA
   2502            interrupt handler with interrupts disabled.
   2503          
   2504          @n @section uartdrv_conf Configuration Options
   2505          
   2506            Some properties of the UARTDRV driver are compile-time configurable. These
   2507            properties are set in a @ref uartdrv_config.h file. A template for this
   2508            file, containing default values, is in the emdrv/config folder.
   2509            To configure UARTDRV for your application, provide a custom configuration file,
   2510            or override the defines on the compiler command line.
   2511            These are the available configuration parameters with default values defined.
   2512            @code
   2513          
   2514            // Size of the receive operation queue.
   2515            #define EMDRV_UARTDRV_MAX_CONCURRENT_RX_BUFS    6
   2516          
   2517            // Size of the transmit operation queue.
   2518            #define EMDRV_UARTDRV_MAX_CONCURRENT_TX_BUFS    6
   2519          
   2520            // Set to 1 to enable hardware flow control.
   2521            #define EMDRV_UARTDRV_FLOW_CONTROL_ENABLE       1
   2522          
   2523            // Maximum number of driver instances.
   2524            // This maximum applies only when EMDRV_UARTDRV_FLOW_CONTROL_ENABLE = 1.
   2525            #define EMDRV_UARTDRV_MAX_DRIVER_INSTANCES      4
   2526          
   2527            // UART software flow control code: request peer to start Tx.
   2528            #define UARTDRV_FC_SW_XON                       0x11
   2529          
   2530            // UART software flow control code: request peer to stop Tx.
   2531            #define UARTDRV_FC_SW_XOFF                      0x13
   2532            @endcode
   2533          
   2534            The properties of each UART driver instance are set at run-time via the
   2535            @ref UARTDRV_InitUart_t data structure input parameter to the @ref UARTDRV_InitUart()
   2536            function for UART and USART peripherals, and the @ref UARTDRV_InitLeuart_t
   2537            data structure input parameter to the @ref UARTDRV_InitLeuart() function for
   2538            LEUART peripherals.
   2539          
   2540          @n @section uartdrv_api The API
   2541          
   2542            This section contains brief descriptions of the functions in the API. For more
   2543            information on input and output parameters and return values,
   2544            click on the hyperlinked function names. Most functions return an error
   2545            code, @ref ECODE_EMDRV_UARTDRV_OK is returned on success,
   2546            see @ref ecode.h and @ref uartdrv.h for other error codes.
   2547          
   2548            The application code must include @em uartdrv.h header file.
   2549          
   2550            @ref UARTDRV_InitUart(), @ref UARTDRV_InitLeuart() and @ref UARTDRV_DeInit() @n
   2551              These functions initialize and deinitialize the UARTDRV driver. Typically,
   2552              @htmlonly UARTDRV_InitUart() @endhtmlonly (for UART/USART) or
   2553              @htmlonly UARTDRV_InitLeuart() @endhtmlonly (for LEUART) are called once in
   2554              the startup code.
   2555          
   2556            @ref UARTDRV_GetReceiveStatus() and @ref UARTDRV_GetTransmitStatus() @n
   2557              Query the status of a current transmit or receive operations. Reports number
   2558              of items (frames) transmitted and remaining.
   2559          
   2560            @ref UARTDRV_GetReceiveDepth() and  @ref UARTDRV_GetTransmitDepth() @n
   2561              Get the number of queued receive or transmit operations.
   2562          
   2563            @ref UARTDRV_Transmit(), UARTDRV_Receive() @n
   2564            UARTDRV_TransmitB(), UARTDRV_ReceiveB() @n
   2565            UARTDRV_ForceTransmit() and UARTDRV_ForceReceive() @n
   2566              Blocking and non-blocking transfer functions are included.
   2567              The blocking versions have an uppercase B (for Blocking) at the end of
   2568              their function name. Blocking functions do not return before the transfer
   2569              is complete. The non-blocking functions signal a transfer completion with a
   2570              callback function. @ref UARTDRV_ForceTransmit() and
   2571              @ref UARTDRV_ForceReceive() are also blocking. These two functions access
   2572              the UART peripheral directly without using DMA or interrupts.
   2573              @ref UARTDRV_ForceTransmit() does not respect flow control.
   2574              @ref UARTDRV_ForceReceive() forces RTS low.
   2575          
   2576            @ref UARTDRV_Abort() @n
   2577              Abort current transmit or receive operations and remove all queued
   2578              operations.
   2579          
   2580            @ref UARTDRV_FlowControlSet(), @ref UARTDRV_FlowControlGetSelfStatus(), @ref UARTDRV_FlowControlSetPeerStatus() and @ref UARTDRV_FlowControlGetPeerStatus() @n
   2581              Set and get flow control status of self or peer device. Note that the return
   2582              value from these two functions depends on the flow control mode set by
   2583              @ref UARTDRV_FlowControlSet(), @ref UARTDRV_InitUart(), or
   2584              @ref UARTDRV_InitLeuart().
   2585          
   2586            @ref UARTDRV_FlowControlIgnoreRestrain() @n
   2587              Enables transmission when restrained by flow control.
   2588          
   2589            @ref UARTDRV_PauseTransmit() and @ref UARTDRV_ResumeTransmit() @n
   2590              Pause a currently active transmit operation by preventing the DMA from loading
   2591              the UART FIFO. Will not override HW flow control state (if applicable), but
   2592              can be used in conjunction.
   2593          
   2594          @n @section uartdrv_fc Flow Control Support
   2595          
   2596            If UART flow control is not required, make sure that
   2597            @ref EMDRV_UARTDRV_FLOW_CONTROL_ENABLE is set to 0. This reduces the code size
   2598            and complexity of the driver.
   2599          
   2600            Both hardware and software flow control are supported. To
   2601            enable either of these, set @ref EMDRV_UARTDRV_FLOW_CONTROL_ENABLE to 1 in
   2602            @ref uartdrv_config.h.
   2603          
   2604          @n @subsection uartdrv_fc_hw Hardware Flow Control
   2605          
   2606            UART hardware flow control uses two additional pins for flow control
   2607            handshaking, the clear-to-send (CTS) and ready-to-send (RTS) pins.
   2608            RTS is an output and CTS is an input. These are active-low signals.
   2609            When CTS is high, the UART transmitter should stop sending frames.
   2610            A receiver should set RTS high when it is no longer capable of
   2611            receiving data.
   2612          
   2613            @par Peripheral Hardware Flow Control
   2614          
   2615            Newer devices, such as EFR32MG1 and EFM32PG1, natively support CTS/RTS in
   2616            the USART peripheral hardware. To enable hardware flow control, perform the
   2617            following steps:
   2618          
   2619            - Set EMDRV_UARTDRV_FLOW_CONTROL_ENABLE to 1.
   2620            - In the @ref UARTDRV_InitUart_t struct passed to @ref UARTDRV_InitUart(), set
   2621              @ref UARTDRV_InitUart_t.fcType = uartdrvFlowControlHwUart.
   2622            - Define the pins for CTS and RTS by setting ctsPort, ctsPin, rtsPort
   2623              and rtsPin in the init struct.
   2624            - Also define the CTS and RTS locations by setting portLocationCts and
   2625              portLocationRts in the init struct.
   2626          
   2627            @par GPIO Hardware Flow Control
   2628          
   2629            To support hardware flow control on devices that don't have UART CTS/RTS
   2630            hardware support, the driver includes the GPIOINT driver to emulate a
   2631            hardware implementation of UART CTS/RTS flow control on these devices.
   2632          
   2633            To enable hardware flow control, perform the following steps:
   2634          
   2635            - Set @ref EMDRV_UARTDRV_FLOW_CONTROL_ENABLE to 1.
   2636            - UART/USART: In the @ref UARTDRV_InitUart_t struct passed to
   2637              @ref UARTDRV_InitUart(), set
   2638              @ref UARTDRV_InitUart_t.fcType = uartdrvFlowControlHw.
   2639            - LEUART: In the @ref UARTDRV_InitLeuart_t struct passed to
   2640              @ref UARTDRV_InitLeuart(), set
   2641              @ref UARTDRV_InitLeuart_t.fcType = uartdrvFlowControlHw.
   2642            - Define the pins for CTS and RTS by setting ctsPort, ctsPin, rtsPort and
   2643              rtsPin in the same init struct.
   2644          
   2645            @note Because of the limitations in GPIO interrupt hardware, you cannot select
   2646            CTS pins in multiple driver instances with the same pin number. For example, pin A0 and
   2647            B0 cannot serve as CTS pins in two concurrent driver instances.
   2648          
   2649            RTS is set high whenever there are no Rx operations queued. The UART
   2650            transmitter is halted when the CTS pin goes high. The transmitter completes
   2651            the current frame before halting. DMA transfers are also halted.
   2652          
   2653          @n @subsection uartdrv_fc_sw Software Flow Control
   2654          
   2655            UART software flow control uses in-band signaling, meaning the receiver sends
   2656            special flow control characters to the transmitter and thereby removes
   2657            the need for dedicated wires for flow control. The two symbols
   2658            UARTDRV_FC_SW_XON and UARTDRV_FC_SW_XOFF are defined in @ref uartdrv_config.h.
   2659          
   2660            To enable support for software flow control, perform the following steps:
   2661          
   2662            - Set @ref EMDRV_UARTDRV_FLOW_CONTROL_ENABLE to 1.
   2663            - UART/USART: In the @ref UARTDRV_InitUart_t structure passed to
   2664              @ref UARTDRV_InitUart(), set
   2665              @ref UARTDRV_InitUart_t.fcType = uartdrvFlowControlSw.
   2666            - LEUART: In the @ref UARTDRV_InitLeuart_t structure passed to
   2667              @ref UARTDRV_InitLeuart(), set
   2668              @ref UARTDRV_InitLeuart_t.fcType = uartdrvFlowControlSw.
   2669          
   2670            @note Software flow control is partial only.
   2671          
   2672            The application must monitor buffers and make decisions on when to send XON/
   2673            XOFF. XON/XOFF can be sent to the peer using @ref UARTDRV_FlowControlSet().
   2674            Though @ref UARTDRV_FlowControlSet() will pause the active transmit operation
   2675            to send a flow control character, there is no way to guarantee the order.
   2676            If the application implements a specific packet format where the flow control
   2677            codes may appear only in fixed positions, the application should not
   2678            use @ref UARTDRV_FlowControlSet() but implement read and write of XON/XOFF
   2679            into packet buffers. If the application code fully implements all the flow
   2680            control logic, @ref EMDRV_UARTDRV_FLOW_CONTROL_ENABLE should be set to 0
   2681            to reduce code space.
   2682          
   2683          @n @section uartdrv_example Example
   2684            @if DOXYDOC_P1_DEVICE
   2685              @if DOXYDOC_EFM32G
   2686              @include uartdrv_example_p1_nomvdis.c
   2687              @endif
   2688              @if DOXYDOC_EZR32HG
   2689              @include uartdrv_example_p1_usart0.c
   2690              @endif
   2691              @ifnot (DOXYDOC_EFM32G || DOXYDOC_EZR32HG)
   2692              @include uartdrv_example_p1.c
   2693              @endif
   2694            @endif
   2695            @if DOXYDOC_P2_DEVICE
   2696            @include uartdrv_example_p2.c
   2697            @endif
   2698            @if DOXYDOC_S2_DEVICE
   2699            @include uartdrv_example_s2.c
   2700            @endif
   2701          
   2702           * @} end group UARTDRV *******************************************************
   2703           * @} end group emdrv *********************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CheckParams
      16   ConfigGpio
        16   -> GPIO_IntConfig
        16   -> GPIO_PinModeSet
      16   DequeueBuffer
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
       0   DisableReceiver
       0   EMU_EnterEM1
       0   EnableReceiver
      24   EnqueueBuffer
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> __aeabi_memcpy
      16   FcApplyState
        16   -> GPIO_PinOutClear
        16   -> GPIO_PinOutSet
        16   -> UARTDRV_ForceTransmit
        16   -> UARTDRV_PauseTransmit
        16   -> UARTDRV_ResumeTransmit
      16   GPIO_IntConfig
        16   -> GPIO_ExtIntConfig
       8   GPIO_PinOutClear
       8   GPIO_PinOutSet
      16   GetTailBuffer
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
       0   HwFcGetClearToSendPin
      16   HwFcManageClearToSend
        16   -> DMADRV_PauseTransfer
        16   -> DMADRV_ResumeTransfer
        16   -> DMADRV_TransferActive
        16   -> HwFcGetClearToSendPin
      24   ReceiveDmaComplete
        24   -- Indirect call
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> DequeueBuffer
        24   -> DisableReceiver
        24   -> FcApplyState
        24   -> GetTailBuffer
        24   -> StartReceiveDma
      32   StartReceiveDma
        32   -> DMADRV_PeripheralMemory
      32   StartTransmitDma
        32   -> DMADRV_MemoryPeripheral
      24   TransmitDmaComplete
        24   -- Indirect call
        24   -> CORE_EnterAtomic
        24   -> CORE_ExitAtomic
        24   -> DequeueBuffer
        24   -> GetTailBuffer
        24   -> StartTransmitDma
      40   UARTDRV_Abort
        40   -- Indirect call
        40   -> CORE_EnterAtomic
        40   -> CORE_ExitAtomic
        40   -> DMADRV_StopTransfer
        40   -> DMADRV_TransferRemainingCount
        40   -> DequeueBuffer
        40   -> DisableReceiver
        40   -> GetTailBuffer
      16   UARTDRV_DeInit
        16   -> ConfigGpio
        16   -> DMADRV_DeInit
        16   -> DMADRV_FreeChannel
        16   -> GPIOINT_CallbackRegister
        16   -> UARTDRV_Abort
        16   -> UARTDRV_FlowControlSet
       0   UARTDRV_FlowControlGetPeerStatus
       0   UARTDRV_FlowControlGetSelfStatus
       0   UARTDRV_FlowControlIgnoreRestrain
       0   UARTDRV_FlowControlSet
         0   -> FcApplyState
       8   UARTDRV_FlowControlSetPeerStatus
         8   -> UARTDRV_PauseTransmit
         8   -> UARTDRV_ResumeTransmit
      24   UARTDRV_ForceReceive
        24   -> CheckParams
        24   -> DisableReceiver
        24   -> EnableReceiver
      24   UARTDRV_ForceTransmit
        24   -> CORE_IrqIsBlocked
        24   -> CheckParams
        24   -> LDMA_IRQHandler
        24   -> USART_Tx
       0   UARTDRV_GetPeripheralStatus
       0   UARTDRV_GetReceiveDepth
      32   UARTDRV_GetReceiveStatus
        32   -> DMADRV_TransferRemainingCount
        32   -> GetTailBuffer
       0   UARTDRV_GetTransmitDepth
      32   UARTDRV_GetTransmitStatus
        32   -> DMADRV_TransferRemainingCount
        32   -> GetTailBuffer
      56   UARTDRV_InitUart
        56   -> CORE_EnterAtomic
        56   -> CORE_ExitAtomic
        56   -> ConfigGpio
        56   -> DMADRV_AllocateChannel
        56   -> DMADRV_Init
        56   -> FcApplyState
        56   -> GPIOINT_CallbackRegister
        56   -> GPIOINT_Init
        56   -> USART_Enable
        56   -> USART_InitAsync
        56   -> __aeabi_memclr4
        56   -> __aeabi_memcpy4
       8   UARTDRV_PauseTransmit
         8   -> DMADRV_PauseTransfer
         8   -> HwFcGetClearToSendPin
      48   UARTDRV_Receive
        48   -> CheckParams
        48   -> EnableReceiver
        48   -> EnqueueBuffer
        48   -> FcApplyState
        48   -> StartReceiveDma
      40   UARTDRV_ReceiveB
        40   -> CheckParams
        40   -> EMU_EnterEM1
        40   -> EnableReceiver
        40   -> EnqueueBuffer
        40   -> FcApplyState
        40   -> StartReceiveDma
       8   UARTDRV_ResumeTransmit
         8   -> DMADRV_ResumeTransfer
         8   -> HwFcGetClearToSendPin
      48   UARTDRV_Transmit
        48   -> CORE_EnterAtomic
        48   -> CORE_ExitAtomic
        48   -> CheckParams
        48   -> EnqueueBuffer
        48   -> StartTransmitDma
      40   UARTDRV_TransmitB
        40   -> CheckParams
        40   -> EMU_EnterEM1
        40   -> EnqueueBuffer
        40   -> StartTransmitDma


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable21
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_10
       4  ??DataTable22_11
       4  ??DataTable22_12
       4  ??DataTable22_13
       4  ??DataTable22_14
       4  ??DataTable22_15
       4  ??DataTable22_16
       4  ??DataTable22_17
       4  ??DataTable22_18
       4  ??DataTable22_19
       4  ??DataTable22_2
       4  ??DataTable22_20
       4  ??DataTable22_21
       4  ??DataTable22_22
       4  ??DataTable22_23
       4  ??DataTable22_24
       4  ??DataTable22_25
       4  ??DataTable22_26
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
      10  ?Subroutine0
       4  ?Subroutine1
      12  ?Subroutine10
      10  ?Subroutine11
      12  ?Subroutine12
      16  ?Subroutine13
      10  ?Subroutine14
      12  ?Subroutine15
      10  ?Subroutine16
      12  ?Subroutine17
      12  ?Subroutine18
      18  ?Subroutine19
       6  ?Subroutine2
      10  ?Subroutine20
      10  ?Subroutine3
       8  ?Subroutine4
      12  ?Subroutine5
      12  ?Subroutine6
       4  ?Subroutine7
      10  ?Subroutine8
      12  ?Subroutine9
      28  ?_0
      34  CheckParams
     154  ConfigGpio
      58  DequeueBuffer
      20  DisableReceiver
      16  EMU_EnterEM1
      28  EnableReceiver
     106  EnqueueBuffer
      94  FcApplyState
      18  GPIO_IntConfig
      14  GPIO_PinOutClear
      12  GPIO_PinOutSet
      34  GetTailBuffer
      38  HwFcGetClearToSendPin
     118  HwFcManageClearToSend
     192  ReceiveDmaComplete
      50  StartReceiveDma
      48  StartTransmitDma
      90  TransmitDmaComplete
     264  UARTDRV_Abort
     102  UARTDRV_DeInit
       4  UARTDRV_FlowControlGetPeerStatus
       4  UARTDRV_FlowControlGetSelfStatus
      10  UARTDRV_FlowControlIgnoreRestrain
      26  UARTDRV_FlowControlSet
      52  UARTDRV_FlowControlSetPeerStatus
      78  UARTDRV_ForceReceive
     142  UARTDRV_ForceTransmit
       6  UARTDRV_GetPeripheralStatus
       4  UARTDRV_GetReceiveDepth
      54  UARTDRV_GetReceiveStatus
       2  UARTDRV_GetTransmitDepth
      52  UARTDRV_GetTransmitStatus
     556  UARTDRV_InitUart
      42  UARTDRV_PauseTransmit
      66  UARTDRV_Receive
      86  UARTDRV_ReceiveB
      54  UARTDRV_ResumeTransmit
      72  UARTDRV_Transmit
      74  UARTDRV_TransmitB
      16  uartdrvHandle
       1  uartdrvHandleIsInitialized

 
    17 bytes in section .bss
    28 bytes in section .rodata
 3 208 bytes in section .text
 
 3 208 bytes of CODE  memory
    28 bytes of CONST memory
    17 bytes of DATA  memory

Errors: none
Warnings: none
