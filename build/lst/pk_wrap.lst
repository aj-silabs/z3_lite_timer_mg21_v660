###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:19:32
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\pk_wrap.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EWF236.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\pk_wrap.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"pk_wrap.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0
#        -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\pk_wrap.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\pk_wrap.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\pk_wrap.c
      1          /***************************************************************************//**
      2           * # License
      3           *
      4           * The licensor of this software is Silicon Laboratories Inc. Your use of this
      5           * software is governed by the terms of Silicon Labs Master Software License
      6           * Agreement (MSLA) available at
      7           * www.silabs.com/about-us/legal/master-software-license-agreement. This
      8           * software is Third Party Software licensed by Silicon Labs from a third party
      9           * and is governed by the sections of the MSLA applicable to Third Party
     10           * Software and the additional terms set forth below.
     11           *
     12           ******************************************************************************/
     13          /*
     14           *  Public Key abstraction layer: wrapper functions
     15           *
     16           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
     17           *  SPDX-License-Identifier: Apache-2.0
     18           *
     19           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
     20           *  not use this file except in compliance with the License.
     21           *  You may obtain a copy of the License at
     22           *
     23           *  http://www.apache.org/licenses/LICENSE-2.0
     24           *
     25           *  Unless required by applicable law or agreed to in writing, software
     26           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     27           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     28           *  See the License for the specific language governing permissions and
     29           *  limitations under the License.
     30           *
     31           *  This file is part of mbed TLS (https://tls.mbed.org)
     32           */
     33          
     34          #if !defined(MBEDTLS_CONFIG_FILE)
     35          #include "mbedtls/config.h"
     36          #else
     37          #include MBEDTLS_CONFIG_FILE
     38          #endif
     39          
     40          #if defined(MBEDTLS_PK_C)
     41          #include "mbedtls/pk_internal.h"
     42          
     43          /* Even if RSA not activated, for the sake of RSA-alt */
     44          #include "mbedtls/rsa.h"
     45          
     46          #include <string.h>
     47          
     48          #if defined(MBEDTLS_ECP_C)
     49          #include "mbedtls/ecp.h"
     50          #endif
     51          
     52          #if defined(MBEDTLS_ECDSA_C)
     53          #include "mbedtls/ecdsa.h"
     54          #endif
     55          
     56          #if defined(MBEDTLS_PLATFORM_C)
     57          #include "mbedtls/platform.h"
     58          #else
     59          #include <stdlib.h>
     60          #define mbedtls_calloc    calloc
     61          #define mbedtls_free       free
     62          #endif
     63          
     64          #include <limits.h>
     65          #include <stdint.h>
     66          
     67          #if defined(MBEDTLS_PK_RSA_ALT_SUPPORT)
     68          /* Implementation that should never be optimized out by the compiler */
     69          static void mbedtls_zeroize( void *v, size_t n ) {
     70              volatile unsigned char *p = v; while( n-- ) *p++ = 0;
     71          }
     72          #endif
     73          
     74          #if defined(MBEDTLS_RSA_C)
     75          static int rsa_can_do( mbedtls_pk_type_t type )
     76          {
     77              return( type == MBEDTLS_PK_RSA ||
     78                      type == MBEDTLS_PK_RSASSA_PSS );
     79          }
     80          
     81          static size_t rsa_get_bitlen( const void *ctx )
     82          {
     83              const mbedtls_rsa_context * rsa = (const mbedtls_rsa_context *) ctx;
     84              return( 8 * mbedtls_rsa_get_len( rsa ) );
     85          }
     86          
     87          static int rsa_verify_wrap( void *ctx, mbedtls_md_type_t md_alg,
     88                             const unsigned char *hash, size_t hash_len,
     89                             const unsigned char *sig, size_t sig_len )
     90          {
     91              int ret;
     92              mbedtls_rsa_context * rsa = (mbedtls_rsa_context *) ctx;
     93              size_t rsa_len = mbedtls_rsa_get_len( rsa );
     94          
     95          #if SIZE_MAX > UINT_MAX
     96              if( md_alg == MBEDTLS_MD_NONE && UINT_MAX < hash_len )
     97                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
     98          #endif /* SIZE_MAX > UINT_MAX */
     99          
    100              if( sig_len < rsa_len )
    101                  return( MBEDTLS_ERR_RSA_VERIFY_FAILED );
    102          
    103              if( ( ret = mbedtls_rsa_pkcs1_verify( rsa, NULL, NULL,
    104                                            MBEDTLS_RSA_PUBLIC, md_alg,
    105                                            (unsigned int) hash_len, hash, sig ) ) != 0 )
    106                  return( ret );
    107          
    108              /* The buffer contains a valid signature followed by extra data.
    109               * We have a special error code for that so that so that callers can
    110               * use mbedtls_pk_verify() to check "Does the buffer start with a
    111               * valid signature?" and not just "Does the buffer contain a valid
    112               * signature?". */
    113              if( sig_len > rsa_len )
    114                  return( MBEDTLS_ERR_PK_SIG_LEN_MISMATCH );
    115          
    116              return( 0 );
    117          }
    118          
    119          static int rsa_sign_wrap( void *ctx, mbedtls_md_type_t md_alg,
    120                             const unsigned char *hash, size_t hash_len,
    121                             unsigned char *sig, size_t *sig_len,
    122                             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    123          {
    124              mbedtls_rsa_context * rsa = (mbedtls_rsa_context *) ctx;
    125          
    126          #if SIZE_MAX > UINT_MAX
    127              if( md_alg == MBEDTLS_MD_NONE && UINT_MAX < hash_len )
    128                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
    129          #endif /* SIZE_MAX > UINT_MAX */
    130          
    131              *sig_len = mbedtls_rsa_get_len( rsa );
    132          
    133              return( mbedtls_rsa_pkcs1_sign( rsa, f_rng, p_rng, MBEDTLS_RSA_PRIVATE,
    134                          md_alg, (unsigned int) hash_len, hash, sig ) );
    135          }
    136          
    137          static int rsa_decrypt_wrap( void *ctx,
    138                              const unsigned char *input, size_t ilen,
    139                              unsigned char *output, size_t *olen, size_t osize,
    140                              int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    141          {
    142              mbedtls_rsa_context * rsa = (mbedtls_rsa_context *) ctx;
    143          
    144              if( ilen != mbedtls_rsa_get_len( rsa ) )
    145                  return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
    146          
    147              return( mbedtls_rsa_pkcs1_decrypt( rsa, f_rng, p_rng,
    148                          MBEDTLS_RSA_PRIVATE, olen, input, output, osize ) );
    149          }
    150          
    151          static int rsa_encrypt_wrap( void *ctx,
    152                              const unsigned char *input, size_t ilen,
    153                              unsigned char *output, size_t *olen, size_t osize,
    154                              int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    155          {
    156              mbedtls_rsa_context * rsa = (mbedtls_rsa_context *) ctx;
    157              *olen = mbedtls_rsa_get_len( rsa );
    158          
    159              if( *olen > osize )
    160                  return( MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE );
    161          
    162              return( mbedtls_rsa_pkcs1_encrypt( rsa, f_rng, p_rng, MBEDTLS_RSA_PUBLIC,
    163                                                 ilen, input, output ) );
    164          }
    165          
    166          static int rsa_check_pair_wrap( const void *pub, const void *prv )
    167          {
    168              return( mbedtls_rsa_check_pub_priv( (const mbedtls_rsa_context *) pub,
    169                                          (const mbedtls_rsa_context *) prv ) );
    170          }
    171          
    172          static void *rsa_alloc_wrap( void )
    173          {
    174              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_rsa_context ) );
    175          
    176              if( ctx != NULL )
    177                  mbedtls_rsa_init( (mbedtls_rsa_context *) ctx, 0, 0 );
    178          
    179              return( ctx );
    180          }
    181          
    182          static void rsa_free_wrap( void *ctx )
    183          {
    184              mbedtls_rsa_free( (mbedtls_rsa_context *) ctx );
    185              mbedtls_free( ctx );
    186          }
    187          
    188          static void rsa_debug( const void *ctx, mbedtls_pk_debug_item *items )
    189          {
    190              items->type = MBEDTLS_PK_DEBUG_MPI;
    191              items->name = "rsa.N";
    192              items->value = &( ((mbedtls_rsa_context *) ctx)->N );
    193          
    194              items++;
    195          
    196              items->type = MBEDTLS_PK_DEBUG_MPI;
    197              items->name = "rsa.E";
    198              items->value = &( ((mbedtls_rsa_context *) ctx)->E );
    199          }
    200          
    201          const mbedtls_pk_info_t mbedtls_rsa_info = {
    202              MBEDTLS_PK_RSA,
    203              "RSA",
    204              rsa_get_bitlen,
    205              rsa_can_do,
    206              rsa_verify_wrap,
    207              rsa_sign_wrap,
    208              rsa_decrypt_wrap,
    209              rsa_encrypt_wrap,
    210              rsa_check_pair_wrap,
    211              rsa_alloc_wrap,
    212              rsa_free_wrap,
    213              rsa_debug,
    214          };
    215          #endif /* MBEDTLS_RSA_C */
    216          
    217          #if defined(MBEDTLS_ECP_C)
    218          /*
    219           * Generic EC key
    220           */
    221          static int eckey_can_do( mbedtls_pk_type_t type )
    222          {
    223              return( type == MBEDTLS_PK_ECKEY ||
    224                      type == MBEDTLS_PK_ECKEY_DH ||
    225                      type == MBEDTLS_PK_ECDSA );
    226          }
    227          
    228          static size_t eckey_get_bitlen( const void *ctx )
    229          {
    230              return( ((mbedtls_ecp_keypair *) ctx)->grp.pbits );
    231          }
    232          
    233          #if defined(MBEDTLS_ECDSA_C)
    234          /* Forward declarations */
    235          static int ecdsa_verify_wrap( void *ctx, mbedtls_md_type_t md_alg,
    236                                 const unsigned char *hash, size_t hash_len,
    237                                 const unsigned char *sig, size_t sig_len );
    238          
    239          static int ecdsa_sign_wrap( void *ctx, mbedtls_md_type_t md_alg,
    240                             const unsigned char *hash, size_t hash_len,
    241                             unsigned char *sig, size_t *sig_len,
    242                             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng );
    243          
    244          static int eckey_verify_wrap( void *ctx, mbedtls_md_type_t md_alg,
    245                                 const unsigned char *hash, size_t hash_len,
    246                                 const unsigned char *sig, size_t sig_len )
    247          {
    248              int ret;
    249              mbedtls_ecdsa_context ecdsa;
    250          
    251              mbedtls_ecdsa_init( &ecdsa );
    252          
    253              if( ( ret = mbedtls_ecdsa_from_keypair( &ecdsa, ctx ) ) == 0 )
    254                  ret = ecdsa_verify_wrap( &ecdsa, md_alg, hash, hash_len, sig, sig_len );
    255          
    256              mbedtls_ecdsa_free( &ecdsa );
    257          
    258              return( ret );
    259          }
    260          
    261          static int eckey_sign_wrap( void *ctx, mbedtls_md_type_t md_alg,
    262                             const unsigned char *hash, size_t hash_len,
    263                             unsigned char *sig, size_t *sig_len,
    264                             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    265          {
    266              int ret;
    267              mbedtls_ecdsa_context ecdsa;
    268          
    269              mbedtls_ecdsa_init( &ecdsa );
    270          
    271              if( ( ret = mbedtls_ecdsa_from_keypair( &ecdsa, ctx ) ) == 0 )
    272                  ret = ecdsa_sign_wrap( &ecdsa, md_alg, hash, hash_len, sig, sig_len,
    273                                         f_rng, p_rng );
    274          
    275              mbedtls_ecdsa_free( &ecdsa );
    276          
    277              return( ret );
    278          }
    279          
    280          #endif /* MBEDTLS_ECDSA_C */
    281          
    282          static int eckey_check_pair( const void *pub, const void *prv )
    283          {
    284              return( mbedtls_ecp_check_pub_priv( (const mbedtls_ecp_keypair *) pub,
    285                                          (const mbedtls_ecp_keypair *) prv ) );
    286          }
    287          
    288          static void *eckey_alloc_wrap( void )
    289          {
    290              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_ecp_keypair ) );
    291          
    292              if( ctx != NULL )
    293                  mbedtls_ecp_keypair_init( ctx );
    294          
    295              return( ctx );
    296          }
    297          
    298          static void eckey_free_wrap( void *ctx )
    299          {
    300              mbedtls_ecp_keypair_free( (mbedtls_ecp_keypair *) ctx );
    301              mbedtls_free( ctx );
    302          }
    303          
    304          static void eckey_debug( const void *ctx, mbedtls_pk_debug_item *items )
    305          {
    306              items->type = MBEDTLS_PK_DEBUG_ECP;
    307              items->name = "eckey.Q";
    308              items->value = &( ((mbedtls_ecp_keypair *) ctx)->Q );
    309          }
    310          
    311          const mbedtls_pk_info_t mbedtls_eckey_info = {
    312              MBEDTLS_PK_ECKEY,
    313              "EC",
    314              eckey_get_bitlen,
    315              eckey_can_do,
    316          #if defined(MBEDTLS_ECDSA_C)
    317              eckey_verify_wrap,
    318              eckey_sign_wrap,
    319          #else
    320              NULL,
    321              NULL,
    322          #endif
    323              NULL,
    324              NULL,
    325              eckey_check_pair,
    326              eckey_alloc_wrap,
    327              eckey_free_wrap,
    328              eckey_debug,
    329          };
    330          
    331          /*
    332           * EC key restricted to ECDH
    333           */
    334          static int eckeydh_can_do( mbedtls_pk_type_t type )
    335          {
    336              return( type == MBEDTLS_PK_ECKEY ||
    337                      type == MBEDTLS_PK_ECKEY_DH );
    338          }
    339          
    340          const mbedtls_pk_info_t mbedtls_eckeydh_info = {
    341              MBEDTLS_PK_ECKEY_DH,
    342              "EC_DH",
    343              eckey_get_bitlen,         /* Same underlying key structure */
    344              eckeydh_can_do,
    345              NULL,
    346              NULL,
    347              NULL,
    348              NULL,
    349              eckey_check_pair,
    350              eckey_alloc_wrap,       /* Same underlying key structure */
    351              eckey_free_wrap,        /* Same underlying key structure */
    352              eckey_debug,            /* Same underlying key structure */
    353          };
    354          #endif /* MBEDTLS_ECP_C */
    355          
    356          #if defined(MBEDTLS_ECDSA_C)
    357          static int ecdsa_can_do( mbedtls_pk_type_t type )
    358          {
    359              return( type == MBEDTLS_PK_ECDSA );
    360          }
    361          
    362          static int ecdsa_verify_wrap( void *ctx, mbedtls_md_type_t md_alg,
    363                                 const unsigned char *hash, size_t hash_len,
    364                                 const unsigned char *sig, size_t sig_len )
    365          {
    366              int ret;
    367              ((void) md_alg);
    368          
    369              ret = mbedtls_ecdsa_read_signature( (mbedtls_ecdsa_context *) ctx,
    370                                          hash, hash_len, sig, sig_len );
    371          
    372              if( ret == MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH )
    373                  return( MBEDTLS_ERR_PK_SIG_LEN_MISMATCH );
    374          
    375              return( ret );
    376          }
    377          
    378          static int ecdsa_sign_wrap( void *ctx, mbedtls_md_type_t md_alg,
    379                             const unsigned char *hash, size_t hash_len,
    380                             unsigned char *sig, size_t *sig_len,
    381                             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    382          {
    383              return( mbedtls_ecdsa_write_signature( (mbedtls_ecdsa_context *) ctx,
    384                          md_alg, hash, hash_len, sig, sig_len, f_rng, p_rng ) );
    385          }
    386          
    387          static void *ecdsa_alloc_wrap( void )
    388          {
    389              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_ecdsa_context ) );
    390          
    391              if( ctx != NULL )
    392                  mbedtls_ecdsa_init( (mbedtls_ecdsa_context *) ctx );
    393          
    394              return( ctx );
    395          }
    396          
    397          static void ecdsa_free_wrap( void *ctx )
    398          {
    399              mbedtls_ecdsa_free( (mbedtls_ecdsa_context *) ctx );
    400              mbedtls_free( ctx );
    401          }
    402          
    403          const mbedtls_pk_info_t mbedtls_ecdsa_info = {
    404              MBEDTLS_PK_ECDSA,
    405              "ECDSA",
    406              eckey_get_bitlen,     /* Compatible key structures */
    407              ecdsa_can_do,
    408              ecdsa_verify_wrap,
    409              ecdsa_sign_wrap,
    410              NULL,
    411              NULL,
    412              eckey_check_pair,   /* Compatible key structures */
    413              ecdsa_alloc_wrap,
    414              ecdsa_free_wrap,
    415              eckey_debug,        /* Compatible key structures */
    416          };
    417          #endif /* MBEDTLS_ECDSA_C */
    418          
    419          #if defined(MBEDTLS_PK_RSA_ALT_SUPPORT)
    420          /*
    421           * Support for alternative RSA-private implementations
    422           */
    423          
    424          static int rsa_alt_can_do( mbedtls_pk_type_t type )
    425          {
    426              return( type == MBEDTLS_PK_RSA );
    427          }
    428          
    429          static size_t rsa_alt_get_bitlen( const void *ctx )
    430          {
    431              const mbedtls_rsa_alt_context *rsa_alt = (const mbedtls_rsa_alt_context *) ctx;
    432          
    433              return( 8 * rsa_alt->key_len_func( rsa_alt->key ) );
    434          }
    435          
    436          static int rsa_alt_sign_wrap( void *ctx, mbedtls_md_type_t md_alg,
    437                             const unsigned char *hash, size_t hash_len,
    438                             unsigned char *sig, size_t *sig_len,
    439                             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    440          {
    441              mbedtls_rsa_alt_context *rsa_alt = (mbedtls_rsa_alt_context *) ctx;
    442          
    443          #if SIZE_MAX > UINT_MAX
    444              if( UINT_MAX < hash_len )
    445                  return( MBEDTLS_ERR_PK_BAD_INPUT_DATA );
    446          #endif /* SIZE_MAX > UINT_MAX */
    447          
    448              *sig_len = rsa_alt->key_len_func( rsa_alt->key );
    449          
    450              return( rsa_alt->sign_func( rsa_alt->key, f_rng, p_rng, MBEDTLS_RSA_PRIVATE,
    451                          md_alg, (unsigned int) hash_len, hash, sig ) );
    452          }
    453          
    454          static int rsa_alt_decrypt_wrap( void *ctx,
    455                              const unsigned char *input, size_t ilen,
    456                              unsigned char *output, size_t *olen, size_t osize,
    457                              int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
    458          {
    459              mbedtls_rsa_alt_context *rsa_alt = (mbedtls_rsa_alt_context *) ctx;
    460          
    461              ((void) f_rng);
    462              ((void) p_rng);
    463          
    464              if( ilen != rsa_alt->key_len_func( rsa_alt->key ) )
    465                  return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
    466          
    467              return( rsa_alt->decrypt_func( rsa_alt->key,
    468                          MBEDTLS_RSA_PRIVATE, olen, input, output, osize ) );
    469          }
    470          
    471          #if defined(MBEDTLS_RSA_C)
    472          static int rsa_alt_check_pair( const void *pub, const void *prv )
    473          {
    474              unsigned char sig[MBEDTLS_MPI_MAX_SIZE];
    475              unsigned char hash[32];
    476              size_t sig_len = 0;
    477              int ret;
    478          
    479              if( rsa_alt_get_bitlen( prv ) != rsa_get_bitlen( pub ) )
    480                  return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
    481          
    482              memset( hash, 0x2a, sizeof( hash ) );
    483          
    484              if( ( ret = rsa_alt_sign_wrap( (void *) prv, MBEDTLS_MD_NONE,
    485                                             hash, sizeof( hash ),
    486                                             sig, &sig_len, NULL, NULL ) ) != 0 )
    487              {
    488                  return( ret );
    489              }
    490          
    491              if( rsa_verify_wrap( (void *) pub, MBEDTLS_MD_NONE,
    492                                   hash, sizeof( hash ), sig, sig_len ) != 0 )
    493              {
    494                  return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
    495              }
    496          
    497              return( 0 );
    498          }
    499          #endif /* MBEDTLS_RSA_C */
    500          
    501          static void *rsa_alt_alloc_wrap( void )
    502          {
    503              void *ctx = mbedtls_calloc( 1, sizeof( mbedtls_rsa_alt_context ) );
    504          
    505              if( ctx != NULL )
    506                  memset( ctx, 0, sizeof( mbedtls_rsa_alt_context ) );
    507          
    508              return( ctx );
    509          }
    510          
    511          static void rsa_alt_free_wrap( void *ctx )
    512          {
    513              mbedtls_zeroize( ctx, sizeof( mbedtls_rsa_alt_context ) );
    514              mbedtls_free( ctx );
    515          }
    516          
    517          const mbedtls_pk_info_t mbedtls_rsa_alt_info = {
    518              MBEDTLS_PK_RSA_ALT,
    519              "RSA-alt",
    520              rsa_alt_get_bitlen,
    521              rsa_alt_can_do,
    522              NULL,
    523              rsa_alt_sign_wrap,
    524              rsa_alt_decrypt_wrap,
    525              NULL,
    526          #if defined(MBEDTLS_RSA_C)
    527              rsa_alt_check_pair,
    528          #else
    529              NULL,
    530          #endif
    531              rsa_alt_alloc_wrap,
    532              rsa_alt_free_wrap,
    533              NULL,
    534          };
    535          
    536          #endif /* MBEDTLS_PK_RSA_ALT_SUPPORT */
    537          
    538          #endif /* MBEDTLS_PK_C */


 
 
 0 bytes of memory

Errors: none
Warnings: none
