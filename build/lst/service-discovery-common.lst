###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:19:49
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\protocol\zigbee\app\framework\util\service-discovery-common.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW3511.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\protocol\zigbee\app\framework\util\service-discovery-common.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"service-discovery-common.c\"" -D PSSTORE_SIZE=0 -D
#        LONGTOKEN_SIZE=0 -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\protocol\zigbee\app\framework\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\service-discovery-common.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\service-discovery-common.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\protocol\zigbee\app\framework\util\service-discovery-common.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Service discovery code that is common to different types of service
      4           * discovery, e.g. match descriptor, NWK address lookup, and IEEE address
      5           * lookup.
      6           *******************************************************************************
      7           * # License
      8           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      9           *******************************************************************************
     10           *
     11           * The licensor of this software is Silicon Laboratories Inc. Your use of this
     12           * software is governed by the terms of Silicon Labs Master Software License
     13           * Agreement (MSLA) available at
     14           * www.silabs.com/about-us/legal/master-software-license-agreement. This
     15           * software is distributed to you in Source Code format and is governed by the
     16           * sections of the MSLA applicable to Source Code.
     17           *
     18           ******************************************************************************/
     19          
     20          #include "app/framework/include/af.h"
     21          #include "app/util/zigbee-framework/zigbee-device-common.h"
     22          #ifdef EZSP_HOST
     23            #include "app/util/zigbee-framework/zigbee-device-host.h"
     24          #endif
     25          #include "service-discovery.h"
     26          
     27          #if EMBER_SUPPORTED_NETWORKS > 4
     28            #error "Service discovery is limited to four networks."
     29          #endif
     30          
     31          #define MAX_SIMPLE_DESCRIPTOR_RESPONSE_PAYLOAD                          \
     32            (128   /* 802.15.4 MTU */                                             \
     33             - 1   /* PHY length byte */                                          \
     34             - 11  /* MAC header 9 + 2 byte CRC */                                \
     35             - 8   /* NWK header */                                               \
     36             - 18  /* NWK security header + 4-byte MIC */                         \
     37             - 8   /* APS header */                                               \
     38             - EMBER_AF_ZDO_RESPONSE_OVERHEAD                                     \
     39             - 3   /* Active Endpoint Response overhead: Address(2), length(1) */ \
     40            )
     41          
     42          #define SIMPLE_DESCRIPTOR_RESPONSE_ENDPOINT_OFFSET \
     43            (EMBER_AF_ZDO_RESPONSE_OVERHEAD                  \
     44             + 2 /* address of interest */                   \
     45             + 1 /* length value */                          \
     46            )
     47          
     48          #define SIMPLE_DESCRIPTOR_RESPONSE_PROFILE_ID_OFFSET \
     49            (SIMPLE_DESCRIPTOR_RESPONSE_ENDPOINT_OFFSET        \
     50             + 1 /* endpoint */                                \
     51            )
     52          
     53          #define SIMPLE_DESCRIPTOR_RESPONSE_DEVICE_ID_OFFSET \
     54            (SIMPLE_DESCRIPTOR_RESPONSE_PROFILE_ID_OFFSET + 2)
     55          
     56          #define SIMPLE_DESCRIPTOR_RESPONSE_INPUT_CLUSTER_LIST_COUNT_INDEX \
     57            (SIMPLE_DESCRIPTOR_RESPONSE_DEVICE_ID_OFFSET                    \
     58             + 2  /* device ID length */                                    \
     59             + 1  /* version (4-bits), reserved (4-bits) */                 \
     60            )
     61          
     62          #define SIMPLE_DESCRIPTOR_RESPONSE_INPUT_CLUSTER_LIST_INDEX \
     63            (SIMPLE_DESCRIPTOR_RESPONSE_INPUT_CLUSTER_LIST_COUNT_INDEX + 1)
     64          
     65          #define MAX_CLUSTERS_IN_ACTIVE_ENDPOINT_RESPONSE (MAX_SIMPLE_DESCRIPTOR_RESPONSE_PAYLOAD >> 1)
     66          
     67          #define ACTIVE_ENDPOINT_RESPONSE_COUNT_OFFSET \
     68            (EMBER_AF_ZDO_RESPONSE_OVERHEAD             \
     69             + 2) // Address of Interest
     70          
     71          //==============================================================================
     72          // Service discovery state machine
     73          //
     74          //   This code handles initiating a limited set of ZDO, receiving
     75          //   the response and sending it back to the cluster or code element that
     76          //   requested it.  Unfortunately the ZDO message does not have any distinct
     77          //   identifiers that would allow us to determine what cluster/endpoint on our
     78          //   local device initiated the request.  Therefore we can only allow one
     79          //    outstanding request at a time.
     80          

   \                                 In section .bss, align 4
     81          EmberEventControl emAfServiceDiscoveryEventControls[EMBER_SUPPORTED_SERVICE_DISCOVERY_STATES_PER_NETWORK][EMBER_SUPPORTED_NETWORKS];
   \                     emAfServiceDiscoveryEventControls:
   \        0x0                      DS8 32
     82          
     83          typedef struct {
     84            bool active;
     85            EmberAfServiceDiscoveryCallback *callback;
     86            // This will contain the target type: broadcast or unicast (high bit)
     87            // and the ZDO cluster ID of the request.  Since ZDO requests
     88            // clear the high bit (only responses use it), we can use that leftover bit
     89            // for something else.
     90            uint16_t requestData;
     91            // Tracking the sequence when sending out discovery requests to be able to get
     92            // the correct discovery state for the request when the response comes back.
     93            // If the state is not active then it can be considered uninitialized.
     94            uint8_t requestSequence;
     95            // tracking the state index in Service Discovery States
     96            uint8_t stateIndex;
     97            //tracking the network index in Service Discovery States
     98            uint8_t networkIndex;
     99          } ServiceDiscoveryState;

   \                                 In section .bss, align 4
    100          static ServiceDiscoveryState states[EMBER_SUPPORTED_SERVICE_DISCOVERY_STATES_PER_NETWORK][EMBER_SUPPORTED_NETWORKS];
   \                     states:
   \        0x0                      DS8 64

   \                                 In section .data, align 1
   \        0x0   0x04               DC8 4
    101          static uint8_t stateLimit = EMBER_SUPPORTED_SERVICE_DISCOVERY_STATES_PER_NETWORK;

   \                                 In section .bss, align 1
    102          static bool statesInitialized = false;
   \                     statesInitialized:
   \        0x0                      DS8 1
    103          #define UNICAST_QUERY_BIT (0x8000)
    104          #define isUnicastQuery(state) (UNICAST_QUERY_BIT == ((state)->requestData & UNICAST_QUERY_BIT))
    105          #define setUnicastQuery(state) ((state)->requestData |= UNICAST_QUERY_BIT)
    106          #define getRequestCluster(state) ((state)->requestData & ~UNICAST_QUERY_BIT)
    107          #define serviceDiscoveryInProgress(state) ((state)->active)
    108          
    109          #ifndef EMBER_AF_DISCOVERY_TIMEOUT_QS
    110            #define EMBER_AF_DISCOVERY_TIMEOUT_QS (2 * 4)
    111          #endif
    112          
    113          // seq. number (1), status (1), address (2), length (1)
    114          #define MATCH_DESCRIPTOR_OVERHEAD               5
    115          #define MINIMUM_MATCH_DESCRIPTOR_SUCCESS_LENGTH MATCH_DESCRIPTOR_OVERHEAD
    116          
    117          // seq. number (1), status (1)
    118          #define EMBER_AF_ZDO_RESPONSE_OVERHEAD 2
    119          // EUI64 (8), node ID (2),
    120          #define MINIMUM_ADDRESS_REQEUST_SUCCESS (EMBER_AF_ZDO_RESPONSE_OVERHEAD + 10)
    121          #define ADDRESS_RESPONSE_NODE_ID_OFFSET (EMBER_AF_ZDO_RESPONSE_OVERHEAD + EUI64_SIZE)
    122          
    123          // Address (2), EP Count (1)
    124          #define MINIMUM_ACTIVE_ENDPOINT_RESPONSE (EMBER_AF_ZDO_RESPONSE_OVERHEAD + 3)
    125          #define ACTIVE_ENDPOINT_RESPONSE_NODE_ID_OFFSET (EMBER_AF_ZDO_RESPONSE_OVERHEAD)
    126          #define ACTIVE_ENDPOINT_RESPONSE_LIST_OFFSET (ACTIVE_ENDPOINT_RESPONSE_NODE_ID_OFFSET + 3)
    127          
    128          #define PREFIX "Svc Disc: "
    129          
    130          //==============================================================================
    131          // Forward Declarations
    132          
    133          static void setupDiscoveryData(ServiceDiscoveryState *state,
    134                                         EmberNodeId messageDest,
    135                                         EmberAfServiceDiscoveryCallback *callback,
    136                                         uint16_t zdoClusterId,
    137                                         uint8_t sequenceNumber);
    138          static void firstTimeInitStates(void);
    139          static ServiceDiscoveryState *findUnusedState(void);
    140          static ServiceDiscoveryState *findStateForResponse(uint8_t sequenceNumber, uint8_t networkIndex);
    141          uint8_t emberGetLastAppZigDevRequestSequence(void);
    142          static ServiceDiscoveryState *findStateForEventControl(EmberEventControl *control);
    143          static bool isStateActiveInCurrentNetwork(void);
    144          #ifdef EMBER_TEST
    145          void setDiscoveryStateLimit(uint8_t limit);
    146          #endif
    147          
    148          //==============================================================================
    149          

   \                                 In section .text, align 2, keep-with-next
    150          EmberStatus emberAfFindDevicesByProfileAndCluster(EmberNodeId target,
    151                                                            EmberAfProfileId profileId,
    152                                                            EmberAfClusterId clusterId,
    153                                                            bool serverCluster,
    154                                                            EmberAfServiceDiscoveryCallback *callback)
    155          {
   \                     emberAfFindDevicesByProfileAndCluster: (+1)
   \        0x0   0xE92D 0x41FC      PUSH     {R2-R8,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x4698             MOV      R8,R3
    156            ServiceDiscoveryState *state = findUnusedState();
   \        0xC   0x....'....        BL       findUnusedState
   \       0x10   0x0004             MOVS     R4,R0
    157            if (state == NULL) {
   \       0x12   0xBF08             IT       EQ 
   \       0x14   0x2070             MOVEQ    R0,#+112
    158              emberAfServiceDiscoveryPrintln("%pService Discovery State limits reached\n", PREFIX);
    159              return EMBER_INVALID_CALL;
   \       0x16   0xD01D             BEQ.N    ??emberAfFindDevicesByProfileAndCluster_0
    160            }
    161            EmberStatus status;
    162          
    163            if (EMBER_BROADCAST_ADDRESS <= target
    164                && target != EMBER_RX_ON_WHEN_IDLE_BROADCAST_ADDRESS) {
   \       0x18   0xF64F 0x71FC      MOVW     R1,#+65532
   \       0x1C   0x428D             CMP      R5,R1
   \       0x1E   0xDB04             BLT.N    ??emberAfFindDevicesByProfileAndCluster_1
   \       0x20   0xF64F 0x70FD      MOVW     R0,#+65533
   \       0x24   0x4285             CMP      R5,R0
   \       0x26   0xBF18             IT       NE 
   \       0x28   0x4605             MOVNE    R5,R0
    165              // Note:  The core spec. only allows a Match Descriptor broadcast to
    166              // the 'rx on when idle' address.  No other broadcast addresses are allowed.
    167              // The Ember stack will silently discard broadcast match descriptors
    168              // to invalid broadcast addresses.
    169              emberAfServiceDiscoveryPrintln("%pIllegal broadcast address, remapping to valid one.",
    170                                             PREFIX);
    171              target = EMBER_RX_ON_WHEN_IDLE_BROADCAST_ADDRESS;
    172            }
    173          
    174            status = emAfSendMatchDescriptor(target, profileId, clusterId, serverCluster);
   \                     ??emberAfFindDevicesByProfileAndCluster_1: (+1)
   \       0x2A   0x4643             MOV      R3,R8
   \       0x2C   0x463A             MOV      R2,R7
   \       0x2E   0x4631             MOV      R1,R6
   \       0x30   0x4628             MOV      R0,R5
   \       0x32   0x....'....        BL       emAfSendMatchDescriptor
   \       0x36   0x4606             MOV      R6,R0
    175            // Get the sequence number sent in the request.
    176            uint8_t sequenceNumber = emberGetLastAppZigDevRequestSequence();
   \       0x38   0x....'....        BL       emberGetLastAppZigDevRequestSequence
    177            if (status != EMBER_SUCCESS) {
   \       0x3C   0x0031             MOVS     R1,R6
   \       0x3E   0xBF18             IT       NE 
   \       0x40   0x4630             MOVNE    R0,R6
    178              emberAfServiceDiscoveryPrintln("%pFailed to send match discovery: 0x%x",
    179                                             PREFIX,
    180                                             status);
    181              return status;
   \       0x42   0xD107             BNE.N    ??emberAfFindDevicesByProfileAndCluster_0
   \       0x44   0x9A08             LDR      R2,[SP, #+32]
    182            }
    183          
    184            emberAfServiceDiscoveryPrintln("%pStarting discovery for cluster 0x%2x",
    185                                           PREFIX,
    186                                           clusterId);
    187            setupDiscoveryData(state,
    188                               target,
    189                               callback,
    190                               MATCH_DESCRIPTORS_REQUEST,
    191                               sequenceNumber);
   \       0x46   0x9000             STR      R0,[SP, #+0]
   \       0x48   0x2306             MOVS     R3,#+6
   \       0x4A   0x4629             MOV      R1,R5
   \       0x4C   0x4620             MOV      R0,R4
   \       0x4E   0x....'....        BL       setupDiscoveryData
    192          
    193            return EMBER_SUCCESS;
   \       0x52   0x2000             MOVS     R0,#+0
   \                     ??emberAfFindDevicesByProfileAndCluster_0: (+1)
   \       0x54   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    194          }
    195          

   \                                 In section .text, align 2, keep-with-next
    196          EmberStatus emberAfFindActiveEndpoints(EmberNodeId target,
    197                                                 EmberAfServiceDiscoveryCallback *callback)
    198          {
   \                     emberAfFindActiveEndpoints: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x....'....        BL       ?Subroutine1
    199            ServiceDiscoveryState *state = findUnusedState();
   \                     ??CrossCallReturnLabel_2: (+1)
   \        0x6   0x0004             MOVS     R4,R0
    200            if (state == NULL) {
   \        0x8   0xD101             BNE.N    ??emberAfFindActiveEndpoints_0
    201              emberAfServiceDiscoveryPrintln("%pService Discovery State limits reached\n", PREFIX);
    202              return EMBER_INVALID_CALL;
   \        0xA   0x2070             MOVS     R0,#+112
   \        0xC   0xBDF2             POP      {R1,R4-R7,PC}
    203            }
    204            EmberStatus status;
    205          
    206            status = emberActiveEndpointsRequest(target, EMBER_AF_DEFAULT_APS_OPTIONS);
   \                     ??emberAfFindActiveEndpoints_0: (+1)
   \        0xE   0xF44F 0x528A      MOV      R2,#+4416
   \       0x12   0x2105             MOVS     R1,#+5
   \       0x14   0x4628             MOV      R0,R5
   \       0x16   0x....'....        BL       emberSendZigDevRequestTarget
   \       0x1A   0x4607             MOV      R7,R0
    207            uint8_t sequenceNumber = emberGetLastAppZigDevRequestSequence();
   \       0x1C   0x....'....        BL       emberGetLastAppZigDevRequestSequence
    208            if (status != EMBER_SUCCESS) {
   \       0x20   0x0039             MOVS     R1,R7
   \       0x22   0xD001             BEQ.N    ??emberAfFindActiveEndpoints_1
    209              emberAfServiceDiscoveryPrintln("%pFailed to send active endpoint request: 0x%x",
    210                                             PREFIX,
    211                                             status);
    212              return status;
   \       0x24   0x4638             MOV      R0,R7
   \       0x26   0xBDF2             POP      {R1,R4-R7,PC}
    213            }
    214          
    215            setupDiscoveryData(state,
    216                               target,
    217                               callback,
    218                               ACTIVE_ENDPOINTS_REQUEST,
    219                               sequenceNumber);
   \                     ??emberAfFindActiveEndpoints_1: (+1)
   \       0x28   0x9000             STR      R0,[SP, #+0]
   \       0x2A   0x2305             MOVS     R3,#+5
   \       0x2C   0x....             B.N      ?Subroutine0
    220            return status;
    221          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x4632             MOV      R2,R6
   \                     ??Subroutine0_0: (+1)
   \        0x2   0x4629             MOV      R1,R5
   \        0x4   0x4620             MOV      R0,R4
   \        0x6   0x....'....        BL       setupDiscoveryData
   \        0xA   0x2000             MOVS     R0,#+0
   \        0xC   0xBDF2             POP      {R1,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x4605             MOV      R5,R0
   \        0x2   0x460E             MOV      R6,R1
   \        0x4   0x....             B.N      findUnusedState
    222          

   \                                 In section .text, align 2, keep-with-next
    223          EmberStatus emberAfFindClustersByDeviceAndEndpoint(EmberNodeId target,
    224                                                             uint8_t targetEndpoint,
    225                                                             EmberAfServiceDiscoveryCallback *callback)
    226          {
   \                     emberAfFindClustersByDeviceAndEndpoint: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x460E             MOV      R6,R1
   \        0x6   0x4617             MOV      R7,R2
    227            ServiceDiscoveryState *state = findUnusedState();
   \        0x8   0x....'....        BL       findUnusedState
   \        0xC   0x0004             MOVS     R4,R0
    228            if (state == NULL) {
   \        0xE   0xD101             BNE.N    ??emberAfFindClustersByDeviceAndEndpoint_0
    229              emberAfServiceDiscoveryPrintln("%pService Discovery State limits reached\n", PREFIX);
    230              return EMBER_INVALID_CALL;
   \       0x10   0x2070             MOVS     R0,#+112
   \       0x12   0xBDF2             POP      {R1,R4-R7,PC}
    231            }
    232            EmberStatus status;
    233          
    234            status = emberSimpleDescriptorRequest(target,
    235                                                  targetEndpoint,
    236                                                  EMBER_AF_DEFAULT_APS_OPTIONS);
   \                     ??emberAfFindClustersByDeviceAndEndpoint_0: (+1)
   \       0x14   0xF44F 0x528A      MOV      R2,#+4416
   \       0x18   0x4631             MOV      R1,R6
   \       0x1A   0x4628             MOV      R0,R5
   \       0x1C   0x....'....        BL       emberSimpleDescriptorRequest
   \       0x20   0x4606             MOV      R6,R0
    237            //Get the sequence number sent in the request.
    238            uint8_t sequenceNumber = emberGetLastAppZigDevRequestSequence();
   \       0x22   0x....'....        BL       emberGetLastAppZigDevRequestSequence
    239          
    240            if (status != EMBER_SUCCESS) {
   \       0x26   0x0031             MOVS     R1,R6
   \       0x28   0xD001             BEQ.N    ??emberAfFindClustersByDeviceAndEndpoint_1
    241              emberAfServiceDiscoveryPrintln("%pFailed to send simple descriptor request: 0x%x",
    242                                             PREFIX,
    243                                             status);
    244              return status;
   \       0x2A   0x4630             MOV      R0,R6
   \       0x2C   0xBDF2             POP      {R1,R4-R7,PC}
    245            }
    246          
    247            setupDiscoveryData(state,
    248                               target,
    249                               callback,
    250                               SIMPLE_DESCRIPTOR_REQUEST,
    251                               sequenceNumber);
   \                     ??emberAfFindClustersByDeviceAndEndpoint_1: (+1)
   \       0x2E   0x9000             STR      R0,[SP, #+0]
   \       0x30   0x2304             MOVS     R3,#+4
   \       0x32   0x463A             MOV      R2,R7
   \       0x34   0x....             B.N      ??Subroutine0_0
    252          
    253            return status;
    254          }
    255          

   \                                 In section .text, align 2, keep-with-next
    256          EmberStatus emberAfFindIeeeAddress(EmberNodeId shortAddress,
    257                                             EmberAfServiceDiscoveryCallback *callback)
    258          {
   \                     emberAfFindIeeeAddress: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x....'....        BL       ?Subroutine1
    259            ServiceDiscoveryState *state = findUnusedState();
   \                     ??CrossCallReturnLabel_1: (+1)
   \        0x6   0x0004             MOVS     R4,R0
    260            if (state == NULL) {
   \        0x8   0xD101             BNE.N    ??emberAfFindIeeeAddress_0
    261              emberAfServiceDiscoveryPrintln("%pService Discovery State limits reached\n", PREFIX);
    262              return EMBER_INVALID_CALL;
   \        0xA   0x2070             MOVS     R0,#+112
   \        0xC   0xBDF2             POP      {R1,R4-R7,PC}
    263            }
    264            EmberStatus status;
    265          
    266            status = emberIeeeAddressRequest(shortAddress,
    267                                             false,         // report kids?
    268                                             0,             // child start index
    269                                             EMBER_APS_OPTION_RETRY);
   \                     ??emberAfFindIeeeAddress_0: (+1)
   \        0xE   0x2340             MOVS     R3,#+64
   \       0x10   0x2200             MOVS     R2,#+0
   \       0x12   0x2100             MOVS     R1,#+0
   \       0x14   0x4628             MOV      R0,R5
   \       0x16   0x....'....        BL       emberIeeeAddressRequest
   \       0x1A   0x4607             MOV      R7,R0
    270            // Get the sequence number sent in the request.
    271            // For SoC, most requests use the application layer's half
    272            // of the sequence numbering space (0x00-0x7f), but this request
    273            // uses the stack's half of the sequence numbering space (0x80-0xFF).
    274            // For Host, all requests use the application layer space.
    275          #if defined(EZSP_HOST)
    276            uint8_t sequenceNumber = emberGetLastAppZigDevRequestSequence();
    277          #else
    278            uint8_t sequenceNumber = emberGetLastStackZigDevRequestSequence();
   \       0x1C   0x....'....        BL       emberGetLastStackZigDevRequestSequence
    279          #endif
    280          
    281            if (status != EMBER_SUCCESS) {
   \       0x20   0x0039             MOVS     R1,R7
   \       0x22   0xD001             BEQ.N    ??emberAfFindIeeeAddress_1
    282              emberAfServiceDiscoveryPrintln("%pFailed to send IEEE address request: 0x%x",
    283                                             PREFIX,
    284                                             status);
    285              return status;
   \       0x24   0x4638             MOV      R0,R7
   \       0x26   0xBDF2             POP      {R1,R4-R7,PC}
    286            }
    287          
    288            setupDiscoveryData(state,
    289                               shortAddress,
    290                               callback,
    291                               IEEE_ADDRESS_REQUEST,
    292                               sequenceNumber);
   \                     ??emberAfFindIeeeAddress_1: (+1)
   \       0x28   0x9000             STR      R0,[SP, #+0]
   \       0x2A   0x2301             MOVS     R3,#+1
   \       0x2C                      REQUIRE ?Subroutine0
   \       0x2C                      ;; // Fall through to label ?Subroutine0
    293          
    294            return status;
    295          }
    296          

   \                                 In section .text, align 2, keep-with-next
    297          EmberStatus emberAfFindNodeId(EmberEUI64 longAddress,
    298                                        EmberAfServiceDiscoveryCallback *callback)
    299          {
   \                     emberAfFindNodeId: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x....'....        BL       ?Subroutine1
    300            ServiceDiscoveryState *state = findUnusedState();
   \                     ??CrossCallReturnLabel_0: (+1)
   \        0x6   0x0004             MOVS     R4,R0
    301            if (state == NULL) {
   \        0x8   0xD101             BNE.N    ??emberAfFindNodeId_0
    302              emberAfServiceDiscoveryPrintln("%pService Discovery State limits reached\n", PREFIX);
    303              return EMBER_INVALID_CALL;
   \        0xA   0x2070             MOVS     R0,#+112
   \        0xC   0xBD76             POP      {R1,R2,R4-R6,PC}
    304            }
    305            EmberStatus status;
    306          
    307            status = emberNetworkAddressRequest(longAddress,
    308                                                false,         // report kids?
    309                                                0);            // child start index
   \                     ??emberAfFindNodeId_0: (+1)
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x2100             MOVS     R1,#+0
   \       0x12   0x4628             MOV      R0,R5
   \       0x14   0x....'....        BL       emberNetworkAddressRequest
   \       0x18   0x4605             MOV      R5,R0
    310            // Get the sequence number sent in the request.
    311            // For SoC, most requests use the application layer's half
    312            // of the sequence numbering space (0x00-0x7f), but this request
    313            // uses the stack's half of the sequence numbering space (0x80-0xFF).
    314            // For Host, all requests use the application layer space.
    315          #if defined(EZSP_HOST)
    316            uint8_t sequenceNumber = emberGetLastAppZigDevRequestSequence();
    317          #else
    318            uint8_t sequenceNumber = emberGetLastStackZigDevRequestSequence();
   \       0x1A   0x....'....        BL       emberGetLastStackZigDevRequestSequence
    319          #endif
    320            if (status != EMBER_SUCCESS) {
   \       0x1E   0x0029             MOVS     R1,R5
   \       0x20   0xD001             BEQ.N    ??emberAfFindNodeId_1
    321              emberAfServiceDiscoveryPrintln("%pFailed to send NWK address request: 0x%x",
    322                                             PREFIX,
    323                                             status);
    324              return status;
   \       0x22   0x4628             MOV      R0,R5
   \       0x24   0xBD76             POP      {R1,R2,R4-R6,PC}
    325            }
    326          
    327            setupDiscoveryData(state,
    328                               EMBER_BROADCAST_ADDRESS,
    329                               callback,
    330                               NETWORK_ADDRESS_REQUEST,
    331                               sequenceNumber);
   \                     ??emberAfFindNodeId_1: (+1)
   \       0x26   0x9000             STR      R0,[SP, #+0]
   \       0x28   0x2300             MOVS     R3,#+0
   \       0x2A   0x4632             MOV      R2,R6
   \       0x2C   0xF64F 0x71FC      MOVW     R1,#+65532
   \       0x30   0x4620             MOV      R0,R4
   \       0x32   0x....'....        BL       setupDiscoveryData
    332          
    333            return status;
   \       0x36   0x2000             MOVS     R0,#+0
   \       0x38   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    334          }
    335          

   \                                 In section .text, align 2, keep-with-next
    336          static void setupDiscoveryData(ServiceDiscoveryState *state,
    337                                         EmberNodeId messageDest,
    338                                         EmberAfServiceDiscoveryCallback *callback,
    339                                         uint16_t zdoClusterRequest,
    340                                         uint8_t sequenceNumber)
    341          {
   \                     setupDiscoveryData: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    342            state->active = true;
    343            state->requestData = zdoClusterRequest;
    344            if (messageDest < EMBER_BROADCAST_ADDRESS) {
   \        0x2   0xF64F 0x75FC      MOVW     R5,#+65532
   \        0x6   0x2401             MOVS     R4,#+1
   \        0x8   0x42A9             CMP      R1,R5
   \        0xA   0x7004             STRB     R4,[R0, #+0]
    345              setUnicastQuery(state);
   \        0xC   0x9904             LDR      R1,[SP, #+16]
   \        0xE   0xBFB8             IT       LT 
   \       0x10   0xF443 0x4300      ORRLT    R3,R3,#0x8000
   \       0x14   0x8103             STRH     R3,[R0, #+8]
    346            }
    347            state->callback = callback;
    348            state->requestSequence = sequenceNumber;
    349            emberAfServiceDiscoveryPrintln("%pWaiting %d sec for discovery to complete",
    350                                           PREFIX,
    351                                           EMBER_AF_DISCOVERY_TIMEOUT_QS >> 2);
    352            emberAfNetworkEventControlSetDelayQS(emAfServiceDiscoveryEventControls[state->stateIndex],
    353                                                 EMBER_AF_DISCOVERY_TIMEOUT_QS);
   \       0x16   0x7AC3             LDRB     R3,[R0, #+11]
   \       0x18   0x6042             STR      R2,[R0, #+4]
   \       0x1A   0x7281             STRB     R1,[R0, #+10]
   \       0x1C   0x....'....        LDR.W    R2,??DataTable6
   \       0x20   0x2108             MOVS     R1,#+8
   \       0x22   0xEB02 0x00C3      ADD      R0,R2,R3, LSL #+3
   \       0x26   0x....'....        BL       emberAfNetworkEventControlSetDelayQS
    354            // keep sleepy end devices out of hibernation until
    355            // service discovery is complete
    356            emberAfAddToCurrentAppTasks(EMBER_AF_WAITING_FOR_SERVICE_DISCOVERY);
   \       0x2A   0x2004             MOVS     R0,#+4
   \       0x2C   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x30   0x....'....        B.W      emberAfAddToCurrentAppTasksCallback
    357          }
    358          

   \                                 In section .text, align 2, keep-with-next
    359          static void serviceDiscoveryComplete(ServiceDiscoveryState *state)
    360          {
   \                     serviceDiscoveryComplete: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x0004             MOVS     R4,R0
    361            if (state == NULL) {
   \        0x4   0xD035             BEQ.N    ??serviceDiscoveryComplete_0
    362              emberAfServiceDiscoveryPrintln("State corresponding to the the request not found\n");
    363              return;
    364            }
    365          
    366            emberAfPushNetworkIndex(state->networkIndex);
   \        0x6   0x7B20             LDRB     R0,[R4, #+12]
   \        0x8   0x....'....        BL       emberAfPushNetworkIndex
    367            state->active = false;
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x7021             STRB     R1,[R4, #+0]
    368            emberAfServiceDiscoveryPrintln("%pcomplete.\n", PREFIX);
    369            emberAfNetworkEventControlSetInactive(emAfServiceDiscoveryEventControls[state->stateIndex]);
   \       0x10   0x7AE2             LDRB     R2,[R4, #+11]
   \       0x12   0x....'....        LDR.W    R0,??DataTable6
   \       0x16   0xEB00 0x00C2      ADD      R0,R0,R2, LSL #+3
   \       0x1A   0x....'....        BL       emberAfNetworkEventControlSetInactive
    370            // Since there can be multiple states active on the same network,
    371            // emberAfRemoveFromCurrentAppTasks should be called only when all the states
    372            // in the current network are inactive.
    373            if (!isStateActiveInCurrentNetwork()) {
   \       0x1E   0x....'....        BL       emberGetCurrentNetwork
   \       0x22   0x4601             MOV      R1,R0
   \       0x24   0x2200             MOVS     R2,#+0
   \       0x26   0x....'....        LDR.W    R3,??DataTable6_1
   \                     ??serviceDiscoveryComplete_1: (+1)
   \       0x2A   0xEB03 0x1501      ADD      R5,R3,R1, LSL #+4
   \       0x2E   0x0616             LSLS     R6,R2,#+24
   \       0x30   0x0D36             LSRS     R6,R6,#+20
   \       0x32   0x5DA8             LDRB     R0,[R5, R6]
   \       0x34   0xB930             CBNZ.N   R0,??serviceDiscoveryComplete_2
   \       0x36   0x1C52             ADDS     R2,R2,#+1
   \       0x38   0xB2D5             UXTB     R5,R2
   \       0x3A   0x2D04             CMP      R5,#+4
   \       0x3C   0xD3F5             BCC.N    ??serviceDiscoveryComplete_1
    374              // allow sleepy end devices to go into hibernation now.
    375              emberAfRemoveFromCurrentAppTasks(EMBER_AF_WAITING_FOR_SERVICE_DISCOVERY);
   \       0x3E   0x2004             MOVS     R0,#+4
   \       0x40   0x....'....        BL       emberAfRemoveFromCurrentAppTasksCallback
    376            }
    377          
    378            if (state->callback != NULL) {
   \                     ??serviceDiscoveryComplete_2: (+1)
   \       0x44   0x6861             LDR      R1,[R4, #+4]
   \       0x46   0xB191             CBZ.N    R1,??serviceDiscoveryComplete_3
    379              EmberAfServiceDiscoveryResult result;
    380              result.status = (isUnicastQuery(state)
    381                               ? EMBER_AF_UNICAST_SERVICE_DISCOVERY_TIMEOUT
    382                               : EMBER_AF_BROADCAST_SERVICE_DISCOVERY_COMPLETE);
   \       0x48   0x8922             LDRH     R2,[R4, #+8]
   \       0x4A   0x0410             LSLS     R0,R2,#+16
    383              result.zdoRequestClusterId = getRequestCluster(state);
   \       0x4C   0xF3C2 0x020E      UBFX     R2,R2,#+0,#+15
   \       0x50   0xF8AD 0x2002      STRH     R2,[SP, #+2]
   \       0x54   0xBF4C             ITE      MI 
   \       0x56   0x2302             MOVMI    R3,#+2
   \       0x58   0x2300             MOVPL    R3,#+0
   \       0x5A   0xF88D 0x3000      STRB     R3,[SP, #+0]
    384              result.matchAddress = EMBER_NULL_NODE_ID;
   \       0x5E   0xF64F 0x72FF      MOVW     R2,#+65535
    385              result.responseData = NULL;
   \       0x62   0x2300             MOVS     R3,#+0
   \       0x64   0xF8AD 0x2004      STRH     R2,[SP, #+4]
   \       0x68   0x9302             STR      R3,[SP, #+8]
    386              (*state->callback)(&result);
   \       0x6A   0x4668             MOV      R0,SP
   \       0x6C   0x4788             BLX      R1
    387            }
    388          
    389            emberAfPopNetworkIndex();
   \                     ??serviceDiscoveryComplete_3: (+1)
   \       0x6E   0x....'....        BL       emberAfPopNetworkIndex
    390          }
   \                     ??serviceDiscoveryComplete_0: (+1)
   \       0x72   0xBD7F             POP      {R0-R6,PC}       ;; return
    391          

   \                                 In section .text, align 2, keep-with-next
    392          void emAfServiceDiscoveryTimeoutHandler(EmberEventControl *control)
    393          {
   \                     emAfServiceDiscoveryTimeoutHandler: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    394            emberEventControlSetInactive(*control);
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0x7020             STRB     R0,[R4, #+0]
    395            ServiceDiscoveryState *state = findStateForEventControl(control);
   \        0x8   0x....'....        BL       firstTimeInitStates
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0x....             LDR.N    R1,??DataTable6
   \                     ??emAfServiceDiscoveryTimeoutHandler_0: (+1)
   \       0x10   0xEB01 0x02C0      ADD      R2,R1,R0, LSL #+3
   \       0x14   0x4294             CMP      R4,R2
   \       0x16   0xD007             BEQ.N    ??emAfServiceDiscoveryTimeoutHandler_1
   \       0x18   0x1C40             ADDS     R0,R0,#+1
   \       0x1A   0xB2C0             UXTB     R0,R0
   \       0x1C   0x2804             CMP      R0,#+4
   \       0x1E   0xDBF7             BLT.N    ??emAfServiceDiscoveryTimeoutHandler_0
   \       0x20   0x2000             MOVS     R0,#+0
    396            serviceDiscoveryComplete(state);
   \                     ??emAfServiceDiscoveryTimeoutHandler_2: (+1)
   \       0x22   0xE8BD 0x4010      POP      {R4,LR}
   \       0x26   0x....             B.N      serviceDiscoveryComplete
   \                     ??emAfServiceDiscoveryTimeoutHandler_1: (+1)
   \       0x28   0x....             LDR.N    R1,??DataTable6_1
   \       0x2A   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \       0x2E   0xE7F8             B.N      ??emAfServiceDiscoveryTimeoutHandler_2
    397          }
    398          

   \                                 In section .text, align 2, keep-with-next
    399          void emAfServiceDiscoveryComplete(uint8_t networkIndex, uint8_t sequenceNumber)
    400          {
   \                     emAfServiceDiscoveryComplete: (+1)
   \        0x0   0x460A             MOV      R2,R1
    401            ServiceDiscoveryState *state = findStateForResponse(sequenceNumber, networkIndex);
   \        0x2   0x4601             MOV      R1,R0
   \        0x4   0xB580             PUSH     {R7,LR}
   \        0x6   0x4610             MOV      R0,R2
   \        0x8   0x....'....        BL       findStateForResponse
    402            serviceDiscoveryComplete(state);
   \        0xC   0xE8BD 0x4002      POP      {R1,LR}
   \       0x10   0x....             B.N      serviceDiscoveryComplete
    403          }
    404          

   \                                 In section .text, align 2, keep-with-next
    405          static void executeCallback(ServiceDiscoveryState *state,
    406                                      const EmberAfServiceDiscoveryResult *result)
    407          {
   \                     executeCallback: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    408            (*state->callback)(result);
   \        0x6   0x6861             LDR      R1,[R4, #+4]
   \        0x8   0x4628             MOV      R0,R5
   \        0xA   0x4788             BLX      R1
    409            if (isUnicastQuery(state)
    410                || result->status == EMBER_AF_BROADCAST_SERVICE_DISCOVERY_COMPLETE_WITH_RESPONSE) {
   \        0xC   0x8920             LDRH     R0,[R4, #+8]
   \        0xE   0x0401             LSLS     R1,R0,#+16
   \       0x10   0xD402             BMI.N    ??executeCallback_0
   \       0x12   0x7828             LDRB     R0,[R5, #+0]
   \       0x14   0x2804             CMP      R0,#+4
   \       0x16   0xD105             BNE.N    ??executeCallback_1
    411              // If the request was unicast and we received a response then we are done.
    412              // No need to wait for the timer to expire.
    413              // Alternatively certain broadcast requests are only expected to get 1
    414              // response, or we only care about the 1st response.
    415          
    416              // We NULL the callback as a way of indicating we already fired it.
    417              // For timeouts, the callback will not be NULL and still fire.
    418              state->callback = NULL;
   \                     ??executeCallback_0: (+1)
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x6061             STR      R1,[R4, #+4]
    419              serviceDiscoveryComplete(state);
   \       0x1C   0x4620             MOV      R0,R4
   \       0x1E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \       0x22   0x....             B.N      serviceDiscoveryComplete
    420            }
    421          }
   \                     ??executeCallback_1: (+1)
   \       0x24   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    422          
    423          static bool processMatchDescriptorResponse(ServiceDiscoveryState *state,
    424                                                     const uint8_t *message,
    425                                                     uint16_t length)
    426          {
    427            EmberNodeId matchId;
    428            uint8_t listLength;
    429          
    430            if (length < MINIMUM_MATCH_DESCRIPTOR_SUCCESS_LENGTH) {
    431              emberAfServiceDiscoveryPrintln("%pMessage too short", PREFIX);
    432              return true;
    433            }
    434          
    435            // This will now be used as the length of the match list.
    436            length -= MATCH_DESCRIPTOR_OVERHEAD;
    437          
    438            // If the parent of a sleepy device supports caching its descriptor
    439            // information then the sender of the response may not be the device
    440            // that actually matches the request.  The device id that matches
    441            // is included in the message.
    442            matchId = message[2] + (message[3] << 8);
    443            listLength = message[4];
    444          
    445            if (listLength != length) {
    446              emberAfServiceDiscoveryPrintln("%pMessage too short for num. endpoints",
    447                                             PREFIX);
    448              return true;
    449            }
    450          
    451            emberAfServiceDiscoveryPrintln("%pMatch%p found from 0x%2x.",
    452                                           PREFIX,
    453                                           (listLength > 0
    454                                            ? ""
    455                                            : " NOT"),
    456                                           matchId);
    457          
    458            // If we got an active response with an empty list then ignore it.
    459            if (listLength != 0) {
    460              EmberAfServiceDiscoveryResult result;
    461              EmberAfEndpointList endpointList;
    462              endpointList.count = length;
    463              endpointList.list = &(message[MATCH_DESCRIPTOR_OVERHEAD]);
    464              result.status = (isUnicastQuery(state)
    465                               ? EMBER_AF_UNICAST_SERVICE_DISCOVERY_COMPLETE_WITH_RESPONSE
    466                               : EMBER_AF_BROADCAST_SERVICE_DISCOVERY_RESPONSE_RECEIVED);
    467              result.zdoRequestClusterId = getRequestCluster(state);
    468              result.matchAddress = matchId;
    469              result.responseData = &endpointList;
    470              executeCallback(state, &result);
    471            }
    472            return true;
    473          }
    474          

   \                                 In section .text, align 2, keep-with-next
    475          static bool processSimpleDescriptorResponse(ServiceDiscoveryState *state,
    476                                                      const uint8_t *message,
    477                                                      uint16_t length)
    478          {
   \                     processSimpleDescriptorResponse: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0xB09C             SUB      SP,SP,#+112
   \        0x6   0x4603             MOV      R3,R0
    479            EmberAfServiceDiscoveryResult result;
    480            EmberAfClusterList clusterList;
    481          
    482            clusterList.profileId = message[SIMPLE_DESCRIPTOR_RESPONSE_PROFILE_ID_OFFSET]
    483                                    + (message[SIMPLE_DESCRIPTOR_RESPONSE_PROFILE_ID_OFFSET + 1] << 8);
   \        0x8   0x7988             LDRB     R0,[R1, #+6]
   \        0xA   0x79CC             LDRB     R4,[R1, #+7]
    484            clusterList.deviceId = message[SIMPLE_DESCRIPTOR_RESPONSE_DEVICE_ID_OFFSET]
    485                                   + (message[SIMPLE_DESCRIPTOR_RESPONSE_DEVICE_ID_OFFSET + 1] << 8);
    486            clusterList.endpoint = message[SIMPLE_DESCRIPTOR_RESPONSE_ENDPOINT_OFFSET];
    487          
    488            // Copying the cluster list to a separate array
    489            // is primarily necessary on Big endian CPUs where
    490            // the over-the-air Zigbee messages are all little-endian
    491            // and we cannot just cast the message pointer into an uint16_t* array.
    492            // However we also do it for the little endian CPUs because the
    493            // message can actually be truncated due to bad Zigbee stacks.
    494            uint16_t clusters[MAX_CLUSTERS_IN_ACTIVE_ENDPOINT_RESPONSE];
    495            uint8_t index = SIMPLE_DESCRIPTOR_RESPONSE_INPUT_CLUSTER_LIST_INDEX;
    496            clusterList.inClusterCount = message[SIMPLE_DESCRIPTOR_RESPONSE_INPUT_CLUSTER_LIST_COUNT_INDEX];
    497            // The +1 is for the input cluster count length.
    498            clusterList.outClusterCount = message[SIMPLE_DESCRIPTOR_RESPONSE_INPUT_CLUSTER_LIST_COUNT_INDEX
    499                                                  + 1 + (clusterList.inClusterCount * 2)];
    500          
    501            if ((length - index - 1) % 2 != 0) {  // subtract 1 for the output cluster count.
   \        0xC   0x3A0D             SUBS     R2,R2,#+13
   \        0xE   0xEB00 0x2004      ADD      R0,R0,R4, LSL #+8
   \       0x12   0xF8AD 0x001C      STRH     R0,[SP, #+28]
   \       0x16   0x7A08             LDRB     R0,[R1, #+8]
   \       0x18   0x7A4C             LDRB     R4,[R1, #+9]
   \       0x1A   0xEB00 0x2004      ADD      R0,R0,R4, LSL #+8
   \       0x1E   0x240C             MOVS     R4,#+12
   \       0x20   0xF8AD 0x001E      STRH     R0,[SP, #+30]
   \       0x24   0x7948             LDRB     R0,[R1, #+5]
   \       0x26   0xF88D 0x0020      STRB     R0,[SP, #+32]
   \       0x2A   0x7AC8             LDRB     R0,[R1, #+11]
   \       0x2C   0xF88D 0x000C      STRB     R0,[SP, #+12]
   \       0x30   0xEB01 0x0040      ADD      R0,R1,R0, LSL #+1
   \       0x34   0x7B05             LDRB     R5,[R0, #+12]
   \       0x36   0xEB02 0x70D2      ADD      R0,R2,R2, LSR #+31
   \       0x3A   0x1040             ASRS     R0,R0,#+1
   \       0x3C   0xF88D 0x5014      STRB     R5,[SP, #+20]
   \       0x40   0xEBB2 0x0240      SUBS     R2,R2,R0, LSL #+1
   \       0x44   0xD143             BNE.N    ??processSimpleDescriptorResponse_0
    502              emberAfServiceDiscoveryPrintln("Error: %p bad simple descriptor length.", PREFIX);
    503              // Return true because we still tried to process the message.
    504              return true;
    505            }
    506            uint8_t loop;
    507            uint8_t clusterIndex = 0;
    508            for (loop = 0; loop < 2; loop++) {
   \       0x46   0x2000             MOVS     R0,#+0
    509              uint8_t count;
    510              uint8_t i;
    511              if (loop == 0) {
    512                clusterList.inClusterList = &(clusters[clusterIndex]);
   \                     ??processSimpleDescriptorResponse_1: (+1)
   \       0x48   0xAE09             ADD      R6,SP,#+36
   \       0x4A   0xB2D7             UXTB     R7,R2
   \       0x4C   0xEB06 0x0647      ADD      R6,R6,R7, LSL #+1
   \       0x50   0x9604             STR      R6,[SP, #+16]
    513                count = clusterList.inClusterCount;
   \       0x52   0xF89D 0x800C      LDRB     R8,[SP, #+12]
   \       0x56   0xE006             B.N      ??processSimpleDescriptorResponse_2
    514              } else {
   \                     ??processSimpleDescriptorResponse_3: (+1)
   \       0x58   0x2800             CMP      R0,#+0
   \       0x5A   0xD0F5             BEQ.N    ??processSimpleDescriptorResponse_1
    515                clusterList.outClusterList = &(clusters[clusterIndex]);
   \       0x5C   0xAF09             ADD      R7,SP,#+36
   \       0x5E   0xEB07 0x0646      ADD      R6,R7,R6, LSL #+1
   \       0x62   0x9606             STR      R6,[SP, #+24]
    516                count = clusterList.outClusterCount;
   \       0x64   0x46A8             MOV      R8,R5
    517              }
    518              for (i = 0; i < count; i++) {
   \                     ??processSimpleDescriptorResponse_2: (+1)
   \       0x66   0xF04F 0x0C00      MOV      R12,#+0
   \       0x6A   0xE00D             B.N      ??processSimpleDescriptorResponse_4
    519                clusters[clusterIndex] = message[index] + (message[index + 1] << 8);
   \                     ??processSimpleDescriptorResponse_5: (+1)
   \       0x6C   0x190F             ADDS     R7,R1,R4
   \       0x6E   0xF811 0xE004      LDRB     LR,[R1, R4]
   \       0x72   0x787F             LDRB     R7,[R7, #+1]
    520                clusterIndex++;
    521                index += 2;
   \       0x74   0x1CA4             ADDS     R4,R4,#+2
   \       0x76   0x1C52             ADDS     R2,R2,#+1
   \       0x78   0xEB0E 0x2E07      ADD      LR,LR,R7, LSL #+8
   \       0x7C   0xAF09             ADD      R7,SP,#+36
   \       0x7E   0xB2E4             UXTB     R4,R4
   \       0x80   0xF827 0xE016      STRH     LR,[R7, R6, LSL #+1]
    522              }
   \       0x84   0xF10C 0x0C01      ADD      R12,R12,#+1
   \                     ??processSimpleDescriptorResponse_4: (+1)
   \       0x88   0xFA5F 0xF78C      UXTB     R7,R12
   \       0x8C   0xB2D6             UXTB     R6,R2
   \       0x8E   0x4547             CMP      R7,R8
   \       0x90   0xDBEC             BLT.N    ??processSimpleDescriptorResponse_5
    523              if (loop == 0) {
   \       0x92   0xB908             CBNZ.N   R0,??processSimpleDescriptorResponse_6
    524                // This is the output cluster count
    525                index++;
   \       0x94   0x1C64             ADDS     R4,R4,#+1
   \       0x96   0xB2E4             UXTB     R4,R4
    526              }
    527            }
   \                     ??processSimpleDescriptorResponse_6: (+1)
   \       0x98   0x1C40             ADDS     R0,R0,#+1
   \       0x9A   0x2802             CMP      R0,#+2
   \       0x9C   0xDBDC             BLT.N    ??processSimpleDescriptorResponse_3
    528          
    529            result.status = (isUnicastQuery(state)
    530                             ? EMBER_AF_UNICAST_SERVICE_DISCOVERY_COMPLETE_WITH_RESPONSE
    531                             : EMBER_AF_BROADCAST_SERVICE_DISCOVERY_RESPONSE_RECEIVED);
   \       0x9E   0x8918             LDRH     R0,[R3, #+8]
   \       0xA0   0x0402             LSLS     R2,R0,#+16
    532            result.matchAddress = message[2] + (message[3] << 8);
    533            result.zdoRequestClusterId = getRequestCluster(state);
    534            result.responseData = &clusterList;
   \       0xA2   0xAA03             ADD      R2,SP,#+12
   \       0xA4   0xBF4C             ITE      MI 
   \       0xA6   0x2003             MOVMI    R0,#+3
   \       0xA8   0x2001             MOVPL    R0,#+1
   \       0xAA   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0xAE   0x7888             LDRB     R0,[R1, #+2]
   \       0xB0   0x78C9             LDRB     R1,[R1, #+3]
   \       0xB2   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \       0xB6   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \       0xBA   0x8919             LDRH     R1,[R3, #+8]
   \       0xBC   0x9202             STR      R2,[SP, #+8]
    535          
    536            executeCallback(state, &result);
   \       0xBE   0x4618             MOV      R0,R3
   \       0xC0   0xF3C1 0x010E      UBFX     R1,R1,#+0,#+15
   \       0xC4   0xF8AD 0x1002      STRH     R1,[SP, #+2]
   \       0xC8   0x4669             MOV      R1,SP
   \       0xCA   0x....'....        BL       executeCallback
    537            return true;
   \                     ??processSimpleDescriptorResponse_0: (+1)
   \       0xCE   0x2001             MOVS     R0,#+1
   \       0xD0   0xB01C             ADD      SP,SP,#+112
   \       0xD2   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    538          }
    539          
    540          // Both NWK and IEEE responses have the same exact format.
    541          static bool processAddressResponse(ServiceDiscoveryState *state,
    542                                             const uint8_t *message,
    543                                             uint16_t length)
    544          {
    545            EmberAfServiceDiscoveryResult result;
    546            EmberEUI64 eui64LittleEndian;
    547          
    548            if (length < MINIMUM_ADDRESS_REQEUST_SUCCESS) {
    549              emberAfServiceDiscoveryPrintln("%pMessage too short", PREFIX);
    550              return true;
    551            }
    552            MEMMOVE(eui64LittleEndian, message + EMBER_AF_ZDO_RESPONSE_OVERHEAD, EUI64_SIZE);
    553            // Given that we only expect one response, we set the status to complete even
    554            // though the request was broadcast.
    555            result.status = (isUnicastQuery(state)
    556                             ? EMBER_AF_UNICAST_SERVICE_DISCOVERY_COMPLETE_WITH_RESPONSE
    557                             : EMBER_AF_BROADCAST_SERVICE_DISCOVERY_COMPLETE_WITH_RESPONSE);
    558            result.matchAddress = (message[ADDRESS_RESPONSE_NODE_ID_OFFSET]
    559                                   + (message[ADDRESS_RESPONSE_NODE_ID_OFFSET + 1] << 8));
    560            result.zdoRequestClusterId = getRequestCluster(state);
    561            result.responseData = eui64LittleEndian;
    562          
    563            executeCallback(state, &result);
    564            return true;
    565          }
    566          
    567          static bool processActiveEndpointResponse(ServiceDiscoveryState* state,
    568                                                    const uint8_t* message,
    569                                                    uint16_t length)
    570          {
    571            EmberAfServiceDiscoveryResult result;
    572            EmberAfEndpointList listStruct;
    573            if (length < MINIMUM_ACTIVE_ENDPOINT_RESPONSE) {
    574              emberAfServiceDiscoveryPrintln("%pMessage too short", PREFIX);
    575              return true;
    576            }
    577            result.matchAddress = (message[ACTIVE_ENDPOINT_RESPONSE_NODE_ID_OFFSET]
    578                                   + (message[ACTIVE_ENDPOINT_RESPONSE_NODE_ID_OFFSET + 1] << 8));
    579            uint8_t count = message[ACTIVE_ENDPOINT_RESPONSE_COUNT_OFFSET];
    580          
    581            // +1 for count value iteslf, +2 for node ID
    582            uint8_t expectedLength = EMBER_AF_ZDO_RESPONSE_OVERHEAD + 1 + 2 + count;
    583          
    584            if (expectedLength != length) {
    585              emberAfServiceDiscoveryPrintln("Error: %p invalid length (%d != %d) for Active Endpoint response",
    586                                             PREFIX,
    587                                             expectedLength,
    588                                             length);
    589              return true;
    590            }
    591            emberAfServiceDiscoveryPrintln("%pgot active EP response", PREFIX);
    592            result.status = (isUnicastQuery(state)
    593                             ? EMBER_AF_UNICAST_SERVICE_DISCOVERY_COMPLETE_WITH_RESPONSE
    594                             : EMBER_AF_BROADCAST_SERVICE_DISCOVERY_RESPONSE_RECEIVED);
    595            result.zdoRequestClusterId = getRequestCluster(state);
    596            result.responseData = &listStruct;
    597            listStruct.list = &(message[ACTIVE_ENDPOINT_RESPONSE_LIST_OFFSET]);
    598            listStruct.count = message[ACTIVE_ENDPOINT_RESPONSE_COUNT_OFFSET];
    599            executeCallback(state, &result);
    600            return true;
    601          }
    602          

   \                                 In section .text, align 2, keep-with-next
    603          bool emAfServiceDiscoveryIncoming(EmberNodeId sender,
    604                                            EmberApsFrame *apsFrame,
    605                                            const uint8_t *message,
    606                                            uint16_t length)
    607          {
   \                     emAfServiceDiscoveryIncoming: (+1)
   \        0x0   0xB5F0             PUSH     {R4-R7,LR}
   \        0x2   0xB085             SUB      SP,SP,#+20
   \        0x4   0x460F             MOV      R7,R1
   \        0x6   0x4615             MOV      R5,R2
   \        0x8   0x461E             MOV      R6,R3
    608            ServiceDiscoveryState *state = findStateForResponse(message[0], emberGetCurrentNetwork());
   \        0xA   0x....'....        BL       emberGetCurrentNetwork
   \        0xE   0x4601             MOV      R1,R0
   \       0x10   0x7828             LDRB     R0,[R5, #+0]
   \       0x12   0x....'....        BL       findStateForResponse
   \       0x16   0x0004             MOVS     R4,R0
    609            if (state == NULL) {
   \       0x18   0xBF1C             ITT      NE 
   \       0x1A   0x7821             LDRBNE   R1,[R4, #+0]
   \       0x1C   0x2900             CMPNE    R1,#+0
    610              return false;
    611            }
    612          
    613            if (!(serviceDiscoveryInProgress(state)
    614                  && (apsFrame->profileId == EMBER_ZDO_PROFILE_ID
    615                      // ZDO Responses set the high bit on the request cluster ID
    616                      && (apsFrame->clusterId == (CLUSTER_ID_RESPONSE_MINIMUM
    617                                                  | getRequestCluster(state)))))) {
   \       0x1E   0xD016             BEQ.N    ??emAfServiceDiscoveryIncoming_0
   \       0x20   0x8838             LDRH     R0,[R7, #+0]
   \       0x22   0x2800             CMP      R0,#+0
   \       0x24   0xBF01             ITTTT    EQ 
   \       0x26   0x8879             LDRHEQ   R1,[R7, #+2]
   \       0x28   0x8922             LDRHEQ   R2,[R4, #+8]
   \       0x2A   0xF442 0x4200      ORREQ    R2,R2,#0x8000
   \       0x2E   0x4291             CMPEQ    R1,R2
   \       0x30   0xD17A             BNE.N    ??emAfServiceDiscoveryIncoming_1
    618              return false;
    619            }
    620          
    621            // The second byte is the status code
    622            if (message[1] != EMBER_ZDP_SUCCESS) {
   \       0x32   0x7868             LDRB     R0,[R5, #+1]
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xD175             BNE.N    ??emAfServiceDiscoveryIncoming_2
    623              return true;
    624            }
    625          
    626            switch (apsFrame->clusterId) {
   \       0x38   0xF44F 0x4200      MOV      R2,#+32768
   \       0x3C   0x1A89             SUBS     R1,R1,R2
   \       0x3E   0x2901             CMP      R1,#+1
   \       0x40   0xD92F             BLS.N    ??emAfServiceDiscoveryIncoming_3
   \       0x42   0x1F09             SUBS     R1,R1,#+4
   \       0x44   0xD004             BEQ.N    ??emAfServiceDiscoveryIncoming_4
   \       0x46   0x1E49             SUBS     R1,R1,#+1
   \       0x48   0xD049             BEQ.N    ??emAfServiceDiscoveryIncoming_5
   \       0x4A   0x1E49             SUBS     R1,R1,#+1
   \       0x4C   0xD006             BEQ.N    ??emAfServiceDiscoveryIncoming_6
   \                     ??emAfServiceDiscoveryIncoming_0: (+1)
   \       0x4E   0xE06B             B.N      ??emAfServiceDiscoveryIncoming_1
    627              case SIMPLE_DESCRIPTOR_RESPONSE:
    628                return processSimpleDescriptorResponse(state, message, length);
   \                     ??emAfServiceDiscoveryIncoming_4: (+1)
   \       0x50   0x4632             MOV      R2,R6
   \       0x52   0x4629             MOV      R1,R5
   \       0x54   0x4620             MOV      R0,R4
   \       0x56   0x....'....        BL       processSimpleDescriptorResponse
   \       0x5A   0xE066             B.N      ??emAfServiceDiscoveryIncoming_7
    629          
    630              case MATCH_DESCRIPTORS_RESPONSE:
    631                return processMatchDescriptorResponse(state, message, length);
   \                     ??emAfServiceDiscoveryIncoming_6: (+1)
   \       0x5C   0x2E04             CMP      R6,#+4
   \       0x5E   0xDD61             BLE.N    ??emAfServiceDiscoveryIncoming_2
   \       0x60   0x78A9             LDRB     R1,[R5, #+2]
   \       0x62   0x78E8             LDRB     R0,[R5, #+3]
   \       0x64   0x1F72             SUBS     R2,R6,#+5
   \       0x66   0xB293             UXTH     R3,R2
   \       0x68   0xEB01 0x2100      ADD      R1,R1,R0, LSL #+8
   \       0x6C   0x7928             LDRB     R0,[R5, #+4]
   \       0x6E   0x4298             CMP      R0,R3
   \       0x70   0xD158             BNE.N    ??emAfServiceDiscoveryIncoming_2
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0xD056             BEQ.N    ??emAfServiceDiscoveryIncoming_2
   \       0x76   0xF88D 0x2000      STRB     R2,[SP, #+0]
   \       0x7A   0x1D6A             ADDS     R2,R5,#+5
   \       0x7C   0x9201             STR      R2,[SP, #+4]
   \       0x7E   0x8922             LDRH     R2,[R4, #+8]
   \       0x80   0xF8AD 0x100C      STRH     R1,[SP, #+12]
   \       0x84   0xF8CD 0xD010      STR      SP,[SP, #+16]
   \       0x88   0x0410             LSLS     R0,R2,#+16
   \       0x8A   0xF3C2 0x020E      UBFX     R2,R2,#+0,#+15
   \       0x8E   0xF8AD 0x200A      STRH     R2,[SP, #+10]
   \       0x92   0xBF4C             ITE      MI 
   \       0x94   0x2303             MOVMI    R3,#+3
   \       0x96   0x2301             MOVPL    R3,#+1
   \       0x98   0xF88D 0x3008      STRB     R3,[SP, #+8]
   \       0x9C   0xA902             ADD      R1,SP,#+8
   \       0x9E   0x4620             MOV      R0,R4
   \       0xA0   0xE03E             B.N      ??emAfServiceDiscoveryIncoming_8
    632          
    633              case NETWORK_ADDRESS_RESPONSE:
    634              case IEEE_ADDRESS_RESPONSE:
    635                return processAddressResponse(state, message, length);
   \                     ??emAfServiceDiscoveryIncoming_3: (+1)
   \       0xA2   0x2E0B             CMP      R6,#+11
   \       0xA4   0xDD3E             BLE.N    ??emAfServiceDiscoveryIncoming_2
   \       0xA6   0x2208             MOVS     R2,#+8
   \       0xA8   0x1CA9             ADDS     R1,R5,#+2
   \       0xAA   0xA803             ADD      R0,SP,#+12
   \       0xAC   0x....'....        BL       halCommonMemMove
   \       0xB0   0x8920             LDRH     R0,[R4, #+8]
   \       0xB2   0x0401             LSLS     R1,R0,#+16
   \       0xB4   0xBF4C             ITE      MI 
   \       0xB6   0x2003             MOVMI    R0,#+3
   \       0xB8   0x2004             MOVPL    R0,#+4
   \       0xBA   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0xBE   0x7AA8             LDRB     R0,[R5, #+10]
   \       0xC0   0x7AE9             LDRB     R1,[R5, #+11]
   \       0xC2   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \       0xC6   0xF8AD 0x0004      STRH     R0,[SP, #+4]
   \       0xCA   0x8921             LDRH     R1,[R4, #+8]
   \       0xCC   0x4620             MOV      R0,R4
   \       0xCE   0xF3C1 0x010E      UBFX     R1,R1,#+0,#+15
   \       0xD2   0xF8AD 0x1002      STRH     R1,[SP, #+2]
   \       0xD6   0xA903             ADD      R1,SP,#+12
   \       0xD8   0x9102             STR      R1,[SP, #+8]
   \       0xDA   0x4669             MOV      R1,SP
   \       0xDC   0xE020             B.N      ??emAfServiceDiscoveryIncoming_8
    636          
    637              case ACTIVE_ENDPOINTS_RESPONSE:
    638                return processActiveEndpointResponse(state, message, length);
   \                     ??emAfServiceDiscoveryIncoming_5: (+1)
   \       0xDE   0x2E04             CMP      R6,#+4
   \       0xE0   0xDD20             BLE.N    ??emAfServiceDiscoveryIncoming_2
   \       0xE2   0x78A8             LDRB     R0,[R5, #+2]
   \       0xE4   0x78E9             LDRB     R1,[R5, #+3]
   \       0xE6   0xEB00 0x2001      ADD      R0,R0,R1, LSL #+8
   \       0xEA   0xF8AD 0x000C      STRH     R0,[SP, #+12]
   \       0xEE   0x7928             LDRB     R0,[R5, #+4]
   \       0xF0   0x1D40             ADDS     R0,R0,#+5
   \       0xF2   0xB2C0             UXTB     R0,R0
   \       0xF4   0x42B0             CMP      R0,R6
   \       0xF6   0xD115             BNE.N    ??emAfServiceDiscoveryIncoming_2
   \       0xF8   0x8921             LDRH     R1,[R4, #+8]
   \       0xFA   0xF8CD 0xD010      STR      SP,[SP, #+16]
   \       0xFE   0x0408             LSLS     R0,R1,#+16
   \      0x100   0xF3C1 0x010E      UBFX     R1,R1,#+0,#+15
   \      0x104   0xF8AD 0x100A      STRH     R1,[SP, #+10]
   \      0x108   0xBF4C             ITE      MI 
   \      0x10A   0x2203             MOVMI    R2,#+3
   \      0x10C   0x2201             MOVPL    R2,#+1
   \      0x10E   0xF88D 0x2008      STRB     R2,[SP, #+8]
   \      0x112   0x1D6A             ADDS     R2,R5,#+5
   \      0x114   0x9201             STR      R2,[SP, #+4]
   \      0x116   0x7929             LDRB     R1,[R5, #+4]
   \      0x118   0x4620             MOV      R0,R4
   \      0x11A   0xF88D 0x1000      STRB     R1,[SP, #+0]
   \      0x11E   0xA902             ADD      R1,SP,#+8
   \                     ??emAfServiceDiscoveryIncoming_8: (+1)
   \      0x120   0x....'....        BL       executeCallback
   \                     ??emAfServiceDiscoveryIncoming_2: (+1)
   \      0x124   0x2001             MOVS     R0,#+1
   \      0x126   0xE000             B.N      ??emAfServiceDiscoveryIncoming_7
    639          
    640              default:
    641                // Some ZDO request we don't care about.
    642                break;
    643            }
    644          
    645            return false;
   \                     ??emAfServiceDiscoveryIncoming_1: (+1)
   \      0x128   0x2000             MOVS     R0,#+0
   \                     ??emAfServiceDiscoveryIncoming_7: (+1)
   \      0x12A   0xB005             ADD      SP,SP,#+20
   \      0x12C   0xBDF0             POP      {R4-R7,PC}       ;; return
    646          }
    647          
    648          // Perform one-time initialization of states[][] entries.
    649          // Sets the self-identifying array indices stateIndex and networkIndex
    650          // for convenient reference when the state entry is accessed.

   \                                 In section .text, align 2, keep-with-next
    651          static void firstTimeInitStates(void)
    652          {
   \                     firstTimeInitStates: (+1)
   \        0x0   0x....             LDR.N    R1,??DataTable6_2
   \        0x2   0x7808             LDRB     R0,[R1, #+0]
   \        0x4   0x2800             CMP      R0,#+0
   \        0x6   0xD000             BEQ.N    ??firstTimeInitStates_0
   \        0x8   0x4770             BX       LR
   \                     ??firstTimeInitStates_0: (+1)
   \        0xA   0xB520             PUSH     {R5,LR}
    653            if (!statesInitialized) {
    654              for (uint8_t si = 0; si < stateLimit; ++si) {
   \        0xC   0x2500             MOVS     R5,#+0
    655                for (uint8_t ni = 0; ni < EMBER_SUPPORTED_NETWORKS; ++ni) {
   \                     ??firstTimeInitStates_1: (+1)
   \        0xE   0x....             LDR.N    R2,??DataTable6_1
   \       0x10   0xEB02 0x1200      ADD      R2,R2,R0, LSL #+4
   \       0x14   0x72D0             STRB     R0,[R2, #+11]
    656                  ServiceDiscoveryState *state = &states[si][ni];
    657                  // Coordinates of this state entry, for convenient reference.
    658                  state->stateIndex = si;
    659                  state->networkIndex = ni;
    660                  // Operational state.
    661                  state->active = false;
    662                  state->callback = NULL;
    663                  state->requestData = 0;
    664                  state->requestSequence = 0;
    665                }
    666              }
   \       0x16   0x1C40             ADDS     R0,R0,#+1
   \       0x18   0x7315             STRB     R5,[R2, #+12]
   \       0x1A   0x7015             STRB     R5,[R2, #+0]
   \       0x1C   0x6055             STR      R5,[R2, #+4]
   \       0x1E   0x8115             STRH     R5,[R2, #+8]
   \       0x20   0x7295             STRB     R5,[R2, #+10]
   \       0x22   0x2804             CMP      R0,#+4
   \       0x24   0xDBF3             BLT.N    ??firstTimeInitStates_1
    667              // Do this only once.
    668              statesInitialized = true;
   \       0x26   0x2001             MOVS     R0,#+1
   \       0x28   0x7008             STRB     R0,[R1, #+0]
    669            }
    670          }
   \       0x2A   0xBD20             POP      {R5,PC}          ;; return
    671          
    672          /**
    673             Given: N/A.
    674             Return: A pointer to the first unused state for the current network
    675             Description: The unused state is found by looking for the first state
    676             which is inactive in the the current network.
    677           */

   \                                 In section .text, align 2, keep-with-next
    678          static ServiceDiscoveryState *findUnusedState(void)
    679          {
   \                     findUnusedState: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    680            firstTimeInitStates();
   \        0x2   0x....'....        BL       firstTimeInitStates
    681            for (int si = 0; si < stateLimit; si++) {
   \        0x6   0x2400             MOVS     R4,#+0
    682              if (!states[si][emberGetCurrentNetwork()].active) {
   \                     ??findUnusedState_0: (+1)
   \        0x8   0x....'....        BL       emberGetCurrentNetwork
   \        0xC   0x....             LDR.N    R1,??DataTable6_1
   \        0xE   0xEB01 0x1504      ADD      R5,R1,R4, LSL #+4
   \       0x12   0x0100             LSLS     R0,R0,#+4
   \       0x14   0x5C28             LDRB     R0,[R5, R0]
   \       0x16   0xB120             CBZ.N    R0,??findUnusedState_1
   \       0x18   0x1C64             ADDS     R4,R4,#+1
   \       0x1A   0x2C04             CMP      R4,#+4
   \       0x1C   0xDBF4             BLT.N    ??findUnusedState_0
    683                return &states[si][emberGetCurrentNetwork()];
    684              }
    685            }
    686            return NULL;
   \       0x1E   0x2000             MOVS     R0,#+0
   \       0x20   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??findUnusedState_1: (+1)
   \       0x22   0x....'....        BL       emberGetCurrentNetwork
   \       0x26   0xEB05 0x1000      ADD      R0,R5,R0, LSL #+4
   \       0x2A   0xBD32             POP      {R1,R4,R5,PC}
    687          }
    688          
    689          /**
    690             Given: The sequence number of the request and the network index
    691             Return: The active service discovery state with that sequence number
    692             in the given network index.
    693           */

   \                                 In section .text, align 2, keep-with-next
    694          static ServiceDiscoveryState *findStateForResponse(uint8_t sequenceNumber, uint8_t networkIndex)
    695          {
   \                     findStateForResponse: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    696            firstTimeInitStates();
   \        0x6   0x....'....        BL       firstTimeInitStates
    697            for (int si = 0; si < stateLimit; si++) {
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x....             LDR.N    R2,??DataTable6_1
    698              if (states[si][networkIndex].requestSequence == sequenceNumber
    699                  && states[si][networkIndex].active) {
   \                     ??findStateForResponse_0: (+1)
   \        0xE   0xEB02 0x1005      ADD      R0,R2,R5, LSL #+4
   \       0x12   0x010B             LSLS     R3,R1,#+4
   \       0x14   0x18C6             ADDS     R6,R0,R3
   \       0x16   0x7AB7             LDRB     R7,[R6, #+10]
   \       0x18   0x42A7             CMP      R7,R4
   \       0x1A   0xD101             BNE.N    ??findStateForResponse_1
   \       0x1C   0x5CC0             LDRB     R0,[R0, R3]
   \       0x1E   0xB920             CBNZ.N   R0,??findStateForResponse_2
   \                     ??findStateForResponse_1: (+1)
   \       0x20   0x1C49             ADDS     R1,R1,#+1
   \       0x22   0x2904             CMP      R1,#+4
   \       0x24   0xDBF3             BLT.N    ??findStateForResponse_0
    700                return &states[si][networkIndex];
    701              }
    702            }
    703            return NULL;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   \                     ??findStateForResponse_2: (+1)
   \       0x2A   0x18D0             ADDS     R0,R2,R3
   \       0x2C   0xEB00 0x1005      ADD      R0,R0,R5, LSL #+4
   \       0x30   0xBDF2             POP      {R1,R4-R7,PC}
    704          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x....'....        DC32     emAfServiceDiscoveryEventControls

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x....'....        DC32     states

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x....'....        DC32     statesInitialized
    705          
    706          /**
    707             Given: Ember event control
    708             Return: A pointer to the service discovery state which corresponds to the
    709             control.
    710           */
    711          static ServiceDiscoveryState *findStateForEventControl(EmberEventControl *control)
    712          {
    713            firstTimeInitStates();
    714            for (uint8_t si = 0; si < stateLimit; si++) {
    715              for (uint8_t ni = 0; ni < EMBER_SUPPORTED_NETWORKS; ni++) {
    716                if (control == &emAfServiceDiscoveryEventControls[si][ni]) {
    717                  return &states[si][ni];
    718                }
    719              }
    720            }
    721            return NULL;
    722          }
    723          
    724          /**
    725             Description: Checking if there are any active states in the current network.
    726           */
    727          static bool isStateActiveInCurrentNetwork(void)
    728          {
    729            uint8_t currentNetwork = emberGetCurrentNetwork();
    730            for (uint8_t si = 0; si < stateLimit; si++) {
    731              if (states[si][currentNetwork].active) {
    732                return true;
    733              }
    734            }
    735            return false;
    736          }
    737          
    738          /**
    739             Given: The limit the number of networks allowed
    740             Description: Even though EMBER_SUPPORTED_SERVICE_DISCOVERY_STATES_PER_NETWORK
    741             can be set to 4, the state limit can be set to a smaller number using this
    742             function for testing purposes.
    743           */
    744          #ifdef EMBER_TEST
    745          void setDiscoveryStateLimit(uint8_t limit)
    746          {
    747            if (limit > EMBER_SUPPORTED_SERVICE_DISCOVERY_STATES_PER_NETWORK) {
    748              emberAfServiceDiscoveryPrintln("Limit exceeds the maximum number of service discovery states allowed."
    749                                             "Setting the limit to %d which is the maximum number if states allowed",
    750                                             EMBER_SUPPORTED_SERVICE_DISCOVERY_STATES_PER_NETWORK);
    751              stateLimit = EMBER_SUPPORTED_SERVICE_DISCOVERY_STATES_PER_NETWORK;
    752            } else {
    753              stateLimit = limit;
    754            }
    755          }
    756          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   emAfServiceDiscoveryComplete
         8   -> findStateForResponse
         0   -> serviceDiscoveryComplete
      40   emAfServiceDiscoveryIncoming
        40   -> emberGetCurrentNetwork
        40   -> executeCallback
        40   -> findStateForResponse
        40   -> halCommonMemMove
        40   -> processSimpleDescriptorResponse
       8   emAfServiceDiscoveryTimeoutHandler
         8   -> firstTimeInitStates
         0   -> serviceDiscoveryComplete
      24   emberAfFindActiveEndpoints
        24   -> emberGetLastAppZigDevRequestSequence
        24   -> emberSendZigDevRequestTarget
        24   -> findUnusedState
        24   -> setupDiscoveryData
      24   emberAfFindClustersByDeviceAndEndpoint
        24   -> emberGetLastAppZigDevRequestSequence
        24   -> emberSimpleDescriptorRequest
        24   -> findUnusedState
        24   -> setupDiscoveryData
      32   emberAfFindDevicesByProfileAndCluster
        32   -> emAfSendMatchDescriptor
        32   -> emberGetLastAppZigDevRequestSequence
        32   -> findUnusedState
        32   -> setupDiscoveryData
      24   emberAfFindIeeeAddress
        24   -> emberGetLastStackZigDevRequestSequence
        24   -> emberIeeeAddressRequest
        24   -> findUnusedState
        24   -> setupDiscoveryData
      24   emberAfFindNodeId
        24   -> emberGetLastStackZigDevRequestSequence
        24   -> emberNetworkAddressRequest
        24   -> findUnusedState
        24   -> setupDiscoveryData
      16   executeCallback
        16   -- Indirect call
         0   -> serviceDiscoveryComplete
      24   findStateForResponse
        24   -> firstTimeInitStates
      16   findUnusedState
        16   -> emberGetCurrentNetwork
        16   -> firstTimeInitStates
       8   firstTimeInitStates
     136   processSimpleDescriptorResponse
       136   -> executeCallback
      32   serviceDiscoveryComplete
        32   -- Indirect call
        32   -> emberAfNetworkEventControlSetInactive
        32   -> emberAfPopNetworkIndex
        32   -> emberAfPushNetworkIndex
        32   -> emberAfRemoveFromCurrentAppTasksCallback
        32   -> emberGetCurrentNetwork
      16   setupDiscoveryData
         0   -> emberAfAddToCurrentAppTasksCallback
        16   -> emberAfNetworkEventControlSetDelayQS


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
      14  ?Subroutine0
       6  ?Subroutine1
      18  emAfServiceDiscoveryComplete
      32  emAfServiceDiscoveryEventControls
     302  emAfServiceDiscoveryIncoming
      48  emAfServiceDiscoveryTimeoutHandler
      46  emberAfFindActiveEndpoints
      54  emberAfFindClustersByDeviceAndEndpoint
      88  emberAfFindDevicesByProfileAndCluster
      44  emberAfFindIeeeAddress
      58  emberAfFindNodeId
      38  executeCallback
      50  findStateForResponse
      44  findUnusedState
      44  firstTimeInitStates
     214  processSimpleDescriptorResponse
     116  serviceDiscoveryComplete
      52  setupDiscoveryData
       1  stateLimit
      64  states
       1  statesInitialized

 
    97 bytes in section .bss
     1 byte  in section .data
 1 248 bytes in section .text
 
 1 248 bytes of CODE memory
    98 bytes of DATA memory

Errors: none
Warnings: none
