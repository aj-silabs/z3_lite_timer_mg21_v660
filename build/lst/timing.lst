###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:19:57
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\timing.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW5745.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\timing.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"timing.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0 -D
#        LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D EMBER_AF_USE_HWCONF
#        -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\timing.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\timing.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\timing.c
      1          /***************************************************************************//**
      2           * # License
      3           *
      4           * The licensor of this software is Silicon Laboratories Inc. Your use of this
      5           * software is governed by the terms of Silicon Labs Master Software License
      6           * Agreement (MSLA) available at
      7           * www.silabs.com/about-us/legal/master-software-license-agreement. This
      8           * software is Third Party Software licensed by Silicon Labs from a third party
      9           * and is governed by the sections of the MSLA applicable to Third Party
     10           * Software and the additional terms set forth below.
     11           *
     12           ******************************************************************************/
     13          /*
     14           *  Portable interface to the CPU cycle counter
     15           *
     16           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
     17           *  SPDX-License-Identifier: Apache-2.0
     18           *
     19           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
     20           *  not use this file except in compliance with the License.
     21           *  You may obtain a copy of the License at
     22           *
     23           *  http://www.apache.org/licenses/LICENSE-2.0
     24           *
     25           *  Unless required by applicable law or agreed to in writing, software
     26           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     27           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     28           *  See the License for the specific language governing permissions and
     29           *  limitations under the License.
     30           *
     31           *  This file is part of mbed TLS (https://tls.mbed.org)
     32           */
     33          
     34          #if !defined(MBEDTLS_CONFIG_FILE)
     35          #include "mbedtls/config.h"
     36          #else
     37          #include MBEDTLS_CONFIG_FILE
     38          #endif
     39          
     40          #if defined(MBEDTLS_SELF_TEST) && defined(MBEDTLS_PLATFORM_C)
     41          #include "mbedtls/platform.h"
     42          #else
     43          #include <stdio.h>
     44          #define mbedtls_printf     printf
     45          #endif
     46          
     47          #if defined(MBEDTLS_TIMING_C)
     48          
     49          #include "mbedtls/timing.h"
     50          
     51          #if !defined(MBEDTLS_TIMING_ALT)
     52          
     53          #if !defined(unix) && !defined(__unix__) && !defined(__unix) && \
     54              !defined(__APPLE__) && !defined(_WIN32)
     55          #error "This module only works on Unix and Windows, see MBEDTLS_TIMING_C in config.h"
     56          #endif
     57          
     58          #ifndef asm
     59          #define asm __asm
     60          #endif
     61          
     62          #if defined(_WIN32) && !defined(EFIX64) && !defined(EFI32)
     63          
     64          #include <windows.h>
     65          #include <winbase.h>
     66          #include <process.h>
     67          
     68          struct _hr_time
     69          {
     70              LARGE_INTEGER start;
     71          };
     72          
     73          #else
     74          
     75          #include <unistd.h>
     76          #include <sys/types.h>
     77          #include <sys/time.h>
     78          #include <signal.h>
     79          #include <time.h>
     80          
     81          struct _hr_time
     82          {
     83              struct timeval start;
     84          };
     85          
     86          #endif /* _WIN32 && !EFIX64 && !EFI32 */
     87          
     88          #if !defined(HAVE_HARDCLOCK) && defined(MBEDTLS_HAVE_ASM) &&  \
     89              ( defined(_MSC_VER) && defined(_M_IX86) ) || defined(__WATCOMC__)
     90          
     91          #define HAVE_HARDCLOCK
     92          
     93          unsigned long mbedtls_timing_hardclock( void )
     94          {
     95              unsigned long tsc;
     96              __asm   rdtsc
     97              __asm   mov  [tsc], eax
     98              return( tsc );
     99          }
    100          #endif /* !HAVE_HARDCLOCK && MBEDTLS_HAVE_ASM &&
    101                    ( _MSC_VER && _M_IX86 ) || __WATCOMC__ */
    102          
    103          /* some versions of mingw-64 have 32-bit longs even on x84_64 */
    104          #if !defined(HAVE_HARDCLOCK) && defined(MBEDTLS_HAVE_ASM) &&  \
    105              defined(__GNUC__) && ( defined(__i386__) || (                       \
    106              ( defined(__amd64__) || defined( __x86_64__) ) && __SIZEOF_LONG__ == 4 ) )
    107          
    108          #define HAVE_HARDCLOCK
    109          
    110          unsigned long mbedtls_timing_hardclock( void )
    111          {
    112              unsigned long lo, hi;
    113              asm volatile( "rdtsc" : "=a" (lo), "=d" (hi) );
    114              return( lo );
    115          }
    116          #endif /* !HAVE_HARDCLOCK && MBEDTLS_HAVE_ASM &&
    117                    __GNUC__ && __i386__ */
    118          
    119          #if !defined(HAVE_HARDCLOCK) && defined(MBEDTLS_HAVE_ASM) &&  \
    120              defined(__GNUC__) && ( defined(__amd64__) || defined(__x86_64__) )
    121          
    122          #define HAVE_HARDCLOCK
    123          
    124          unsigned long mbedtls_timing_hardclock( void )
    125          {
    126              unsigned long lo, hi;
    127              asm volatile( "rdtsc" : "=a" (lo), "=d" (hi) );
    128              return( lo | ( hi << 32 ) );
    129          }
    130          #endif /* !HAVE_HARDCLOCK && MBEDTLS_HAVE_ASM &&
    131                    __GNUC__ && ( __amd64__ || __x86_64__ ) */
    132          
    133          #if !defined(HAVE_HARDCLOCK) && defined(MBEDTLS_HAVE_ASM) &&  \
    134              defined(__GNUC__) && ( defined(__powerpc__) || defined(__ppc__) )
    135          
    136          #define HAVE_HARDCLOCK
    137          
    138          unsigned long mbedtls_timing_hardclock( void )
    139          {
    140              unsigned long tbl, tbu0, tbu1;
    141          
    142              do
    143              {
    144                  asm volatile( "mftbu %0" : "=r" (tbu0) );
    145                  asm volatile( "mftb  %0" : "=r" (tbl ) );
    146                  asm volatile( "mftbu %0" : "=r" (tbu1) );
    147              }
    148              while( tbu0 != tbu1 );
    149          
    150              return( tbl );
    151          }
    152          #endif /* !HAVE_HARDCLOCK && MBEDTLS_HAVE_ASM &&
    153                    __GNUC__ && ( __powerpc__ || __ppc__ ) */
    154          
    155          #if !defined(HAVE_HARDCLOCK) && defined(MBEDTLS_HAVE_ASM) &&  \
    156              defined(__GNUC__) && defined(__sparc64__)
    157          
    158          #if defined(__OpenBSD__)
    159          #warning OpenBSD does not allow access to tick register using software version instead
    160          #else
    161          #define HAVE_HARDCLOCK
    162          
    163          unsigned long mbedtls_timing_hardclock( void )
    164          {
    165              unsigned long tick;
    166              asm volatile( "rdpr %%tick, %0;" : "=&r" (tick) );
    167              return( tick );
    168          }
    169          #endif /* __OpenBSD__ */
    170          #endif /* !HAVE_HARDCLOCK && MBEDTLS_HAVE_ASM &&
    171                    __GNUC__ && __sparc64__ */
    172          
    173          #if !defined(HAVE_HARDCLOCK) && defined(MBEDTLS_HAVE_ASM) &&  \
    174              defined(__GNUC__) && defined(__sparc__) && !defined(__sparc64__)
    175          
    176          #define HAVE_HARDCLOCK
    177          
    178          unsigned long mbedtls_timing_hardclock( void )
    179          {
    180              unsigned long tick;
    181              asm volatile( ".byte 0x83, 0x41, 0x00, 0x00" );
    182              asm volatile( "mov   %%g1, %0" : "=r" (tick) );
    183              return( tick );
    184          }
    185          #endif /* !HAVE_HARDCLOCK && MBEDTLS_HAVE_ASM &&
    186                    __GNUC__ && __sparc__ && !__sparc64__ */
    187          
    188          #if !defined(HAVE_HARDCLOCK) && defined(MBEDTLS_HAVE_ASM) &&      \
    189              defined(__GNUC__) && defined(__alpha__)
    190          
    191          #define HAVE_HARDCLOCK
    192          
    193          unsigned long mbedtls_timing_hardclock( void )
    194          {
    195              unsigned long cc;
    196              asm volatile( "rpcc %0" : "=r" (cc) );
    197              return( cc & 0xFFFFFFFF );
    198          }
    199          #endif /* !HAVE_HARDCLOCK && MBEDTLS_HAVE_ASM &&
    200                    __GNUC__ && __alpha__ */
    201          
    202          #if !defined(HAVE_HARDCLOCK) && defined(MBEDTLS_HAVE_ASM) &&      \
    203              defined(__GNUC__) && defined(__ia64__)
    204          
    205          #define HAVE_HARDCLOCK
    206          
    207          unsigned long mbedtls_timing_hardclock( void )
    208          {
    209              unsigned long itc;
    210              asm volatile( "mov %0 = ar.itc" : "=r" (itc) );
    211              return( itc );
    212          }
    213          #endif /* !HAVE_HARDCLOCK && MBEDTLS_HAVE_ASM &&
    214                    __GNUC__ && __ia64__ */
    215          
    216          #if !defined(HAVE_HARDCLOCK) && defined(_MSC_VER) && \
    217              !defined(EFIX64) && !defined(EFI32)
    218          
    219          #define HAVE_HARDCLOCK
    220          
    221          unsigned long mbedtls_timing_hardclock( void )
    222          {
    223              LARGE_INTEGER offset;
    224          
    225              QueryPerformanceCounter( &offset );
    226          
    227              return( (unsigned long)( offset.QuadPart ) );
    228          }
    229          #endif /* !HAVE_HARDCLOCK && _MSC_VER && !EFIX64 && !EFI32 */
    230          
    231          #if !defined(HAVE_HARDCLOCK)
    232          
    233          #define HAVE_HARDCLOCK
    234          
    235          static int hardclock_init = 0;
    236          static struct timeval tv_init;
    237          
    238          unsigned long mbedtls_timing_hardclock( void )
    239          {
    240              struct timeval tv_cur;
    241          
    242              if( hardclock_init == 0 )
    243              {
    244                  gettimeofday( &tv_init, NULL );
    245                  hardclock_init = 1;
    246              }
    247          
    248              gettimeofday( &tv_cur, NULL );
    249              return( ( tv_cur.tv_sec  - tv_init.tv_sec  ) * 1000000
    250                    + ( tv_cur.tv_usec - tv_init.tv_usec ) );
    251          }
    252          #endif /* !HAVE_HARDCLOCK */
    253          
    254          volatile int mbedtls_timing_alarmed = 0;
    255          
    256          #if defined(_WIN32) && !defined(EFIX64) && !defined(EFI32)
    257          
    258          unsigned long mbedtls_timing_get_timer( struct mbedtls_timing_hr_time *val, int reset )
    259          {
    260              struct _hr_time *t = (struct _hr_time *) val;
    261          
    262              if( reset )
    263              {
    264                  QueryPerformanceCounter( &t->start );
    265                  return( 0 );
    266              }
    267              else
    268              {
    269                  unsigned long delta;
    270                  LARGE_INTEGER now, hfreq;
    271                  QueryPerformanceCounter(  &now );
    272                  QueryPerformanceFrequency( &hfreq );
    273                  delta = (unsigned long)( ( now.QuadPart - t->start.QuadPart ) * 1000ul
    274                                           / hfreq.QuadPart );
    275                  return( delta );
    276              }
    277          }
    278          
    279          /* It's OK to use a global because alarm() is supposed to be global anyway */
    280          static DWORD alarmMs;
    281          
    282          static void TimerProc( void *TimerContext )
    283          {
    284              (void) TimerContext;
    285              Sleep( alarmMs );
    286              mbedtls_timing_alarmed = 1;
    287              /* _endthread will be called implicitly on return
    288               * That ensures execution of thread funcition's epilogue */
    289          }
    290          
    291          void mbedtls_set_alarm( int seconds )
    292          {
    293              if( seconds == 0 )
    294              {
    295                  /* No need to create a thread for this simple case.
    296                   * Also, this shorcut is more reliable at least on MinGW32 */
    297                  mbedtls_timing_alarmed = 1;
    298                  return;
    299              }
    300          
    301              mbedtls_timing_alarmed = 0;
    302              alarmMs = seconds * 1000;
    303              (void) _beginthread( TimerProc, 0, NULL );
    304          }
    305          
    306          #else /* _WIN32 && !EFIX64 && !EFI32 */
    307          
    308          unsigned long mbedtls_timing_get_timer( struct mbedtls_timing_hr_time *val, int reset )
    309          {
    310              struct _hr_time *t = (struct _hr_time *) val;
    311          
    312              if( reset )
    313              {
    314                  gettimeofday( &t->start, NULL );
    315                  return( 0 );
    316              }
    317              else
    318              {
    319                  unsigned long delta;
    320                  struct timeval now;
    321                  gettimeofday( &now, NULL );
    322                  delta = ( now.tv_sec  - t->start.tv_sec  ) * 1000ul
    323                        + ( now.tv_usec - t->start.tv_usec ) / 1000;
    324                  return( delta );
    325              }
    326          }
    327          
    328          static void sighandler( int signum )
    329          {
    330              mbedtls_timing_alarmed = 1;
    331              signal( signum, sighandler );
    332          }
    333          
    334          void mbedtls_set_alarm( int seconds )
    335          {
    336              mbedtls_timing_alarmed = 0;
    337              signal( SIGALRM, sighandler );
    338              alarm( seconds );
    339              if( seconds == 0 )
    340              {
    341                  /* alarm(0) cancelled any previous pending alarm, but the
    342                     handler won't fire, so raise the flag straight away. */
    343                  mbedtls_timing_alarmed = 1;
    344              }
    345          }
    346          
    347          #endif /* _WIN32 && !EFIX64 && !EFI32 */
    348          
    349          /*
    350           * Set delays to watch
    351           */
    352          void mbedtls_timing_set_delay( void *data, uint32_t int_ms, uint32_t fin_ms )
    353          {
    354              mbedtls_timing_delay_context *ctx = (mbedtls_timing_delay_context *) data;
    355          
    356              ctx->int_ms = int_ms;
    357              ctx->fin_ms = fin_ms;
    358          
    359              if( fin_ms != 0 )
    360                  (void) mbedtls_timing_get_timer( &ctx->timer, 1 );
    361          }
    362          
    363          /*
    364           * Get number of delays expired
    365           */
    366          int mbedtls_timing_get_delay( void *data )
    367          {
    368              mbedtls_timing_delay_context *ctx = (mbedtls_timing_delay_context *) data;
    369              unsigned long elapsed_ms;
    370          
    371              if( ctx->fin_ms == 0 )
    372                  return( -1 );
    373          
    374              elapsed_ms = mbedtls_timing_get_timer( &ctx->timer, 0 );
    375          
    376              if( elapsed_ms >= ctx->fin_ms )
    377                  return( 2 );
    378          
    379              if( elapsed_ms >= ctx->int_ms )
    380                  return( 1 );
    381          
    382              return( 0 );
    383          }
    384          
    385          #if defined(MBEDTLS_SELF_TEST)
    386          
    387          /*
    388           * Busy-waits for the given number of milliseconds.
    389           * Used for testing mbedtls_timing_hardclock.
    390           */
    391          static void busy_msleep( unsigned long msec )
    392          {
    393              struct mbedtls_timing_hr_time hires;
    394              unsigned long i = 0; /* for busy-waiting */
    395              volatile unsigned long j; /* to prevent optimisation */
    396          
    397              (void) mbedtls_timing_get_timer( &hires, 1 );
    398          
    399              while( mbedtls_timing_get_timer( &hires, 0 ) < msec )
    400                  i++;
    401          
    402              j = i;
    403              (void) j;
    404          }
    405          
    406          #define FAIL    do                                                      \
    407              {                                                                   \
    408                  if( verbose != 0 )                                              \
    409                  {                                                               \
    410                      mbedtls_printf( "failed at line %d\n", __LINE__ );          \
    411                      mbedtls_printf( " cycles=%lu ratio=%lu millisecs=%lu secs=%lu hardfail=%d a=%lu b=%lu\n", \
    412                                      cycles, ratio, millisecs, secs, hardfail,   \
    413                                      (unsigned long) a, (unsigned long) b );     \
    414                      mbedtls_printf( " elapsed(hires)=%lu elapsed(ctx)=%lu status(ctx)=%d\n", \
    415                                      mbedtls_timing_get_timer( &hires, 0 ),      \
    416                                      mbedtls_timing_get_timer( &ctx.timer, 0 ),  \
    417                                      mbedtls_timing_get_delay( &ctx ) );         \
    418                  }                                                               \
    419                  return( 1 );                                                    \
    420              } while( 0 )
    421          
    422          /*
    423           * Checkup routine
    424           *
    425           * Warning: this is work in progress, some tests may not be reliable enough
    426           * yet! False positives may happen.
    427           */
    428          int mbedtls_timing_self_test( int verbose )
    429          {
    430              unsigned long cycles = 0, ratio = 0;
    431              unsigned long millisecs = 0, secs = 0;
    432              int hardfail = 0;
    433              struct mbedtls_timing_hr_time hires;
    434              uint32_t a = 0, b = 0;
    435              mbedtls_timing_delay_context ctx;
    436          
    437              if( verbose != 0 )
    438                  mbedtls_printf( "  TIMING tests note: will take some time!\n" );
    439          
    440              if( verbose != 0 )
    441                  mbedtls_printf( "  TIMING test #1 (set_alarm / get_timer): " );
    442          
    443              {
    444                  secs = 1;
    445          
    446                  (void) mbedtls_timing_get_timer( &hires, 1 );
    447          
    448                  mbedtls_set_alarm( (int) secs );
    449                  while( !mbedtls_timing_alarmed )
    450                      ;
    451          
    452                  millisecs = mbedtls_timing_get_timer( &hires, 0 );
    453          
    454                  /* For some reason on Windows it looks like alarm has an extra delay
    455                   * (maybe related to creating a new thread). Allow some room here. */
    456                  if( millisecs < 800 * secs || millisecs > 1200 * secs + 300 )
    457                      FAIL;
    458              }
    459          
    460              if( verbose != 0 )
    461                  mbedtls_printf( "passed\n" );
    462          
    463              if( verbose != 0 )
    464                  mbedtls_printf( "  TIMING test #2 (set/get_delay        ): " );
    465          
    466              {
    467                  a = 800;
    468                  b = 400;
    469                  mbedtls_timing_set_delay( &ctx, a, a + b );          /* T = 0 */
    470          
    471                  busy_msleep( a - a / 4 );                      /* T = a - a/4 */
    472                  if( mbedtls_timing_get_delay( &ctx ) != 0 )
    473                      FAIL;
    474          
    475                  busy_msleep( a / 4 + b / 4 );                  /* T = a + b/4 */
    476                  if( mbedtls_timing_get_delay( &ctx ) != 1 )
    477                      FAIL;
    478          
    479                  busy_msleep( b );                          /* T = a + b + b/4 */
    480                  if( mbedtls_timing_get_delay( &ctx ) != 2 )
    481                      FAIL;
    482              }
    483          
    484              mbedtls_timing_set_delay( &ctx, 0, 0 );
    485              busy_msleep( 200 );
    486              if( mbedtls_timing_get_delay( &ctx ) != -1 )
    487                  FAIL;
    488          
    489              if( verbose != 0 )
    490                  mbedtls_printf( "passed\n" );
    491          
    492              if( verbose != 0 )
    493                  mbedtls_printf( "  TIMING test #3 (hardclock / get_timer): " );
    494          
    495              /*
    496               * Allow one failure for possible counter wrapping.
    497               * On a 4Ghz 32-bit machine the cycle counter wraps about once per second;
    498               * since the whole test is about 10ms, it shouldn't happen twice in a row.
    499               */
    500          
    501          hard_test:
    502              if( hardfail > 1 )
    503              {
    504                  if( verbose != 0 )
    505                      mbedtls_printf( "failed (ignored)\n" );
    506          
    507                  goto hard_test_done;
    508              }
    509          
    510              /* Get a reference ratio cycles/ms */
    511              millisecs = 1;
    512              cycles = mbedtls_timing_hardclock();
    513              busy_msleep( millisecs );
    514              cycles = mbedtls_timing_hardclock() - cycles;
    515              ratio = cycles / millisecs;
    516          
    517              /* Check that the ratio is mostly constant */
    518              for( millisecs = 2; millisecs <= 4; millisecs++ )
    519              {
    520                  cycles = mbedtls_timing_hardclock();
    521                  busy_msleep( millisecs );
    522                  cycles = mbedtls_timing_hardclock() - cycles;
    523          
    524                  /* Allow variation up to 20% */
    525                  if( cycles / millisecs < ratio - ratio / 5 ||
    526                      cycles / millisecs > ratio + ratio / 5 )
    527                  {
    528                      hardfail++;
    529                      goto hard_test;
    530                  }
    531              }
    532          
    533              if( verbose != 0 )
    534                  mbedtls_printf( "passed\n" );
    535          
    536          hard_test_done:
    537          
    538              if( verbose != 0 )
    539                  mbedtls_printf( "\n" );
    540          
    541              return( 0 );
    542          }
    543          
    544          #endif /* MBEDTLS_SELF_TEST */
    545          
    546          #endif /* !MBEDTLS_TIMING_ALT */
    547          
    548          #endif /* MBEDTLS_TIMING_C */


 
 
 0 bytes of memory

Errors: none
Warnings: none
