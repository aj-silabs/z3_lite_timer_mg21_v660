###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:01
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\aes.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW9006.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\aes.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"aes.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0 -D
#        LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D EMBER_AF_USE_HWCONF
#        -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\aes.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\aes.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\aes.c
      1          /***************************************************************************//**
      2           * # License
      3           *
      4           * The licensor of this software is Silicon Laboratories Inc. Your use of this
      5           * software is governed by the terms of Silicon Labs Master Software License
      6           * Agreement (MSLA) available at
      7           * www.silabs.com/about-us/legal/master-software-license-agreement. This
      8           * software is Third Party Software licensed by Silicon Labs from a third party
      9           * and is governed by the sections of the MSLA applicable to Third Party
     10           * Software and the additional terms set forth below.
     11           *
     12           ******************************************************************************/
     13          /*
     14           *  FIPS-197 compliant AES implementation
     15           *
     16           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
     17           *  SPDX-License-Identifier: Apache-2.0
     18           *
     19           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
     20           *  not use this file except in compliance with the License.
     21           *  You may obtain a copy of the License at
     22           *
     23           *  http://www.apache.org/licenses/LICENSE-2.0
     24           *
     25           *  Unless required by applicable law or agreed to in writing, software
     26           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     27           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     28           *  See the License for the specific language governing permissions and
     29           *  limitations under the License.
     30           *
     31           *  This file is part of mbed TLS (https://tls.mbed.org)
     32           */
     33          /*
     34           *  The AES block cipher was designed by Vincent Rijmen and Joan Daemen.
     35           *
     36           *  http://csrc.nist.gov/encryption/aes/rijndael/Rijndael.pdf
     37           *  http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf
     38           */
     39          
     40          #if !defined(MBEDTLS_CONFIG_FILE)
     41          #include "mbedtls/config.h"
     42          #else
     43          #include MBEDTLS_CONFIG_FILE
     44          #endif
     45          
     46          #if defined(MBEDTLS_AES_C)
     47          
     48          #include <string.h>
     49          
     50          #include "mbedtls/aes.h"
     51          #if defined(MBEDTLS_PADLOCK_C)
     52          #include "mbedtls/padlock.h"
     53          #endif
     54          #if defined(MBEDTLS_AESNI_C)
     55          #include "mbedtls/aesni.h"
     56          #endif
     57          
     58          #if defined(MBEDTLS_SELF_TEST)
     59          #if defined(MBEDTLS_PLATFORM_C)
     60          #include "mbedtls/platform.h"
     61          #else
     62          #include <stdio.h>
     63          #define mbedtls_printf printf
     64          #endif /* MBEDTLS_PLATFORM_C */
     65          #endif /* MBEDTLS_SELF_TEST */
     66          
     67          #if !defined(MBEDTLS_AES_ALT)
     68          
     69          /* Implementation that should never be optimized out by the compiler */
     70          static void mbedtls_zeroize( void *v, size_t n ) {
     71              volatile unsigned char *p = (unsigned char*)v; while( n-- ) *p++ = 0;
     72          }
     73          
     74          /*
     75           * 32-bit integer manipulation macros (little endian)
     76           */
     77          #ifndef GET_UINT32_LE
     78          #define GET_UINT32_LE(n,b,i)                            \
     79          {                                                       \
     80              (n) = ( (uint32_t) (b)[(i)    ]       )             \
     81                  | ( (uint32_t) (b)[(i) + 1] <<  8 )             \
     82                  | ( (uint32_t) (b)[(i) + 2] << 16 )             \
     83                  | ( (uint32_t) (b)[(i) + 3] << 24 );            \
     84          }
     85          #endif
     86          
     87          #ifndef PUT_UINT32_LE
     88          #define PUT_UINT32_LE(n,b,i)                                    \
     89          {                                                               \
     90              (b)[(i)    ] = (unsigned char) ( ( (n)       ) & 0xFF );    \
     91              (b)[(i) + 1] = (unsigned char) ( ( (n) >>  8 ) & 0xFF );    \
     92              (b)[(i) + 2] = (unsigned char) ( ( (n) >> 16 ) & 0xFF );    \
     93              (b)[(i) + 3] = (unsigned char) ( ( (n) >> 24 ) & 0xFF );    \
     94          }
     95          #endif
     96          
     97          #if defined(MBEDTLS_PADLOCK_C) &&                      \
     98              ( defined(MBEDTLS_HAVE_X86) || defined(MBEDTLS_PADLOCK_ALIGN16) )
     99          static int aes_padlock_ace = -1;
    100          #endif
    101          
    102          #if defined(MBEDTLS_AES_ROM_TABLES)
    103          /*
    104           * Forward S-box
    105           */
    106          static const unsigned char FSb[256] =
    107          {
    108              0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,
    109              0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    110              0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,
    111              0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    112              0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,
    113              0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    114              0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,
    115              0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    116              0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,
    117              0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    118              0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,
    119              0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    120              0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,
    121              0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    122              0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,
    123              0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    124              0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,
    125              0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    126              0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,
    127              0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    128              0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,
    129              0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    130              0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,
    131              0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    132              0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,
    133              0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    134              0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,
    135              0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    136              0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,
    137              0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    138              0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,
    139              0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
    140          };
    141          
    142          /*
    143           * Forward tables
    144           */
    145          #define FT \
    146          \
    147              V(A5,63,63,C6), V(84,7C,7C,F8), V(99,77,77,EE), V(8D,7B,7B,F6), \
    148              V(0D,F2,F2,FF), V(BD,6B,6B,D6), V(B1,6F,6F,DE), V(54,C5,C5,91), \
    149              V(50,30,30,60), V(03,01,01,02), V(A9,67,67,CE), V(7D,2B,2B,56), \
    150              V(19,FE,FE,E7), V(62,D7,D7,B5), V(E6,AB,AB,4D), V(9A,76,76,EC), \
    151              V(45,CA,CA,8F), V(9D,82,82,1F), V(40,C9,C9,89), V(87,7D,7D,FA), \
    152              V(15,FA,FA,EF), V(EB,59,59,B2), V(C9,47,47,8E), V(0B,F0,F0,FB), \
    153              V(EC,AD,AD,41), V(67,D4,D4,B3), V(FD,A2,A2,5F), V(EA,AF,AF,45), \
    154              V(BF,9C,9C,23), V(F7,A4,A4,53), V(96,72,72,E4), V(5B,C0,C0,9B), \
    155              V(C2,B7,B7,75), V(1C,FD,FD,E1), V(AE,93,93,3D), V(6A,26,26,4C), \
    156              V(5A,36,36,6C), V(41,3F,3F,7E), V(02,F7,F7,F5), V(4F,CC,CC,83), \
    157              V(5C,34,34,68), V(F4,A5,A5,51), V(34,E5,E5,D1), V(08,F1,F1,F9), \
    158              V(93,71,71,E2), V(73,D8,D8,AB), V(53,31,31,62), V(3F,15,15,2A), \
    159              V(0C,04,04,08), V(52,C7,C7,95), V(65,23,23,46), V(5E,C3,C3,9D), \
    160              V(28,18,18,30), V(A1,96,96,37), V(0F,05,05,0A), V(B5,9A,9A,2F), \
    161              V(09,07,07,0E), V(36,12,12,24), V(9B,80,80,1B), V(3D,E2,E2,DF), \
    162              V(26,EB,EB,CD), V(69,27,27,4E), V(CD,B2,B2,7F), V(9F,75,75,EA), \
    163              V(1B,09,09,12), V(9E,83,83,1D), V(74,2C,2C,58), V(2E,1A,1A,34), \
    164              V(2D,1B,1B,36), V(B2,6E,6E,DC), V(EE,5A,5A,B4), V(FB,A0,A0,5B), \
    165              V(F6,52,52,A4), V(4D,3B,3B,76), V(61,D6,D6,B7), V(CE,B3,B3,7D), \
    166              V(7B,29,29,52), V(3E,E3,E3,DD), V(71,2F,2F,5E), V(97,84,84,13), \
    167              V(F5,53,53,A6), V(68,D1,D1,B9), V(00,00,00,00), V(2C,ED,ED,C1), \
    168              V(60,20,20,40), V(1F,FC,FC,E3), V(C8,B1,B1,79), V(ED,5B,5B,B6), \
    169              V(BE,6A,6A,D4), V(46,CB,CB,8D), V(D9,BE,BE,67), V(4B,39,39,72), \
    170              V(DE,4A,4A,94), V(D4,4C,4C,98), V(E8,58,58,B0), V(4A,CF,CF,85), \
    171              V(6B,D0,D0,BB), V(2A,EF,EF,C5), V(E5,AA,AA,4F), V(16,FB,FB,ED), \
    172              V(C5,43,43,86), V(D7,4D,4D,9A), V(55,33,33,66), V(94,85,85,11), \
    173              V(CF,45,45,8A), V(10,F9,F9,E9), V(06,02,02,04), V(81,7F,7F,FE), \
    174              V(F0,50,50,A0), V(44,3C,3C,78), V(BA,9F,9F,25), V(E3,A8,A8,4B), \
    175              V(F3,51,51,A2), V(FE,A3,A3,5D), V(C0,40,40,80), V(8A,8F,8F,05), \
    176              V(AD,92,92,3F), V(BC,9D,9D,21), V(48,38,38,70), V(04,F5,F5,F1), \
    177              V(DF,BC,BC,63), V(C1,B6,B6,77), V(75,DA,DA,AF), V(63,21,21,42), \
    178              V(30,10,10,20), V(1A,FF,FF,E5), V(0E,F3,F3,FD), V(6D,D2,D2,BF), \
    179              V(4C,CD,CD,81), V(14,0C,0C,18), V(35,13,13,26), V(2F,EC,EC,C3), \
    180              V(E1,5F,5F,BE), V(A2,97,97,35), V(CC,44,44,88), V(39,17,17,2E), \
    181              V(57,C4,C4,93), V(F2,A7,A7,55), V(82,7E,7E,FC), V(47,3D,3D,7A), \
    182              V(AC,64,64,C8), V(E7,5D,5D,BA), V(2B,19,19,32), V(95,73,73,E6), \
    183              V(A0,60,60,C0), V(98,81,81,19), V(D1,4F,4F,9E), V(7F,DC,DC,A3), \
    184              V(66,22,22,44), V(7E,2A,2A,54), V(AB,90,90,3B), V(83,88,88,0B), \
    185              V(CA,46,46,8C), V(29,EE,EE,C7), V(D3,B8,B8,6B), V(3C,14,14,28), \
    186              V(79,DE,DE,A7), V(E2,5E,5E,BC), V(1D,0B,0B,16), V(76,DB,DB,AD), \
    187              V(3B,E0,E0,DB), V(56,32,32,64), V(4E,3A,3A,74), V(1E,0A,0A,14), \
    188              V(DB,49,49,92), V(0A,06,06,0C), V(6C,24,24,48), V(E4,5C,5C,B8), \
    189              V(5D,C2,C2,9F), V(6E,D3,D3,BD), V(EF,AC,AC,43), V(A6,62,62,C4), \
    190              V(A8,91,91,39), V(A4,95,95,31), V(37,E4,E4,D3), V(8B,79,79,F2), \
    191              V(32,E7,E7,D5), V(43,C8,C8,8B), V(59,37,37,6E), V(B7,6D,6D,DA), \
    192              V(8C,8D,8D,01), V(64,D5,D5,B1), V(D2,4E,4E,9C), V(E0,A9,A9,49), \
    193              V(B4,6C,6C,D8), V(FA,56,56,AC), V(07,F4,F4,F3), V(25,EA,EA,CF), \
    194              V(AF,65,65,CA), V(8E,7A,7A,F4), V(E9,AE,AE,47), V(18,08,08,10), \
    195              V(D5,BA,BA,6F), V(88,78,78,F0), V(6F,25,25,4A), V(72,2E,2E,5C), \
    196              V(24,1C,1C,38), V(F1,A6,A6,57), V(C7,B4,B4,73), V(51,C6,C6,97), \
    197              V(23,E8,E8,CB), V(7C,DD,DD,A1), V(9C,74,74,E8), V(21,1F,1F,3E), \
    198              V(DD,4B,4B,96), V(DC,BD,BD,61), V(86,8B,8B,0D), V(85,8A,8A,0F), \
    199              V(90,70,70,E0), V(42,3E,3E,7C), V(C4,B5,B5,71), V(AA,66,66,CC), \
    200              V(D8,48,48,90), V(05,03,03,06), V(01,F6,F6,F7), V(12,0E,0E,1C), \
    201              V(A3,61,61,C2), V(5F,35,35,6A), V(F9,57,57,AE), V(D0,B9,B9,69), \
    202              V(91,86,86,17), V(58,C1,C1,99), V(27,1D,1D,3A), V(B9,9E,9E,27), \
    203              V(38,E1,E1,D9), V(13,F8,F8,EB), V(B3,98,98,2B), V(33,11,11,22), \
    204              V(BB,69,69,D2), V(70,D9,D9,A9), V(89,8E,8E,07), V(A7,94,94,33), \
    205              V(B6,9B,9B,2D), V(22,1E,1E,3C), V(92,87,87,15), V(20,E9,E9,C9), \
    206              V(49,CE,CE,87), V(FF,55,55,AA), V(78,28,28,50), V(7A,DF,DF,A5), \
    207              V(8F,8C,8C,03), V(F8,A1,A1,59), V(80,89,89,09), V(17,0D,0D,1A), \
    208              V(DA,BF,BF,65), V(31,E6,E6,D7), V(C6,42,42,84), V(B8,68,68,D0), \
    209              V(C3,41,41,82), V(B0,99,99,29), V(77,2D,2D,5A), V(11,0F,0F,1E), \
    210              V(CB,B0,B0,7B), V(FC,54,54,A8), V(D6,BB,BB,6D), V(3A,16,16,2C)
    211          
    212          #define V(a,b,c,d) 0x##a##b##c##d
    213          static const uint32_t FT0[256] = { FT };
    214          #undef V
    215          
    216          #define V(a,b,c,d) 0x##b##c##d##a
    217          static const uint32_t FT1[256] = { FT };
    218          #undef V
    219          
    220          #define V(a,b,c,d) 0x##c##d##a##b
    221          static const uint32_t FT2[256] = { FT };
    222          #undef V
    223          
    224          #define V(a,b,c,d) 0x##d##a##b##c
    225          static const uint32_t FT3[256] = { FT };
    226          #undef V
    227          
    228          #undef FT
    229          
    230          /*
    231           * Reverse S-box
    232           */
    233          static const unsigned char RSb[256] =
    234          {
    235              0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,
    236              0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    237              0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,
    238              0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    239              0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,
    240              0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    241              0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,
    242              0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    243              0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,
    244              0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    245              0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,
    246              0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    247              0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,
    248              0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    249              0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,
    250              0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    251              0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,
    252              0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    253              0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,
    254              0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    255              0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,
    256              0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    257              0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,
    258              0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    259              0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,
    260              0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    261              0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,
    262              0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    263              0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,
    264              0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    265              0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,
    266              0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
    267          };
    268          
    269          /*
    270           * Reverse tables
    271           */
    272          #define RT \
    273          \
    274              V(50,A7,F4,51), V(53,65,41,7E), V(C3,A4,17,1A), V(96,5E,27,3A), \
    275              V(CB,6B,AB,3B), V(F1,45,9D,1F), V(AB,58,FA,AC), V(93,03,E3,4B), \
    276              V(55,FA,30,20), V(F6,6D,76,AD), V(91,76,CC,88), V(25,4C,02,F5), \
    277              V(FC,D7,E5,4F), V(D7,CB,2A,C5), V(80,44,35,26), V(8F,A3,62,B5), \
    278              V(49,5A,B1,DE), V(67,1B,BA,25), V(98,0E,EA,45), V(E1,C0,FE,5D), \
    279              V(02,75,2F,C3), V(12,F0,4C,81), V(A3,97,46,8D), V(C6,F9,D3,6B), \
    280              V(E7,5F,8F,03), V(95,9C,92,15), V(EB,7A,6D,BF), V(DA,59,52,95), \
    281              V(2D,83,BE,D4), V(D3,21,74,58), V(29,69,E0,49), V(44,C8,C9,8E), \
    282              V(6A,89,C2,75), V(78,79,8E,F4), V(6B,3E,58,99), V(DD,71,B9,27), \
    283              V(B6,4F,E1,BE), V(17,AD,88,F0), V(66,AC,20,C9), V(B4,3A,CE,7D), \
    284              V(18,4A,DF,63), V(82,31,1A,E5), V(60,33,51,97), V(45,7F,53,62), \
    285              V(E0,77,64,B1), V(84,AE,6B,BB), V(1C,A0,81,FE), V(94,2B,08,F9), \
    286              V(58,68,48,70), V(19,FD,45,8F), V(87,6C,DE,94), V(B7,F8,7B,52), \
    287              V(23,D3,73,AB), V(E2,02,4B,72), V(57,8F,1F,E3), V(2A,AB,55,66), \
    288              V(07,28,EB,B2), V(03,C2,B5,2F), V(9A,7B,C5,86), V(A5,08,37,D3), \
    289              V(F2,87,28,30), V(B2,A5,BF,23), V(BA,6A,03,02), V(5C,82,16,ED), \
    290              V(2B,1C,CF,8A), V(92,B4,79,A7), V(F0,F2,07,F3), V(A1,E2,69,4E), \
    291              V(CD,F4,DA,65), V(D5,BE,05,06), V(1F,62,34,D1), V(8A,FE,A6,C4), \
    292              V(9D,53,2E,34), V(A0,55,F3,A2), V(32,E1,8A,05), V(75,EB,F6,A4), \
    293              V(39,EC,83,0B), V(AA,EF,60,40), V(06,9F,71,5E), V(51,10,6E,BD), \
    294              V(F9,8A,21,3E), V(3D,06,DD,96), V(AE,05,3E,DD), V(46,BD,E6,4D), \
    295              V(B5,8D,54,91), V(05,5D,C4,71), V(6F,D4,06,04), V(FF,15,50,60), \
    296              V(24,FB,98,19), V(97,E9,BD,D6), V(CC,43,40,89), V(77,9E,D9,67), \
    297              V(BD,42,E8,B0), V(88,8B,89,07), V(38,5B,19,E7), V(DB,EE,C8,79), \
    298              V(47,0A,7C,A1), V(E9,0F,42,7C), V(C9,1E,84,F8), V(00,00,00,00), \
    299              V(83,86,80,09), V(48,ED,2B,32), V(AC,70,11,1E), V(4E,72,5A,6C), \
    300              V(FB,FF,0E,FD), V(56,38,85,0F), V(1E,D5,AE,3D), V(27,39,2D,36), \
    301              V(64,D9,0F,0A), V(21,A6,5C,68), V(D1,54,5B,9B), V(3A,2E,36,24), \
    302              V(B1,67,0A,0C), V(0F,E7,57,93), V(D2,96,EE,B4), V(9E,91,9B,1B), \
    303              V(4F,C5,C0,80), V(A2,20,DC,61), V(69,4B,77,5A), V(16,1A,12,1C), \
    304              V(0A,BA,93,E2), V(E5,2A,A0,C0), V(43,E0,22,3C), V(1D,17,1B,12), \
    305              V(0B,0D,09,0E), V(AD,C7,8B,F2), V(B9,A8,B6,2D), V(C8,A9,1E,14), \
    306              V(85,19,F1,57), V(4C,07,75,AF), V(BB,DD,99,EE), V(FD,60,7F,A3), \
    307              V(9F,26,01,F7), V(BC,F5,72,5C), V(C5,3B,66,44), V(34,7E,FB,5B), \
    308              V(76,29,43,8B), V(DC,C6,23,CB), V(68,FC,ED,B6), V(63,F1,E4,B8), \
    309              V(CA,DC,31,D7), V(10,85,63,42), V(40,22,97,13), V(20,11,C6,84), \
    310              V(7D,24,4A,85), V(F8,3D,BB,D2), V(11,32,F9,AE), V(6D,A1,29,C7), \
    311              V(4B,2F,9E,1D), V(F3,30,B2,DC), V(EC,52,86,0D), V(D0,E3,C1,77), \
    312              V(6C,16,B3,2B), V(99,B9,70,A9), V(FA,48,94,11), V(22,64,E9,47), \
    313              V(C4,8C,FC,A8), V(1A,3F,F0,A0), V(D8,2C,7D,56), V(EF,90,33,22), \
    314              V(C7,4E,49,87), V(C1,D1,38,D9), V(FE,A2,CA,8C), V(36,0B,D4,98), \
    315              V(CF,81,F5,A6), V(28,DE,7A,A5), V(26,8E,B7,DA), V(A4,BF,AD,3F), \
    316              V(E4,9D,3A,2C), V(0D,92,78,50), V(9B,CC,5F,6A), V(62,46,7E,54), \
    317              V(C2,13,8D,F6), V(E8,B8,D8,90), V(5E,F7,39,2E), V(F5,AF,C3,82), \
    318              V(BE,80,5D,9F), V(7C,93,D0,69), V(A9,2D,D5,6F), V(B3,12,25,CF), \
    319              V(3B,99,AC,C8), V(A7,7D,18,10), V(6E,63,9C,E8), V(7B,BB,3B,DB), \
    320              V(09,78,26,CD), V(F4,18,59,6E), V(01,B7,9A,EC), V(A8,9A,4F,83), \
    321              V(65,6E,95,E6), V(7E,E6,FF,AA), V(08,CF,BC,21), V(E6,E8,15,EF), \
    322              V(D9,9B,E7,BA), V(CE,36,6F,4A), V(D4,09,9F,EA), V(D6,7C,B0,29), \
    323              V(AF,B2,A4,31), V(31,23,3F,2A), V(30,94,A5,C6), V(C0,66,A2,35), \
    324              V(37,BC,4E,74), V(A6,CA,82,FC), V(B0,D0,90,E0), V(15,D8,A7,33), \
    325              V(4A,98,04,F1), V(F7,DA,EC,41), V(0E,50,CD,7F), V(2F,F6,91,17), \
    326              V(8D,D6,4D,76), V(4D,B0,EF,43), V(54,4D,AA,CC), V(DF,04,96,E4), \
    327              V(E3,B5,D1,9E), V(1B,88,6A,4C), V(B8,1F,2C,C1), V(7F,51,65,46), \
    328              V(04,EA,5E,9D), V(5D,35,8C,01), V(73,74,87,FA), V(2E,41,0B,FB), \
    329              V(5A,1D,67,B3), V(52,D2,DB,92), V(33,56,10,E9), V(13,47,D6,6D), \
    330              V(8C,61,D7,9A), V(7A,0C,A1,37), V(8E,14,F8,59), V(89,3C,13,EB), \
    331              V(EE,27,A9,CE), V(35,C9,61,B7), V(ED,E5,1C,E1), V(3C,B1,47,7A), \
    332              V(59,DF,D2,9C), V(3F,73,F2,55), V(79,CE,14,18), V(BF,37,C7,73), \
    333              V(EA,CD,F7,53), V(5B,AA,FD,5F), V(14,6F,3D,DF), V(86,DB,44,78), \
    334              V(81,F3,AF,CA), V(3E,C4,68,B9), V(2C,34,24,38), V(5F,40,A3,C2), \
    335              V(72,C3,1D,16), V(0C,25,E2,BC), V(8B,49,3C,28), V(41,95,0D,FF), \
    336              V(71,01,A8,39), V(DE,B3,0C,08), V(9C,E4,B4,D8), V(90,C1,56,64), \
    337              V(61,84,CB,7B), V(70,B6,32,D5), V(74,5C,6C,48), V(42,57,B8,D0)
    338          
    339          #define V(a,b,c,d) 0x##a##b##c##d
    340          static const uint32_t RT0[256] = { RT };
    341          #undef V
    342          
    343          #define V(a,b,c,d) 0x##b##c##d##a
    344          static const uint32_t RT1[256] = { RT };
    345          #undef V
    346          
    347          #define V(a,b,c,d) 0x##c##d##a##b
    348          static const uint32_t RT2[256] = { RT };
    349          #undef V
    350          
    351          #define V(a,b,c,d) 0x##d##a##b##c
    352          static const uint32_t RT3[256] = { RT };
    353          #undef V
    354          
    355          #undef RT
    356          
    357          /*
    358           * Round constants
    359           */
    360          static const uint32_t RCON[10] =
    361          {
    362              0x00000001, 0x00000002, 0x00000004, 0x00000008,
    363              0x00000010, 0x00000020, 0x00000040, 0x00000080,
    364              0x0000001B, 0x00000036
    365          };
    366          
    367          #else /* MBEDTLS_AES_ROM_TABLES */
    368          
    369          /*
    370           * Forward S-box & tables
    371           */
    372          static unsigned char FSb[256];
    373          static uint32_t FT0[256];
    374          static uint32_t FT1[256];
    375          static uint32_t FT2[256];
    376          static uint32_t FT3[256];
    377          
    378          /*
    379           * Reverse S-box & tables
    380           */
    381          static unsigned char RSb[256];
    382          static uint32_t RT0[256];
    383          static uint32_t RT1[256];
    384          static uint32_t RT2[256];
    385          static uint32_t RT3[256];
    386          
    387          /*
    388           * Round constants
    389           */
    390          static uint32_t RCON[10];
    391          
    392          /*
    393           * Tables generation code
    394           */
    395          #define ROTL8(x) ( ( x << 8 ) & 0xFFFFFFFF ) | ( x >> 24 )
    396          #define XTIME(x) ( ( x << 1 ) ^ ( ( x & 0x80 ) ? 0x1B : 0x00 ) )
    397          #define MUL(x,y) ( ( x && y ) ? pow[(log[x]+log[y]) % 255] : 0 )
    398          
    399          static int aes_init_done = 0;
    400          
    401          static void aes_gen_tables( void )
    402          {
    403              int i, x, y, z;
    404              int pow[256];
    405              int log[256];
    406          
    407              /*
    408               * compute pow and log tables over GF(2^8)
    409               */
    410              for( i = 0, x = 1; i < 256; i++ )
    411              {
    412                  pow[i] = x;
    413                  log[x] = i;
    414                  x = ( x ^ XTIME( x ) ) & 0xFF;
    415              }
    416          
    417              /*
    418               * calculate the round constants
    419               */
    420              for( i = 0, x = 1; i < 10; i++ )
    421              {
    422                  RCON[i] = (uint32_t) x;
    423                  x = XTIME( x ) & 0xFF;
    424              }
    425          
    426              /*
    427               * generate the forward and reverse S-boxes
    428               */
    429              FSb[0x00] = 0x63;
    430              RSb[0x63] = 0x00;
    431          
    432              for( i = 1; i < 256; i++ )
    433              {
    434                  x = pow[255 - log[i]];
    435          
    436                  y  = x; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
    437                  x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
    438                  x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
    439                  x ^= y; y = ( ( y << 1 ) | ( y >> 7 ) ) & 0xFF;
    440                  x ^= y ^ 0x63;
    441          
    442                  FSb[i] = (unsigned char) x;
    443                  RSb[x] = (unsigned char) i;
    444              }
    445          
    446              /*
    447               * generate the forward and reverse tables
    448               */
    449              for( i = 0; i < 256; i++ )
    450              {
    451                  x = FSb[i];
    452                  y = XTIME( x ) & 0xFF;
    453                  z =  ( y ^ x ) & 0xFF;
    454          
    455                  FT0[i] = ( (uint32_t) y       ) ^
    456                           ( (uint32_t) x <<  8 ) ^
    457                           ( (uint32_t) x << 16 ) ^
    458                           ( (uint32_t) z << 24 );
    459          
    460                  FT1[i] = ROTL8( FT0[i] );
    461                  FT2[i] = ROTL8( FT1[i] );
    462                  FT3[i] = ROTL8( FT2[i] );
    463          
    464                  x = RSb[i];
    465          
    466                  RT0[i] = ( (uint32_t) MUL( 0x0E, x )       ) ^
    467                           ( (uint32_t) MUL( 0x09, x ) <<  8 ) ^
    468                           ( (uint32_t) MUL( 0x0D, x ) << 16 ) ^
    469                           ( (uint32_t) MUL( 0x0B, x ) << 24 );
    470          
    471                  RT1[i] = ROTL8( RT0[i] );
    472                  RT2[i] = ROTL8( RT1[i] );
    473                  RT3[i] = ROTL8( RT2[i] );
    474              }
    475          }
    476          
    477          #endif /* MBEDTLS_AES_ROM_TABLES */
    478          
    479          void mbedtls_aes_init( mbedtls_aes_context *ctx )
    480          {
    481              memset( ctx, 0, sizeof( mbedtls_aes_context ) );
    482          }
    483          
    484          void mbedtls_aes_free( mbedtls_aes_context *ctx )
    485          {
    486              if( ctx == NULL )
    487                  return;
    488          
    489              mbedtls_zeroize( ctx, sizeof( mbedtls_aes_context ) );
    490          }
    491          
    492          /*
    493           * AES key schedule (encryption)
    494           */
    495          #if !defined(MBEDTLS_AES_SETKEY_ENC_ALT)
    496          int mbedtls_aes_setkey_enc( mbedtls_aes_context *ctx, const unsigned char *key,
    497                              unsigned int keybits )
    498          {
    499              unsigned int i;
    500              uint32_t *RK;
    501          
    502          #if !defined(MBEDTLS_AES_ROM_TABLES)
    503              if( aes_init_done == 0 )
    504              {
    505                  aes_gen_tables();
    506                  aes_init_done = 1;
    507          
    508              }
    509          #endif
    510          
    511              switch( keybits )
    512              {
    513                  case 128: ctx->nr = 10; break;
    514                  case 192: ctx->nr = 12; break;
    515                  case 256: ctx->nr = 14; break;
    516                  default : return( MBEDTLS_ERR_AES_INVALID_KEY_LENGTH );
    517              }
    518          
    519          #if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_PADLOCK_ALIGN16)
    520              if( aes_padlock_ace == -1 )
    521                  aes_padlock_ace = mbedtls_padlock_has_support( MBEDTLS_PADLOCK_ACE );
    522          
    523              if( aes_padlock_ace )
    524                  ctx->rk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx->buf );
    525              else
    526          #endif
    527              ctx->rk = RK = ctx->buf;
    528          
    529          #if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)
    530              if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )
    531                  return( mbedtls_aesni_setkey_enc( (unsigned char *) ctx->rk, key, keybits ) );
    532          #endif
    533          
    534              for( i = 0; i < ( keybits >> 5 ); i++ )
    535              {
    536                  GET_UINT32_LE( RK[i], key, i << 2 );
    537              }
    538          
    539              switch( ctx->nr )
    540              {
    541                  case 10:
    542          
    543                      for( i = 0; i < 10; i++, RK += 4 )
    544                      {
    545                          RK[4]  = RK[0] ^ RCON[i] ^
    546                          ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
    547                          ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^
    548                          ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
    549                          ( (uint32_t) FSb[ ( RK[3]       ) & 0xFF ] << 24 );
    550          
    551                          RK[5]  = RK[1] ^ RK[4];
    552                          RK[6]  = RK[2] ^ RK[5];
    553                          RK[7]  = RK[3] ^ RK[6];
    554                      }
    555                      break;
    556          
    557                  case 12:
    558          
    559                      for( i = 0; i < 8; i++, RK += 6 )
    560                      {
    561                          RK[6]  = RK[0] ^ RCON[i] ^
    562                          ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
    563                          ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^
    564                          ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
    565                          ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );
    566          
    567                          RK[7]  = RK[1] ^ RK[6];
    568                          RK[8]  = RK[2] ^ RK[7];
    569                          RK[9]  = RK[3] ^ RK[8];
    570                          RK[10] = RK[4] ^ RK[9];
    571                          RK[11] = RK[5] ^ RK[10];
    572                      }
    573                      break;
    574          
    575                  case 14:
    576          
    577                      for( i = 0; i < 7; i++, RK += 8 )
    578                      {
    579                          RK[8]  = RK[0] ^ RCON[i] ^
    580                          ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
    581                          ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^
    582                          ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
    583                          ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );
    584          
    585                          RK[9]  = RK[1] ^ RK[8];
    586                          RK[10] = RK[2] ^ RK[9];
    587                          RK[11] = RK[3] ^ RK[10];
    588          
    589                          RK[12] = RK[4] ^
    590                          ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^
    591                          ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^
    592                          ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
    593                          ( (uint32_t) FSb[ ( RK[11] >> 24 ) & 0xFF ] << 24 );
    594          
    595                          RK[13] = RK[5] ^ RK[12];
    596                          RK[14] = RK[6] ^ RK[13];
    597                          RK[15] = RK[7] ^ RK[14];
    598                      }
    599                      break;
    600              }
    601          
    602              return( 0 );
    603          }
    604          #endif /* !MBEDTLS_AES_SETKEY_ENC_ALT */
    605          
    606          /*
    607           * AES key schedule (decryption)
    608           */
    609          #if !defined(MBEDTLS_AES_SETKEY_DEC_ALT)
    610          int mbedtls_aes_setkey_dec( mbedtls_aes_context *ctx, const unsigned char *key,
    611                              unsigned int keybits )
    612          {
    613              int i, j, ret;
    614              mbedtls_aes_context cty;
    615              uint32_t *RK;
    616              uint32_t *SK;
    617          
    618              mbedtls_aes_init( &cty );
    619          
    620          #if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_PADLOCK_ALIGN16)
    621              if( aes_padlock_ace == -1 )
    622                  aes_padlock_ace = mbedtls_padlock_has_support( MBEDTLS_PADLOCK_ACE );
    623          
    624              if( aes_padlock_ace )
    625                  ctx->rk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx->buf );
    626              else
    627          #endif
    628              ctx->rk = RK = ctx->buf;
    629          
    630              /* Also checks keybits */
    631              if( ( ret = mbedtls_aes_setkey_enc( &cty, key, keybits ) ) != 0 )
    632                  goto exit;
    633          
    634              ctx->nr = cty.nr;
    635          
    636          #if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)
    637              if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )
    638              {
    639                  mbedtls_aesni_inverse_key( (unsigned char *) ctx->rk,
    640                                     (const unsigned char *) cty.rk, ctx->nr );
    641                  goto exit;
    642              }
    643          #endif
    644          
    645              SK = cty.rk + cty.nr * 4;
    646          
    647              *RK++ = *SK++;
    648              *RK++ = *SK++;
    649              *RK++ = *SK++;
    650              *RK++ = *SK++;
    651          
    652              for( i = ctx->nr - 1, SK -= 8; i > 0; i--, SK -= 8 )
    653              {
    654                  for( j = 0; j < 4; j++, SK++ )
    655                  {
    656                      *RK++ = RT0[ FSb[ ( *SK       ) & 0xFF ] ] ^
    657                              RT1[ FSb[ ( *SK >>  8 ) & 0xFF ] ] ^
    658                              RT2[ FSb[ ( *SK >> 16 ) & 0xFF ] ] ^
    659                              RT3[ FSb[ ( *SK >> 24 ) & 0xFF ] ];
    660                  }
    661              }
    662          
    663              *RK++ = *SK++;
    664              *RK++ = *SK++;
    665              *RK++ = *SK++;
    666              *RK++ = *SK++;
    667          
    668          exit:
    669              mbedtls_aes_free( &cty );
    670          
    671              return( ret );
    672          }
    673          #endif /* !MBEDTLS_AES_SETKEY_DEC_ALT */
    674          
    675          #define AES_FROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)     \
    676          {                                               \
    677              X0 = *RK++ ^ FT0[ ( Y0       ) & 0xFF ] ^   \
    678                           FT1[ ( Y1 >>  8 ) & 0xFF ] ^   \
    679                           FT2[ ( Y2 >> 16 ) & 0xFF ] ^   \
    680                           FT3[ ( Y3 >> 24 ) & 0xFF ];    \
    681                                                          \
    682              X1 = *RK++ ^ FT0[ ( Y1       ) & 0xFF ] ^   \
    683                           FT1[ ( Y2 >>  8 ) & 0xFF ] ^   \
    684                           FT2[ ( Y3 >> 16 ) & 0xFF ] ^   \
    685                           FT3[ ( Y0 >> 24 ) & 0xFF ];    \
    686                                                          \
    687              X2 = *RK++ ^ FT0[ ( Y2       ) & 0xFF ] ^   \
    688                           FT1[ ( Y3 >>  8 ) & 0xFF ] ^   \
    689                           FT2[ ( Y0 >> 16 ) & 0xFF ] ^   \
    690                           FT3[ ( Y1 >> 24 ) & 0xFF ];    \
    691                                                          \
    692              X3 = *RK++ ^ FT0[ ( Y3       ) & 0xFF ] ^   \
    693                           FT1[ ( Y0 >>  8 ) & 0xFF ] ^   \
    694                           FT2[ ( Y1 >> 16 ) & 0xFF ] ^   \
    695                           FT3[ ( Y2 >> 24 ) & 0xFF ];    \
    696          }
    697          
    698          #define AES_RROUND(X0,X1,X2,X3,Y0,Y1,Y2,Y3)     \
    699          {                                               \
    700              X0 = *RK++ ^ RT0[ ( Y0       ) & 0xFF ] ^   \
    701                           RT1[ ( Y3 >>  8 ) & 0xFF ] ^   \
    702                           RT2[ ( Y2 >> 16 ) & 0xFF ] ^   \
    703                           RT3[ ( Y1 >> 24 ) & 0xFF ];    \
    704                                                          \
    705              X1 = *RK++ ^ RT0[ ( Y1       ) & 0xFF ] ^   \
    706                           RT1[ ( Y0 >>  8 ) & 0xFF ] ^   \
    707                           RT2[ ( Y3 >> 16 ) & 0xFF ] ^   \
    708                           RT3[ ( Y2 >> 24 ) & 0xFF ];    \
    709                                                          \
    710              X2 = *RK++ ^ RT0[ ( Y2       ) & 0xFF ] ^   \
    711                           RT1[ ( Y1 >>  8 ) & 0xFF ] ^   \
    712                           RT2[ ( Y0 >> 16 ) & 0xFF ] ^   \
    713                           RT3[ ( Y3 >> 24 ) & 0xFF ];    \
    714                                                          \
    715              X3 = *RK++ ^ RT0[ ( Y3       ) & 0xFF ] ^   \
    716                           RT1[ ( Y2 >>  8 ) & 0xFF ] ^   \
    717                           RT2[ ( Y1 >> 16 ) & 0xFF ] ^   \
    718                           RT3[ ( Y0 >> 24 ) & 0xFF ];    \
    719          }
    720          
    721          /*
    722           * AES-ECB block encryption
    723           */
    724          #if !defined(MBEDTLS_AES_ENCRYPT_ALT)
    725          int mbedtls_internal_aes_encrypt( mbedtls_aes_context *ctx,
    726                                            const unsigned char input[16],
    727                                            unsigned char output[16] )
    728          {
    729              int i;
    730              uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
    731          
    732              RK = ctx->rk;
    733          
    734              GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
    735              GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
    736              GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
    737              GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
    738          
    739              for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
    740              {
    741                  AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
    742                  AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
    743              }
    744          
    745              AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
    746          
    747              X0 = *RK++ ^ \
    748                      ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^
    749                      ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
    750                      ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
    751                      ( (uint32_t) FSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
    752          
    753              X1 = *RK++ ^ \
    754                      ( (uint32_t) FSb[ ( Y1       ) & 0xFF ]       ) ^
    755                      ( (uint32_t) FSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
    756                      ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
    757                      ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );
    758          
    759              X2 = *RK++ ^ \
    760                      ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^
    761                      ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
    762                      ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
    763                      ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
    764          
    765              X3 = *RK++ ^ \
    766                      ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
    767                      ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
    768                      ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
    769                      ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );
    770          
    771              PUT_UINT32_LE( X0, output,  0 );
    772              PUT_UINT32_LE( X1, output,  4 );
    773              PUT_UINT32_LE( X2, output,  8 );
    774              PUT_UINT32_LE( X3, output, 12 );
    775          
    776              return( 0 );
    777          }
    778          #endif /* !MBEDTLS_AES_ENCRYPT_ALT */
    779          
    780          #if !defined(MBEDTLS_DEPRECATED_REMOVED)
    781          void mbedtls_aes_encrypt( mbedtls_aes_context *ctx,
    782                                    const unsigned char input[16],
    783                                    unsigned char output[16] )
    784          {
    785              mbedtls_internal_aes_encrypt( ctx, input, output );
    786          }
    787          #endif /* !MBEDTLS_DEPRECATED_REMOVED */
    788          
    789          /*
    790           * AES-ECB block decryption
    791           */
    792          #if !defined(MBEDTLS_AES_DECRYPT_ALT)
    793          int mbedtls_internal_aes_decrypt( mbedtls_aes_context *ctx,
    794                                            const unsigned char input[16],
    795                                            unsigned char output[16] )
    796          {
    797              int i;
    798              uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;
    799          
    800              RK = ctx->rk;
    801          
    802              GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
    803              GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
    804              GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
    805              GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
    806          
    807              for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
    808              {
    809                  AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
    810                  AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
    811              }
    812          
    813              AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );
    814          
    815              X0 = *RK++ ^ \
    816                      ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^
    817                      ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
    818                      ( (uint32_t) RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
    819                      ( (uint32_t) RSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
    820          
    821              X1 = *RK++ ^ \
    822                      ( (uint32_t) RSb[ ( Y1       ) & 0xFF ]       ) ^
    823                      ( (uint32_t) RSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
    824                      ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
    825                      ( (uint32_t) RSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );
    826          
    827              X2 = *RK++ ^ \
    828                      ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
    829                      ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
    830                      ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
    831                      ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
    832          
    833              X3 = *RK++ ^ \
    834                      ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
    835                      ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
    836                      ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
    837                      ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );
    838          
    839              PUT_UINT32_LE( X0, output,  0 );
    840              PUT_UINT32_LE( X1, output,  4 );
    841              PUT_UINT32_LE( X2, output,  8 );
    842              PUT_UINT32_LE( X3, output, 12 );
    843          
    844              return( 0 );
    845          }
    846          #endif /* !MBEDTLS_AES_DECRYPT_ALT */
    847          
    848          #if !defined(MBEDTLS_DEPRECATED_REMOVED)
    849          void mbedtls_aes_decrypt( mbedtls_aes_context *ctx,
    850                                    const unsigned char input[16],
    851                                    unsigned char output[16] )
    852          {
    853              mbedtls_internal_aes_decrypt( ctx, input, output );
    854          }
    855          #endif /* !MBEDTLS_DEPRECATED_REMOVED */
    856          
    857          /*
    858           * AES-ECB block encryption/decryption
    859           */
    860          int mbedtls_aes_crypt_ecb( mbedtls_aes_context *ctx,
    861                              int mode,
    862                              const unsigned char input[16],
    863                              unsigned char output[16] )
    864          {
    865          #if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)
    866              if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )
    867                  return( mbedtls_aesni_crypt_ecb( ctx, mode, input, output ) );
    868          #endif
    869          
    870          #if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_HAVE_X86)
    871              if( aes_padlock_ace )
    872              {
    873                  if( mbedtls_padlock_xcryptecb( ctx, mode, input, output ) == 0 )
    874                      return( 0 );
    875          
    876                  // If padlock data misaligned, we just fall back to
    877                  // unaccelerated mode
    878                  //
    879              }
    880          #endif
    881          
    882              if( mode == MBEDTLS_AES_ENCRYPT )
    883                  return( mbedtls_internal_aes_encrypt( ctx, input, output ) );
    884              else
    885                  return( mbedtls_internal_aes_decrypt( ctx, input, output ) );
    886          }
    887          
    888          #if defined(MBEDTLS_CIPHER_MODE_CBC)
    889          /*
    890           * AES-CBC buffer encryption/decryption
    891           */
    892          int mbedtls_aes_crypt_cbc( mbedtls_aes_context *ctx,
    893                              int mode,
    894                              size_t length,
    895                              unsigned char iv[16],
    896                              const unsigned char *input,
    897                              unsigned char *output )
    898          {
    899              int i;
    900              unsigned char temp[16];
    901          
    902              if( length % 16 )
    903                  return( MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH );
    904          
    905          #if defined(MBEDTLS_PADLOCK_C) && defined(MBEDTLS_HAVE_X86)
    906              if( aes_padlock_ace )
    907              {
    908                  if( mbedtls_padlock_xcryptcbc( ctx, mode, length, iv, input, output ) == 0 )
    909                      return( 0 );
    910          
    911                  // If padlock data misaligned, we just fall back to
    912                  // unaccelerated mode
    913                  //
    914              }
    915          #endif
    916          
    917              if( mode == MBEDTLS_AES_DECRYPT )
    918              {
    919                  while( length > 0 )
    920                  {
    921                      memcpy( temp, input, 16 );
    922                      mbedtls_aes_crypt_ecb( ctx, mode, input, output );
    923          
    924                      for( i = 0; i < 16; i++ )
    925                          output[i] = (unsigned char)( output[i] ^ iv[i] );
    926          
    927                      memcpy( iv, temp, 16 );
    928          
    929                      input  += 16;
    930                      output += 16;
    931                      length -= 16;
    932                  }
    933              }
    934              else
    935              {
    936                  while( length > 0 )
    937                  {
    938                      for( i = 0; i < 16; i++ )
    939                          output[i] = (unsigned char)( input[i] ^ iv[i] );
    940          
    941                      mbedtls_aes_crypt_ecb( ctx, mode, output, output );
    942                      memcpy( iv, output, 16 );
    943          
    944                      input  += 16;
    945                      output += 16;
    946                      length -= 16;
    947                  }
    948              }
    949          
    950              return( 0 );
    951          }
    952          #endif /* MBEDTLS_CIPHER_MODE_CBC */
    953          
    954          #if defined(MBEDTLS_CIPHER_MODE_CFB)
    955          /*
    956           * AES-CFB128 buffer encryption/decryption
    957           */
    958          int mbedtls_aes_crypt_cfb128( mbedtls_aes_context *ctx,
    959                                 int mode,
    960                                 size_t length,
    961                                 size_t *iv_off,
    962                                 unsigned char iv[16],
    963                                 const unsigned char *input,
    964                                 unsigned char *output )
    965          {
    966              int c;
    967              size_t n = *iv_off;
    968          
    969              if( mode == MBEDTLS_AES_DECRYPT )
    970              {
    971                  while( length-- )
    972                  {
    973                      if( n == 0 )
    974                          mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );
    975          
    976                      c = *input++;
    977                      *output++ = (unsigned char)( c ^ iv[n] );
    978                      iv[n] = (unsigned char) c;
    979          
    980                      n = ( n + 1 ) & 0x0F;
    981                  }
    982              }
    983              else
    984              {
    985                  while( length-- )
    986                  {
    987                      if( n == 0 )
    988                          mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );
    989          
    990                      iv[n] = *output++ = (unsigned char)( iv[n] ^ *input++ );
    991          
    992                      n = ( n + 1 ) & 0x0F;
    993                  }
    994              }
    995          
    996              *iv_off = n;
    997          
    998              return( 0 );
    999          }
   1000          
   1001          /*
   1002           * AES-CFB8 buffer encryption/decryption
   1003           */
   1004          int mbedtls_aes_crypt_cfb8( mbedtls_aes_context *ctx,
   1005                                 int mode,
   1006                                 size_t length,
   1007                                 unsigned char iv[16],
   1008                                 const unsigned char *input,
   1009                                 unsigned char *output )
   1010          {
   1011              unsigned char c;
   1012              unsigned char ov[17];
   1013          
   1014              while( length-- )
   1015              {
   1016                  memcpy( ov, iv, 16 );
   1017                  mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, iv, iv );
   1018          
   1019                  if( mode == MBEDTLS_AES_DECRYPT )
   1020                      ov[16] = *input;
   1021          
   1022                  c = *output++ = (unsigned char)( iv[0] ^ *input++ );
   1023          
   1024                  if( mode == MBEDTLS_AES_ENCRYPT )
   1025                      ov[16] = c;
   1026          
   1027                  memcpy( iv, ov + 1, 16 );
   1028              }
   1029          
   1030              return( 0 );
   1031          }
   1032          #endif /*MBEDTLS_CIPHER_MODE_CFB */
   1033          
   1034          #if defined(MBEDTLS_CIPHER_MODE_CTR)
   1035          /*
   1036           * AES-CTR buffer encryption/decryption
   1037           */
   1038          int mbedtls_aes_crypt_ctr( mbedtls_aes_context *ctx,
   1039                                 size_t length,
   1040                                 size_t *nc_off,
   1041                                 unsigned char nonce_counter[16],
   1042                                 unsigned char stream_block[16],
   1043                                 const unsigned char *input,
   1044                                 unsigned char *output )
   1045          {
   1046              int c, i;
   1047              size_t n = *nc_off;
   1048          
   1049              while( length-- )
   1050              {
   1051                  if( n == 0 ) {
   1052                      mbedtls_aes_crypt_ecb( ctx, MBEDTLS_AES_ENCRYPT, nonce_counter, stream_block );
   1053          
   1054                      for( i = 16; i > 0; i-- )
   1055                          if( ++nonce_counter[i - 1] != 0 )
   1056                              break;
   1057                  }
   1058                  c = *input++;
   1059                  *output++ = (unsigned char)( c ^ stream_block[n] );
   1060          
   1061                  n = ( n + 1 ) & 0x0F;
   1062              }
   1063          
   1064              *nc_off = n;
   1065          
   1066              return( 0 );
   1067          }
   1068          #endif /* MBEDTLS_CIPHER_MODE_CTR */
   1069          
   1070          #endif /* !MBEDTLS_AES_ALT */
   1071          
   1072          #if defined(MBEDTLS_SELF_TEST)
   1073          /*
   1074           * AES test vectors from:
   1075           *
   1076           * http://csrc.nist.gov/archive/aes/rijndael/rijndael-vals.zip
   1077           */
   1078          static const unsigned char aes_test_ecb_dec[3][16] =
   1079          {
   1080              { 0x44, 0x41, 0x6A, 0xC2, 0xD1, 0xF5, 0x3C, 0x58,
   1081                0x33, 0x03, 0x91, 0x7E, 0x6B, 0xE9, 0xEB, 0xE0 },
   1082              { 0x48, 0xE3, 0x1E, 0x9E, 0x25, 0x67, 0x18, 0xF2,
   1083                0x92, 0x29, 0x31, 0x9C, 0x19, 0xF1, 0x5B, 0xA4 },
   1084              { 0x05, 0x8C, 0xCF, 0xFD, 0xBB, 0xCB, 0x38, 0x2D,
   1085                0x1F, 0x6F, 0x56, 0x58, 0x5D, 0x8A, 0x4A, 0xDE }
   1086          };
   1087          
   1088          static const unsigned char aes_test_ecb_enc[3][16] =
   1089          {
   1090              { 0xC3, 0x4C, 0x05, 0x2C, 0xC0, 0xDA, 0x8D, 0x73,
   1091                0x45, 0x1A, 0xFE, 0x5F, 0x03, 0xBE, 0x29, 0x7F },
   1092              { 0xF3, 0xF6, 0x75, 0x2A, 0xE8, 0xD7, 0x83, 0x11,
   1093                0x38, 0xF0, 0x41, 0x56, 0x06, 0x31, 0xB1, 0x14 },
   1094              { 0x8B, 0x79, 0xEE, 0xCC, 0x93, 0xA0, 0xEE, 0x5D,
   1095                0xFF, 0x30, 0xB4, 0xEA, 0x21, 0x63, 0x6D, 0xA4 }
   1096          };
   1097          
   1098          #if defined(MBEDTLS_CIPHER_MODE_CBC)
   1099          static const unsigned char aes_test_cbc_dec[3][16] =
   1100          {
   1101              { 0xFA, 0xCA, 0x37, 0xE0, 0xB0, 0xC8, 0x53, 0x73,
   1102                0xDF, 0x70, 0x6E, 0x73, 0xF7, 0xC9, 0xAF, 0x86 },
   1103              { 0x5D, 0xF6, 0x78, 0xDD, 0x17, 0xBA, 0x4E, 0x75,
   1104                0xB6, 0x17, 0x68, 0xC6, 0xAD, 0xEF, 0x7C, 0x7B },
   1105              { 0x48, 0x04, 0xE1, 0x81, 0x8F, 0xE6, 0x29, 0x75,
   1106                0x19, 0xA3, 0xE8, 0x8C, 0x57, 0x31, 0x04, 0x13 }
   1107          };
   1108          
   1109          static const unsigned char aes_test_cbc_enc[3][16] =
   1110          {
   1111              { 0x8A, 0x05, 0xFC, 0x5E, 0x09, 0x5A, 0xF4, 0x84,
   1112                0x8A, 0x08, 0xD3, 0x28, 0xD3, 0x68, 0x8E, 0x3D },
   1113              { 0x7B, 0xD9, 0x66, 0xD5, 0x3A, 0xD8, 0xC1, 0xBB,
   1114                0x85, 0xD2, 0xAD, 0xFA, 0xE8, 0x7B, 0xB1, 0x04 },
   1115              { 0xFE, 0x3C, 0x53, 0x65, 0x3E, 0x2F, 0x45, 0xB5,
   1116                0x6F, 0xCD, 0x88, 0xB2, 0xCC, 0x89, 0x8F, 0xF0 }
   1117          };
   1118          #endif /* MBEDTLS_CIPHER_MODE_CBC */
   1119          
   1120          #if defined(MBEDTLS_CIPHER_MODE_CFB)
   1121          /*
   1122           * AES-CFB128 test vectors from:
   1123           *
   1124           * http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf
   1125           */
   1126          static const unsigned char aes_test_cfb128_key[3][32] =
   1127          {
   1128              { 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,
   1129                0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C },
   1130              { 0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52,
   1131                0xC8, 0x10, 0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5,
   1132                0x62, 0xF8, 0xEA, 0xD2, 0x52, 0x2C, 0x6B, 0x7B },
   1133              { 0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE,
   1134                0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81,
   1135                0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7,
   1136                0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4 }
   1137          };
   1138          
   1139          static const unsigned char aes_test_cfb128_iv[16] =
   1140          {
   1141              0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
   1142              0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
   1143          };
   1144          
   1145          static const unsigned char aes_test_cfb128_pt[64] =
   1146          {
   1147              0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,
   1148              0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A,
   1149              0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C,
   1150              0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51,
   1151              0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11,
   1152              0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF,
   1153              0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17,
   1154              0xAD, 0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10
   1155          };
   1156          
   1157          static const unsigned char aes_test_cfb128_ct[3][64] =
   1158          {
   1159              { 0x3B, 0x3F, 0xD9, 0x2E, 0xB7, 0x2D, 0xAD, 0x20,
   1160                0x33, 0x34, 0x49, 0xF8, 0xE8, 0x3C, 0xFB, 0x4A,
   1161                0xC8, 0xA6, 0x45, 0x37, 0xA0, 0xB3, 0xA9, 0x3F,
   1162                0xCD, 0xE3, 0xCD, 0xAD, 0x9F, 0x1C, 0xE5, 0x8B,
   1163                0x26, 0x75, 0x1F, 0x67, 0xA3, 0xCB, 0xB1, 0x40,
   1164                0xB1, 0x80, 0x8C, 0xF1, 0x87, 0xA4, 0xF4, 0xDF,
   1165                0xC0, 0x4B, 0x05, 0x35, 0x7C, 0x5D, 0x1C, 0x0E,
   1166                0xEA, 0xC4, 0xC6, 0x6F, 0x9F, 0xF7, 0xF2, 0xE6 },
   1167              { 0xCD, 0xC8, 0x0D, 0x6F, 0xDD, 0xF1, 0x8C, 0xAB,
   1168                0x34, 0xC2, 0x59, 0x09, 0xC9, 0x9A, 0x41, 0x74,
   1169                0x67, 0xCE, 0x7F, 0x7F, 0x81, 0x17, 0x36, 0x21,
   1170                0x96, 0x1A, 0x2B, 0x70, 0x17, 0x1D, 0x3D, 0x7A,
   1171                0x2E, 0x1E, 0x8A, 0x1D, 0xD5, 0x9B, 0x88, 0xB1,
   1172                0xC8, 0xE6, 0x0F, 0xED, 0x1E, 0xFA, 0xC4, 0xC9,
   1173                0xC0, 0x5F, 0x9F, 0x9C, 0xA9, 0x83, 0x4F, 0xA0,
   1174                0x42, 0xAE, 0x8F, 0xBA, 0x58, 0x4B, 0x09, 0xFF },
   1175              { 0xDC, 0x7E, 0x84, 0xBF, 0xDA, 0x79, 0x16, 0x4B,
   1176                0x7E, 0xCD, 0x84, 0x86, 0x98, 0x5D, 0x38, 0x60,
   1177                0x39, 0xFF, 0xED, 0x14, 0x3B, 0x28, 0xB1, 0xC8,
   1178                0x32, 0x11, 0x3C, 0x63, 0x31, 0xE5, 0x40, 0x7B,
   1179                0xDF, 0x10, 0x13, 0x24, 0x15, 0xE5, 0x4B, 0x92,
   1180                0xA1, 0x3E, 0xD0, 0xA8, 0x26, 0x7A, 0xE2, 0xF9,
   1181                0x75, 0xA3, 0x85, 0x74, 0x1A, 0xB9, 0xCE, 0xF8,
   1182                0x20, 0x31, 0x62, 0x3D, 0x55, 0xB1, 0xE4, 0x71 }
   1183          };
   1184          #endif /* MBEDTLS_CIPHER_MODE_CFB */
   1185          
   1186          #if defined(MBEDTLS_CIPHER_MODE_CTR)
   1187          /*
   1188           * AES-CTR test vectors from:
   1189           *
   1190           * http://www.faqs.org/rfcs/rfc3686.html
   1191           */
   1192          
   1193          static const unsigned char aes_test_ctr_key[3][16] =
   1194          {
   1195              { 0xAE, 0x68, 0x52, 0xF8, 0x12, 0x10, 0x67, 0xCC,
   1196                0x4B, 0xF7, 0xA5, 0x76, 0x55, 0x77, 0xF3, 0x9E },
   1197              { 0x7E, 0x24, 0x06, 0x78, 0x17, 0xFA, 0xE0, 0xD7,
   1198                0x43, 0xD6, 0xCE, 0x1F, 0x32, 0x53, 0x91, 0x63 },
   1199              { 0x76, 0x91, 0xBE, 0x03, 0x5E, 0x50, 0x20, 0xA8,
   1200                0xAC, 0x6E, 0x61, 0x85, 0x29, 0xF9, 0xA0, 0xDC }
   1201          };
   1202          
   1203          static const unsigned char aes_test_ctr_nonce_counter[3][16] =
   1204          {
   1205              { 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
   1206                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
   1207              { 0x00, 0x6C, 0xB6, 0xDB, 0xC0, 0x54, 0x3B, 0x59,
   1208                0xDA, 0x48, 0xD9, 0x0B, 0x00, 0x00, 0x00, 0x01 },
   1209              { 0x00, 0xE0, 0x01, 0x7B, 0x27, 0x77, 0x7F, 0x3F,
   1210                0x4A, 0x17, 0x86, 0xF0, 0x00, 0x00, 0x00, 0x01 }
   1211          };
   1212          
   1213          static const unsigned char aes_test_ctr_pt[3][48] =
   1214          {
   1215              { 0x53, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x20, 0x62,
   1216                0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x6D, 0x73, 0x67 },
   1217          
   1218              { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
   1219                0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
   1220                0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
   1221                0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F },
   1222          
   1223              { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
   1224                0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
   1225                0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
   1226                0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
   1227                0x20, 0x21, 0x22, 0x23 }
   1228          };
   1229          
   1230          static const unsigned char aes_test_ctr_ct[3][48] =
   1231          {
   1232              { 0xE4, 0x09, 0x5D, 0x4F, 0xB7, 0xA7, 0xB3, 0x79,
   1233                0x2D, 0x61, 0x75, 0xA3, 0x26, 0x13, 0x11, 0xB8 },
   1234              { 0x51, 0x04, 0xA1, 0x06, 0x16, 0x8A, 0x72, 0xD9,
   1235                0x79, 0x0D, 0x41, 0xEE, 0x8E, 0xDA, 0xD3, 0x88,
   1236                0xEB, 0x2E, 0x1E, 0xFC, 0x46, 0xDA, 0x57, 0xC8,
   1237                0xFC, 0xE6, 0x30, 0xDF, 0x91, 0x41, 0xBE, 0x28 },
   1238              { 0xC1, 0xCF, 0x48, 0xA8, 0x9F, 0x2F, 0xFD, 0xD9,
   1239                0xCF, 0x46, 0x52, 0xE9, 0xEF, 0xDB, 0x72, 0xD7,
   1240                0x45, 0x40, 0xA4, 0x2B, 0xDE, 0x6D, 0x78, 0x36,
   1241                0xD5, 0x9A, 0x5C, 0xEA, 0xAE, 0xF3, 0x10, 0x53,
   1242                0x25, 0xB2, 0x07, 0x2F }
   1243          };
   1244          
   1245          static const int aes_test_ctr_len[3] =
   1246              { 16, 32, 36 };
   1247          #endif /* MBEDTLS_CIPHER_MODE_CTR */
   1248          
   1249          /*
   1250           * Checkup routine
   1251           */
   1252          int mbedtls_aes_self_test( int verbose )
   1253          {
   1254              int ret = 0, i, j, u, mode;
   1255              unsigned int keybits;
   1256              unsigned char key[32];
   1257              unsigned char buf[64];
   1258              const unsigned char *aes_tests;
   1259          #if defined(MBEDTLS_CIPHER_MODE_CBC) || defined(MBEDTLS_CIPHER_MODE_CFB)
   1260              unsigned char iv[16];
   1261          #endif
   1262          #if defined(MBEDTLS_CIPHER_MODE_CBC)
   1263              unsigned char prv[16];
   1264          #endif
   1265          #if defined(MBEDTLS_CIPHER_MODE_CTR) || defined(MBEDTLS_CIPHER_MODE_CFB)
   1266              size_t offset;
   1267          #endif
   1268          #if defined(MBEDTLS_CIPHER_MODE_CTR)
   1269              int len;
   1270              unsigned char nonce_counter[16];
   1271              unsigned char stream_block[16];
   1272          #endif
   1273              mbedtls_aes_context ctx;
   1274          
   1275              memset( key, 0, 32 );
   1276              mbedtls_aes_init( &ctx );
   1277          
   1278              /*
   1279               * ECB mode
   1280               */
   1281              for( i = 0; i < 6; i++ )
   1282              {
   1283                  u = i >> 1;
   1284                  keybits = 128 + u * 64;
   1285                  mode = i & 1;
   1286          
   1287                  if( verbose != 0 )
   1288                      mbedtls_printf( "  AES-ECB-%3d (%s): ", keybits,
   1289                                      ( mode == MBEDTLS_AES_DECRYPT ) ? "dec" : "enc" );
   1290          
   1291                  memset( buf, 0, 16 );
   1292          
   1293                  if( mode == MBEDTLS_AES_DECRYPT )
   1294                  {
   1295                      ret = mbedtls_aes_setkey_dec( &ctx, key, keybits );
   1296                      aes_tests = aes_test_ecb_dec[u];
   1297                  }
   1298                  else
   1299                  {
   1300                      ret = mbedtls_aes_setkey_enc( &ctx, key, keybits );
   1301                      aes_tests = aes_test_ecb_enc[u];
   1302                  }
   1303          
   1304                  /*
   1305                   * AES-192 is an optional feature that may be unavailable when
   1306                   * there is an alternative underlying implementation i.e. when
   1307                   * MBEDTLS_AES_ALT is defined.
   1308                   */
   1309                  if( ret == MBEDTLS_ERR_AES_FEATURE_UNAVAILABLE && keybits == 192 )
   1310                  {
   1311                      mbedtls_printf( "skipped\n" );
   1312                      continue;
   1313                  }
   1314                  else if( ret != 0 )
   1315                  {
   1316                      goto exit;
   1317                  }
   1318          
   1319                  for( j = 0; j < 10000; j++ )
   1320                  {
   1321                      ret = mbedtls_aes_crypt_ecb( &ctx, mode, buf, buf );
   1322                      if( ret != 0 )
   1323                          goto exit;
   1324                  }
   1325          
   1326                  if( memcmp( buf, aes_tests, 16 ) != 0 )
   1327                  {
   1328                      ret = 1;
   1329                      goto exit;
   1330                  }
   1331          
   1332                  if( verbose != 0 )
   1333                      mbedtls_printf( "passed\n" );
   1334              }
   1335          
   1336              if( verbose != 0 )
   1337                  mbedtls_printf( "\n" );
   1338          
   1339          #if defined(MBEDTLS_CIPHER_MODE_CBC)
   1340              /*
   1341               * CBC mode
   1342               */
   1343              for( i = 0; i < 6; i++ )
   1344              {
   1345                  u = i >> 1;
   1346                  keybits = 128 + u * 64;
   1347                  mode = i & 1;
   1348          
   1349                  if( verbose != 0 )
   1350                      mbedtls_printf( "  AES-CBC-%3d (%s): ", keybits,
   1351                                      ( mode == MBEDTLS_AES_DECRYPT ) ? "dec" : "enc" );
   1352          
   1353                  memset( iv , 0, 16 );
   1354                  memset( prv, 0, 16 );
   1355                  memset( buf, 0, 16 );
   1356          
   1357                  if( mode == MBEDTLS_AES_DECRYPT )
   1358                  {
   1359                      ret = mbedtls_aes_setkey_dec( &ctx, key, keybits );
   1360                      aes_tests = aes_test_cbc_dec[u];
   1361                  }
   1362                  else
   1363                  {
   1364                      ret = mbedtls_aes_setkey_enc( &ctx, key, keybits );
   1365                      aes_tests = aes_test_cbc_enc[u];
   1366                  }
   1367          
   1368                  /*
   1369                   * AES-192 is an optional feature that may be unavailable when
   1370                   * there is an alternative underlying implementation i.e. when
   1371                   * MBEDTLS_AES_ALT is defined.
   1372                   */
   1373                  if( ret == MBEDTLS_ERR_AES_FEATURE_UNAVAILABLE && keybits == 192 )
   1374                  {
   1375                      mbedtls_printf( "skipped\n" );
   1376                      continue;
   1377                  }
   1378                  else if( ret != 0 )
   1379                  {
   1380                      goto exit;
   1381                  }
   1382          
   1383                  for( j = 0; j < 10000; j++ )
   1384                  {
   1385                      if( mode == MBEDTLS_AES_ENCRYPT )
   1386                      {
   1387                          unsigned char tmp[16];
   1388          
   1389                          memcpy( tmp, prv, 16 );
   1390                          memcpy( prv, buf, 16 );
   1391                          memcpy( buf, tmp, 16 );
   1392                      }
   1393          
   1394                      ret = mbedtls_aes_crypt_cbc( &ctx, mode, 16, iv, buf, buf );
   1395                      if( ret != 0 )
   1396                          goto exit;
   1397          
   1398                  }
   1399          
   1400                  if( memcmp( buf, aes_tests, 16 ) != 0 )
   1401                  {
   1402                      ret = 1;
   1403                      goto exit;
   1404                  }
   1405          
   1406                  if( verbose != 0 )
   1407                      mbedtls_printf( "passed\n" );
   1408              }
   1409          
   1410              if( verbose != 0 )
   1411                  mbedtls_printf( "\n" );
   1412          #endif /* MBEDTLS_CIPHER_MODE_CBC */
   1413          
   1414          #if defined(MBEDTLS_CIPHER_MODE_CFB)
   1415              /*
   1416               * CFB128 mode
   1417               */
   1418              for( i = 0; i < 6; i++ )
   1419              {
   1420                  u = i >> 1;
   1421                  keybits = 128 + u * 64;
   1422                  mode = i & 1;
   1423          
   1424                  if( verbose != 0 )
   1425                      mbedtls_printf( "  AES-CFB128-%3d (%s): ", keybits,
   1426                                      ( mode == MBEDTLS_AES_DECRYPT ) ? "dec" : "enc" );
   1427          
   1428                  memcpy( iv,  aes_test_cfb128_iv, 16 );
   1429                  memcpy( key, aes_test_cfb128_key[u], keybits / 8 );
   1430          
   1431                  offset = 0;
   1432                  ret = mbedtls_aes_setkey_enc( &ctx, key, keybits );
   1433                  /*
   1434                   * AES-192 is an optional feature that may be unavailable when
   1435                   * there is an alternative underlying implementation i.e. when
   1436                   * MBEDTLS_AES_ALT is defined.
   1437                   */
   1438                  if( ret == MBEDTLS_ERR_AES_FEATURE_UNAVAILABLE && keybits == 192 )
   1439                  {
   1440                      mbedtls_printf( "skipped\n" );
   1441                      continue;
   1442                  }
   1443                  else if( ret != 0 )
   1444                  {
   1445                      goto exit;
   1446                  }
   1447          
   1448                  if( mode == MBEDTLS_AES_DECRYPT )
   1449                  {
   1450                      memcpy( buf, aes_test_cfb128_ct[u], 64 );
   1451                      aes_tests = aes_test_cfb128_pt;
   1452                  }
   1453                  else
   1454                  {
   1455                      memcpy( buf, aes_test_cfb128_pt, 64 );
   1456                      aes_tests = aes_test_cfb128_ct[u];
   1457                  }
   1458          
   1459                  ret = mbedtls_aes_crypt_cfb128( &ctx, mode, 64, &offset, iv, buf, buf );
   1460                  if( ret != 0 )
   1461                      goto exit;
   1462          
   1463                  if( memcmp( buf, aes_tests, 64 ) != 0 )
   1464                  {
   1465                      ret = 1;
   1466                      goto exit;
   1467                  }
   1468          
   1469                  if( verbose != 0 )
   1470                      mbedtls_printf( "passed\n" );
   1471              }
   1472          
   1473              if( verbose != 0 )
   1474                  mbedtls_printf( "\n" );
   1475          #endif /* MBEDTLS_CIPHER_MODE_CFB */
   1476          
   1477          #if defined(MBEDTLS_CIPHER_MODE_CTR)
   1478              /*
   1479               * CTR mode
   1480               */
   1481              for( i = 0; i < 6; i++ )
   1482              {
   1483                  u = i >> 1;
   1484                  mode = i & 1;
   1485          
   1486                  if( verbose != 0 )
   1487                      mbedtls_printf( "  AES-CTR-128 (%s): ",
   1488                                      ( mode == MBEDTLS_AES_DECRYPT ) ? "dec" : "enc" );
   1489          
   1490                  memcpy( nonce_counter, aes_test_ctr_nonce_counter[u], 16 );
   1491                  memcpy( key, aes_test_ctr_key[u], 16 );
   1492          
   1493                  offset = 0;
   1494                  if( ( ret = mbedtls_aes_setkey_enc( &ctx, key, 128 ) ) != 0 )
   1495                      goto exit;
   1496          
   1497                  len = aes_test_ctr_len[u];
   1498          
   1499                  if( mode == MBEDTLS_AES_DECRYPT )
   1500                  {
   1501                      memcpy( buf, aes_test_ctr_ct[u], len );
   1502                      aes_tests = aes_test_ctr_pt[u];
   1503                  }
   1504                  else
   1505                  {
   1506                      memcpy( buf, aes_test_ctr_pt[u], len );
   1507                      aes_tests = aes_test_ctr_ct[u];
   1508                  }
   1509          
   1510                  ret = mbedtls_aes_crypt_ctr( &ctx, len, &offset, nonce_counter,
   1511                                               stream_block, buf, buf );
   1512                  if( ret != 0 )
   1513                      goto exit;
   1514          
   1515                  if( memcmp( buf, aes_tests, len ) != 0 )
   1516                  {
   1517                      ret = 1;
   1518                      goto exit;
   1519                  }
   1520          
   1521                  if( verbose != 0 )
   1522                      mbedtls_printf( "passed\n" );
   1523              }
   1524          
   1525              if( verbose != 0 )
   1526                  mbedtls_printf( "\n" );
   1527          #endif /* MBEDTLS_CIPHER_MODE_CTR */
   1528          
   1529              ret = 0;
   1530          
   1531          exit:
   1532              if( ret != 0 && verbose != 0 )
   1533                  mbedtls_printf( "failed\n" );
   1534          
   1535              mbedtls_aes_free( &ctx );
   1536          
   1537              return( ret );
   1538          }
   1539          
   1540          #endif /* MBEDTLS_SELF_TEST */
   1541          
   1542          #endif /* MBEDTLS_AES_C */


 
 
 0 bytes of memory

Errors: none
Warnings: none
