###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:45
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emdrv\dmadrv\src\dmadrv.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW393C.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emdrv\dmadrv\src\dmadrv.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"dmadrv.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0 -D
#        LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D EMBER_AF_USE_HWCONF
#        -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emdrv\dmadrv\src\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\dmadrv.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\dmadrv.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emdrv\dmadrv\src\dmadrv.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief DMADRV API implementation.
      4           *******************************************************************************
      5           * # License
      6           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      7           *******************************************************************************
      8           *
      9           * The licensor of this software is Silicon Laboratories Inc.  Your use of this
     10           * software is governed by the terms of Silicon Labs Master Software License
     11           * Agreement (MSLA) available at
     12           * www.silabs.com/about-us/legal/master-software-license-agreement.  This
     13           * software is distributed to you in Source Code format and is governed by the
     14           * sections of the MSLA applicable to Source Code.
     15           *
     16           ******************************************************************************/
     17          
     18          #include <stdbool.h>
     19          #include <stddef.h>
     20          
     21          #include "em_device.h"
     22          #include "em_cmu.h"
     23          #include "em_core.h"
     24          
     25          #include "dmadrv.h"
     26          
     27          #if defined(EMDRV_DMADRV_UDMA)
     28          #include "dmactrl.h"
     29          #endif
     30          
     31          /// @cond DO_NOT_INCLUDE_WITH_DOXYGEN
     32          
     33          #if !defined(EMDRV_DMADRV_DMA_CH_COUNT) \
     34            || (EMDRV_DMADRV_DMA_CH_COUNT > DMA_CHAN_COUNT)
     35          #define EMDRV_DMADRV_DMA_CH_COUNT DMA_CHAN_COUNT
     36          #endif
     37          
     38          typedef enum {
     39            dmaDirectionMemToPeripheral,
     40            dmaDirectionPeripheralToMem
     41          } DmaDirection_t;
     42          
     43          typedef enum {
     44            dmaModeBasic,
     45            dmaModePingPong
     46          } DmaMode_t;
     47          
     48          #if defined(EMDRV_DMADRV_USE_NATIVE_API) && defined(EMDRV_DMADRV_UDMA)
     49          typedef struct {
     50            bool              allocated;
     51          } ChTable_t;
     52          
     53          #elif defined(EMDRV_DMADRV_USE_NATIVE_API) && defined(EMDRV_DMADRV_LDMA)
     54          typedef struct {
     55            DMADRV_Callback_t callback;
     56            void              *userParam;
     57            unsigned int      callbackCount;
     58            bool              allocated;
     59          } ChTable_t;
     60          
     61          #else
     62          typedef struct {
     63            DMADRV_Callback_t callback;
     64            void              *userParam;
     65            unsigned int      callbackCount;
     66          #if defined(EMDRV_DMADRV_UDMA)
     67            int               length;
     68          #endif
     69            bool              allocated;
     70          #if defined(EMDRV_DMADRV_LDMA)
     71            DmaMode_t         mode;
     72          #endif
     73          } ChTable_t;
     74          #endif
     75          

   \                                 In section .bss, align 1
     76          static bool initialized = false;
   \                     initialized:
   \        0x0                      DS8 1

   \                                 In section .bss, align 4
     77          static ChTable_t chTable[EMDRV_DMADRV_DMA_CH_COUNT];
   \                     chTable:
   \        0x0                      DS8 128
     78          
     79          #if defined(EMDRV_DMADRV_UDMA) && !defined(EMDRV_DMADRV_USE_NATIVE_API)
     80          static DMA_CB_TypeDef dmaCallBack[EMDRV_DMADRV_DMA_CH_COUNT];
     81          #endif
     82          
     83          #if defined(EMDRV_DMADRV_LDMA) && !defined(EMDRV_DMADRV_USE_NATIVE_API)

   \                                 In section .rodata, align 4
     84          const LDMA_TransferCfg_t xferCfg = LDMA_TRANSFER_CFG_PERIPHERAL(0);
   \                     xferCfg:
   \        0x0   0x0000'0000        DC32 0
   \        0x4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
     85          const LDMA_Descriptor_t m2p = LDMA_DESCRIPTOR_SINGLE_M2P_BYTE(NULL, NULL, 1UL);
   \                     m2p:
   \        0x0   0x00 0x00          DC8 0, 0, 16, 48
   \              0x10 0x30    
   \        0x4   0x0000'0000        DC32 0, 0
   \              0x0000'0000  
   \        0xC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
     86          const LDMA_Descriptor_t p2m = LDMA_DESCRIPTOR_SINGLE_P2M_BYTE(NULL, NULL, 1UL);
   \                     p2m:
   \        0x0   0x00 0x00          DC8 0, 0, 16, 3
   \              0x10 0x03    
   \        0x4   0x0000'0000        DC32 0, 0
   \              0x0000'0000  
   \        0xC   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
     87          
     88          typedef struct {
     89            LDMA_Descriptor_t desc[2];
     90          } DmaXfer_t;
     91          

   \                                 In section .bss, align 4
     92          static DmaXfer_t dmaXfer[EMDRV_DMADRV_DMA_CH_COUNT];
   \                     dmaXfer:
   \        0x0                      DS8 256
     93          #endif
     94          
     95          #if !defined(EMDRV_DMADRV_USE_NATIVE_API)
     96          static Ecode_t StartTransfer(DmaMode_t             mode,
     97                                       DmaDirection_t        direction,
     98                                       unsigned int          channelId,
     99                                       DMADRV_PeripheralSignal_t
    100                                       peripheralSignal,
    101                                       void                  *buf0,
    102                                       void                  *buf1,
    103                                       void                  *buf2,
    104                                       bool                  bufInc,
    105                                       int                   len,
    106                                       DMADRV_DataSize_t     size,
    107                                       DMADRV_Callback_t     callback,
    108                                       void                  *cbUserParam);
    109          #endif
    110          
    111          /// @endcond
    112          
    113          /***************************************************************************//**
    114           * @brief
    115           *  Allocate (reserve) a DMA channel.
    116           *
    117           * @param[out] channelId
    118           *  The channel ID assigned by DMADRV.
    119           *
    120           * @param[in] capabilities
    121           *  Not used.
    122           *
    123           * @return
    124           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    125           *  DMADRV @ref Ecode_t is returned.
    126           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    127          Ecode_t DMADRV_AllocateChannel(unsigned int *channelId, void *capabilities)
    128          {
   \                     DMADRV_AllocateChannel: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
    129            int i;
    130            (void)capabilities;
    131            CORE_DECLARE_IRQ_STATE;
    132          
    133            if ( !initialized ) {
   \        0x4   0x....'....        LDR.W    R1,??DataTable16
   \        0x8   0x7808             LDRB     R0,[R1, #+0]
   \        0xA   0xB910             CBNZ.N   R0,??DMADRV_AllocateChannel_0
    134              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0xC   0x....'....        LDR.W    R0,??DataTable16_1  ;; 0xf0008002
   \       0x10   0xBD70             POP      {R4-R6,PC}
    135            }
    136          
    137            if ( channelId == NULL ) {
   \                     ??DMADRV_AllocateChannel_0: (+1)
   \       0x12   0xB914             CBNZ.N   R4,??DMADRV_AllocateChannel_1
    138              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \       0x14   0x....'....        LDR.W    R0,??DataTable16_2  ;; 0xf0008001
   \       0x18   0xBD70             POP      {R4-R6,PC}
    139            }
    140          
    141            CORE_ENTER_ATOMIC();
   \                     ??DMADRV_AllocateChannel_1: (+1)
   \       0x1A   0x....'....        BL       CORE_EnterAtomic
   \       0x1E   0x4601             MOV      R1,R0
    142            for ( i = 0; i < (int)EMDRV_DMADRV_DMA_CH_COUNT; i++ ) {
   \       0x20   0x2200             MOVS     R2,#+0
   \       0x22   0x....'....        LDR.W    R3,??DataTable16_3
    143              if ( !chTable[i].allocated ) {
   \                     ??DMADRV_AllocateChannel_2: (+1)
   \       0x26   0x0115             LSLS     R5,R2,#+4
   \       0x28   0x195E             ADDS     R6,R3,R5
   \       0x2A   0x7B30             LDRB     R0,[R6, #+12]
   \       0x2C   0xB140             CBZ.N    R0,??DMADRV_AllocateChannel_3
   \       0x2E   0x1C52             ADDS     R2,R2,#+1
   \       0x30   0x2A08             CMP      R2,#+8
   \       0x32   0xDBF8             BLT.N    ??DMADRV_AllocateChannel_2
    144                *channelId             = i;
    145                chTable[i].allocated = true;
    146          #if !defined(EMDRV_DMADRV_USE_NATIVE_API) || defined(EMDRV_DMADRV_LDMA)
    147                chTable[i].callback  = NULL;
    148          #endif
    149                CORE_EXIT_ATOMIC();
    150                return ECODE_EMDRV_DMADRV_OK;
    151              }
    152            }
    153            CORE_EXIT_ATOMIC();
   \       0x34   0x4608             MOV      R0,R1
   \       0x36   0x....'....        BL       CORE_ExitAtomic
    154            return ECODE_EMDRV_DMADRV_CHANNELS_EXHAUSTED;
   \       0x3A   0x....'....        LDR.W    R0,??DataTable16_4  ;; 0xf0008004
   \       0x3E   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??DMADRV_AllocateChannel_3: (+1)
   \       0x40   0x6022             STR      R2,[R4, #+0]
   \       0x42   0x2001             MOVS     R0,#+1
   \       0x44   0x7330             STRB     R0,[R6, #+12]
   \       0x46   0x2200             MOVS     R2,#+0
   \       0x48   0x515A             STR      R2,[R3, R5]
   \       0x4A   0x4608             MOV      R0,R1
   \       0x4C   0x....'....        BL       CORE_ExitAtomic
   \       0x50   0x2000             MOVS     R0,#+0
   \       0x52   0xBD70             POP      {R4-R6,PC}
    155          }
    156          
    157          /***************************************************************************//**
    158           * @brief
    159           *  Deinitialize DMADRV.
    160           *
    161           * @details
    162           *  If DMA channels are not currently allocated, it will disable DMA hardware
    163           *  and mask associated interrupts.
    164           *
    165           * @return
    166           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    167           *  DMADRV @ref Ecode_t is returned.
    168           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    169          Ecode_t DMADRV_DeInit(void)
    170          {
   \                     DMADRV_DeInit: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    171            int i;
    172            bool inUse;
    173            CORE_DECLARE_IRQ_STATE;
    174          
    175            inUse = false;
    176          
    177            CORE_ENTER_ATOMIC();
   \        0x2   0x....'....        BL       CORE_EnterAtomic
   \        0x6   0x4604             MOV      R4,R0
    178            for ( i = 0; i < (int)EMDRV_DMADRV_DMA_CH_COUNT; i++ ) {
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x....'....        LDR.W    R2,??DataTable16_3
    179              if ( chTable[i].allocated ) {
   \                     ??DMADRV_DeInit_0: (+1)
   \        0xE   0xEB02 0x1301      ADD      R3,R2,R1, LSL #+4
   \       0x12   0x7B18             LDRB     R0,[R3, #+12]
   \       0x14   0xB950             CBNZ.N   R0,??DMADRV_DeInit_1
   \       0x16   0x1C49             ADDS     R1,R1,#+1
   \       0x18   0x2908             CMP      R1,#+8
   \       0x1A   0xDBF8             BLT.N    ??DMADRV_DeInit_0
    180                inUse = true;
    181                break;
    182              }
    183            }
    184          
    185            if ( !inUse ) {
    186          #if defined(EMDRV_DMADRV_UDMA)
    187              NVIC_DisableIRQ(DMA_IRQn);
    188              DMA->IEN    = _DMA_IEN_RESETVALUE;
    189              DMA->CONFIG = _DMA_CONFIG_RESETVALUE;
    190              CMU_ClockEnable(cmuClock_DMA, false);
    191          #elif defined(EMDRV_DMADRV_LDMA)
    192              LDMA_DeInit();
   \       0x1C   0x....'....        BL       LDMA_DeInit
    193          #endif
    194              initialized = false;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0x....'....        LDR.W    R1,??DataTable16
   \       0x26   0x7008             STRB     R0,[R1, #+0]
    195              CORE_EXIT_ATOMIC();
   \       0x28   0x4620             MOV      R0,R4
   \       0x2A   0x....             B.N      ?Subroutine0
    196              return ECODE_EMDRV_DMADRV_OK;
    197            }
    198            CORE_EXIT_ATOMIC();
   \                     ??DMADRV_DeInit_1: (+1)
   \       0x2C   0x4620             MOV      R0,R4
   \       0x2E   0x....'....        BL       CORE_ExitAtomic
    199          
    200            return ECODE_EMDRV_DMADRV_IN_USE;
   \       0x32   0x....'....        LDR.W    R0,??DataTable16_5  ;; 0xf0008005
   \       0x36   0xBD10             POP      {R4,PC}
    201          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x....'....        BL       CORE_ExitAtomic
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xBD10             POP      {R4,PC}          ;; return
    202          
    203          /***************************************************************************//**
    204           * @brief
    205           *  Free an allocated (reserved) DMA channel.
    206           *
    207           * @param[in] channelId
    208           *  The channel ID to free.
    209           *
    210           * @return
    211           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    212           *  DMADRV @ref Ecode_t is returned.
    213           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    214          Ecode_t DMADRV_FreeChannel(unsigned int channelId)
    215          {
   \                     DMADRV_FreeChannel: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x4604             MOV      R4,R0
    216            CORE_DECLARE_IRQ_STATE;
    217          
    218            if ( !initialized ) {
   \        0x4   0x....'....        LDR.W    R1,??DataTable16
   \        0x8   0x7808             LDRB     R0,[R1, #+0]
   \        0xA   0xB900             CBNZ.N   R0,??DMADRV_FreeChannel_0
    219              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0xC   0x....             B.N      ?Subroutine3
    220            }
    221          
    222            if ( channelId >= EMDRV_DMADRV_DMA_CH_COUNT ) {
   \                     ??DMADRV_FreeChannel_0: (+1)
   \        0xE   0x2C08             CMP      R4,#+8
   \       0x10   0xD300             BCC.N    ??DMADRV_FreeChannel_1
    223              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \       0x12   0x....             B.N      ?Subroutine2
    224            }
    225          
    226            CORE_ENTER_ATOMIC();
   \                     ??DMADRV_FreeChannel_1: (+1)
   \       0x14   0x....'....        BL       CORE_EnterAtomic
    227            if ( chTable[channelId].allocated ) {
   \       0x18   0x....'....        LDR.W    R2,??DataTable16_3
   \       0x1C   0xEB02 0x1204      ADD      R2,R2,R4, LSL #+4
   \       0x20   0x7B11             LDRB     R1,[R2, #+12]
   \       0x22   0xB111             CBZ.N    R1,??DMADRV_FreeChannel_2
    228              chTable[channelId].allocated = false;
   \       0x24   0x2300             MOVS     R3,#+0
   \       0x26   0x7313             STRB     R3,[R2, #+12]
    229              CORE_EXIT_ATOMIC();
   \       0x28   0x....             B.N      ?Subroutine0
    230              return ECODE_EMDRV_DMADRV_OK;
    231            }
    232            CORE_EXIT_ATOMIC();
   \                     ??DMADRV_FreeChannel_2: (+1)
   \       0x2A   0x....'....        BL       CORE_ExitAtomic
    233          
    234            return ECODE_EMDRV_DMADRV_ALREADY_FREED;
   \       0x2E   0x....'....        LDR.W    R0,??DataTable16_6  ;; 0xf0008006
   \       0x32   0xBD10             POP      {R4,PC}          ;; return
    235          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_1  ;; 0xf0008002
   \        0x2   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_2  ;; 0xf0008001
   \        0x2   0xBD10             POP      {R4,PC}
    236          
    237          /***************************************************************************//**
    238           * @brief
    239           *  Initialize DMADRV.
    240           *
    241           * @details
    242           *  The DMA hardware is initialized.
    243           *
    244           * @return
    245           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    246           *  DMADRV @ref Ecode_t is returned.
    247           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    248          Ecode_t DMADRV_Init(void)
    249          {
   \                     DMADRV_Init: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    250            int i;
    251            CORE_DECLARE_IRQ_STATE;
    252          #if defined(EMDRV_DMADRV_UDMA)
    253            DMA_Init_TypeDef dmaInit;
    254          #elif defined(EMDRV_DMADRV_LDMA)
    255            LDMA_Init_t dmaInit = LDMA_INIT_DEFAULT;
   \        0x2   0x....'....        LDR.W    R1,??DataTable16_7
   \        0x6   0x680A             LDR      R2,[R1, #+0]
    256            dmaInit.ldmaInitCtrlNumFixed = EMDRV_DMADRV_DMA_CH_PRIORITY;
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x9200             STR      R2,[SP, #+0]
   \        0xC   0xF88D 0x3000      STRB     R3,[SP, #+0]
    257          #endif
    258          
    259            CORE_ENTER_ATOMIC();
   \       0x10   0x....'....        BL       CORE_EnterAtomic
    260            if ( initialized ) {
   \       0x14   0x....'....        BL       ??Subroutine13_0
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x18   0xB121             CBZ.N    R1,??DMADRV_Init_0
    261              CORE_EXIT_ATOMIC();
   \       0x1A   0x....'....        BL       CORE_ExitAtomic
    262              return ECODE_EMDRV_DMADRV_ALREADY_INITIALIZED;
   \       0x1E   0x....'....        LDR.W    R0,??DataTable16_8  ;; 0xf0008003
   \       0x22   0xBD02             POP      {R1,PC}
    263            }
    264            initialized = true;
   \                     ??DMADRV_Init_0: (+1)
   \       0x24   0x2101             MOVS     R1,#+1
   \       0x26   0x7011             STRB     R1,[R2, #+0]
    265            CORE_EXIT_ATOMIC();
   \       0x28   0x....'....        BL       CORE_ExitAtomic
    266          
    267            if ( EMDRV_DMADRV_DMA_IRQ_PRIORITY > 7 ) {
    268              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
    269            }
    270          
    271            for ( i = 0; i < (int)EMDRV_DMADRV_DMA_CH_COUNT; i++ ) {
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x....'....        LDR.W    R1,??DataTable16_3
   \       0x32   0x2200             MOVS     R2,#+0
    272              chTable[i].allocated = false;
   \                     ??DMADRV_Init_1: (+1)
   \       0x34   0xEB01 0x1300      ADD      R3,R1,R0, LSL #+4
    273            }
   \       0x38   0x1C40             ADDS     R0,R0,#+1
   \       0x3A   0x2808             CMP      R0,#+8
   \       0x3C   0x731A             STRB     R2,[R3, #+12]
   \       0x3E   0xDBF9             BLT.N    ??DMADRV_Init_1
    274          
    275          #if defined(EMDRV_DMADRV_UDMA)
    276            NVIC_SetPriority(DMA_IRQn, EMDRV_DMADRV_DMA_IRQ_PRIORITY);
    277            dmaInit.hprot        = 0;
    278            dmaInit.controlBlock = dmaControlBlock;
    279            DMA_Init(&dmaInit);
    280          #elif defined(EMDRV_DMADRV_LDMA)
    281            dmaInit.ldmaInitIrqPriority = EMDRV_DMADRV_DMA_IRQ_PRIORITY;
   \       0x40   0x2004             MOVS     R0,#+4
   \       0x42   0xF88D 0x0003      STRB     R0,[SP, #+3]
    282            LDMA_Init(&dmaInit);
   \       0x46   0x4668             MOV      R0,SP
   \       0x48   0x....'....        BL       LDMA_Init
    283          #endif
    284          
    285            return ECODE_EMDRV_DMADRV_OK;
   \       0x4C   0x2000             MOVS     R0,#+0
   \       0x4E   0xBD02             POP      {R1,PC}          ;; return
    286          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine13: (+1)
   \        0x0   0x460C             MOV      R4,R1
   \                     ??Subroutine13_0: (+1)
   \        0x2   0x....             LDR.N    R2,??DataTable16
   \        0x4   0x7811             LDRB     R1,[R2, #+0]
   \        0x6   0x4770             BX       LR

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x1E 0x00          DC8 30, 0, 0, 3
   \              0x00 0x03    
    287          
    288          #if defined(EMDRV_DMADRV_LDMA) && defined(EMDRV_DMADRV_USE_NATIVE_API)
    289          /***************************************************************************//**
    290           * @brief
    291           *  Start an LDMA transfer.
    292           *
    293           * @details
    294           *  This function can only be used on LDMA when @ref EMDRV_DMADRV_USE_NATIVE_API
    295           *  is defined. It is a wrapper similar to emlib LDMA function.
    296           *
    297           * @param[in] channelId
    298           *  The channel ID to use.
    299           *
    300           * @param[in] transfer
    301           *  A DMA transfer configuration data structure.
    302           *
    303           * @param[in] descriptor
    304           *  A DMA transfer descriptor, can be an array of descriptors linked together.
    305           *
    306           * @param[in] callback
    307           *  An optional callback function for signalling completion. May be NULL if not
    308           *  needed.
    309           *
    310           * @param[in] cbUserParam
    311           *  An optional user parameter to feed to the callback function. May be NULL if
    312           *  not needed.
    313           *
    314           * @return
    315           *   @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    316           *   DMADRV @ref Ecode_t is returned.
    317           ******************************************************************************/
    318          Ecode_t DMADRV_LdmaStartTransfer(int                channelId,
    319                                           LDMA_TransferCfg_t *transfer,
    320                                           LDMA_Descriptor_t  *descriptor,
    321                                           DMADRV_Callback_t  callback,
    322                                           void               *cbUserParam)
    323          {
    324            ChTable_t *ch;
    325          
    326            if ( !initialized ) {
    327              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
    328            }
    329          
    330            if ( channelId >= (int)EMDRV_DMADRV_DMA_CH_COUNT ) {
    331              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
    332            }
    333          
    334            ch = &chTable[channelId];
    335            if ( ch->allocated == false ) {
    336              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
    337            }
    338          
    339            ch->callback      = callback;
    340            ch->userParam     = cbUserParam;
    341            ch->callbackCount = 0;
    342            LDMA_StartTransfer(channelId, transfer, descriptor);
    343          
    344            return ECODE_EMDRV_DMADRV_OK;
    345          }
    346          #endif
    347          
    348          #if !defined(EMDRV_DMADRV_USE_NATIVE_API) || defined(DOXY_DOC_ONLY)
    349          /***************************************************************************//**
    350           * @brief
    351           *  Start a memory to a peripheral DMA transfer.
    352           *
    353           * @param[in] channelId
    354           *  The channel ID to use for the transfer.
    355           *
    356           * @param[in] peripheralSignal
    357           *  Selects which peripheral/peripheralsignal to use.
    358           *
    359           * @param[in] dst
    360           *  A destination (peripheral register) memory address.
    361           *
    362           * @param[in] src
    363           *  A source memory address.
    364           *
    365           * @param[in] srcInc
    366           *  Set to true to enable source address increment (increments according to
    367           *  @a size parameter).
    368           *
    369           * @param[in] len
    370           *  A number of items (of @a size size) to transfer.
    371           *
    372           * @param[in] size
    373           *  An item size, byte, halfword or word.
    374           *
    375           * @param[in] callback
    376           *  A function to call on DMA completion, use NULL if not needed.
    377           *
    378           * @param[in] cbUserParam
    379           *  An optional user parameter to feed to the callback function. Use NULL if
    380           *  not needed.
    381           *
    382           * @return
    383           *   @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    384           *   DMADRV @ref Ecode_t is returned.
    385           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    386          Ecode_t DMADRV_MemoryPeripheral(unsigned int          channelId,
    387                                          DMADRV_PeripheralSignal_t
    388                                          peripheralSignal,
    389                                          void                  *dst,
    390                                          void                  *src,
    391                                          bool                  srcInc,
    392                                          int                   len,
    393                                          DMADRV_DataSize_t     size,
    394                                          DMADRV_Callback_t     callback,
    395                                          void                  *cbUserParam)
    396          {
   \                     DMADRV_MemoryPeripheral: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x....'....        BL       ?Subroutine11
    397            return StartTransfer(dmaModeBasic,
    398                                 dmaDirectionMemToPeripheral,
    399                                 channelId,
    400                                 peripheralSignal,
    401                                 dst,
    402                                 src,
    403                                 NULL,
    404                                 srcInc,
    405                                 len,
    406                                 size,
    407                                 callback,
    408                                 cbUserParam);
   \                     ??CrossCallReturnLabel_5: (+1)
   \        0x8   0x2100             MOVS     R1,#+0
   \        0xA   0x....             B.N      ?Subroutine9

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \                     ??Subroutine9_0: (+1)
   \        0x2   0x....'....        BL       StartTransfer
   \        0x6   0xB009             ADD      SP,SP,#+36
   \        0x8   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x9C10             LDR      R4,[SP, #+64]
   \        0x2   0x9D0E             LDR      R5,[SP, #+56]
   \        0x4   0x9E0F             LDR      R6,[SP, #+60]
   \        0x6   0x9F11             LDR      R7,[SP, #+68]
   \        0x8   0xF8DD 0xC048      LDR      R12,[SP, #+72]
   \        0xC   0x9405             STR      R4,[SP, #+20]
   \        0xE   0x9301             STR      R3,[SP, #+4]
   \       0x10   0x9200             STR      R2,[SP, #+0]
   \       0x12   0x2400             MOVS     R4,#+0
   \       0x14   0x460B             MOV      R3,R1
   \       0x16   0x4602             MOV      R2,R0
   \       0x18   0xF8CD 0xC01C      STR      R12,[SP, #+28]
   \       0x1C   0x9706             STR      R7,[SP, #+24]
   \       0x1E   0x9604             STR      R6,[SP, #+16]
   \       0x20   0x9503             STR      R5,[SP, #+12]
   \       0x22   0x9402             STR      R4,[SP, #+8]
   \       0x24   0x4770             BX       LR
    409          }
    410          #endif
    411          
    412          #if !defined(EMDRV_DMADRV_USE_NATIVE_API) || defined(DOXY_DOC_ONLY)
    413          /***************************************************************************//**
    414           * @brief
    415           *  Start a memory to a peripheral ping-pong DMA transfer.
    416           *
    417           * @param[in] channelId
    418           *  The channel ID to use for the transfer.
    419           *
    420           * @param[in] peripheralSignal
    421           *  Selects which peripheral/peripheralsignal to use.
    422           *
    423           * @param[in] dst
    424           *  A destination (peripheral register) memory address.
    425           *
    426           * @param[in] src0
    427           *  A source memory address of the first (ping) buffer.
    428           *
    429           * @param[in] src1
    430           *  A source memory address of the second (pong) buffer.
    431           *
    432           * @param[in] srcInc
    433           *  Set to true to enable source address increment (increments according to
    434           *  @a size parameter).
    435           *
    436           * @param[in] len
    437           *  A number of items (of @a size size) to transfer.
    438           *
    439           * @param[in] size
    440           *  An item size, byte, halfword or word.
    441           *
    442           * @param[in] callback
    443           *  A function to call on DMA completion, use NULL if not needed.
    444           *
    445           * @param[in] cbUserParam
    446           *  An optional user parameter to feed to the callback function. Use NULL if
    447           *  not needed.
    448           *
    449           * @return
    450           *   @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    451           *   DMADRV @ref Ecode_t is returned.
    452           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    453          Ecode_t DMADRV_MemoryPeripheralPingPong(
    454            unsigned int          channelId,
    455            DMADRV_PeripheralSignal_t
    456            peripheralSignal,
    457            void                  *dst,
    458            void                  *src0,
    459            void                  *src1,
    460            bool                  srcInc,
    461            int                   len,
    462            DMADRV_DataSize_t     size,
    463            DMADRV_Callback_t     callback,
    464            void                  *cbUserParam)
    465          {
   \                     DMADRV_MemoryPeripheralPingPong: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x....'....        BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_15: (+1)
   \        0x8   0xF8DD 0xE04C      LDR      LR,[SP, #+76]
    466            return StartTransfer(dmaModePingPong,
    467                                 dmaDirectionMemToPeripheral,
    468                                 channelId,
    469                                 peripheralSignal,
    470                                 dst,
    471                                 src0,
    472                                 src1,
    473                                 srcInc,
    474                                 len,
    475                                 size,
    476                                 callback,
    477                                 cbUserParam);
   \        0xC   0x9301             STR      R3,[SP, #+4]
   \        0xE   0x9200             STR      R2,[SP, #+0]
   \       0x10   0x460B             MOV      R3,R1
   \       0x12   0x4602             MOV      R2,R0
   \       0x14   0xF8CD 0xE01C      STR      LR,[SP, #+28]
   \       0x18   0x....'....        BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x1C   0x2100             MOVS     R1,#+0
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0x....             B.N      ??Subroutine9_0
    478          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine15: (+1)
   \        0x0   0xF8CD 0xC018      STR      R12,[SP, #+24]
   \        0x4   0x9405             STR      R4,[SP, #+20]
   \        0x6   0x9704             STR      R7,[SP, #+16]
   \        0x8   0x9503             STR      R5,[SP, #+12]
   \        0xA   0x9602             STR      R6,[SP, #+8]
   \        0xC   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine14: (+1)
   \        0x0   0x9E0E             LDR      R6,[SP, #+56]
   \        0x2   0x9D0F             LDR      R5,[SP, #+60]
   \        0x4   0x9F10             LDR      R7,[SP, #+64]
   \        0x6   0x9C11             LDR      R4,[SP, #+68]
   \        0x8   0xF8DD 0xC048      LDR      R12,[SP, #+72]
   \        0xC   0x4770             BX       LR
    479          #endif
    480          
    481          #if !defined(EMDRV_DMADRV_USE_NATIVE_API) || defined(DOXY_DOC_ONLY)
    482          /***************************************************************************//**
    483           * @brief
    484           *  Start a peripheral to memory DMA transfer.
    485           *
    486           * @param[in] channelId
    487           *  The channel ID to use for the transfer.
    488           *
    489           * @param[in] peripheralSignal
    490           *  Selects which peripheral/peripheralsignal to use.
    491           *
    492           * @param[in] dst
    493           *  A destination memory address.
    494           *
    495           * @param[in] src
    496           *  A source memory (peripheral register) address.
    497           *
    498           * @param[in] dstInc
    499           *  Set to true to enable destination address increment (increments according
    500           *  to @a size parameter).
    501           *
    502           * @param[in] len
    503           *  A number of items (of @a size size) to transfer.
    504           *
    505           * @param[in] size
    506           *  An item size, byte, halfword or word.
    507           *
    508           * @param[in] callback
    509           *  A function to call on DMA completion, use NULL if not needed.
    510           *
    511           * @param[in] cbUserParam
    512           *  An optional user parameter to feed to the callback function. Use NULL if
    513           *  not needed.
    514           *
    515           * @return
    516           *   @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    517           *   DMADRV @ref Ecode_t is returned.
    518           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    519          Ecode_t DMADRV_PeripheralMemory(unsigned int          channelId,
    520                                          DMADRV_PeripheralSignal_t
    521                                          peripheralSignal,
    522                                          void                  *dst,
    523                                          void                  *src,
    524                                          bool                  dstInc,
    525                                          int                   len,
    526                                          DMADRV_DataSize_t     size,
    527                                          DMADRV_Callback_t     callback,
    528                                          void                  *cbUserParam)
    529          {
   \                     DMADRV_PeripheralMemory: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x....'....        BL       ?Subroutine11
    530            return StartTransfer(dmaModeBasic,
    531                                 dmaDirectionPeripheralToMem,
    532                                 channelId,
    533                                 peripheralSignal,
    534                                 dst,
    535                                 src,
    536                                 NULL,
    537                                 dstInc,
    538                                 len,
    539                                 size,
    540                                 callback,
    541                                 cbUserParam);
   \                     ??CrossCallReturnLabel_6: (+1)
   \        0x8   0x2101             MOVS     R1,#+1
   \        0xA                      REQUIRE ?Subroutine9
   \        0xA                      ;; // Fall through to label ?Subroutine9
    542          }
    543          #endif
    544          
    545          #if !defined(EMDRV_DMADRV_USE_NATIVE_API) || defined(DOXY_DOC_ONLY)
    546          /***************************************************************************//**
    547           * @brief
    548           *  Start a peripheral to memory ping-pong DMA transfer.
    549           *
    550           * @param[in] channelId
    551           *  The channel ID to use for the transfer.
    552           *
    553           * @param[in] peripheralSignal
    554           *  Selects which peripheral/peripheralsignal to use.
    555           *
    556           * @param[in] dst0
    557           *  A destination memory address of the first (ping) buffer.
    558           *
    559           * @param[in] dst1
    560           *  A destination memory address of the second (pong) buffer.
    561           *
    562           * @param[in] src
    563           *  A source memory (peripheral register) address.
    564           *
    565           * @param[in] dstInc
    566           *  Set to true to enable destination address increment (increments according
    567           *  to @a size parameter).
    568           *
    569           * @param[in] len
    570           *  A number of items (of @a size size) to transfer.
    571           *
    572           * @param[in] size
    573           *  An item size, byte, halfword or word.
    574           *
    575           * @param[in] callback
    576           *  A function to call on DMA completion, use NULL if not needed.
    577           *
    578           * @param[in] cbUserParam
    579           *  An optional user parameter to feed to the callback function. Use NULL if
    580           *  not needed.
    581           *
    582           * @return
    583           *   @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    584           *   DMADRV @ref Ecode_t is returned.
    585           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    586          Ecode_t DMADRV_PeripheralMemoryPingPong(
    587            unsigned int          channelId,
    588            DMADRV_PeripheralSignal_t
    589            peripheralSignal,
    590            void                  *dst0,
    591            void                  *dst1,
    592            void                  *src,
    593            bool                  dstInc,
    594            int                   len,
    595            DMADRV_DataSize_t     size,
    596            DMADRV_Callback_t     callback,
    597            void                  *cbUserParam)
    598          {
   \                     DMADRV_PeripheralMemoryPingPong: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0xB088             SUB      SP,SP,#+32
   \        0x4   0x....'....        BL       ?Subroutine14
   \                     ??CrossCallReturnLabel_16: (+1)
   \        0x8   0xF8DD 0xE04C      LDR      LR,[SP, #+76]
    599            return StartTransfer(dmaModePingPong,
    600                                 dmaDirectionPeripheralToMem,
    601                                 channelId,
    602                                 peripheralSignal,
    603                                 dst0,
    604                                 dst1,
    605                                 src,
    606                                 dstInc,
    607                                 len,
    608                                 size,
    609                                 callback,
    610                                 cbUserParam);
   \        0xC   0x9301             STR      R3,[SP, #+4]
   \        0xE   0x9200             STR      R2,[SP, #+0]
   \       0x10   0x460B             MOV      R3,R1
   \       0x12   0x4602             MOV      R2,R0
   \       0x14   0xF8CD 0xE01C      STR      LR,[SP, #+28]
   \       0x18   0x....'....        BL       ?Subroutine15
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x1C   0x2101             MOVS     R1,#+1
   \       0x1E   0x2001             MOVS     R0,#+1
   \       0x20   0x....             B.N      ??Subroutine9_0
    611          }
    612          #endif /* !defined( EMDRV_DMADRV_USE_NATIVE_API ) */
    613          
    614          /***************************************************************************//**
    615           * @brief
    616           *  Pause an ongoing DMA transfer.
    617           *
    618           * @param[in] channelId
    619           *  The channel ID of the transfer to pause.
    620           *
    621           * @return
    622           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    623           *  DMADRV @ref Ecode_t is returned.
    624           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    625          Ecode_t DMADRV_PauseTransfer(unsigned int channelId)
    626          {
   \                     DMADRV_PauseTransfer: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    627            if ( !initialized ) {
   \        0x2   0x....'....        BL       ??Subroutine13_0
   \                     ??CrossCallReturnLabel_12: (+1)
   \        0x6   0xB901             CBNZ.N   R1,??DMADRV_PauseTransfer_0
    628              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0x8   0x....             B.N      ?Subroutine8
    629            }
    630          
    631            if ( channelId >= EMDRV_DMADRV_DMA_CH_COUNT ) {
   \                     ??DMADRV_PauseTransfer_0: (+1)
   \        0xA   0x2808             CMP      R0,#+8
   \        0xC   0xD300             BCC.N    ??DMADRV_PauseTransfer_1
    632              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \        0xE   0x....             B.N      ?Subroutine7
    633            }
    634          
    635            if ( chTable[channelId].allocated == false ) {
   \                     ??DMADRV_PauseTransfer_1: (+1)
   \       0x10   0x....'....        BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x14   0xB901             CBNZ.N   R1,??DMADRV_PauseTransfer_2
    636              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   \       0x16   0x....             B.N      ?Subroutine6
    637            }
    638          
    639          #if defined(EMDRV_DMADRV_UDMA)
    640            DMA_ChannelRequestEnable(channelId, false);
    641          #elif defined(EMDRV_DMADRV_LDMA)
    642            LDMA_EnableChannelRequest(channelId, false);
   \                     ??DMADRV_PauseTransfer_2: (+1)
   \       0x18   0x2100             MOVS     R1,#+0
   \       0x1A   0x....             B.N      ?Subroutine5
    643          #endif
    644          
    645            return ECODE_EMDRV_DMADRV_OK;
    646          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_1  ;; 0xf0008002
   \        0x2   0xBD02             POP      {R1,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_2  ;; 0xf0008001
   \        0x2   0xBD02             POP      {R1,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_9  ;; 0xf0008007
   \        0x2   0xBD02             POP      {R1,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x....'....        BL       LDMA_EnableChannelRequest
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0x....             LDR.N    R2,??DataTable16_3
   \        0x2   0xEB02 0x1300      ADD      R3,R2,R0, LSL #+4
   \        0x6   0x7B19             LDRB     R1,[R3, #+12]
   \        0x8   0x4770             BX       LR
    647          
    648          /***************************************************************************//**
    649           * @brief
    650           *  Resume an ongoing DMA transfer.
    651           *
    652           * @param[in] channelId
    653           *  The channel ID of the transfer to resume.
    654           *
    655           * @return
    656           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    657           *  DMADRV @ref Ecode_t is returned.
    658           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    659          Ecode_t DMADRV_ResumeTransfer(unsigned int channelId)
    660          {
   \                     DMADRV_ResumeTransfer: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    661            if ( !initialized ) {
   \        0x2   0x....'....        BL       ??Subroutine13_0
   \                     ??CrossCallReturnLabel_13: (+1)
   \        0x6   0xB901             CBNZ.N   R1,??DMADRV_ResumeTransfer_0
    662              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0x8   0x....             B.N      ?Subroutine8
    663            }
    664          
    665            if ( channelId >= EMDRV_DMADRV_DMA_CH_COUNT ) {
   \                     ??DMADRV_ResumeTransfer_0: (+1)
   \        0xA   0x2808             CMP      R0,#+8
   \        0xC   0xD300             BCC.N    ??DMADRV_ResumeTransfer_1
    666              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \        0xE   0x....             B.N      ?Subroutine7
    667            }
    668          
    669            if ( chTable[channelId].allocated == false ) {
   \                     ??DMADRV_ResumeTransfer_1: (+1)
   \       0x10   0x....'....        BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x14   0xB901             CBNZ.N   R1,??DMADRV_ResumeTransfer_2
    670              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   \       0x16   0x....             B.N      ?Subroutine6
    671            }
    672          
    673          #if defined(EMDRV_DMADRV_UDMA)
    674            DMA_ChannelRequestEnable(channelId, true);
    675          #elif defined(EMDRV_DMADRV_LDMA)
    676            LDMA_EnableChannelRequest(channelId, true);
   \                     ??DMADRV_ResumeTransfer_2: (+1)
   \       0x18   0x2101             MOVS     R1,#+1
   \       0x1A   0x....             B.N      ?Subroutine5
    677          #endif
    678          
    679            return ECODE_EMDRV_DMADRV_OK;
    680          }
    681          
    682          /***************************************************************************//**
    683           * @brief
    684           *  Stop an ongoing DMA transfer.
    685           *
    686           * @param[in] channelId
    687           *  The channel ID of the transfer to stop.
    688           *
    689           * @return
    690           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    691           *  DMADRV @ref Ecode_t is returned.
    692           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    693          Ecode_t DMADRV_StopTransfer(unsigned int channelId)
    694          {
   \                     DMADRV_StopTransfer: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    695            if ( !initialized ) {
   \        0x2   0x....'....        BL       ??Subroutine13_0
   \                     ??CrossCallReturnLabel_14: (+1)
   \        0x6   0xB901             CBNZ.N   R1,??DMADRV_StopTransfer_0
    696              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0x8   0x....             B.N      ?Subroutine8
    697            }
    698          
    699            if ( channelId >= EMDRV_DMADRV_DMA_CH_COUNT ) {
   \                     ??DMADRV_StopTransfer_0: (+1)
   \        0xA   0x2808             CMP      R0,#+8
   \        0xC   0xD300             BCC.N    ??DMADRV_StopTransfer_1
    700              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \        0xE   0x....             B.N      ?Subroutine7
    701            }
    702          
    703            if ( chTable[channelId].allocated == false ) {
   \                     ??DMADRV_StopTransfer_1: (+1)
   \       0x10   0x....'....        BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x14   0xB901             CBNZ.N   R1,??DMADRV_StopTransfer_2
    704              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   \       0x16   0x....             B.N      ?Subroutine6
    705            }
    706          
    707          #if defined(EMDRV_DMADRV_UDMA)
    708            DMA_ChannelEnable(channelId, false);
    709          #elif defined(EMDRV_DMADRV_LDMA)
    710            LDMA_StopTransfer(channelId);
   \                     ??DMADRV_StopTransfer_2: (+1)
   \       0x18   0x....'....        BL       LDMA_StopTransfer
    711          #endif
    712          
    713            return ECODE_EMDRV_DMADRV_OK;
   \       0x1C   0x2000             MOVS     R0,#+0
   \       0x1E   0xBD02             POP      {R1,PC}          ;; return
    714          }
    715          
    716          /***************************************************************************//**
    717           * @brief
    718           *  Check if a transfer is running.
    719           *
    720           * @param[in] channelId
    721           *  The channel ID of the transfer to check.
    722           *
    723           * @param[out] active
    724           *  True if transfer is running, false otherwise.
    725           *
    726           * @return
    727           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    728           *  DMADRV @ref Ecode_t is returned.
    729           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    730          Ecode_t DMADRV_TransferActive(unsigned int channelId, bool *active)
    731          {
   \                     DMADRV_TransferActive: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    732            if ( !initialized ) {
   \        0x2   0x....             LDR.N    R3,??DataTable16
   \        0x4   0x781A             LDRB     R2,[R3, #+0]
   \        0x6   0xB902             CBNZ.N   R2,??DMADRV_TransferActive_0
    733              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0x8   0x....             B.N      ?Subroutine3
    734            }
    735          
    736            if ( (channelId >= EMDRV_DMADRV_DMA_CH_COUNT)
    737                 || (active == NULL) ) {
   \                     ??DMADRV_TransferActive_0: (+1)
   \        0xA   0x2808             CMP      R0,#+8
   \        0xC   0xD200             BCS.N    ??DMADRV_TransferActive_1
   \        0xE   0xB901             CBNZ.N   R1,??DMADRV_TransferActive_2
    738              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \                     ??DMADRV_TransferActive_1: (+1)
   \       0x10   0x....             B.N      ?Subroutine2
    739            }
    740          
    741            if ( chTable[channelId].allocated == false ) {
   \                     ??DMADRV_TransferActive_2: (+1)
   \       0x12   0x....'....        BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x16   0xB902             CBNZ.N   R2,??DMADRV_TransferActive_3
    742              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   \       0x18   0x....             B.N      ?Subroutine4
    743            }
    744          
    745          #if defined(EMDRV_DMADRV_UDMA)
    746            if ( DMA_ChannelEnabled(channelId) )
    747          #elif defined(EMDRV_DMADRV_LDMA)
    748            if ( LDMA_ChannelEnabled(channelId) )
   \                     ??DMADRV_TransferActive_3: (+1)
   \       0x1A   0x2820             CMP      R0,#+32
   \       0x1C   0xD207             BCS.N    ??DMADRV_TransferActive_4
   \       0x1E   0x....             LDR.N    R2,??DataTable16_10  ;; 0x4004002c
   \       0x20   0x6812             LDR      R2,[R2, #+0]
   \       0x22   0x40C2             LSRS     R2,R2,R0
   \       0x24   0xF012 0x0001      ANDS     R0,R2,#0x1
   \       0x28   0xD002             BEQ.N    ??DMADRV_TransferActive_5
   \       0x2A   0x2001             MOVS     R0,#+1
   \       0x2C   0xE000             B.N      ??DMADRV_TransferActive_5
    749          #endif
    750            {
    751              *active = true;
    752            } else {
    753              *active = false;
   \                     ??DMADRV_TransferActive_4: (+1)
   \       0x2E   0x2000             MOVS     R0,#+0
    754            }
   \                     ??DMADRV_TransferActive_5: (+1)
   \       0x30   0x....             B.N      ?Subroutine1
    755          
    756            return ECODE_EMDRV_DMADRV_OK;
    757          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine12: (+1)
   \        0x0   0x....             LDR.N    R3,??DataTable16_3
   \        0x2   0xEB03 0x1400      ADD      R4,R3,R0, LSL #+4
   \        0x6   0x7B22             LDRB     R2,[R4, #+12]
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x....             LDR.N    R0,??DataTable16_9  ;; 0xf0008007
   \        0x2   0xBD10             POP      {R4,PC}

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x7008             STRB     R0,[R1, #+0]
   \        0x2   0x2000             MOVS     R0,#+0
   \        0x4   0xBD10             POP      {R4,PC}          ;; return
    758          
    759          /***************************************************************************//**
    760           * @brief
    761           *  Check if a transfer complete is pending.
    762           *
    763           * @details
    764           *  Will check the channel interrupt flag. This assumes that the DMA is configured
    765           *  to give a completion interrupt.
    766           *
    767           * @param[in] channelId
    768           *  The channel ID of the transfer to check.
    769           *
    770           * @param[out] pending
    771           *  True if a transfer complete is pending, false otherwise.
    772           *
    773           * @return
    774           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    775           *  DMADRV @ref Ecode_t is returned.
    776           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    777          Ecode_t DMADRV_TransferCompletePending(unsigned int channelId, bool *pending)
    778          {
   \                     DMADRV_TransferCompletePending: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    779            if ( !initialized ) {
   \        0x2   0x....             LDR.N    R3,??DataTable16
   \        0x4   0x781A             LDRB     R2,[R3, #+0]
   \        0x6   0xB902             CBNZ.N   R2,??DMADRV_TransferCompletePending_0
    780              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0x8   0x....             B.N      ?Subroutine3
    781            }
    782          
    783            if ( (channelId >= EMDRV_DMADRV_DMA_CH_COUNT)
    784                 || (pending == NULL) ) {
   \                     ??DMADRV_TransferCompletePending_0: (+1)
   \        0xA   0x2808             CMP      R0,#+8
   \        0xC   0xD200             BCS.N    ??DMADRV_TransferCompletePending_1
   \        0xE   0xB901             CBNZ.N   R1,??DMADRV_TransferCompletePending_2
    785              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \                     ??DMADRV_TransferCompletePending_1: (+1)
   \       0x10   0x....             B.N      ?Subroutine2
    786            }
    787          
    788            if ( chTable[channelId].allocated == false ) {
   \                     ??DMADRV_TransferCompletePending_2: (+1)
   \       0x12   0x....'....        BL       ?Subroutine12
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x16   0xB902             CBNZ.N   R2,??DMADRV_TransferCompletePending_3
    789              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   \       0x18   0x....             B.N      ?Subroutine4
    790            }
    791          
    792          #if defined(EMDRV_DMADRV_UDMA)
    793            if ( DMA->IF & (1 << channelId) )
    794          #elif defined(EMDRV_DMADRV_LDMA)
    795            if ( LDMA->IF & (1 << channelId) )
   \                     ??DMADRV_TransferCompletePending_3: (+1)
   \       0x1A   0x....             LDR.N    R2,??DataTable16_11  ;; 0x40040050
   \       0x1C   0x6813             LDR      R3,[R2, #+0]
   \       0x1E   0x40C3             LSRS     R3,R3,R0
   \       0x20   0xF013 0x0001      ANDS     R0,R3,#0x1
   \       0x24   0xBF18             IT       NE 
   \       0x26   0x2001             MOVNE    R0,#+1
   \       0x28   0x....             B.N      ?Subroutine1
    796          #endif
    797            {
    798              *pending = true;
    799            } else {
    800              *pending = false;
    801            }
    802          
    803            return ECODE_EMDRV_DMADRV_OK;
    804          }
    805          
    806          /***************************************************************************//**
    807           * @brief
    808           *  Check if a transfer has completed.
    809           *
    810           * @note
    811           *  This function should be used in a polled environment.
    812           *  Will only work reliably for transfers NOT using the completion interrupt.
    813           *  On UDMA, it will only work on basic transfers on the primary channel.
    814           *
    815           * @param[in] channelId
    816           *  The channel ID of the transfer to check.
    817           *
    818           * @param[out] done
    819           *  True if a transfer has completed, false otherwise.
    820           *
    821           * @return
    822           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    823           *  DMADRV @ref Ecode_t is returned.
    824           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    825          Ecode_t DMADRV_TransferDone(unsigned int channelId, bool *done)
    826          {
   \                     DMADRV_TransferDone: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....'....        BL       ?Subroutine13
    827          #if defined(EMDRV_DMADRV_UDMA)
    828            uint32_t remaining, iflag;
    829          #endif
    830          
    831            if ( !initialized ) {
   \                     ??CrossCallReturnLabel_9: (+1)
   \        0x6   0xB901             CBNZ.N   R1,??DMADRV_TransferDone_0
    832              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0x8   0x....             B.N      ?Subroutine3
    833            }
    834          
    835            if ( (channelId >= EMDRV_DMADRV_DMA_CH_COUNT)
    836                 || (done == NULL) ) {
   \                     ??DMADRV_TransferDone_0: (+1)
   \        0xA   0x2808             CMP      R0,#+8
   \        0xC   0xD200             BCS.N    ??DMADRV_TransferDone_1
   \        0xE   0xB904             CBNZ.N   R4,??DMADRV_TransferDone_2
    837              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \                     ??DMADRV_TransferDone_1: (+1)
   \       0x10   0x....             B.N      ?Subroutine2
    838            }
    839          
    840            if ( chTable[channelId].allocated == false ) {
   \                     ??DMADRV_TransferDone_2: (+1)
   \       0x12   0x....'....        BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x16   0xB901             CBNZ.N   R1,??DMADRV_TransferDone_3
    841              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   \       0x18   0x....             B.N      ?Subroutine4
    842            }
    843          
    844          #if defined(EMDRV_DMADRV_UDMA)
    845            CORE_ATOMIC_SECTION(
    846              /* This works for primary channel only ! */
    847              remaining = (dmaControlBlock[channelId].CTRL
    848                           & _DMA_CTRL_N_MINUS_1_MASK)
    849                          >> _DMA_CTRL_N_MINUS_1_SHIFT;
    850              iflag = DMA->IF;
    851              )
    852          
    853            if ( (remaining == 0) && (iflag & (1 << channelId)) ) {
    854              *done = true;
    855            } else {
    856              *done = false;
    857            }
    858          #elif defined(EMDRV_DMADRV_LDMA)
    859            *done = LDMA_TransferDone(channelId);
   \                     ??DMADRV_TransferDone_3: (+1)
   \       0x1A   0x....'....        BL       LDMA_TransferDone
   \       0x1E   0x7020             STRB     R0,[R4, #+0]
    860          #endif
    861          
    862            return ECODE_EMDRV_DMADRV_OK;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xBD10             POP      {R4,PC}          ;; return
    863          }
    864          
    865          /***************************************************************************//**
    866           * @brief
    867           *  Get number of items remaining in a transfer.
    868           *
    869           * @note
    870           *  This function does not take into account that a DMA transfer with
    871           *  a chain of linked transfers might be ongoing. It will only check the
    872           *  count for the current transfer.
    873           *  On UDMA, it will only work on the primary channel.
    874           *
    875           * @param[in] channelId
    876           *  The channel ID of the transfer to check.
    877           *
    878           * @param[out] remaining
    879           *  A number of items remaining in the transfer.
    880           *
    881           * @return
    882           *  @ref ECODE_EMDRV_DMADRV_OK on success. On failure, an appropriate
    883           *  DMADRV @ref Ecode_t is returned.
    884           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    885          Ecode_t DMADRV_TransferRemainingCount(unsigned int channelId,
    886                                                int *remaining)
    887          {
   \                     DMADRV_TransferRemainingCount: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
   \        0x2   0x....'....        BL       ?Subroutine13
    888          #if defined(EMDRV_DMADRV_UDMA)
    889            uint32_t remain, iflag;
    890          #endif
    891          
    892            if ( !initialized ) {
   \                     ??CrossCallReturnLabel_10: (+1)
   \        0x6   0xB901             CBNZ.N   R1,??DMADRV_TransferRemainingCount_0
    893              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0x8   0x....             B.N      ?Subroutine3
    894            }
    895          
    896            if ( (channelId >= EMDRV_DMADRV_DMA_CH_COUNT)
    897                 || (remaining == NULL) ) {
   \                     ??DMADRV_TransferRemainingCount_0: (+1)
   \        0xA   0x2808             CMP      R0,#+8
   \        0xC   0xD200             BCS.N    ??DMADRV_TransferRemainingCount_1
   \        0xE   0xB904             CBNZ.N   R4,??DMADRV_TransferRemainingCount_2
    898              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \                     ??DMADRV_TransferRemainingCount_1: (+1)
   \       0x10   0x....             B.N      ?Subroutine2
    899            }
    900          
    901            if ( chTable[channelId].allocated == false ) {
   \                     ??DMADRV_TransferRemainingCount_2: (+1)
   \       0x12   0x....'....        BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x16   0xB901             CBNZ.N   R1,??DMADRV_TransferRemainingCount_3
    902              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   \       0x18   0x....             B.N      ?Subroutine4
    903            }
    904          
    905          #if defined(EMDRV_DMADRV_UDMA)
    906            CORE_ATOMIC_SECTION(
    907              /* This works for the primary channel only ! */
    908              remain = (dmaControlBlock[channelId].CTRL
    909                        & _DMA_CTRL_N_MINUS_1_MASK)
    910                       >> _DMA_CTRL_N_MINUS_1_SHIFT;
    911              iflag = DMA->IF;
    912              )
    913          
    914            if ( (remain == 0) && (iflag & (1 << channelId)) ) {
    915              *remaining = 0;
    916            } else {
    917              *remaining = 1 + remain;
    918            }
    919          #elif defined(EMDRV_DMADRV_LDMA)
    920            *remaining = LDMA_TransferRemainingCount(channelId);
   \                     ??DMADRV_TransferRemainingCount_3: (+1)
   \       0x1A   0x....'....        BL       LDMA_TransferRemainingCount
   \       0x1E   0x6020             STR      R0,[R4, #+0]
    921          #endif
    922          
    923            return ECODE_EMDRV_DMADRV_OK;
   \       0x20   0x2000             MOVS     R0,#+0
   \       0x22   0xBD10             POP      {R4,PC}          ;; return
    924          }
    925          
    926          /// @cond DO_NOT_INCLUDE_WITH_DOXYGEN
    927          
    928          #if defined(EMDRV_DMADRV_LDMA)
    929          /***************************************************************************//**
    930           * @brief
    931           *  An interrupt handler for LDMA.
    932           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    933          void LDMA_IRQHandler(void)
    934          {
   \                     LDMA_IRQHandler: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
    935          #if !defined(EMDRV_DMADRV_USE_NATIVE_API)
    936            bool stop;
    937          #endif
    938            ChTable_t *ch;
    939            uint32_t pending, chnum, chmask;
    940          
    941            /* Get all pending and enabled interrupts. */
    942            pending  = LDMA->IF;
   \        0x2   0x....             LDR.N    R0,??DataTable16_11  ;; 0x40040050
   \        0x4   0x6804             LDR      R4,[R0, #+0]
    943            pending &= LDMA->IEN;
   \        0x6   0x6840             LDR      R0,[R0, #+4]
   \        0x8   0x4004             ANDS     R4,R0,R4
    944          
    945            /* Check for LDMA error. */
    946            if ( pending & LDMA_IF_ERROR ) {
   \        0xA   0xD500             BPL.N    ??LDMA_IRQHandler_0
    947              /* Loop to enable debugger to see what has happened. */
    948              while (true) {
   \                     ??LDMA_IRQHandler_1: (+1)
   \        0xC   0xE7FE             B.N      ??LDMA_IRQHandler_1
    949                /* Wait forever. */
    950              }
    951            }
    952          
    953            /* Iterate over all LDMA channels. */
    954            for ( chnum = 0, chmask = 1;
   \                     ??LDMA_IRQHandler_0: (+1)
   \        0xE   0x2500             MOVS     R5,#+0
   \       0x10   0x2601             MOVS     R6,#+1
    955                  chnum < EMDRV_DMADRV_DMA_CH_COUNT;
    956                  chnum++, chmask <<= 1 ) {
    957              if ( pending & chmask ) {
   \                     ??LDMA_IRQHandler_2: (+1)
   \       0x12   0x4234             TST      R4,R6
   \       0x14   0xD01E             BEQ.N    ??LDMA_IRQHandler_3
    958                /* Clear the interrupt flag. */
    959          #if defined (LDMA_HAS_SET_CLEAR)
    960                LDMA->IF_CLR = chmask;
    961          #else
    962                LDMA->IFC = chmask;
    963          #endif
    964          
    965                ch = &chTable[chnum];
    966                if ( ch->callback != NULL ) {
   \       0x16   0x....             LDR.N    R2,??DataTable16_3
   \       0x18   0xEB02 0x1705      ADD      R7,R2,R5, LSL #+4
   \       0x1C   0x....             LDR.N    R1,??DataTable16_12  ;; 0x40042050
   \       0x1E   0x600E             STR      R6,[R1, #+0]
   \       0x20   0x6838             LDR      R0,[R7, #+0]
   \       0x22   0xB1B8             CBZ.N    R0,??LDMA_IRQHandler_3
    967                  ch->callbackCount++;
   \       0x24   0x68B8             LDR      R0,[R7, #+8]
    968          #if defined(EMDRV_DMADRV_USE_NATIVE_API)
    969                  ch->callback(chnum, ch->callbackCount, ch->userParam);
    970          #else
    971                  stop = !ch->callback(chnum, ch->callbackCount, ch->userParam);
   \       0x26   0x687A             LDR      R2,[R7, #+4]
   \       0x28   0x683B             LDR      R3,[R7, #+0]
   \       0x2A   0x1C40             ADDS     R0,R0,#+1
   \       0x2C   0x60B8             STR      R0,[R7, #+8]
   \       0x2E   0x4601             MOV      R1,R0
   \       0x30   0x4628             MOV      R0,R5
   \       0x32   0x4798             BLX      R3
   \       0x34   0x2800             CMP      R0,#+0
   \       0x36   0xBF04             ITT      EQ 
   \       0x38   0x7B78             LDRBEQ   R0,[R7, #+13]
   \       0x3A   0x2801             CMPEQ    R0,#+1
    972          
    973                  if ( (ch->mode == dmaModePingPong) && stop ) {
   \       0x3C   0xD10A             BNE.N    ??LDMA_IRQHandler_3
    974                    dmaXfer[chnum].desc[0].xfer.link = 0;
   \       0x3E   0x....             LDR.N    R1,??DataTable16_13
   \       0x40   0xEB01 0x1045      ADD      R0,R1,R5, LSL #+5
   \       0x44   0x68C2             LDR      R2,[R0, #+12]
    975                    dmaXfer[chnum].desc[1].xfer.link = 0;
   \       0x46   0x69C1             LDR      R1,[R0, #+28]
   \       0x48   0xF022 0x0202      BIC      R2,R2,#0x2
   \       0x4C   0x60C2             STR      R2,[R0, #+12]
   \       0x4E   0xF021 0x0102      BIC      R1,R1,#0x2
   \       0x52   0x61C1             STR      R1,[R0, #+28]
    976                  }
    977          #endif
    978                }
    979              }
    980            }
   \                     ??LDMA_IRQHandler_3: (+1)
   \       0x54   0x1C6D             ADDS     R5,R5,#+1
   \       0x56   0x0076             LSLS     R6,R6,#+1
   \       0x58   0x2D08             CMP      R5,#+8
   \       0x5A   0xD3DA             BCC.N    ??LDMA_IRQHandler_2
    981          }
   \       0x5C   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    982          #endif /* defined( EMDRV_DMADRV_LDMA ) */
    983          
    984          #if defined(EMDRV_DMADRV_UDMA) && !defined(EMDRV_DMADRV_USE_NATIVE_API)
    985          /***************************************************************************//**
    986           * @brief
    987           *  A callback function for UDMA basic transfers.
    988           ******************************************************************************/
    989          static void DmaBasicCallback(unsigned int channel, bool primary, void *user)
    990          {
    991            ChTable_t *ch = &chTable[channel];
    992            (void)user;
    993            (void)primary;
    994          
    995            if ( ch->callback != NULL ) {
    996              ch->callbackCount++;
    997              ch->callback(channel, ch->callbackCount, ch->userParam);
    998            }
    999          }
   1000          #endif
   1001          
   1002          #if defined(EMDRV_DMADRV_UDMA) && !defined(EMDRV_DMADRV_USE_NATIVE_API)
   1003          /***************************************************************************//**
   1004           * @brief
   1005           *  A callback function for UDMA ping-pong transfers.
   1006           ******************************************************************************/
   1007          static void DmaPingPongCallback(unsigned int channel, bool primary, void *user)
   1008          {
   1009            bool stop = true;
   1010            ChTable_t *ch = &chTable[channel];
   1011          
   1012            (void)user;
   1013          
   1014            if ( ch->callback != NULL ) {
   1015              ch->callbackCount++;
   1016              stop = !ch->callback(channel, ch->callbackCount, ch->userParam);
   1017            }
   1018          
   1019            DMA_RefreshPingPong(channel,
   1020                                primary,
   1021                                false,
   1022                                NULL,
   1023                                NULL,
   1024                                ch->length - 1,
   1025                                stop);
   1026          }
   1027          #endif
   1028          
   1029          #if defined(EMDRV_DMADRV_UDMA) && !defined(EMDRV_DMADRV_USE_NATIVE_API)
   1030          /***************************************************************************//**
   1031           * @brief
   1032           *  Start a UDMA transfer.
   1033           ******************************************************************************/
   1034          static Ecode_t StartTransfer(DmaMode_t             mode,
   1035                                       DmaDirection_t        direction,
   1036                                       unsigned int          channelId,
   1037                                       DMADRV_PeripheralSignal_t
   1038                                       peripheralSignal,
   1039                                       void                  *buf0,
   1040                                       void                  *buf1,
   1041                                       void                  *buf2,
   1042                                       bool                  bufInc,
   1043                                       int                   len,
   1044                                       DMADRV_DataSize_t     size,
   1045                                       DMADRV_Callback_t     callback,
   1046                                       void                  *cbUserParam)
   1047          {
   1048            ChTable_t *ch;
   1049            DMA_CfgChannel_TypeDef chCfg;
   1050            DMA_CfgDescr_TypeDef   descrCfg;
   1051          
   1052            if ( !initialized ) {
   1053              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   1054            }
   1055          
   1056            if ( (channelId >= EMDRV_DMADRV_DMA_CH_COUNT)
   1057                 || (buf0 == NULL)
   1058                 || (buf1 == NULL)
   1059                 || (len > DMADRV_MAX_XFER_COUNT)
   1060                 || ((mode == dmaModePingPong) && (buf2 == NULL)) ) {
   1061              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   1062            }
   1063          
   1064            ch = &chTable[channelId];
   1065            if ( ch->allocated == false ) {
   1066              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   1067            }
   1068          
   1069            /* Se tup the interrupt callback routine. */
   1070            if ( mode == dmaModeBasic ) {
   1071              dmaCallBack[channelId].cbFunc  = DmaBasicCallback;
   1072            } else {
   1073              dmaCallBack[channelId].cbFunc  = DmaPingPongCallback;
   1074            }
   1075            dmaCallBack[channelId].userPtr = NULL;
   1076          
   1077            /* Set up the channel */
   1078            chCfg.highPri = false;              /* Can't use hi pri with peripherals. */
   1079          
   1080            /* Whether the interrupt is needed. */
   1081            if ( (callback != NULL) || (mode == dmaModePingPong) ) {
   1082              chCfg.enableInt = true;
   1083            } else {
   1084              chCfg.enableInt = false;
   1085            }
   1086            chCfg.select = peripheralSignal;
   1087            chCfg.cb     = &dmaCallBack[channelId];
   1088            DMA_CfgChannel(channelId, &chCfg);
   1089          
   1090            /* Set up the channel descriptor. */
   1091            if ( direction == dmaDirectionMemToPeripheral ) {
   1092              if ( bufInc ) {
   1093                if ( size == dmadrvDataSize1 ) {
   1094                  descrCfg.srcInc = dmaDataInc1;
   1095                } else if ( size == dmadrvDataSize2 ) {
   1096                  descrCfg.srcInc = dmaDataInc2;
   1097                } else { /* dmadrvDataSize4 */
   1098                  descrCfg.srcInc = dmaDataInc4;
   1099                }
   1100              } else {
   1101                descrCfg.srcInc = dmaDataIncNone;
   1102              }
   1103              descrCfg.dstInc = dmaDataIncNone;
   1104            } else {
   1105              if ( bufInc ) {
   1106                if ( size == dmadrvDataSize1 ) {
   1107                  descrCfg.dstInc = dmaDataInc1;
   1108                } else if ( size == dmadrvDataSize2 ) {
   1109                  descrCfg.dstInc = dmaDataInc2;
   1110                } else { /* dmadrvDataSize4 */
   1111                  descrCfg.dstInc = dmaDataInc4;
   1112                }
   1113              } else {
   1114                descrCfg.dstInc = dmaDataIncNone;
   1115              }
   1116              descrCfg.srcInc = dmaDataIncNone;
   1117            }
   1118            descrCfg.size    = (DMA_DataSize_TypeDef)size;
   1119            descrCfg.arbRate = dmaArbitrate1;
   1120            descrCfg.hprot   = 0;
   1121            DMA_CfgDescr(channelId, true, &descrCfg);
   1122            if ( mode == dmaModePingPong ) {
   1123              DMA_CfgDescr(channelId, false, &descrCfg);
   1124            }
   1125          
   1126            ch->callback      = callback;
   1127            ch->userParam     = cbUserParam;
   1128            ch->callbackCount = 0;
   1129            ch->length        = len;
   1130          
   1131            DMA->IFC = 1 << channelId;
   1132          
   1133            /* Start the DMA cycle. */
   1134            if ( mode == dmaModeBasic ) {
   1135              DMA_ActivateBasic(channelId, true, false, buf0, buf1, len - 1);
   1136            } else {
   1137              if ( direction == dmaDirectionMemToPeripheral ) {
   1138                DMA_ActivatePingPong(channelId,
   1139                                     false,
   1140                                     buf0,                              /* dest */
   1141                                     buf1,                              /* src  */
   1142                                     len - 1,
   1143                                     buf0,                              /* dest */
   1144                                     buf2,                              /* src  */
   1145                                     len - 1);
   1146              } else {
   1147                DMA_ActivatePingPong(channelId,
   1148                                     false,
   1149                                     buf0,                              /* dest */
   1150                                     buf2,                              /* src  */
   1151                                     len - 1,
   1152                                     buf1,                              /* dest */
   1153                                     buf2,                              /* src  */
   1154                                     len - 1);
   1155              }
   1156            }
   1157          
   1158            return ECODE_EMDRV_DMADRV_OK;
   1159          }
   1160          #endif /* defined( EMDRV_DMADRV_UDMA ) && !defined( EMDRV_DMADRV_USE_NATIVE_API ) */
   1161          
   1162          #if defined(EMDRV_DMADRV_LDMA) && !defined(EMDRV_DMADRV_USE_NATIVE_API)
   1163          /***************************************************************************//**
   1164           * @brief
   1165           *  Start an LDMA transfer.
   1166           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1167          static Ecode_t StartTransfer(DmaMode_t             mode,
   1168                                       DmaDirection_t        direction,
   1169                                       unsigned int          channelId,
   1170                                       DMADRV_PeripheralSignal_t
   1171                                       peripheralSignal,
   1172                                       void                  *buf0,
   1173                                       void                  *buf1,
   1174                                       void                  *buf2,
   1175                                       bool                  bufInc,
   1176                                       int                   len,
   1177                                       DMADRV_DataSize_t     size,
   1178                                       DMADRV_Callback_t     callback,
   1179                                       void                  *cbUserParam)
   1180          {
   \                     StartTransfer: (+1)
   \        0x0   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \        0x4   0x469B             MOV      R11,R3
   1181            ChTable_t *ch;
   1182            LDMA_TransferCfg_t xfer;
   1183            LDMA_Descriptor_t *desc;
   1184          
   1185            if ( !initialized ) {
   \        0x6   0x....             LDR.N    R4,??DataTable16
   \        0x8   0x7823             LDRB     R3,[R4, #+0]
   \        0xA   0xB086             SUB      SP,SP,#+24
   \        0xC   0xB90B             CBNZ.N   R3,??StartTransfer_0
   1186              return ECODE_EMDRV_DMADRV_NOT_INITIALIZED;
   \        0xE   0x....             LDR.N    R0,??DataTable16_1  ;; 0xf0008002
   \       0x10   0xE094             B.N      ??StartTransfer_1
   1187            }
   \                     ??StartTransfer_0: (+1)
   \       0x12   0x9201             STR      R2,[SP, #+4]
   1188          
   1189            if ( (channelId >= EMDRV_DMADRV_DMA_CH_COUNT)
   1190                 || (buf0 == NULL)
   1191                 || (buf1 == NULL)
   1192                 || (len > DMADRV_MAX_XFER_COUNT)
   1193                 || ((mode == dmaModePingPong) && (buf2 == NULL)) ) {
   \       0x14   0x2A08             CMP      R2,#+8
   \       0x16   0xD214             BCS.N    ??StartTransfer_2
   \       0x18   0x9C10             LDR      R4,[SP, #+64]
   \       0x1A   0x2C00             CMP      R4,#+0
   \       0x1C   0xBF1C             ITT      NE 
   \       0x1E   0x9D11             LDRNE    R5,[SP, #+68]
   \       0x20   0x2D00             CMPNE    R5,#+0
   \       0x22   0xD00E             BEQ.N    ??StartTransfer_2
   \       0x24   0xF8DD 0x8050      LDR      R8,[SP, #+80]
   \       0x28   0xF640 0x0201      MOVW     R2,#+2049
   \       0x2C   0x4590             CMP      R8,R2
   \       0x2E   0xDA08             BGE.N    ??StartTransfer_2
   \       0x30   0xF8DD 0x9048      LDR      R9,[SP, #+72]
   \       0x34   0x2801             CMP      R0,#+1
   \       0x36   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \       0x3A   0xBF08             IT       EQ 
   \       0x3C   0xF1B9 0x0F00      CMPEQ    R9,#+0
   \       0x40   0xD101             BNE.N    ??StartTransfer_3
   1194              return ECODE_EMDRV_DMADRV_PARAM_ERROR;
   \                     ??StartTransfer_2: (+1)
   \       0x42   0x....             LDR.N    R0,??DataTable16_2  ;; 0xf0008001
   \       0x44   0xE07A             B.N      ??StartTransfer_1
   1195            }
   1196          
   1197            ch = &chTable[channelId];
   1198            if ( ch->allocated == false ) {
   \                     ??StartTransfer_3: (+1)
   \       0x46   0x9A01             LDR      R2,[SP, #+4]
   \       0x48   0x....             LDR.N    R0,??DataTable16_3
   \       0x4A   0xEB00 0x1602      ADD      R6,R0,R2, LSL #+4
   \       0x4E   0x7B30             LDRB     R0,[R6, #+12]
   \       0x50   0xB908             CBNZ.N   R0,??StartTransfer_4
   1199              return ECODE_EMDRV_DMADRV_CH_NOT_ALLOCATED;
   \       0x52   0x....             LDR.N    R0,??DataTable16_9  ;; 0xf0008007
   \       0x54   0xE072             B.N      ??StartTransfer_1
   1200            }
   \                     ??StartTransfer_4: (+1)
   \       0x56   0xF88D 0x1001      STRB     R1,[SP, #+1]
   1201          
   1202            xfer = xferCfg;
   \       0x5A   0xA802             ADD      R0,SP,#+8
   \       0x5C   0x2110             MOVS     R1,#+16
   \       0x5E   0x....'....        BL       __aeabi_memclr4
   1203            desc = &dmaXfer[channelId].desc[0];
   1204          
   1205            if ( direction == dmaDirectionMemToPeripheral ) {
   \       0x62   0x9801             LDR      R0,[SP, #+4]
   \       0x64   0x....             LDR.N    R1,??DataTable16_13
   \       0x66   0xF8DD 0xA04C      LDR      R10,[SP, #+76]
   \       0x6A   0xEB01 0x1740      ADD      R7,R1,R0, LSL #+5
   \       0x6E   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \       0x72   0x2800             CMP      R0,#+0
   \       0x74   0x4638             MOV      R0,R7
   \       0x76   0xD10A             BNE.N    ??StartTransfer_5
   1206              *desc = m2p;
   \       0x78   0x....             LDR.N    R1,??DataTable16_14
   \       0x7A   0x2210             MOVS     R2,#+16
   \       0x7C   0x....'....        BL       __aeabi_memcpy4
   1207              if ( !bufInc ) {
   \       0x80   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x84   0xD10E             BNE.N    ??StartTransfer_6
   1208                desc->xfer.srcInc = ldmaCtrlSrcIncNone;
   \       0x86   0x6838             LDR      R0,[R7, #+0]
   \       0x88   0xF040 0x7040      ORR      R0,R0,#0x3000000
   \       0x8C   0xE009             B.N      ??StartTransfer_7
   1209              }
   1210            } else {
   1211              *desc = p2m;
   \                     ??StartTransfer_5: (+1)
   \       0x8E   0x....             LDR.N    R1,??DataTable16_15
   \       0x90   0x2210             MOVS     R2,#+16
   \       0x92   0x....'....        BL       __aeabi_memcpy4
   1212              if ( !bufInc ) {
   \       0x96   0xF1BA 0x0F00      CMP      R10,#+0
   \       0x9A   0xD103             BNE.N    ??StartTransfer_6
   1213                desc->xfer.dstInc = ldmaCtrlDstIncNone;
   \       0x9C   0x6838             LDR      R0,[R7, #+0]
   \       0x9E   0xF040 0x5040      ORR      R0,R0,#0x30000000
   \                     ??StartTransfer_7: (+1)
   \       0xA2   0x6038             STR      R0,[R7, #+0]
   1214              }
   1215            }
   1216          
   1217            xfer.ldmaReqSel    = peripheralSignal;
   \                     ??StartTransfer_6: (+1)
   \       0xA4   0xF8CD 0xB008      STR      R11,[SP, #+8]
   1218            desc->xfer.xferCnt = len - 1;
   \       0xA8   0x6839             LDR      R1,[R7, #+0]
   \       0xAA   0xF1A8 0x0201      SUB      R2,R8,#+1
   \       0xAE   0x9815             LDR      R0,[SP, #+84]
   \       0xB0   0xF362 0x110E      BFI      R1,R2,#+4,#+11
   \       0xB4   0x6039             STR      R1,[R7, #+0]
   1219            desc->xfer.dstAddr = (uint32_t)(uint8_t *)buf0;
   \       0xB6   0x60BC             STR      R4,[R7, #+8]
   1220            desc->xfer.srcAddr = (uint32_t)(uint8_t *)buf1;
   \       0xB8   0x607D             STR      R5,[R7, #+4]
   1221            desc->xfer.size    = size;
   \       0xBA   0x6839             LDR      R1,[R7, #+0]
   \       0xBC   0xF360 0x619B      BFI      R1,R0,#+26,#+2
   \       0xC0   0x6039             STR      R1,[R7, #+0]
   \       0xC2   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xC6   0x9C16             LDR      R4,[SP, #+88]
   \       0xC8   0x2801             CMP      R0,#+1
   \       0xCA   0xD11F             BNE.N    ??StartTransfer_8
   1222          
   1223            if ( mode == dmaModePingPong ) {
   1224              desc->xfer.linkMode = ldmaLinkModeRel;
   1225              desc->xfer.link     = 1;
   \       0xCC   0x68F8             LDR      R0,[R7, #+12]
   1226              desc->xfer.linkAddr = 4;      /* Refer to the "pong" descriptor. */
   1227          
   1228              /* Set the "pong" descriptor equal to the "ping" descriptor. */
   1229              dmaXfer[channelId].desc[1] = *desc;
   \       0xCE   0x4639             MOV      R1,R7
   \       0xD0   0x2210             MOVS     R2,#+16
   \       0xD2   0xF040 0x0003      ORR      R0,R0,#0x3
   \       0xD6   0x60F8             STR      R0,[R7, #+12]
   \       0xD8   0x7B38             LDRB     R0,[R7, #+12]
   \       0xDA   0xF000 0x0003      AND      R0,R0,#0x3
   \       0xDE   0xF040 0x0010      ORR      R0,R0,#0x10
   \       0xE2   0x60F8             STR      R0,[R7, #+12]
   \       0xE4   0xF107 0x0010      ADD      R0,R7,#+16
   \       0xE8   0x....'....        BL       __aeabi_memcpy4
   1230              /* Refer to the "ping" descriptor. */
   1231              dmaXfer[channelId].desc[1].xfer.linkAddr = -4;
   \       0xEC   0x7F38             LDRB     R0,[R7, #+28]
   \       0xEE   0xF000 0x0003      AND      R0,R0,#0x3
   \       0xF2   0xF060 0x000F      ORN      R0,R0,#+15
   \       0xF6   0x61F8             STR      R0,[R7, #+28]
   1232              dmaXfer[channelId].desc[1].xfer.srcAddr = (uint32_t)(uint8_t *)buf2;
   \       0xF8   0xF8C7 0x9014      STR      R9,[R7, #+20]
   1233          
   1234              if ( direction == dmaDirectionPeripheralToMem ) {
   \       0xFC   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \      0x100   0x2801             CMP      R0,#+1
   \      0x102   0xD10D             BNE.N    ??StartTransfer_9
   1235                dmaXfer[channelId].desc[1].xfer.dstAddr = (uint32_t)(uint8_t *)buf1;
   \      0x104   0x61BD             STR      R5,[R7, #+24]
   1236                desc->xfer.srcAddr = (uint32_t)(uint8_t *)buf2;
   \      0x106   0xF8C7 0x9004      STR      R9,[R7, #+4]
   \      0x10A   0xE009             B.N      ??StartTransfer_9
   1237              }
   1238            }
   1239          
   1240            /* Whether an interrupt is needed. */
   1241            if ( (callback == NULL) && (mode == dmaModeBasic) ) {
   \                     ??StartTransfer_8: (+1)
   \      0x10C   0x0020             MOVS     R0,R4
   \      0x10E   0xBF04             ITT      EQ 
   \      0x110   0xF89D 0x0000      LDRBEQ   R0,[SP, #+0]
   \      0x114   0x2800             CMPEQ    R0,#+0
   \      0x116   0xD103             BNE.N    ??StartTransfer_9
   1242              desc->xfer.doneIfs = 0;
   \      0x118   0x6839             LDR      R1,[R7, #+0]
   \      0x11A   0xF421 0x1180      BIC      R1,R1,#0x100000
   \      0x11E   0x6039             STR      R1,[R7, #+0]
   \                     ??StartTransfer_9: (+1)
   \      0x120   0x9817             LDR      R0,[SP, #+92]
   1243            }
   1244          
   1245            ch->callback      = callback;
   \      0x122   0x6034             STR      R4,[R6, #+0]
   1246            ch->userParam     = cbUserParam;
   1247            ch->callbackCount = 0;
   1248            ch->mode          = mode;
   1249          
   1250            LDMA_StartTransfer(channelId, &xfer, desc);
   \      0x124   0x463A             MOV      R2,R7
   \      0x126   0x6070             STR      R0,[R6, #+4]
   \      0x128   0x2000             MOVS     R0,#+0
   \      0x12A   0x60B0             STR      R0,[R6, #+8]
   \      0x12C   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \      0x130   0x7371             STRB     R1,[R6, #+13]
   \      0x132   0x9801             LDR      R0,[SP, #+4]
   \      0x134   0xA902             ADD      R1,SP,#+8
   \      0x136   0x....'....        BL       LDMA_StartTransfer
   1251          
   1252            return ECODE_EMDRV_DMADRV_OK;
   \      0x13A   0x2000             MOVS     R0,#+0
   \                     ??StartTransfer_1: (+1)
   \      0x13C   0xB007             ADD      SP,SP,#+28
   \      0x13E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1253          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \        0x0   0x....'....        DC32     initialized

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \        0x0   0xF000'8002        DC32     0xf0008002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \        0x0   0xF000'8001        DC32     0xf0008001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \        0x0   0x....'....        DC32     chTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \        0x0   0xF000'8004        DC32     0xf0008004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \        0x0   0xF000'8005        DC32     0xf0008005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \        0x0   0xF000'8006        DC32     0xf0008006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \        0x0   0xF000'8003        DC32     0xf0008003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \        0x0   0xF000'8007        DC32     0xf0008007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \        0x0   0x4004'002C        DC32     0x4004002c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \        0x0   0x4004'0050        DC32     0x40040050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \        0x0   0x4004'2050        DC32     0x40042050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \        0x0   0x....'....        DC32     dmaXfer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \        0x0   0x....'....        DC32     m2p

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \        0x0   0x....'....        DC32     p2m
   1254          #endif /* defined( EMDRV_DMADRV_LDMA ) && !defined( EMDRV_DMADRV_USE_NATIVE_API ) */
   1255          
   1256          /// @endcond
   1257          
   1258          /******** THE REST OF THE FILE IS DOCUMENTATION ONLY !**********************//**
   1259           * @addtogroup emdrv
   1260           * @{
   1261           * @addtogroup DMADRV
   1262           * @brief DMADRV Direct Memory Access Driver
   1263           * @{
   1264          
   1265             @details
   1266          
   1267             @li @ref dmadrv_intro
   1268             @li @ref dmadrv_conf
   1269             @li @ref dmadrv_api
   1270             @li @ref dmadrv_example
   1271          
   1272             @n @section dmadrv_intro Introduction
   1273          
   1274             The DMADRV driver supports writing code using DMA which will work
   1275             regardless of the type of the DMA controller on the underlying microcontroller.
   1276             Additionally, DMA can be used in several modules that are
   1277             completely unaware of each other.
   1278             The driver does not preclude use of the native emlib API of the underlying
   1279             DMA controller. On the contrary, it will often result in more efficient
   1280             code and is necessary for complex DMA operations. The housekeeping
   1281             functions of this driver are valuable even in this use-case.
   1282          
   1283             The dmadrv.c and dmadrv.h source files are in the
   1284             emdrv/dmadrv folder.
   1285          
   1286             @note DMA transfer completion callback functions are called from within the
   1287             DMA interrupt handler.
   1288          
   1289             @n @section dmadrv_conf Configuration Options
   1290          
   1291             Some properties of the DMADRV driver are compile-time configurable. These
   1292             properties are stored in a file named @ref dmadrv_config.h. A template for this
   1293             file, containing default values, is in the emdrv/config folder.
   1294             Currently the configuration options are as follows:
   1295             @li The interrupt priority of the DMA peripheral.
   1296             @li A number of DMA channels to support.
   1297             @li Use the native emlib API belonging to the underlying DMA hardware in
   1298                combination with the DMADRV API.
   1299          
   1300             Both configuration options will help reduce the driver's RAM footprint.
   1301          
   1302             To configure DMADRV, provide a custom configuration file. This is an
   1303             example @ref dmadrv_config.h file:
   1304             @verbatim
   1305           #ifndef __SILICON_LABS_DMADRV_CONFIG_H__
   1306           #define __SILICON_LABS_DMADRV_CONFIG_H__
   1307          
   1308             // DMADRV DMA interrupt priority configuration option.
   1309             // Set DMA interrupt priority. Range is 0..7, 0 is the highest priority.
   1310           #define EMDRV_DMADRV_DMA_IRQ_PRIORITY 4
   1311          
   1312             // DMADRV channel count configuration option.
   1313             // A number of DMA channels to support. A lower DMA channel count will reduce
   1314             // RAM footprint.
   1315           #define EMDRV_DMADRV_DMA_CH_COUNT 4
   1316          
   1317             // DMADRV native API configuration option.
   1318             // Use the native emlib API of the DMA controller in addition to DMADRV
   1319             // housekeeping functions, such as AllocateChannel/FreeChannel, and so on.
   1320           #define EMDRV_DMADRV_USE_NATIVE_API
   1321          
   1322           #endif
   1323             @endverbatim
   1324          
   1325             @n @section dmadrv_api The API
   1326          
   1327             This section contains brief descriptions of the API functions.
   1328             For more information about input and output parameters and return values,
   1329             click on the hyperlinked function names. Most functions return an error
   1330             code, @ref ECODE_EMDRV_DMADRV_OK is returned on success,
   1331             see @ref ecode.h and @ref dmadrv.h for other error codes.
   1332          
   1333             The application code must include @em dmadrv.h header file.
   1334          
   1335             @ref DMADRV_Init(), @ref DMADRV_DeInit() @n
   1336              These functions initialize or deinitialize the DMADRV driver. Typically,
   1337              @htmlonly DMADRV_Init() @endhtmlonly is called once in the startup code.
   1338          
   1339             @ref DMADRV_AllocateChannel(), @ref DMADRV_FreeChannel() @n
   1340              DMA channel reserve and release functions. It is recommended that
   1341              application code check that @htmlonly DMADRV_AllocateChannel() @endhtmlonly
   1342              returns @htmlonly ECODE_EMDRV_DMADRV_OK @endhtmlonly before starting a DMA
   1343              transfer.
   1344          
   1345             @ref DMADRV_MemoryPeripheral() @n
   1346              Start a DMA transfer from memory to a peripheral.
   1347          
   1348             @ref DMADRV_PeripheralMemory() @n
   1349              Start a DMA transfer from a peripheral to memory.
   1350          
   1351             @ref DMADRV_MemoryPeripheralPingPong() @n
   1352              Start a DMA ping-pong transfer from memory to a peripheral.
   1353          
   1354             @ref DMADRV_PeripheralMemoryPingPong() @n
   1355              Start a DMA ping-pong transfer from a peripheral to memory.
   1356          
   1357             @ref DMADRV_LdmaStartTransfer() @n
   1358              Start a DMA transfer on an LDMA controller. This function can only be used
   1359              when configuration option @ref EMDRV_DMADRV_USE_NATIVE_API is defined.
   1360              It is a wrapper similar to the emlib LDMA function, but adds support for
   1361              completion callback and user-defined callback function parameter.
   1362          
   1363             @ref DMADRV_StopTransfer() @n
   1364              Stop an ongoing DMA transfer.
   1365          
   1366             @ref DMADRV_TransferActive() @n
   1367              Check if a transfer is ongoing.
   1368          
   1369             @ref DMADRV_TransferCompletePending() @n
   1370              Check if a transfer completion is pending.
   1371          
   1372             @ref DMADRV_TransferDone() @n
   1373              Check if a transfer has completed.
   1374          
   1375             @ref DMADRV_TransferRemainingCount() @n
   1376              Get number of items remaining in a transfer.
   1377          
   1378             @n @section dmadrv_example Example
   1379             Transfer a text string to USART1.
   1380             @verbatim
   1381           #include "dmadrv.h"
   1382          
   1383             char str[] = "Hello DMA !";
   1384             unsigned int channel;
   1385          
   1386             int main( void )
   1387             {
   1388             // Initialize DMA.
   1389             DMADRV_Init();
   1390          
   1391             // Request a DMA channel.
   1392             DMADRV_AllocateChannel( &channel, NULL );
   1393          
   1394             // Start the DMA transfer.
   1395             DMADRV_MemoryPeripheral( channel,
   1396                                     dmadrvPeripheralSignal_USART1_TXBL,
   1397                                     (void*)&(USART1->TXDATA),
   1398                                     str,
   1399                                     true,
   1400                                     sizeof( str ),
   1401                                     dmadrvDataSize1,
   1402                                     NULL,
   1403                                     NULL );
   1404          
   1405             return 0;
   1406             }
   1407             @endverbatim
   1408          
   1409           * @} end group DMADRV ********************************************************
   1410           * @} end group emdrv ****************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   DMADRV_AllocateChannel
        16   -> CORE_EnterAtomic
        16   -> CORE_ExitAtomic
       8   DMADRV_DeInit
         8   -> CORE_EnterAtomic
         8   -> CORE_ExitAtomic
         8   -> LDMA_DeInit
       8   DMADRV_FreeChannel
         8   -> CORE_EnterAtomic
         8   -> CORE_ExitAtomic
       8   DMADRV_Init
         8   -> CORE_EnterAtomic
         8   -> CORE_ExitAtomic
         8   -> LDMA_Init
      56   DMADRV_MemoryPeripheral
        56   -> StartTransfer
      56   DMADRV_MemoryPeripheralPingPong
        56   -> StartTransfer
       8   DMADRV_PauseTransfer
         8   -> LDMA_EnableChannelRequest
      56   DMADRV_PeripheralMemory
        56   -> StartTransfer
      56   DMADRV_PeripheralMemoryPingPong
        56   -> StartTransfer
       8   DMADRV_ResumeTransfer
         8   -> LDMA_EnableChannelRequest
       8   DMADRV_StopTransfer
         8   -> LDMA_StopTransfer
       8   DMADRV_TransferActive
       8   DMADRV_TransferCompletePending
       8   DMADRV_TransferDone
         8   -> LDMA_TransferDone
       8   DMADRV_TransferRemainingCount
         8   -> LDMA_TransferRemainingCount
      24   LDMA_IRQHandler
        24   -- Indirect call
      64   StartTransfer
        64   -> LDMA_StartTransfer
        64   -> __aeabi_memclr4
        64   -> __aeabi_memcpy4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       8  ?Subroutine0
       6  ?Subroutine1
      10  ?Subroutine10
      38  ?Subroutine11
      10  ?Subroutine12
       8  ?Subroutine13
      14  ?Subroutine14
      14  ?Subroutine15
       4  ?Subroutine2
       4  ?Subroutine3
       4  ?Subroutine4
       8  ?Subroutine5
       4  ?Subroutine6
       4  ?Subroutine7
       4  ?Subroutine8
      10  ?Subroutine9
       4  ?_0
      84  DMADRV_AllocateChannel
      56  DMADRV_DeInit
      52  DMADRV_FreeChannel
      80  DMADRV_Init
      12  DMADRV_MemoryPeripheral
      34  DMADRV_MemoryPeripheralPingPong
      28  DMADRV_PauseTransfer
      10  DMADRV_PeripheralMemory
      34  DMADRV_PeripheralMemoryPingPong
      28  DMADRV_ResumeTransfer
      32  DMADRV_StopTransfer
      50  DMADRV_TransferActive
      42  DMADRV_TransferCompletePending
      36  DMADRV_TransferDone
      36  DMADRV_TransferRemainingCount
      94  LDMA_IRQHandler
     322  StartTransfer
     128  chTable
     256  dmaXfer
       1  initialized
      16  m2p
      16  p2m
      16  xferCfg

 
   385 bytes in section .bss
    52 bytes in section .rodata
 1 244 bytes in section .text
 
 1 244 bytes of CODE  memory
    52 bytes of CONST memory
   385 bytes of DATA  memory

Errors: none
Warnings: none
