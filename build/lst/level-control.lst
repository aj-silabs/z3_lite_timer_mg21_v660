###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:19:16
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\protocol\zigbee\app\framework\plugin\level-control\level-control.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EWAFDB.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\protocol\zigbee\app\framework\plugin\level-control\level-control.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"level-control.c\"" -D PSSTORE_SIZE=0 -D
#        LONGTOKEN_SIZE=0 -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\protocol\zigbee\app\framework\plugin\level-control\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\level-control.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\level-control.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\protocol\zigbee\app\framework\plugin\level-control\level-control.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Routines for the Level Control plugin, which implements the
      4           *        Level Control cluster.
      5           *******************************************************************************
      6           * # License
      7           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      8           *******************************************************************************
      9           *
     10           * The licensor of this software is Silicon Laboratories Inc. Your use of this
     11           * software is governed by the terms of Silicon Labs Master Software License
     12           * Agreement (MSLA) available at
     13           * www.silabs.com/about-us/legal/master-software-license-agreement. This
     14           * software is distributed to you in Source Code format and is governed by the
     15           * sections of the MSLA applicable to Source Code.
     16           *
     17           ******************************************************************************/
     18          
     19          // this file contains all the common includes for clusters in the util
     20          #include "app/framework/include/af.h"
     21          
     22          // clusters specific header
     23          #include "level-control.h"
     24          
     25          #ifdef EMBER_AF_PLUGIN_REPORTING
     26            #include "app/framework/plugin/reporting/reporting.h"
     27          #endif
     28          
     29          #ifdef EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER
     30            #include "app/framework/plugin/zll-level-control-server/zll-level-control-server.h"
     31          #endif //EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER
     32          
     33          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_START_UP_CURRENT_LEVEL_ATTRIBUTE
     34          static bool areStartUpLevelControlServerAttributesTokenized(uint8_t endpoint);
     35          #endif
     36          
     37          #if (EMBER_AF_PLUGIN_LEVEL_CONTROL_RATE == 0)
     38            #define FASTEST_TRANSITION_TIME_MS 0
     39          #else
     40            #define FASTEST_TRANSITION_TIME_MS (MILLISECOND_TICKS_PER_SECOND / EMBER_AF_PLUGIN_LEVEL_CONTROL_RATE)
     41          #endif
     42          
     43          #ifdef EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER
     44            #define MIN_LEVEL EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER_MINIMUM_LEVEL
     45            #define MAX_LEVEL EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER_MAXIMUM_LEVEL
     46          #else
     47            #define MIN_LEVEL EMBER_AF_PLUGIN_LEVEL_CONTROL_MINIMUM_LEVEL
     48            #define MAX_LEVEL EMBER_AF_PLUGIN_LEVEL_CONTROL_MAXIMUM_LEVEL
     49          #endif
     50          
     51          #define INVALID_STORED_LEVEL 0xFFFF
     52          
     53          #define STARTUP_CURRENT_LEVEL_USE_DEVICE_MINIMUM 0x00
     54          #define STARTUP_CURRENT_LEVEL_USE_PREVIOUS_LEVEL 0xFF
     55          
     56          typedef struct {
     57            uint8_t commandId;
     58            uint8_t moveToLevel;
     59            bool increasing;
     60            bool useOnLevel;
     61            uint8_t onLevel;
     62            uint16_t storedLevel;
     63            uint32_t eventDurationMs;
     64            uint32_t transitionTimeMs;
     65            uint32_t elapsedTimeMs;
     66          } EmberAfLevelControlState;
     67          

   \                                 In section .bss, align 4
     68          static EmberAfLevelControlState stateTable[EMBER_AF_LEVEL_CONTROL_CLUSTER_SERVER_ENDPOINT_COUNT];
   \                     stateTable:
   \        0x0                      DS8 40
     69          
     70          static EmberAfLevelControlState *getState(uint8_t endpoint);
     71          
     72          static void moveToLevelHandler(uint8_t commandId,
     73                                         uint8_t level,
     74                                         uint16_t transitionTimeDs,
     75                                         uint8_t optionMask,
     76                                         uint8_t optionOverride,
     77                                         uint16_t storedLevel);
     78          static void moveHandler(uint8_t commandId,
     79                                  uint8_t moveMode,
     80                                  uint8_t rate,
     81                                  uint8_t optionMask,
     82                                  uint8_t optionOverride);
     83          static void stepHandler(uint8_t commandId,
     84                                  uint8_t stepMode,
     85                                  uint8_t stepSize,
     86                                  uint16_t transitionTimeDs,
     87                                  uint8_t optionMask,
     88                                  uint8_t optionOverride);
     89          static void stopHandler(uint8_t commandId,
     90                                  uint8_t optionMask,
     91                                  uint8_t optionOverride);
     92          
     93          static void setOnOffValue(uint8_t endpoint, bool onOff);
     94          static void writeRemainingTime(uint8_t endpoint, uint16_t remainingTimeMs);
     95          static bool shouldExecuteIfOff(uint8_t endpoint,
     96                                         uint8_t commandId,
     97                                         uint8_t optionMask,
     98                                         uint8_t optionOverride);
     99          
    100          #if defined(ZCL_USING_LEVEL_CONTROL_CLUSTER_OPTIONS_ATTRIBUTE) \
    101            && defined(EMBER_AF_PLUGIN_COLOR_CONTROL_SERVER_TEMP)
    102          static void reallyUpdateCoupledColorTemp(uint8_t endpoint);
    103          #define updateCoupledColorTemp(endpoint) reallyUpdateCoupledColorTemp(endpoint)
    104          #else
    105          #define updateCoupledColorTemp(endpoint)
    106          #endif // LEVEL...OPTIONS_ATTRIBUTE && COLOR...SERVER_TEMP
    107          

   \                                 In section .text, align 2, keep-with-next
    108          static void schedule(uint8_t endpoint, uint32_t delayMs)
    109          {
   \                     schedule: (+1)
   \        0x0   0x460A             MOV      R2,R1
   \        0x2   0xB580             PUSH     {R7,LR}
    110            emberAfScheduleServerTickExtended(endpoint,
    111                                              ZCL_LEVEL_CONTROL_CLUSTER_ID,
    112                                              delayMs,
    113                                              EMBER_AF_LONG_POLL,
    114                                              EMBER_AF_OK_TO_SLEEP);
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x9100             STR      R1,[SP, #+0]
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x2108             MOVS     R1,#+8
   \        0xC   0x....'....        BL       emberAfScheduleServerTickExtended
    115          }
   \       0x10   0xBD01             POP      {R0,PC}          ;; return
    116          

   \                                 In section .text, align 2, keep-with-next
    117          static void deactivate(uint8_t endpoint)
    118          {
    119            emberAfDeactivateServerTick(endpoint, ZCL_LEVEL_CONTROL_CLUSTER_ID);
   \                     deactivate: (+1)
   \        0x0   0x2108             MOVS     R1,#+8
   \        0x2   0x....'....        B.W      emberAfDeactivateServerTick
    120          }
    121          

   \                                 In section .text, align 2, keep-with-next
    122          static EmberAfLevelControlState *getState(uint8_t endpoint)
    123          {
   \                     getState: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    124            uint8_t ep = emberAfFindClusterServerEndpointIndex(endpoint,
    125                                                               ZCL_LEVEL_CONTROL_CLUSTER_ID);
   \        0x2   0x2108             MOVS     R1,#+8
   \        0x4   0x....'....        BL       emberAfFindClusterServerEndpointIndex
    126            return (ep == 0xFF ? NULL : &stateTable[ep]);
   \        0x8   0x28FF             CMP      R0,#+255
   \        0xA   0xD101             BNE.N    ??getState_0
   \        0xC   0x2000             MOVS     R0,#+0
   \        0xE   0xBD02             POP      {R1,PC}
   \                     ??getState_0: (+1)
   \       0x10   0x2114             MOVS     R1,#+20
   \       0x12   0x4348             MULS     R0,R1,R0
   \       0x14   0x....'....        LDR.W    R2,??DataTable6
   \       0x18   0x4410             ADD      R0,R2,R0
   \       0x1A   0xBD02             POP      {R1,PC}          ;; return
    127          }
    128          
    129          #if defined(ZCL_USING_LEVEL_CONTROL_CLUSTER_OPTIONS_ATTRIBUTE) \
    130            && defined(EMBER_AF_PLUGIN_COLOR_CONTROL_SERVER_TEMP)

   \                                 In section .text, align 2, keep-with-next
    131          static void reallyUpdateCoupledColorTemp(uint8_t endpoint)
    132          {
   \                     reallyUpdateCoupledColorTemp: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
    133            uint8_t options;
    134            EmberAfStatus status = emberAfReadServerAttribute(endpoint,
    135                                                              ZCL_LEVEL_CONTROL_CLUSTER_ID,
    136                                                              ZCL_OPTIONS_ATTRIBUTE_ID,
    137                                                              &options,
    138                                                              sizeof(options));
    139            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \        0x2   0x2501             MOVS     R5,#+1
   \        0x4   0x4604             MOV      R4,R0
   \        0x6   0x9500             STR      R5,[SP, #+0]
   \        0x8   0xAB01             ADD      R3,SP,#+4
   \        0xA   0x220F             MOVS     R2,#+15
   \        0xC   0x2108             MOVS     R1,#+8
   \        0xE   0x....'....        BL       emberAfReadServerAttribute
   \       0x12   0xB930             CBNZ.N   R0,??reallyUpdateCoupledColorTemp_0
    140              emberAfLevelControlClusterPrintln("Unable to read Options attribute: 0x%X",
    141                                                status);
    142              return;
    143            }
    144          
    145            if (READBITS(options, EMBER_ZCL_LEVEL_CONTROL_OPTIONS_COUPLE_COLOR_TEMP_TO_LEVEL)) {
   \       0x14   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x18   0x0781             LSLS     R1,R0,#+30
   \       0x1A   0xBF44             ITT      MI 
    146              emberAfPluginLevelControlCoupledColorTempChangeCallback(endpoint);
   \       0x1C   0x4620             MOVMI    R0,R4
   \       0x1E   0x....'....        BLMI     emberAfPluginLevelControlCoupledColorTempChangeCallback
    147            }
    148          }
   \                     ??reallyUpdateCoupledColorTemp_0: (+1)
   \       0x22   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
    149          #endif // LEVEL...OPTIONS_ATTRIBUTE && COLOR...SERVER_TEMP
    150          

   \                                 In section .text, align 2, keep-with-next
    151          void emberAfLevelControlClusterServerTickCallback(uint8_t endpoint)
    152          {
   \                     emberAfLevelControlClusterServerTickCallback: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4605             MOV      R5,R0
    153            EmberAfLevelControlState *state = getState(endpoint);
   \        0x4   0x....'....        BL       getState
   \        0x8   0x0004             MOVS     R4,R0
    154            EmberAfStatus status;
    155            uint8_t currentLevel;
    156          
    157            if (state == NULL) {
   \        0xA   0xF000 0x808D      BEQ.W    ??emberAfLevelControlClusterServerTickCallback_0
    158              return;
    159            }
    160          
    161            state->elapsedTimeMs += state->eventDurationMs;
   \        0xE   0x6921             LDR      R1,[R4, #+16]
   \       0x10   0x68A0             LDR      R0,[R4, #+8]
    162          
    163          #if !defined(ZCL_USING_LEVEL_CONTROL_CLUSTER_OPTIONS_ATTRIBUTE) \
    164            && defined(EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER)
    165            if (emberAfPluginZllLevelControlServerIgnoreMoveToLevelMoveStepStop(endpoint,
    166                                                                                state->commandId)) {
    167              return;
    168            }
    169          #endif
    170          
    171            // Read the attribute; print error message and return if it can't be read
    172            status = emberAfReadServerAttribute(endpoint,
    173                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    174                                                ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    175                                                (uint8_t *)&currentLevel,
    176                                                sizeof(currentLevel));
    177            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \       0x12   0xAB01             ADD      R3,SP,#+4
   \       0x14   0x2200             MOVS     R2,#+0
   \       0x16   0x1841             ADDS     R1,R0,R1
   \       0x18   0x6121             STR      R1,[R4, #+16]
   \       0x1A   0x2101             MOVS     R1,#+1
   \       0x1C   0x9100             STR      R1,[SP, #+0]
   \       0x1E   0x2108             MOVS     R1,#+8
   \       0x20   0x4628             MOV      R0,R5
   \       0x22   0x....'....        BL       emberAfReadServerAttribute
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD16E             BNE.N    ??emberAfLevelControlClusterServerTickCallback_1
    178              emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
    179              writeRemainingTime(endpoint, 0);
    180              return;
    181            }
    182          
    183            emberAfLevelControlClusterPrint("Event: move from %d", currentLevel);
    184          
    185            // adjust by the proper amount, either up or down
    186            if (state->transitionTimeMs == 0) {
   \       0x2A   0x68E0             LDR      R0,[R4, #+12]
   \       0x2C   0xB908             CBNZ.N   R0,??emberAfLevelControlClusterServerTickCallback_2
    187              // Immediate, not over a time interval.
    188              currentLevel = state->moveToLevel;
   \       0x2E   0x7860             LDRB     R0,[R4, #+1]
   \       0x30   0xE013             B.N      ??emberAfLevelControlClusterServerTickCallback_3
    189            } else if (state->increasing) {
   \                     ??emberAfLevelControlClusterServerTickCallback_2: (+1)
   \       0x32   0x78A0             LDRB     R0,[R4, #+2]
   \       0x34   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \       0x38   0x....'....        LDR.W    R6,??DataTable6_1
   \       0x3C   0xB180             CBZ.N    R0,??emberAfLevelControlClusterServerTickCallback_4
    190              assert(currentLevel < MAX_LEVEL);
   \       0x3E   0x29FE             CMP      R1,#+254
   \       0x40   0xDB02             BLT.N    ??CrossCallReturnLabel_20
   \       0x42   0x21BE             MOVS     R1,#+190
   \       0x44   0x....'....        BL       ?Subroutine8
    191              assert(currentLevel < state->moveToLevel);
   \                     ??CrossCallReturnLabel_20: (+1)
   \       0x48   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x4C   0xD302             BCC.N    ??CrossCallReturnLabel_19
   \       0x4E   0x21BF             MOVS     R1,#+191
   \       0x50   0x....'....        BL       ?Subroutine8
    192              currentLevel++;
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x54   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x58   0x1C40             ADDS     R0,R0,#+1
   \                     ??emberAfLevelControlClusterServerTickCallback_3: (+1)
   \       0x5A   0xF88D 0x0004      STRB     R0,[SP, #+4]
   \       0x5E   0xE00F             B.N      ??emberAfLevelControlClusterServerTickCallback_5
    193            } else {
    194              assert(MIN_LEVEL < currentLevel);
   \                     ??emberAfLevelControlClusterServerTickCallback_4: (+1)
   \       0x60   0x2901             CMP      R1,#+1
   \       0x62   0xDC02             BGT.N    ??CrossCallReturnLabel_18
   \       0x64   0x21C2             MOVS     R1,#+194
   \       0x66   0x....'....        BL       ?Subroutine8
    195              assert(state->moveToLevel < currentLevel);
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x6A   0x....'....        BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x6E   0xD302             BCC.N    ??CrossCallReturnLabel_17
   \       0x70   0x21C3             MOVS     R1,#+195
   \       0x72   0x....'....        BL       ?Subroutine8
    196              currentLevel--;
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x76   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x7A   0x1E41             SUBS     R1,R0,#+1
   \       0x7C   0xF88D 0x1004      STRB     R1,[SP, #+4]
    197            }
    198          
    199            emberAfLevelControlClusterPrint(" to %d ", currentLevel);
    200            emberAfLevelControlClusterPrintln("(diff %c1)",
    201                                              state->increasing ? '+' : '-');
    202          
    203            status = emberAfWriteServerAttribute(endpoint,
    204                                                 ZCL_LEVEL_CONTROL_CLUSTER_ID,
    205                                                 ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    206                                                 (uint8_t *)&currentLevel,
    207                                                 ZCL_INT8U_ATTRIBUTE_TYPE);
    208            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \                     ??emberAfLevelControlClusterServerTickCallback_5: (+1)
   \       0x80   0x2020             MOVS     R0,#+32
   \       0x82   0x9000             STR      R0,[SP, #+0]
   \       0x84   0xAB01             ADD      R3,SP,#+4
   \       0x86   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x8A   0x2800             CMP      R0,#+0
   \       0x8C   0xD13C             BNE.N    ??emberAfLevelControlClusterServerTickCallback_1
    209              emberAfLevelControlClusterPrintln("ERR: writing current level %x", status);
    210              writeRemainingTime(endpoint, 0);
    211              return;
    212            }
    213          
    214            updateCoupledColorTemp(endpoint);
   \       0x8E   0x4628             MOV      R0,R5
   \       0x90   0x....'....        BL       reallyUpdateCoupledColorTemp
    215          
    216            // The level has changed, so the scene is no longer valid.
    217            if (emberAfContainsServer(endpoint, ZCL_SCENES_CLUSTER_ID)) {
   \       0x94   0x2105             MOVS     R1,#+5
   \       0x96   0x4628             MOV      R0,R5
   \       0x98   0x....'....        BL       emberAfContainsServer
   \       0x9C   0xB110             CBZ.N    R0,??emberAfLevelControlClusterServerTickCallback_6
    218              emberAfScenesClusterMakeInvalidCallback(endpoint);
   \       0x9E   0x4628             MOV      R0,R5
   \       0xA0   0x....'....        BL       emberAfScenesClusterMakeInvalidCallback
    219            }
    220          
    221            // Are we at the requested level?
    222            if (currentLevel == state->moveToLevel) {
   \                     ??emberAfLevelControlClusterServerTickCallback_6: (+1)
   \       0xA4   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0xA8   0xD133             BNE.N    ??emberAfLevelControlClusterServerTickCallback_7
    223              if (state->commandId == ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID
    224                  || state->commandId == ZCL_MOVE_WITH_ON_OFF_COMMAND_ID
    225                  || state->commandId == ZCL_STEP_WITH_ON_OFF_COMMAND_ID) {
   \       0xAA   0x7820             LDRB     R0,[R4, #+0]
   \       0xAC   0x2804             CMP      R0,#+4
   \       0xAE   0xBF1C             ITT      NE 
   \       0xB0   0x2805             CMPNE    R0,#+5
   \       0xB2   0x2806             CMPNE    R0,#+6
   \       0xB4   0xD117             BNE.N    ??emberAfLevelControlClusterServerTickCallback_8
    226                setOnOffValue(endpoint, (currentLevel != MIN_LEVEL));
   \       0xB6   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0xBA   0x2801             CMP      R0,#+1
   \       0xBC   0x4628             MOV      R0,R5
   \       0xBE   0xBF14             ITE      NE 
   \       0xC0   0x2101             MOVNE    R1,#+1
   \       0xC2   0x2100             MOVEQ    R1,#+0
   \       0xC4   0x....'....        BL       setOnOffValue
    227                if (currentLevel == MIN_LEVEL && state->useOnLevel) {
   \       0xC8   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0xCC   0x2801             CMP      R0,#+1
   \       0xCE   0xD11B             BNE.N    ??emberAfLevelControlClusterServerTickCallback_1
   \       0xD0   0x78E0             LDRB     R0,[R4, #+3]
   \       0xD2   0xB1C8             CBZ.N    R0,??emberAfLevelControlClusterServerTickCallback_1
    228                  status = emberAfWriteServerAttribute(endpoint,
    229                                                       ZCL_LEVEL_CONTROL_CLUSTER_ID,
    230                                                       ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    231                                                       (uint8_t *)&state->onLevel,
    232                                                       ZCL_INT8U_ATTRIBUTE_TYPE);
    233                  if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \       0xD4   0x2120             MOVS     R1,#+32
   \       0xD6   0x9100             STR      R1,[SP, #+0]
   \       0xD8   0x1D23             ADDS     R3,R4,#+4
   \       0xDA   0x2200             MOVS     R2,#+0
   \       0xDC   0x2108             MOVS     R1,#+8
   \       0xDE   0x4628             MOV      R0,R5
   \       0xE0   0x....'....        BL       emberAfWriteServerAttribute
   \       0xE4   0xE00C             B.N      ??CrossCallReturnLabel_7
    234                    emberAfLevelControlClusterPrintln("ERR: writing current level %x",
    235                                                      status);
    236                  } else {
    237                    updateCoupledColorTemp(endpoint);
    238                  }
    239                }
    240              } else {
    241                if (state->storedLevel != INVALID_STORED_LEVEL) {
   \                     ??emberAfLevelControlClusterServerTickCallback_8: (+1)
   \       0xE6   0x88E0             LDRH     R0,[R4, #+6]
   \       0xE8   0xF64F 0x71FF      MOVW     R1,#+65535
   \       0xEC   0x4288             CMP      R0,R1
   \       0xEE   0xD00B             BEQ.N    ??emberAfLevelControlClusterServerTickCallback_1
    242                  uint8_t storedLevel8u = (uint8_t) state->storedLevel;
   \       0xF0   0xF88D 0x0005      STRB     R0,[SP, #+5]
    243                  status = emberAfWriteServerAttribute(endpoint,
    244                                                       ZCL_LEVEL_CONTROL_CLUSTER_ID,
    245                                                       ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    246                                                       (uint8_t *)&storedLevel8u,
    247                                                       ZCL_INT8U_ATTRIBUTE_TYPE);
    248                  if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \       0xF4   0x2020             MOVS     R0,#+32
   \       0xF6   0x9000             STR      R0,[SP, #+0]
   \       0xF8   0xF10D 0x0305      ADD      R3,SP,#+5
   \       0xFC   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_7: (+1)
   \      0x100   0xB910             CBNZ.N   R0,??emberAfLevelControlClusterServerTickCallback_1
    249                    emberAfLevelControlClusterPrintln("ERR: writing current level %x",
    250                                                      status);
    251                  } else {
    252                    updateCoupledColorTemp(endpoint);
   \      0x102   0x4628             MOV      R0,R5
   \      0x104   0x....'....        BL       reallyUpdateCoupledColorTemp
    253                  }
    254                }
    255              }
    256              writeRemainingTime(endpoint, 0);
   \                     ??emberAfLevelControlClusterServerTickCallback_1: (+1)
   \      0x108   0x2100             MOVS     R1,#+0
   \      0x10A   0x4628             MOV      R0,R5
   \      0x10C   0x....'....        BL       writeRemainingTime
   \      0x110   0xBD73             POP      {R0,R1,R4-R6,PC}
    257            } else {
    258              writeRemainingTime(endpoint,
    259                                 state->transitionTimeMs - state->elapsedTimeMs);
   \                     ??emberAfLevelControlClusterServerTickCallback_7: (+1)
   \      0x112   0x68E1             LDR      R1,[R4, #+12]
   \      0x114   0x6920             LDR      R0,[R4, #+16]
   \      0x116   0x1A09             SUBS     R1,R1,R0
   \      0x118   0xB289             UXTH     R1,R1
   \      0x11A   0x4628             MOV      R0,R5
   \      0x11C   0x....'....        BL       writeRemainingTime
    260              schedule(endpoint, state->eventDurationMs);
   \      0x120   0x68A1             LDR      R1,[R4, #+8]
   \      0x122   0x4628             MOV      R0,R5
   \      0x124   0x....'....        BL       schedule
    261            }
    262          }
   \                     ??emberAfLevelControlClusterServerTickCallback_0: (+1)
   \      0x128   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x4630             MOV      R0,R6
   \        0x2   0x....'....        B.W      halInternalAssertFailed

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x2200             MOVS     R2,#+0
   \        0x2   0x2108             MOVS     R1,#+8
   \        0x4   0x4628             MOV      R0,R5
   \        0x6   0x....'....        B.W      emberAfWriteServerAttribute

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \        0x4   0x7861             LDRB     R1,[R4, #+1]
   \        0x6   0x4288             CMP      R0,R1
   \        0x8   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x7860             LDRB     R0,[R4, #+1]
   \        0x2   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \        0x6   0x4288             CMP      R0,R1
   \        0x8   0x4770             BX       LR
    263          

   \                                 In section .text, align 2, keep-with-next
    264          static void writeRemainingTime(uint8_t endpoint, uint16_t remainingTimeMs)
    265          {
    266          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_LEVEL_CONTROL_REMAINING_TIME_ATTRIBUTE
    267            // Convert milliseconds to tenths of a second, rounding any fractional value
    268            // up to the nearest whole value.  This means:
    269            //
    270            //   0 ms = 0.00 ds = 0 ds
    271            //   1 ms = 0.01 ds = 1 ds
    272            //   ...
    273            //   100 ms = 1.00 ds = 1 ds
    274            //   101 ms = 1.01 ds = 2 ds
    275            //   ...
    276            //   200 ms = 2.00 ds = 2 ds
    277            //   201 ms = 2.01 ds = 3 ds
    278            //   ...
    279            //
    280            // This is done to ensure that the attribute, in tenths of a second, only
    281            // goes to zero when the remaining time in milliseconds is actually zero.
    282            uint16_t remainingTimeDs = (remainingTimeMs + 99) / 100;
   \                     writeRemainingTime: (+1)
   \        0x0   0x3163             ADDS     R1,R1,#+99
   \        0x2   0x2264             MOVS     R2,#+100
   \        0x4   0xFB91 0xF1F2      SDIV     R1,R1,R2
   \        0x8   0xB5E0             PUSH     {R5-R7,LR}
    283            EmberStatus status = emberAfWriteServerAttribute(endpoint,
    284                                                             ZCL_LEVEL_CONTROL_CLUSTER_ID,
    285                                                             ZCL_LEVEL_CONTROL_REMAINING_TIME_ATTRIBUTE_ID,
    286                                                             (uint8_t *)&remainingTimeDs,
    287                                                             ZCL_INT16U_ATTRIBUTE_TYPE);
   \        0xA   0x2321             MOVS     R3,#+33
   \        0xC   0xF8AD 0x1004      STRH     R1,[SP, #+4]
   \       0x10   0x9300             STR      R3,[SP, #+0]
   \       0x12   0xAB01             ADD      R3,SP,#+4
   \       0x14   0x2201             MOVS     R2,#+1
   \       0x16   0x2108             MOVS     R1,#+8
   \       0x18   0x....'....        BL       emberAfWriteServerAttribute
    288            if (status != EMBER_ZCL_STATUS_SUCCESS) {
    289              emberAfLevelControlClusterPrintln("ERR: writing remaining time %x", status);
    290            }
    291          #endif
    292          }
   \       0x1C   0xBD07             POP      {R0-R2,PC}       ;; return
    293          

   \                                 In section .text, align 2, keep-with-next
    294          static void setOnOffValue(uint8_t endpoint, bool onOff)
    295          {
   \                     setOnOffValue: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460D             MOV      R5,R1
   \        0x4   0x4604             MOV      R4,R0
    296            if (emberAfContainsServer(endpoint, ZCL_ON_OFF_CLUSTER_ID)) {
   \        0x6   0x2106             MOVS     R1,#+6
   \        0x8   0x....'....        BL       emberAfContainsServer
   \        0xC   0xB140             CBZ.N    R0,??setOnOffValue_0
    297              emberAfLevelControlClusterPrintln("Setting on/off to %p due to level change",
    298                                                onOff ? "ON" : "OFF");
    299              emberAfOnOffClusterSetValueCallback(endpoint,
    300                                                  (onOff ? ZCL_ON_COMMAND_ID : ZCL_OFF_COMMAND_ID),
    301                                                  true);
   \        0xE   0x0029             MOVS     R1,R5
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0xE8BD 0x4038      POP      {R3-R5,LR}
   \       0x16   0xBF18             IT       NE 
   \       0x18   0x2101             MOVNE    R1,#+1
   \       0x1A   0x2201             MOVS     R2,#+1
   \       0x1C   0x....'....        B.W      emberAfOnOffClusterSetValueCallback
    302            }
    303          }
   \                     ??setOnOffValue_0: (+1)
   \       0x20   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    304          

   \                                 In section .text, align 2, keep-with-next
    305          static bool shouldExecuteIfOff(uint8_t endpoint,
    306                                         uint8_t commandId,
    307                                         uint8_t optionMask,
    308                                         uint8_t optionOverride)
    309          {
   \                     shouldExecuteIfOff: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
   \        0x2   0x4606             MOV      R6,R0
   \        0x4   0x4614             MOV      R4,R2
   \        0x6   0x461D             MOV      R5,R3
    310          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_OPTIONS_ATTRIBUTE
    311            // From 3.10.2.2.8.1 of ZCL7 document 14-0127-20j-zcl-ch-3-general.docx:
    312            //   "Command execution SHALL NOT continue beyond the Options processing if
    313            //    all of these criteria are true:
    314            //      - The command is one of the ‘without On/Off’ commands: Move, Move to
    315            //        Level, Stop, or Step.
    316            //      - The On/Off cluster exists on the same endpoint as this cluster.
    317            //      - The OnOff attribute of the On/Off cluster, on this endpoint, is 0x00
    318            //        (FALSE).
    319            //      - The value of the ExecuteIfOff bit is 0."
    320            if (commandId > ZCL_STOP_COMMAND_ID) {
   \        0x8   0x2904             CMP      R1,#+4
   \        0xA   0xDA1E             BGE.N    ??shouldExecuteIfOff_0
    321              return true;
    322            }
    323          
    324            if (!emberAfContainsServer(endpoint, ZCL_ON_OFF_CLUSTER_ID)) {
   \        0xC   0x2106             MOVS     R1,#+6
   \        0xE   0x....'....        BL       emberAfContainsServer
   \       0x12   0xB1D0             CBZ.N    R0,??shouldExecuteIfOff_0
    325              return true;
    326            }
    327          
    328            uint8_t options;
    329            EmberAfStatus status = emberAfReadServerAttribute(endpoint,
    330                                                              ZCL_LEVEL_CONTROL_CLUSTER_ID,
    331                                                              ZCL_OPTIONS_ATTRIBUTE_ID,
    332                                                              &options,
    333                                                              sizeof(options));
    334            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0x9000             STR      R0,[SP, #+0]
   \       0x18   0xAB01             ADD      R3,SP,#+4
   \       0x1A   0x220F             MOVS     R2,#+15
   \       0x1C   0x2108             MOVS     R1,#+8
   \       0x1E   0x4630             MOV      R0,R6
   \       0x20   0x....'....        BL       emberAfReadServerAttribute
   \       0x24   0xB110             CBZ.N    R0,??shouldExecuteIfOff_1
    335              emberAfLevelControlClusterPrintln("Unable to read Options attribute: 0x%X",
    336                                                status);
    337              // If we can't read the attribute, then we should just assume that it has its
    338              // default value.
    339              options = 0x00;
   \       0x26   0x2000             MOVS     R0,#+0
   \       0x28   0xF88D 0x0004      STRB     R0,[SP, #+4]
    340            }
    341          
    342            bool on;
    343            status = emberAfReadServerAttribute(endpoint,
    344                                                ZCL_ON_OFF_CLUSTER_ID,
    345                                                ZCL_ON_OFF_ATTRIBUTE_ID,
    346                                                (uint8_t *)&on,
    347                                                sizeof(on));
    348            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \                     ??shouldExecuteIfOff_1: (+1)
   \       0x2C   0x2101             MOVS     R1,#+1
   \       0x2E   0x9100             STR      R1,[SP, #+0]
   \       0x30   0xF10D 0x0305      ADD      R3,SP,#+5
   \       0x34   0x2200             MOVS     R2,#+0
   \       0x36   0x2106             MOVS     R1,#+6
   \       0x38   0x4630             MOV      R0,R6
   \       0x3A   0x....'....        BL       emberAfReadServerAttribute
   \       0x3E   0x2800             CMP      R0,#+0
   \       0x40   0xBF04             ITT      EQ 
   \       0x42   0xF89D 0x0005      LDRBEQ   R0,[SP, #+5]
   \       0x46   0x2800             CMPEQ    R0,#+0
    349              emberAfLevelControlClusterPrintln("Unable to read OnOff attribute: 0x%X",
    350                                                status);
    351              return true;
    352            }
    353            // The device is on - hence ExecuteIfOff does not matter
    354            if (on) {
   \       0x48   0xD001             BEQ.N    ??shouldExecuteIfOff_2
    355              return true;
   \                     ??shouldExecuteIfOff_0: (+1)
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0xBD76             POP      {R1,R2,R4-R6,PC}
    356            }
    357            // The OptionsMask & OptionsOverride fields SHALL both be present or both
    358            // omitted in the command. A temporary Options bitmap SHALL be created from
    359            // the Options attribute, using the OptionsMask & OptionsOverride fields, if
    360            // present. Each bit of the temporary Options bitmap SHALL be determined as
    361            // follows:
    362            // Each bit in the Options attribute SHALL determine the corresponding bit in
    363            // the temporary Options bitmap, unless the OptionsMask field is present and
    364            // has the corresponding bit set to 1, in which case the corresponding bit in
    365            // the OptionsOverride field SHALL determine the corresponding bit in the
    366            // temporary Options bitmap.
    367            //The resulting temporary Options bitmap SHALL then be processed as defined
    368            // in section 3.10.2.2.3.
    369          
    370            // ---------- The following order is important in decission making -------
    371            // -----------more readable ----------
    372            //
    373            if (optionMask == 0xFF && optionOverride == 0xFF) {
   \                     ??shouldExecuteIfOff_2: (+1)
   \       0x4E   0x2CFF             CMP      R4,#+255
   \       0x50   0xBF08             IT       EQ 
   \       0x52   0x2DFF             CMPEQ    R5,#+255
   \       0x54   0xD004             BEQ.N    ??shouldExecuteIfOff_3
    374              // 0xFF are the default values passed to the command handler when
    375              // the payload is not present - in that case there is use of option
    376              // attribute to decide execution of the command
    377              return READBITS(options, EMBER_ZCL_LEVEL_CONTROL_OPTIONS_EXECUTE_IF_OFF);
    378            }
    379            // ---------- The above is to distinguish if the payload is present or not
    380          
    381            if (READBITS(optionMask, EMBER_ZCL_LEVEL_CONTROL_OPTIONS_EXECUTE_IF_OFF)) {
   \       0x56   0x07E0             LSLS     R0,R4,#+31
   \       0x58   0xD502             BPL.N    ??shouldExecuteIfOff_3
    382              // Mask is present and set in the command payload, this indicates
    383              // use the over ride as temporary option
    384              return READBITS(optionOverride, EMBER_ZCL_LEVEL_CONTROL_OPTIONS_EXECUTE_IF_OFF);
   \       0x5A   0xF005 0x0001      AND      R0,R5,#0x1
   \       0x5E   0xBD76             POP      {R1,R2,R4-R6,PC}
    385            }
    386            // if we are here - use the option bits
    387            return (READBITS(options, EMBER_ZCL_LEVEL_CONTROL_OPTIONS_EXECUTE_IF_OFF));
   \                     ??shouldExecuteIfOff_3: (+1)
   \       0x60   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x64   0xF000 0x0001      AND      R0,R0,#0x1
   \       0x68   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    388          
    389          #else
    390            // By default, we return true to continue supporting backwards compatibility.
    391            return true;
    392          #endif
    393          }
    394          

   \                                 In section .text, align 2, keep-with-next
    395          bool emberAfLevelControlClusterMoveToLevelCallback(uint8_t level,
    396                                                             uint16_t transitionTime,
    397                                                             uint8_t optionMask,
    398                                                             uint8_t optionOverride)
    399          {
   \                     emberAfLevelControlClusterMoveToLevelCallback: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    400            emberAfLevelControlClusterPrintln("%pMOVE_TO_LEVEL %x %2x %x %x",
    401                                              "RX level-control:",
    402                                              level,
    403                                              transitionTime,
    404                                              optionMask,
    405                                              optionOverride);
    406            moveToLevelHandler(ZCL_MOVE_TO_LEVEL_COMMAND_ID,
    407                               level,
    408                               transitionTime,
    409                               optionMask,
    410                               optionOverride,
    411                               INVALID_STORED_LEVEL); // Don't revert to the stored level
   \        0x2   0x9300             STR      R3,[SP, #+0]
   \        0x4   0x4613             MOV      R3,R2
   \        0x6   0x460A             MOV      R2,R1
   \        0x8   0xF64F 0x74FF      MOVW     R4,#+65535
   \        0xC   0x4601             MOV      R1,R0
   \        0xE   0x9401             STR      R4,[SP, #+4]
   \       0x10   0x2000             MOVS     R0,#+0
   \       0x12   0x....'....        BL       moveToLevelHandler
    412            return true;
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    413          }
    414          

   \                                 In section .text, align 2, keep-with-next
    415          bool emberAfLevelControlClusterMoveToLevelWithOnOffCallback(uint8_t level,
    416                                                                      uint16_t transitionTime)
    417          {
   \                     emberAfLevelControlClusterMoveToLevelWithOnOffCallback: (+1)
   \        0x0   0x460A             MOV      R2,R1
   \        0x2   0xB5E0             PUSH     {R5-R7,LR}
    418            emberAfLevelControlClusterPrintln("%pMOVE_TO_LEVEL_WITH_ON_OFF %x %2x",
    419                                              "RX level-control:",
    420                                              level,
    421                                              transitionTime);
    422            moveToLevelHandler(ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID,
    423                               level,
    424                               transitionTime,
    425                               0xFF,
    426                               0xFF,
    427                               INVALID_STORED_LEVEL); // Don't revert to the stored level
   \        0x4   0xF64F 0x71FF      MOVW     R1,#+65535
   \        0x8   0x9101             STR      R1,[SP, #+4]
   \        0xA   0x23FF             MOVS     R3,#+255
   \        0xC   0x4601             MOV      R1,R0
   \        0xE   0x9300             STR      R3,[SP, #+0]
   \       0x10   0x2004             MOVS     R0,#+4
   \       0x12   0x....'....        BL       moveToLevelHandler
    428            return true;
   \       0x16   0x2001             MOVS     R0,#+1
   \       0x18   0xBD0E             POP      {R1-R3,PC}       ;; return
    429          }
    430          

   \                                 In section .text, align 2, keep-with-next
    431          bool emberAfLevelControlClusterMoveCallback(uint8_t moveMode,
    432                                                      uint8_t rate,
    433                                                      uint8_t optionMask,
    434                                                      uint8_t optionOverride)
    435          {
   \                     emberAfLevelControlClusterMoveCallback: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    436            emberAfLevelControlClusterPrintln("%pMOVE %x %x",
    437                                              "RX level-control:",
    438                                              moveMode,
    439                                              rate);
    440            moveHandler(ZCL_MOVE_COMMAND_ID, moveMode, rate, optionMask, optionOverride);
   \        0x2   0x9300             STR      R3,[SP, #+0]
   \        0x4   0x4613             MOV      R3,R2
   \        0x6   0x460A             MOV      R2,R1
   \        0x8   0x4601             MOV      R1,R0
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x....             B.N      ?Subroutine0
    441            return true;
    442          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x....'....        BL       moveHandler
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0xBD02             POP      {R1,PC}          ;; return
    443          

   \                                 In section .text, align 2, keep-with-next
    444          bool emberAfLevelControlClusterMoveWithOnOffCallback(uint8_t moveMode, uint8_t rate)
    445          {
   \                     emberAfLevelControlClusterMoveWithOnOffCallback: (+1)
   \        0x0   0x460A             MOV      R2,R1
   \        0x2   0xB580             PUSH     {R7,LR}
    446            emberAfLevelControlClusterPrintln("%pMOVE_WITH_ON_OFF %x %x",
    447                                              "RX level-control:",
    448                                              moveMode,
    449                                              rate);
    450            moveHandler(ZCL_MOVE_WITH_ON_OFF_COMMAND_ID, moveMode, rate, 0xFF, 0xFF);
   \        0x4   0x21FF             MOVS     R1,#+255
   \        0x6   0x9100             STR      R1,[SP, #+0]
   \        0x8   0x4601             MOV      R1,R0
   \        0xA   0x23FF             MOVS     R3,#+255
   \        0xC   0x2005             MOVS     R0,#+5
   \        0xE                      REQUIRE ?Subroutine0
   \        0xE                      ;; // Fall through to label ?Subroutine0
    451            return true;
    452          }
    453          

   \                                 In section .text, align 2, keep-with-next
    454          bool emberAfLevelControlClusterStepCallback(uint8_t stepMode,
    455                                                      uint8_t stepSize,
    456                                                      uint16_t transitionTime,
    457                                                      uint8_t optionMask,
    458                                                      uint8_t optionOverride)
    459          {
   \                     emberAfLevelControlClusterStepCallback: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    460            emberAfLevelControlClusterPrintln("%pSTEP %x %x %2x",
    461                                              "RX level-control:",
    462                                              stepMode,
    463                                              stepSize,
    464                                              transitionTime);
    465            stepHandler(ZCL_STEP_COMMAND_ID, stepMode, stepSize, transitionTime, optionMask, optionOverride);
   \        0x2   0x9300             STR      R3,[SP, #+0]
   \        0x4   0x9C04             LDR      R4,[SP, #+16]
   \        0x6   0x4613             MOV      R3,R2
   \        0x8   0x460A             MOV      R2,R1
   \        0xA   0x4601             MOV      R1,R0
   \        0xC   0x9401             STR      R4,[SP, #+4]
   \        0xE   0x2002             MOVS     R0,#+2
   \       0x10   0x....'....        BL       stepHandler
    466            return true;
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    467          }
    468          

   \                                 In section .text, align 2, keep-with-next
    469          bool emberAfLevelControlClusterStepWithOnOffCallback(uint8_t stepMode,
    470                                                               uint8_t stepSize,
    471                                                               uint16_t transitionTime)
    472          {
   \                     emberAfLevelControlClusterStepWithOnOffCallback: (+1)
   \        0x0   0x4613             MOV      R3,R2
   \        0x2   0xB5E0             PUSH     {R5-R7,LR}
    473            emberAfLevelControlClusterPrintln("%pSTEP_WITH_ON_OFF %x %x %2x",
    474                                              "RX level-control:",
    475                                              stepMode,
    476                                              stepSize,
    477                                              transitionTime);
    478            stepHandler(ZCL_STEP_WITH_ON_OFF_COMMAND_ID,
    479                        stepMode,
    480                        stepSize,
    481                        transitionTime,
    482                        0xFF,
    483                        0xFF);
   \        0x4   0x22FF             MOVS     R2,#+255
   \        0x6   0x9201             STR      R2,[SP, #+4]
   \        0x8   0x9200             STR      R2,[SP, #+0]
   \        0xA   0x460A             MOV      R2,R1
   \        0xC   0x4601             MOV      R1,R0
   \        0xE   0x2006             MOVS     R0,#+6
   \       0x10   0x....'....        BL       stepHandler
    484            return true;
   \       0x14   0x2001             MOVS     R0,#+1
   \       0x16   0xBD0E             POP      {R1-R3,PC}       ;; return
    485          }
    486          

   \                                 In section .text, align 2, keep-with-next
    487          bool emberAfLevelControlClusterStopCallback(uint8_t optionMask,
    488                                                      uint8_t optionOverride)
    489          {
   \                     emberAfLevelControlClusterStopCallback: (+1)
   \        0x0   0x460A             MOV      R2,R1
    490            emberAfLevelControlClusterPrintln("%pSTOP", "RX level-control:");
    491            stopHandler(ZCL_STOP_COMMAND_ID, optionMask, optionOverride);
   \        0x2   0x4601             MOV      R1,R0
   \        0x4   0xB580             PUSH     {R7,LR}
   \        0x6   0x2003             MOVS     R0,#+3
   \        0x8   0x....             B.N      ?Subroutine1
    492            return true;
    493          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x....'....        BL       stopHandler
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0xBD02             POP      {R1,PC}          ;; return
    494          

   \                                 In section .text, align 2, keep-with-next
    495          bool emberAfLevelControlClusterStopWithOnOffCallback(void)
    496          {
   \                     emberAfLevelControlClusterStopWithOnOffCallback: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    497            emberAfLevelControlClusterPrintln("%pSTOP_WITH_ON_OFF", "RX level-control:");
    498            stopHandler(ZCL_STOP_WITH_ON_OFF_COMMAND_ID, 0xFF, 0xFF);
   \        0x2   0x22FF             MOVS     R2,#+255
   \        0x4   0x21FF             MOVS     R1,#+255
   \        0x6   0x2007             MOVS     R0,#+7
   \        0x8                      REQUIRE ?Subroutine1
   \        0x8                      ;; // Fall through to label ?Subroutine1
    499            return true;
    500          }
    501          

   \                                 In section .text, align 2, keep-with-next
    502          static void moveToLevelHandler(uint8_t commandId,
    503                                         uint8_t level,
    504                                         uint16_t transitionTimeDs,
    505                                         uint8_t optionMask,
    506                                         uint8_t optionOverride,
    507                                         uint16_t storedLevel)
    508          {
   \                     moveToLevelHandler: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x460D             MOV      R5,R1
    509            uint8_t endpoint = emberAfCurrentEndpoint();
   \        0x6   0x....             LDR.N    R6,??DataTable6_2
   \        0x8   0x6831             LDR      R1,[R6, #+0]
   \        0xA   0x4690             MOV      R8,R2
   \        0xC   0x4607             MOV      R7,R0
   \        0xE   0x680A             LDR      R2,[R1, #+0]
   \       0x10   0x469A             MOV      R10,R3
   \       0x12   0x....'....        BL       ?Subroutine3
    510            EmberAfLevelControlState *state = getState(endpoint);
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x16   0x0004             MOVS     R4,R0
    511            EmberAfStatus status;
    512            uint8_t currentLevel;
    513            uint8_t actualStepSize;
    514          
    515            if (state == NULL) {
   \       0x18   0xBF08             IT       EQ 
   \       0x1A   0xF04F 0x0A01      MOVEQ    R10,#+1
    516              status = EMBER_ZCL_STATUS_FAILURE;
    517              goto send_default_response;
   \       0x1E   0xD058             BEQ.N    ??moveToLevelHandler_0
   \       0x20   0x9B0A             LDR      R3,[SP, #+40]
    518            }
    519          
    520            if (!shouldExecuteIfOff(endpoint, commandId, optionMask, optionOverride)) {
   \       0x22   0x4652             MOV      R2,R10
   \       0x24   0x4639             MOV      R1,R7
   \       0x26   0x4648             MOV      R0,R9
   \       0x28   0x....'....        BL       shouldExecuteIfOff
   \       0x2C   0xB318             CBZ.N    R0,??moveToLevelHandler_1
    521              status = EMBER_ZCL_STATUS_SUCCESS;
    522              goto send_default_response;
    523            }
    524          
    525            // Cancel any currently active command before fiddling with the state.
    526            deactivate(endpoint);
   \       0x2E   0x4648             MOV      R0,R9
   \       0x30   0x....'....        BL       deactivate
    527          
    528            status = emberAfReadServerAttribute(endpoint,
    529                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    530                                                ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    531                                                (uint8_t *)&currentLevel,
    532                                                sizeof(currentLevel));
   \       0x34   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x38   0xEA5F 0x0A00      MOVS     R10,R0
    533            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \       0x3C   0xD149             BNE.N    ??moveToLevelHandler_0
    534              emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
    535              goto send_default_response;
    536            }
    537          
    538            state->commandId = commandId;
    539          
    540            // Move To Level commands cause the device to move from its current level to
    541            // the specified level at the specified rate.
    542            if (MAX_LEVEL < level) {
   \       0x3E   0x2DFF             CMP      R5,#+255
   \       0x40   0x7027             STRB     R7,[R4, #+0]
   \       0x42   0xBF08             IT       EQ 
   \       0x44   0x25FE             MOVEQ    R5,#+254
    543              state->moveToLevel = MAX_LEVEL;
   \       0x46   0xD002             BEQ.N    ??moveToLevelHandler_2
    544            } else if (level < MIN_LEVEL) {
   \       0x48   0x0028             MOVS     R0,R5
   \       0x4A   0xBF08             IT       EQ 
   \       0x4C   0x2501             MOVEQ    R5,#+1
    545              state->moveToLevel = MIN_LEVEL;
    546            } else {
    547              state->moveToLevel = level;
   \                     ??moveToLevelHandler_2: (+1)
   \       0x4E   0x7065             STRB     R5,[R4, #+1]
    548            }
    549          
    550            // If the level is decreasing, the On/Off attribute is left unchanged.  This
    551            // logic is to prevent a light from transitioning from off to bright to dim.
    552            // Instead, a light that is off will stay off until the target level is
    553            // reached.
    554            if (currentLevel <= state->moveToLevel) {
   \       0x50   0x7861             LDRB     R1,[R4, #+1]
   \       0x52   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x56   0x4281             CMP      R1,R0
   \       0x58   0xD316             BCC.N    ??moveToLevelHandler_3
    555              if (commandId == ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID) {
   \       0x5A   0x2F04             CMP      R7,#+4
   \       0x5C   0xD106             BNE.N    ??moveToLevelHandler_4
    556                setOnOffValue(endpoint, (state->moveToLevel != MIN_LEVEL));
   \       0x5E   0x2901             CMP      R1,#+1
   \       0x60   0x4648             MOV      R0,R9
   \       0x62   0xBF14             ITE      NE 
   \       0x64   0x2101             MOVNE    R1,#+1
   \       0x66   0x2100             MOVEQ    R1,#+0
   \       0x68   0x....'....        BL       setOnOffValue
    557              }
    558              if (currentLevel == state->moveToLevel) {
   \                     ??moveToLevelHandler_4: (+1)
   \       0x6C   0x7860             LDRB     R0,[R4, #+1]
   \       0x6E   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \       0x72   0x4281             CMP      R1,R0
   \       0x74   0xD102             BNE.N    ??moveToLevelHandler_5
    559                status = EMBER_ZCL_STATUS_SUCCESS;
   \                     ??moveToLevelHandler_1: (+1)
   \       0x76   0xF04F 0x0A00      MOV      R10,#+0
    560                goto send_default_response;
   \       0x7A   0xE02A             B.N      ??moveToLevelHandler_0
    561              }
    562              state->increasing = true;
   \                     ??moveToLevelHandler_5: (+1)
   \       0x7C   0x2101             MOVS     R1,#+1
   \       0x7E   0x70A1             STRB     R1,[R4, #+2]
    563              actualStepSize = state->moveToLevel - currentLevel;
   \       0x80   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \       0x84   0x1A41             SUBS     R1,R0,R1
   \       0x86   0xE004             B.N      ??moveToLevelHandler_6
    564            } else {
    565              state->increasing = false;
   \                     ??moveToLevelHandler_3: (+1)
   \       0x88   0x2000             MOVS     R0,#+0
   \       0x8A   0x70A0             STRB     R0,[R4, #+2]
    566              actualStepSize = currentLevel - state->moveToLevel;
   \       0x8C   0xF89D 0x2004      LDRB     R2,[SP, #+4]
   \       0x90   0x1A51             SUBS     R1,R2,R1
    567            }
    568          
    569            // If the Transition time field takes the value 0xFFFF, then the time taken
    570            // to move to the new level shall instead be determined by the On/Off
    571            // Transition Time attribute.  If On/Off Transition Time, which is an
    572            // optional attribute, is not present, the device shall move to its new level
    573            // as fast as it is able.
    574            if (transitionTimeDs == 0xFFFF) {
   \                     ??moveToLevelHandler_6: (+1)
   \       0x92   0xF64F 0x73FF      MOVW     R3,#+65535
   \       0x96   0x4598             CMP      R8,R3
   \       0x98   0xBF08             IT       EQ 
   \       0x9A   0x2200             MOVEQ    R2,#+0
    575          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_ON_OFF_TRANSITION_TIME_ATTRIBUTE
    576              status = emberAfReadServerAttribute(endpoint,
    577                                                  ZCL_LEVEL_CONTROL_CLUSTER_ID,
    578                                                  ZCL_ON_OFF_TRANSITION_TIME_ATTRIBUTE_ID,
    579                                                  (uint8_t *)&transitionTimeDs,
    580                                                  sizeof(transitionTimeDs));
    581              if (status != EMBER_ZCL_STATUS_SUCCESS) {
    582                emberAfLevelControlClusterPrintln("ERR: reading on/off transition time %x",
    583                                                  status);
    584                goto send_default_response;
    585              }
    586          
    587              // Transition time comes in (or is stored, in the case of On/Off Transition
    588              // Time) as tenths of a second, but we work in milliseconds.
    589              state->transitionTimeMs = (transitionTimeDs
    590                                         * MILLISECOND_TICKS_PER_SECOND
    591                                         / 10);
    592          #else //ZCL_USING_LEVEL_CONTROL_CLUSTER_ON_OFF_TRANSITION_TIME_ATTRIBUTE
    593              // If the Transition Time field is 0xFFFF and On/Off Transition Time,
    594              // which is an optional attribute, is not present, the device shall move to
    595              // its new level as fast as it is able.
    596              state->transitionTimeMs = FASTEST_TRANSITION_TIME_MS;
   \       0x9C   0xD006             BEQ.N    ??moveToLevelHandler_7
    597          #endif //ZCL_USING_LEVEL_CONTROL_CLUSTER_ON_OFF_TRANSITION_TIME_ATTRIBUTE
    598            } else {
    599              // Transition time comes in (or is stored, in the case of On/Off Transition
    600              // Time) as tenths of a second, but we work in milliseconds.
    601              state->transitionTimeMs = (transitionTimeDs
    602                                         * MILLISECOND_TICKS_PER_SECOND
    603                                         / 10);
   \       0x9E   0xF44F 0x707A      MOV      R0,#+1000
   \       0xA2   0xFB00 0xF008      MUL      R0,R0,R8
   \       0xA6   0x220A             MOVS     R2,#+10
   \       0xA8   0xFBB0 0xF2F2      UDIV     R2,R0,R2
    604            }
    605          
    606            // The duration between events will be the transition time divided by the
    607            // distance we must move.
    608            state->eventDurationMs = state->transitionTimeMs / actualStepSize;
   \                     ??moveToLevelHandler_7: (+1)
   \       0xAC   0xB2C9             UXTB     R1,R1
   \       0xAE   0xFBB2 0xF1F1      UDIV     R1,R2,R1
   \       0xB2   0x980B             LDR      R0,[SP, #+44]
    609            state->elapsedTimeMs = 0;
   \       0xB4   0x2300             MOVS     R3,#+0
   \       0xB6   0x60A1             STR      R1,[R4, #+8]
    610          
    611            // OnLevel is not used for Move commands.
    612            state->useOnLevel = false;
    613          
    614            state->storedLevel = storedLevel;
    615          
    616            // The setup was successful, so mark the new state as active and return.
    617            schedule(endpoint, state->eventDurationMs);
   \       0xB8   0x68A1             LDR      R1,[R4, #+8]
   \       0xBA   0x80E0             STRH     R0,[R4, #+6]
   \       0xBC   0x60E2             STR      R2,[R4, #+12]
   \       0xBE   0x6123             STR      R3,[R4, #+16]
   \       0xC0   0x70E3             STRB     R3,[R4, #+3]
   \       0xC2   0x4648             MOV      R0,R9
   \       0xC4   0x....'....        BL       schedule
    618            status = EMBER_ZCL_STATUS_SUCCESS;
    619          
    620          #ifdef EMBER_AF_PLUGIN_ZLL_LEVEL_CONTROL_SERVER
    621            if (commandId == ZCL_MOVE_TO_LEVEL_WITH_ON_OFF_COMMAND_ID) {
   \       0xC8   0x2F04             CMP      R7,#+4
   \       0xCA   0xBF04             ITT      EQ 
    622              emberAfPluginZllLevelControlServerMoveToLevelWithOnOffZllExtensions(emberAfCurrentCommand());
   \       0xCC   0x6830             LDREQ    R0,[R6, #+0]
   \       0xCE   0x....'....        BLEQ     emberAfPluginZllLevelControlServerMoveToLevelWithOnOffZllExtensions
    623            }
    624          #endif
    625          
    626            send_default_response:
    627            if (emberAfCurrentCommand()->apsFrame->clusterId
    628                == ZCL_LEVEL_CONTROL_CLUSTER_ID) {
   \                     ??moveToLevelHandler_0: (+1)
   \       0xD2   0x6830             LDR      R0,[R6, #+0]
   \       0xD4   0x6801             LDR      R1,[R0, #+0]
   \       0xD6   0x884A             LDRH     R2,[R1, #+2]
   \       0xD8   0x2A08             CMP      R2,#+8
   \       0xDA   0xBF04             ITT      EQ 
    629              emberAfSendImmediateDefaultResponse(status);
   \       0xDC   0x4650             MOVEQ    R0,R10
   \       0xDE   0x....'....        BLEQ     emberAfSendImmediateDefaultResponse
    630            }
    631          }
   \       0xE2   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xF892 0x9005      LDRB     R9,[R2, #+5]
   \        0x4   0x4648             MOV      R0,R9
   \        0x6   0x....             B.N      getState

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0x9000             STR      R0,[SP, #+0]
   \        0x4   0xAB01             ADD      R3,SP,#+4
   \        0x6   0x2200             MOVS     R2,#+0
   \        0x8   0x2108             MOVS     R1,#+8
   \        0xA   0x4648             MOV      R0,R9
   \        0xC   0x....'....        B.W      emberAfReadServerAttribute
    632          

   \                                 In section .text, align 2, keep-with-next
    633          static void moveHandler(uint8_t commandId, uint8_t moveMode, uint8_t rate, uint8_t optionMask, uint8_t optionOverride)
    634          {
   \                     moveHandler: (+1)
   \        0x0   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \        0x4   0x4607             MOV      R7,R0
   \        0x6   0x460E             MOV      R6,R1
    635            uint8_t endpoint = emberAfCurrentEndpoint();
   \        0x8   0x....             LDR.N    R0,??DataTable6_2
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0x4690             MOV      R8,R2
   \        0xE   0x4699             MOV      R9,R3
   \       0x10   0x680A             LDR      R2,[R1, #+0]
   \       0x12   0x7955             LDRB     R5,[R2, #+5]
    636            EmberAfLevelControlState *state = getState(endpoint);
   \       0x14   0x4628             MOV      R0,R5
   \       0x16   0x....'....        BL       getState
   \       0x1A   0x0004             MOVS     R4,R0
    637            EmberAfStatus status;
    638            uint8_t currentLevel;
    639            uint8_t difference;
    640          
    641            if (state == NULL) {
   \       0x1C   0xD104             BNE.N    ??moveHandler_0
    642              status = EMBER_ZCL_STATUS_FAILURE;
   \       0x1E   0x2001             MOVS     R0,#+1
    643              goto send_default_response;
    644            }
    645          
    646            if (!shouldExecuteIfOff(endpoint, commandId, optionMask, optionOverride)) {
    647              status = EMBER_ZCL_STATUS_SUCCESS;
    648              goto send_default_response;
    649            }
    650          
    651            // Cancel any currently active command before fiddling with the state.
    652            deactivate(endpoint);
    653          
    654            status = emberAfReadServerAttribute(endpoint,
    655                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    656                                                ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    657                                                (uint8_t *)&currentLevel,
    658                                                sizeof(currentLevel));
    659            if (status != EMBER_ZCL_STATUS_SUCCESS) {
    660              emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
    661              goto send_default_response;
    662            }
    663          
    664            state->commandId = commandId;
    665          
    666            // Move commands cause the device to move from its current level to either
    667            // the maximum or minimum level at the specified rate.
    668            switch (moveMode) {
    669              case EMBER_ZCL_MOVE_MODE_UP:
    670                state->increasing = true;
    671                state->moveToLevel = MAX_LEVEL;
    672                difference = MAX_LEVEL - currentLevel;
    673                break;
    674              case EMBER_ZCL_MOVE_MODE_DOWN:
    675                state->increasing = false;
    676                state->moveToLevel = MIN_LEVEL;
    677                difference = currentLevel - MIN_LEVEL;
    678                break;
    679              default:
    680                status = EMBER_ZCL_STATUS_INVALID_FIELD;
    681                goto send_default_response;
    682            }
    683          
    684            // If the level is decreasing, the On/Off attribute is left unchanged.  This
    685            // logic is to prevent a light from transitioning from off to bright to dim.
    686            // Instead, a light that is off will stay off until the target level is
    687            // reached.
    688            if (currentLevel <= state->moveToLevel) {
    689              if (commandId == ZCL_MOVE_WITH_ON_OFF_COMMAND_ID) {
    690                setOnOffValue(endpoint, (state->moveToLevel != MIN_LEVEL));
    691              }
    692              if (currentLevel == state->moveToLevel) {
    693                status = EMBER_ZCL_STATUS_SUCCESS;
    694                goto send_default_response;
    695              }
    696            }
    697          
    698            // If the Rate field is 0xFF, the device should move as fast as it is able.
    699            // Otherwise, the rate is in units per second.
    700            if (rate == 0xFF) {
    701              state->eventDurationMs = FASTEST_TRANSITION_TIME_MS;
    702            } else {
    703              state->eventDurationMs = MILLISECOND_TICKS_PER_SECOND / rate;
    704            }
    705            state->transitionTimeMs = difference * state->eventDurationMs;
    706            state->elapsedTimeMs = 0;
    707          
    708            // OnLevel is not used for Move commands.
    709            state->useOnLevel = false;
    710          
    711            // The setup was successful, so mark the new state as active and return.
    712            schedule(endpoint, state->eventDurationMs);
    713            status = EMBER_ZCL_STATUS_SUCCESS;
    714          
    715            send_default_response:
    716            emberAfSendImmediateDefaultResponse(status);
   \                     ??moveHandler_1: (+1)
   \       0x20   0x....'....        BL       emberAfSendImmediateDefaultResponse
    717          }
   \       0x24   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
   \                     ??moveHandler_0: (+1)
   \       0x28   0x9B0A             LDR      R3,[SP, #+40]
   \       0x2A   0x464A             MOV      R2,R9
   \       0x2C   0x4639             MOV      R1,R7
   \       0x2E   0x4628             MOV      R0,R5
   \       0x30   0x....'....        BL       shouldExecuteIfOff
   \       0x34   0xB398             CBZ.N    R0,??moveHandler_2
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0x....'....        BL       deactivate
   \       0x3C   0x2001             MOVS     R0,#+1
   \       0x3E   0x9000             STR      R0,[SP, #+0]
   \       0x40   0xAB01             ADD      R3,SP,#+4
   \       0x42   0x2200             MOVS     R2,#+0
   \       0x44   0x2108             MOVS     R1,#+8
   \       0x46   0x4628             MOV      R0,R5
   \       0x48   0x....'....        BL       emberAfReadServerAttribute
   \       0x4C   0x0001             MOVS     R1,R0
   \       0x4E   0xD1E7             BNE.N    ??moveHandler_1
   \       0x50   0x7027             STRB     R7,[R4, #+0]
   \       0x52   0xB116             CBZ.N    R6,??moveHandler_3
   \       0x54   0x2E01             CMP      R6,#+1
   \       0x56   0xD012             BEQ.N    ??moveHandler_4
   \       0x58   0xE019             B.N      ??moveHandler_5
   \                     ??moveHandler_3: (+1)
   \       0x5A   0x2001             MOVS     R0,#+1
   \       0x5C   0x21FE             MOVS     R1,#+254
   \       0x5E   0x70A0             STRB     R0,[R4, #+2]
   \       0x60   0x7061             STRB     R1,[R4, #+1]
   \       0x62   0xF89D 0x6004      LDRB     R6,[SP, #+4]
   \       0x66   0xF1C6 0x06FE      RSB      R6,R6,#+254
   \                     ??moveHandler_6: (+1)
   \       0x6A   0x....'....        BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x6E   0xD318             BCC.N    ??moveHandler_7
   \       0x70   0x2F05             CMP      R7,#+5
   \       0x72   0xD111             BNE.N    ??moveHandler_8
   \       0x74   0x2801             CMP      R0,#+1
   \       0x76   0xBF14             ITE      NE 
   \       0x78   0x2101             MOVNE    R1,#+1
   \       0x7A   0x2100             MOVEQ    R1,#+0
   \       0x7C   0xE009             B.N      ??moveHandler_9
   \                     ??moveHandler_4: (+1)
   \       0x7E   0x2000             MOVS     R0,#+0
   \       0x80   0x2101             MOVS     R1,#+1
   \       0x82   0x70A0             STRB     R0,[R4, #+2]
   \       0x84   0x7061             STRB     R1,[R4, #+1]
   \       0x86   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x8A   0x1E46             SUBS     R6,R0,#+1
   \       0x8C   0xE7ED             B.N      ??moveHandler_6
   \                     ??moveHandler_5: (+1)
   \       0x8E   0x2085             MOVS     R0,#+133
   \       0x90   0xE7C6             B.N      ??moveHandler_1
   \                     ??moveHandler_9: (+1)
   \       0x92   0x4628             MOV      R0,R5
   \       0x94   0x....'....        BL       setOnOffValue
   \                     ??moveHandler_8: (+1)
   \       0x98   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x9C   0xD101             BNE.N    ??moveHandler_7
   \                     ??moveHandler_2: (+1)
   \       0x9E   0x2000             MOVS     R0,#+0
   \       0xA0   0xE7BE             B.N      ??moveHandler_1
   \                     ??moveHandler_7: (+1)
   \       0xA2   0xF1B8 0x0FFF      CMP      R8,#+255
   \       0xA6   0xB2F6             UXTB     R6,R6
   \       0xA8   0xBF0E             ITEE     EQ 
   \       0xAA   0x2000             MOVEQ    R0,#+0
   \       0xAC   0xF44F 0x707A      MOVNE    R0,#+1000
   \       0xB0   0xFBB0 0xF0F8      UDIVNE   R0,R0,R8
   \       0xB4   0x4346             MULS     R6,R6,R0
   \       0xB6   0x60A0             STR      R0,[R4, #+8]
   \       0xB8   0x2100             MOVS     R1,#+0
   \       0xBA   0x60E6             STR      R6,[R4, #+12]
   \       0xBC   0x6121             STR      R1,[R4, #+16]
   \       0xBE   0x70E1             STRB     R1,[R4, #+3]
   \       0xC0   0x68A1             LDR      R1,[R4, #+8]
   \       0xC2   0x4628             MOV      R0,R5
   \       0xC4   0x....'....        BL       schedule
   \       0xC8   0xE7E9             B.N      ??moveHandler_2
    718          

   \                                 In section .text, align 2, keep-with-next
    719          static void stepHandler(uint8_t commandId,
    720                                  uint8_t stepMode,
    721                                  uint8_t stepSize,
    722                                  uint16_t transitionTimeDs,
    723                                  uint8_t optionMask,
    724                                  uint8_t optionOverride)
    725          {
   \                     stepHandler: (+1)
   \        0x0   0xE92D 0x47FC      PUSH     {R2-R10,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
    726            uint8_t endpoint = emberAfCurrentEndpoint();
   \        0x8   0x....             LDR.N    R0,??DataTable6_2
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0x4692             MOV      R10,R2
   \        0xE   0x4698             MOV      R8,R3
   \       0x10   0x680A             LDR      R2,[R1, #+0]
    727            EmberAfLevelControlState *state = getState(endpoint);
   \       0x12   0x4657             MOV      R7,R10
   \       0x14   0x....'....        BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x18   0x0004             MOVS     R4,R0
    728            EmberAfStatus status;
    729            uint8_t currentLevel;
    730            uint8_t actualStepSize = stepSize;
    731          
    732            if (state == NULL) {
   \       0x1A   0xD104             BNE.N    ??stepHandler_0
    733              status = EMBER_ZCL_STATUS_FAILURE;
   \       0x1C   0x2001             MOVS     R0,#+1
    734              goto send_default_response;
    735            }
    736          
    737            if (!shouldExecuteIfOff(endpoint, commandId, optionMask, optionOverride)) {
    738              status = EMBER_ZCL_STATUS_SUCCESS;
    739              goto send_default_response;
    740            }
    741          
    742            // Cancel any currently active command before fiddling with the state.
    743            deactivate(endpoint);
    744          
    745            status = emberAfReadServerAttribute(endpoint,
    746                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    747                                                ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    748                                                (uint8_t *)&currentLevel,
    749                                                sizeof(currentLevel));
    750            if (status != EMBER_ZCL_STATUS_SUCCESS) {
    751              emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
    752              goto send_default_response;
    753            }
    754          
    755            state->commandId = commandId;
    756          
    757            // Step commands cause the device to move from its current level to a new
    758            // level over the specified transition time.
    759            switch (stepMode) {
    760              case EMBER_ZCL_STEP_MODE_UP:
    761                state->increasing = true;
    762                if (MAX_LEVEL - currentLevel < stepSize) {
    763                  state->moveToLevel = MAX_LEVEL;
    764                  actualStepSize = (MAX_LEVEL - currentLevel);
    765                } else {
    766                  state->moveToLevel = currentLevel + stepSize;
    767                }
    768                break;
    769              case EMBER_ZCL_STEP_MODE_DOWN:
    770                state->increasing = false;
    771                if (currentLevel - MIN_LEVEL < stepSize) {
    772                  state->moveToLevel = MIN_LEVEL;
    773                  actualStepSize = (currentLevel - MIN_LEVEL);
    774                } else {
    775                  state->moveToLevel = currentLevel - stepSize;
    776                }
    777                break;
    778              default:
    779                status = EMBER_ZCL_STATUS_INVALID_FIELD;
    780                goto send_default_response;
    781            }
    782          
    783            // If the level is decreasing, the On/Off attribute is left unchanged.  This
    784            // logic is to prevent a light from transitioning from off to bright to dim.
    785            // Instead, a light that is off will stay off until the target level is
    786            // reached.
    787            if (currentLevel <= state->moveToLevel) {
    788              if (commandId == ZCL_STEP_WITH_ON_OFF_COMMAND_ID) {
    789                setOnOffValue(endpoint, (state->moveToLevel != MIN_LEVEL));
    790              }
    791              if (currentLevel == state->moveToLevel) {
    792                status = EMBER_ZCL_STATUS_SUCCESS;
    793                goto send_default_response;
    794              }
    795            }
    796          
    797            // If the Transition Time field is 0xFFFF, the device should move as fast as
    798            // it is able.
    799            if (transitionTimeDs == 0xFFFF) {
    800              state->transitionTimeMs = FASTEST_TRANSITION_TIME_MS;
    801            } else {
    802              // Transition time comes in as tenths of a second, but we work in
    803              // milliseconds.
    804              state->transitionTimeMs = (transitionTimeDs
    805                                         * MILLISECOND_TICKS_PER_SECOND
    806                                         / 10);
    807              // If the new level was pegged at the minimum level, the transition time
    808              // shall be proportionally reduced.  This is done after the conversion to
    809              // milliseconds to reduce rounding errors in integer division.
    810              if (stepSize != actualStepSize) {
    811                state->transitionTimeMs = (state->transitionTimeMs
    812                                           * actualStepSize
    813                                           / stepSize);
    814              }
    815            }
    816          
    817            // The duration between events will be the transition time divided by the
    818            // distance we must move.
    819            state->eventDurationMs = state->transitionTimeMs / actualStepSize;
    820            state->elapsedTimeMs = 0;
    821          
    822            // OnLevel is not used for Step commands.
    823            state->useOnLevel = false;
    824          
    825            // The setup was successful, so mark the new state as active and return.
    826            schedule(endpoint, state->eventDurationMs);
    827            status = EMBER_ZCL_STATUS_SUCCESS;
    828          
    829            send_default_response:
    830            emberAfSendImmediateDefaultResponse(status);
   \                     ??stepHandler_1: (+1)
   \       0x1E   0x....'....        BL       emberAfSendImmediateDefaultResponse
    831          }
   \       0x22   0xE8BD 0x87F3      POP      {R0,R1,R4-R10,PC}  ;; return
   \                     ??stepHandler_0: (+1)
   \       0x26   0x9B0B             LDR      R3,[SP, #+44]
   \       0x28   0x9A0A             LDR      R2,[SP, #+40]
   \       0x2A   0x4629             MOV      R1,R5
   \       0x2C   0x4648             MOV      R0,R9
   \       0x2E   0x....'....        BL       shouldExecuteIfOff
   \       0x32   0x2800             CMP      R0,#+0
   \       0x34   0xD042             BEQ.N    ??stepHandler_2
   \       0x36   0x4648             MOV      R0,R9
   \       0x38   0x....'....        BL       deactivate
   \       0x3C   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x40   0x0001             MOVS     R1,R0
   \       0x42   0xD1EC             BNE.N    ??stepHandler_1
   \       0x44   0x7025             STRB     R5,[R4, #+0]
   \       0x46   0xB116             CBZ.N    R6,??stepHandler_3
   \       0x48   0x2E01             CMP      R6,#+1
   \       0x4A   0xD01D             BEQ.N    ??stepHandler_4
   \       0x4C   0xE02E             B.N      ??stepHandler_5
   \                     ??stepHandler_3: (+1)
   \       0x4E   0x2101             MOVS     R1,#+1
   \       0x50   0x70A1             STRB     R1,[R4, #+2]
   \       0x52   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \       0x56   0xF1C1 0x01FE      RSB      R1,R1,#+254
   \       0x5A   0x4551             CMP      R1,R10
   \       0x5C   0xDA0F             BGE.N    ??stepHandler_6
   \       0x5E   0x20FE             MOVS     R0,#+254
   \       0x60   0x7060             STRB     R0,[R4, #+1]
   \       0x62   0xF89D 0x7004      LDRB     R7,[SP, #+4]
   \       0x66   0xF1C7 0x07FE      RSB      R7,R7,#+254
   \                     ??stepHandler_7: (+1)
   \       0x6A   0x....'....        BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x6E   0xD327             BCC.N    ??stepHandler_8
   \       0x70   0x2D06             CMP      R5,#+6
   \       0x72   0xD120             BNE.N    ??stepHandler_9
   \       0x74   0x2801             CMP      R0,#+1
   \       0x76   0xBF14             ITE      NE 
   \       0x78   0x2101             MOVNE    R1,#+1
   \       0x7A   0x2100             MOVEQ    R1,#+0
   \       0x7C   0xE018             B.N      ??stepHandler_10
   \                     ??stepHandler_6: (+1)
   \       0x7E   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0x82   0x4450             ADD      R0,R10,R0
   \                     ??stepHandler_11: (+1)
   \       0x84   0x7060             STRB     R0,[R4, #+1]
   \       0x86   0xE7F0             B.N      ??stepHandler_7
   \                     ??stepHandler_4: (+1)
   \       0x88   0x2100             MOVS     R1,#+0
   \       0x8A   0x70A1             STRB     R1,[R4, #+2]
   \       0x8C   0xF89D 0x2004      LDRB     R2,[SP, #+4]
   \       0x90   0x1E52             SUBS     R2,R2,#+1
   \       0x92   0x4552             CMP      R2,R10
   \       0x94   0xDA05             BGE.N    ??stepHandler_12
   \       0x96   0x2001             MOVS     R0,#+1
   \       0x98   0x7060             STRB     R0,[R4, #+1]
   \       0x9A   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \       0x9E   0x1E4F             SUBS     R7,R1,#+1
   \       0xA0   0xE7E3             B.N      ??stepHandler_7
   \                     ??stepHandler_12: (+1)
   \       0xA2   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \       0xA6   0xEBA0 0x000A      SUB      R0,R0,R10
   \       0xAA   0xE7EB             B.N      ??stepHandler_11
   \                     ??stepHandler_5: (+1)
   \       0xAC   0x2085             MOVS     R0,#+133
   \       0xAE   0xE7B6             B.N      ??stepHandler_1
   \                     ??stepHandler_10: (+1)
   \       0xB0   0x4648             MOV      R0,R9
   \       0xB2   0x....'....        BL       setOnOffValue
   \                     ??stepHandler_9: (+1)
   \       0xB6   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0xBA   0xD101             BNE.N    ??stepHandler_8
   \                     ??stepHandler_2: (+1)
   \       0xBC   0x2000             MOVS     R0,#+0
   \       0xBE   0xE7AE             B.N      ??stepHandler_1
   \                     ??stepHandler_8: (+1)
   \       0xC0   0xF64F 0x72FF      MOVW     R2,#+65535
   \       0xC4   0x4590             CMP      R8,R2
   \       0xC6   0xB2F9             UXTB     R1,R7
   \       0xC8   0xBF08             IT       EQ 
   \       0xCA   0x2000             MOVEQ    R0,#+0
   \       0xCC   0xD00C             BEQ.N    ??stepHandler_13
   \       0xCE   0xF44F 0x707A      MOV      R0,#+1000
   \       0xD2   0xFB00 0xF308      MUL      R3,R0,R8
   \       0xD6   0x220A             MOVS     R2,#+10
   \       0xD8   0xB2FF             UXTB     R7,R7
   \       0xDA   0xFBB3 0xF0F2      UDIV     R0,R3,R2
   \       0xDE   0x45BA             CMP      R10,R7
   \       0xE0   0xBF1C             ITT      NE 
   \       0xE2   0x4348             MULNE    R0,R1,R0
   \       0xE4   0xFBB0 0xF0FA      UDIVNE   R0,R0,R10
   \                     ??stepHandler_13: (+1)
   \       0xE8   0x60E0             STR      R0,[R4, #+12]
   \       0xEA   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \       0xEE   0x2100             MOVS     R1,#+0
   \       0xF0   0x6121             STR      R1,[R4, #+16]
   \       0xF2   0x60A0             STR      R0,[R4, #+8]
   \       0xF4   0x70E1             STRB     R1,[R4, #+3]
   \       0xF6   0x68A1             LDR      R1,[R4, #+8]
   \       0xF8   0x4648             MOV      R0,R9
   \       0xFA   0x....'....        BL       schedule
   \       0xFE   0xE7DD             B.N      ??stepHandler_2
    832          

   \                                 In section .text, align 2, keep-with-next
    833          static void stopHandler(uint8_t commandId,
    834                                  uint8_t optionMask,
    835                                  uint8_t optionOverride)
    836          {
   \                     stopHandler: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
    837            uint8_t endpoint = emberAfCurrentEndpoint();
   \        0x6   0x....             LDR.N    R0,??DataTable6_2
   \        0x8   0x6801             LDR      R1,[R0, #+0]
   \        0xA   0x4616             MOV      R6,R2
   \        0xC   0x680A             LDR      R2,[R1, #+0]
   \        0xE   0x7957             LDRB     R7,[R2, #+5]
    838            EmberAfLevelControlState *state = getState(endpoint);
    839            EmberAfStatus status;
    840          
    841            if (state == NULL) {
   \       0x10   0x4638             MOV      R0,R7
   \       0x12   0x....'....        BL       getState
   \       0x16   0xB908             CBNZ.N   R0,??stopHandler_0
    842              status = EMBER_ZCL_STATUS_FAILURE;
   \       0x18   0x2001             MOVS     R0,#+1
    843              goto send_default_response;
   \       0x1A   0xE00E             B.N      ??stopHandler_1
    844            }
    845          
    846            if (!shouldExecuteIfOff(endpoint, commandId, optionMask, optionOverride)) {
   \                     ??stopHandler_0: (+1)
   \       0x1C   0x4633             MOV      R3,R6
   \       0x1E   0x462A             MOV      R2,R5
   \       0x20   0x4621             MOV      R1,R4
   \       0x22   0x4638             MOV      R0,R7
   \       0x24   0x....'....        BL       shouldExecuteIfOff
   \       0x28   0xB138             CBZ.N    R0,??stopHandler_1
    847              status = EMBER_ZCL_STATUS_SUCCESS;
    848              goto send_default_response;
    849            }
    850          
    851            // Cancel any currently active command.
    852            deactivate(endpoint);
   \       0x2A   0x4638             MOV      R0,R7
   \       0x2C   0x....'....        BL       deactivate
    853            writeRemainingTime(endpoint, 0);
   \       0x30   0x2100             MOVS     R1,#+0
   \       0x32   0x4638             MOV      R0,R7
   \       0x34   0x....'....        BL       writeRemainingTime
    854            status = EMBER_ZCL_STATUS_SUCCESS;
   \       0x38   0x2000             MOVS     R0,#+0
    855          
    856            send_default_response:
    857            emberAfSendImmediateDefaultResponse(status);
   \                     ??stopHandler_1: (+1)
   \       0x3A   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \       0x3E   0x....'....        B.W      emberAfSendImmediateDefaultResponse
    858          }
    859          
    860          // Follows 07-5123-04 (ZigBee Cluster Library doc), section 3.10.2.1.1.
    861          // Quotes are from table 3.46.

   \                                 In section .text, align 2, keep-with-next
    862          void emberAfOnOffClusterLevelControlEffectCallback(uint8_t endpoint,
    863                                                             bool newValue)
    864          {
   \                     emberAfOnOffClusterLevelControlEffectCallback: (+1)
   \        0x0   0xB57F             PUSH     {R0-R6,LR}
   \        0x2   0x4604             MOV      R4,R0
    865            uint8_t temporaryCurrentLevelCache;
    866            uint16_t currentOnOffTransitionTime;
    867            uint8_t currentOnLevel;
    868            uint8_t minimumLevelAllowedForTheDevice = MIN_LEVEL;
   \        0x4   0x2001             MOVS     R0,#+1
   \        0x6   0x460D             MOV      R5,R1
   \        0x8   0xF88D 0x0009      STRB     R0,[SP, #+9]
    869            EmberAfStatus status;
    870          
    871            // "Temporarilty store CurrentLevel."
    872            status = emberAfReadServerAttribute(endpoint,
    873                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    874                                                ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    875                                                (uint8_t *)&temporaryCurrentLevelCache,
    876                                                sizeof(temporaryCurrentLevelCache));
    877            if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \        0xC   0x9000             STR      R0,[SP, #+0]
   \        0xE   0xAB02             ADD      R3,SP,#+8
   \       0x10   0x....'....        BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x14   0x....'....        BL       emberAfReadServerAttribute
   \       0x18   0xB9F8             CBNZ.N   R0,??emberAfOnOffClusterLevelControlEffectCallback_0
    878              emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
    879              return;
    880            }
    881          
    882            // Read the OnLevel attribute.
    883          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_ON_LEVEL_ATTRIBUTE
    884            status = emberAfReadServerAttribute(endpoint,
    885                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    886                                                ZCL_ON_LEVEL_ATTRIBUTE_ID,
    887                                                (uint8_t *)&currentOnLevel,
    888                                                sizeof(currentOnLevel));
    889            if (status != EMBER_ZCL_STATUS_SUCCESS) {
    890              emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
    891              return;
    892            }
    893          #else
    894            currentOnLevel = 0xFF;
    895          #endif
    896          
    897            // Read the OnOffTransitionTime attribute.
    898          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_ON_OFF_TRANSITION_TIME_ATTRIBUTE
    899            status = emberAfReadServerAttribute(endpoint,
    900                                                ZCL_LEVEL_CONTROL_CLUSTER_ID,
    901                                                ZCL_ON_OFF_TRANSITION_TIME_ATTRIBUTE_ID,
    902                                                (uint8_t *)&currentOnOffTransitionTime,
    903                                                sizeof(currentOnOffTransitionTime));
    904            if (status != EMBER_ZCL_STATUS_SUCCESS) {
    905              emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
    906              return;
    907            }
    908          #else
    909            currentOnOffTransitionTime = 0xFFFF;
    910          #endif
    911          
    912            if (newValue) {
   \       0x1A   0xF64F 0x76FF      MOVW     R6,#+65535
   \       0x1E   0xB185             CBZ.N    R5,??emberAfOnOffClusterLevelControlEffectCallback_1
    913              // If newValue is ZCL_ON_COMMAND_ID...
    914              // "Set CurrentLevel to minimum level allowed for the device."
    915              status = emberAfWriteServerAttribute(endpoint,
    916                                                   ZCL_LEVEL_CONTROL_CLUSTER_ID,
    917                                                   ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    918                                                   (uint8_t *)&minimumLevelAllowedForTheDevice,
    919                                                   ZCL_INT8U_ATTRIBUTE_TYPE);
    920              if (status != EMBER_ZCL_STATUS_SUCCESS) {
   \       0x20   0x2020             MOVS     R0,#+32
   \       0x22   0x9000             STR      R0,[SP, #+0]
   \       0x24   0xF10D 0x0309      ADD      R3,SP,#+9
   \       0x28   0x....'....        BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x2C   0x....'....        BL       emberAfWriteServerAttribute
   \       0x30   0xB998             CBNZ.N   R0,??emberAfOnOffClusterLevelControlEffectCallback_0
    921                emberAfLevelControlClusterPrintln("ERR: reading current level %x", status);
    922                return;
    923              }
    924          
    925              // "Move CurrentLevel to OnLevel, or to the stored level if OnLevel is not
    926              // defined, over the time period OnOffTransitionTime."
    927              moveToLevelHandler(ZCL_MOVE_TO_LEVEL_COMMAND_ID,
    928                                 (currentOnLevel == 0xFF
    929                                  ? temporaryCurrentLevelCache
    930                                  : currentOnLevel),
    931                                 currentOnOffTransitionTime,
    932                                 0xFF,
    933                                 0xFF,
    934                                 INVALID_STORED_LEVEL); // Don't revert to stored level
   \       0x32   0x20FF             MOVS     R0,#+255
   \       0x34   0x9601             STR      R6,[SP, #+4]
   \       0x36   0x9000             STR      R0,[SP, #+0]
   \       0x38   0x23FF             MOVS     R3,#+255
   \       0x3A   0x4632             MOV      R2,R6
   \       0x3C   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \       0x40   0xE008             B.N      ??emberAfOnOffClusterLevelControlEffectCallback_2
    935            } else {
    936              // ...else if newValue is ZCL_OFF_COMMAND_ID...
    937              // "Move CurrentLevel to the minimum level allowed for the device over the
    938              // time period OnOffTransitionTime."
    939              moveToLevelHandler(ZCL_MOVE_TO_LEVEL_COMMAND_ID,
    940                                 minimumLevelAllowedForTheDevice,
    941                                 currentOnOffTransitionTime,
    942                                 0xFF,
    943                                 0xFF,
    944                                 temporaryCurrentLevelCache);
   \                     ??emberAfOnOffClusterLevelControlEffectCallback_1: (+1)
   \       0x42   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \       0x46   0x21FF             MOVS     R1,#+255
   \       0x48   0x9100             STR      R1,[SP, #+0]
   \       0x4A   0x9001             STR      R0,[SP, #+4]
   \       0x4C   0x23FF             MOVS     R3,#+255
   \       0x4E   0x4632             MOV      R2,R6
   \       0x50   0xF89D 0x1009      LDRB     R1,[SP, #+9]
   \                     ??emberAfOnOffClusterLevelControlEffectCallback_2: (+1)
   \       0x54   0x2000             MOVS     R0,#+0
   \       0x56   0x....'....        BL       moveToLevelHandler
    945          
    946              // "If OnLevel is not defined, set the CurrentLevel to the stored level."
    947              // The emberAfLevelControlClusterServerTickCallback implementation handles
    948              // this.
    949            }
    950          }
   \                     ??emberAfOnOffClusterLevelControlEffectCallback_0: (+1)
   \       0x5A   0xBD7F             POP      {R0-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x2340             MOVS     R3,#+64
   \                     ??Subroutine6_0: (+1)
   \        0x2   0x2200             MOVS     R2,#+0
   \        0x4   0x2108             MOVS     R1,#+8
   \        0x6   0x4620             MOV      R0,R4
   \        0x8   0x4770             BX       LR
    951          

   \                                 In section .text, align 2, keep-with-next
    952          void emberAfLevelControlClusterServerInitCallback(uint8_t endpoint)
    953          {
   \                     emberAfLevelControlClusterServerInitCallback: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0xB084             SUB      SP,SP,#+16
    954          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_START_UP_CURRENT_LEVEL_ATTRIBUTE
    955            // StartUp behavior relies StartUpCurrentLevel attributes being tokenized.
    956            if (areStartUpLevelControlServerAttributesTokenized(endpoint)) {
   \        0x4   0x2500             MOVS     R5,#+0
   \        0x6   0x4604             MOV      R4,R0
   \        0x8   0x9500             STR      R5,[SP, #+0]
   \        0xA   0x2340             MOVS     R3,#+64
   \        0xC   0x2200             MOVS     R2,#+0
   \        0xE   0x2108             MOVS     R1,#+8
   \       0x10   0x....'....        BL       emberAfLocateAttributeMetadata
   \       0x14   0x7900             LDRB     R0,[R0, #+4]
   \       0x16   0x0781             LSLS     R1,R0,#+30
   \       0x18   0xD536             BPL.N    ??emberAfLevelControlClusterServerInitCallback_0
   \       0x1A   0x9500             STR      R5,[SP, #+0]
   \       0x1C   0x....'....        BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_21: (+1)
   \       0x20   0x....'....        BL       emberAfLocateAttributeMetadata
   \       0x24   0x7900             LDRB     R0,[R0, #+4]
   \       0x26   0x0781             LSLS     R1,R0,#+30
   \       0x28   0xD52E             BPL.N    ??emberAfLevelControlClusterServerInitCallback_0
    957              // Read the StartUpOnOff attribute and set the OnOff attribute as per
    958              // following from zcl 7 14-0127-20i-zcl-ch-3-general.doc.
    959              // 3.10.2.2.14	StartUpCurrentLevel Attribute
    960              // The StartUpCurrentLevel attribute SHALL define the desired startup level
    961              // for a device when it is supplied with power and this level SHALL be
    962              // reflected in the CurrentLevel attribute. The values of the StartUpCurrentLevel
    963              // attribute are listed below:
    964              // Table 3 58. Values of the StartUpCurrentLevel Attribute
    965              // Value      Action on power up
    966              // 0x00       Set the CurrentLevel attribute to the minimum value permitted on the device.
    967              // 0x01-0xfe  Set the CurrentLevel attribute to this value.
    968              // 0xff       Set the CurrentLevel attribute to its previous value.
    969          
    970              // Initialize startUpCurrentLevel to assume previous value for currentLevel.
    971              uint8_t startUpCurrentLevel = STARTUP_CURRENT_LEVEL_USE_PREVIOUS_LEVEL;
   \       0x2A   0x20FF             MOVS     R0,#+255
   \       0x2C   0xF88D 0x000D      STRB     R0,[SP, #+13]
    972              EmberAfStatus status = emberAfReadAttribute(endpoint,
    973                                                          ZCL_LEVEL_CONTROL_CLUSTER_ID,
    974                                                          ZCL_START_UP_CURRENT_LEVEL_ATTRIBUTE_ID,
    975                                                          CLUSTER_MASK_SERVER,
    976                                                          (uint8_t *)&startUpCurrentLevel,
    977                                                          sizeof(startUpCurrentLevel),
    978                                                          NULL);
    979              if (status == EMBER_ZCL_STATUS_SUCCESS) {
   \       0x30   0x2201             MOVS     R2,#+1
   \       0x32   0xF10D 0x000D      ADD      R0,SP,#+13
   \       0x36   0x9201             STR      R2,[SP, #+4]
   \       0x38   0x9000             STR      R0,[SP, #+0]
   \       0x3A   0x9502             STR      R5,[SP, #+8]
   \       0x3C   0x....'....        BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_22: (+1)
   \       0x40   0x....'....        BL       emberAfReadAttribute
   \       0x44   0xBB00             CBNZ.N   R0,??emberAfLevelControlClusterServerInitCallback_0
    980                uint8_t currentLevel = 0;
   \       0x46   0xF88D 0x000C      STRB     R0,[SP, #+12]
    981                status = emberAfReadAttribute(endpoint,
    982                                              ZCL_LEVEL_CONTROL_CLUSTER_ID,
    983                                              ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
    984                                              CLUSTER_MASK_SERVER,
    985                                              (uint8_t *)&currentLevel,
    986                                              sizeof(currentLevel),
    987                                              NULL);
    988                if (status == EMBER_ZCL_STATUS_SUCCESS) {
   \       0x4A   0x2201             MOVS     R2,#+1
   \       0x4C   0xA803             ADD      R0,SP,#+12
   \       0x4E   0x9201             STR      R2,[SP, #+4]
   \       0x50   0x9000             STR      R0,[SP, #+0]
   \       0x52   0x9502             STR      R5,[SP, #+8]
   \       0x54   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x58   0x....'....        BL       emberAfReadAttribute
   \       0x5C   0xB9A0             CBNZ.N   R0,??emberAfLevelControlClusterServerInitCallback_0
    989                  switch (startUpCurrentLevel) {
   \       0x5E   0xF89D 0x100D      LDRB     R1,[SP, #+13]
   \       0x62   0xB111             CBZ.N    R1,??emberAfLevelControlClusterServerInitCallback_1
   \       0x64   0x29FF             CMP      R1,#+255
   \       0x66   0xD007             BEQ.N    ??emberAfLevelControlClusterServerInitCallback_2
    990                    case STARTUP_CURRENT_LEVEL_USE_DEVICE_MINIMUM:
    991                      currentLevel = MIN_LEVEL;
    992                      break;
    993                    case STARTUP_CURRENT_LEVEL_USE_PREVIOUS_LEVEL:
    994                      // Just fetched it.
    995                      break;
    996                    default:
    997                      // Otherwise set to specified value 0x01-0xFE.
    998                      // But, need to enforce currentLevel's min/max, right?
    999                      // Spec doesn't mention this.
   1000                      if (startUpCurrentLevel < MIN_LEVEL) {
   \       0x68   0xB909             CBNZ.N   R1,??emberAfLevelControlClusterServerInitCallback_3
   1001                        currentLevel = MIN_LEVEL;
   \                     ??emberAfLevelControlClusterServerInitCallback_1: (+1)
   \       0x6A   0x2101             MOVS     R1,#+1
   \       0x6C   0xE002             B.N      ??emberAfLevelControlClusterServerInitCallback_4
   1002                      } else if (startUpCurrentLevel > MAX_LEVEL) {
   \                     ??emberAfLevelControlClusterServerInitCallback_3: (+1)
   \       0x6E   0x29FF             CMP      R1,#+255
   \       0x70   0xBF08             IT       EQ 
   \       0x72   0x21FE             MOVEQ    R1,#+254
   1003                        currentLevel = MAX_LEVEL;
   1004                      } else {
   1005                        currentLevel = startUpCurrentLevel;
   \                     ??emberAfLevelControlClusterServerInitCallback_4: (+1)
   \       0x74   0xF88D 0x100C      STRB     R1,[SP, #+12]
   1006                      }
   1007                      break;
   1008                  }
   1009                  status = emberAfWriteAttribute(endpoint,
   1010                                                 ZCL_LEVEL_CONTROL_CLUSTER_ID,
   1011                                                 ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
   1012                                                 CLUSTER_MASK_SERVER,
   1013                                                 (uint8_t *)&currentLevel,
   1014                                                 ZCL_INT8U_ATTRIBUTE_TYPE);
   \                     ??emberAfLevelControlClusterServerInitCallback_2: (+1)
   \       0x78   0x2120             MOVS     R1,#+32
   \       0x7A   0xA803             ADD      R0,SP,#+12
   \       0x7C   0x9101             STR      R1,[SP, #+4]
   \       0x7E   0x9000             STR      R0,[SP, #+0]
   \       0x80   0x....'....        BL       ?Subroutine6
   1015                }
   1016              }
   1017            }
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x84   0x....'....        BL       emberAfWriteAttribute
   1018          #endif
   1019            emberAfPluginLevelControlClusterServerPostInitCallback(endpoint);
   \                     ??emberAfLevelControlClusterServerInitCallback_0: (+1)
   \       0x88   0x4620             MOV      R0,R4
   \       0x8A   0x....'....        BL       emberAfPluginLevelControlClusterServerPostInitCallback
   1020          }
   \       0x8E   0xB005             ADD      SP,SP,#+20
   \       0x90   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0x2340             MOVS     R3,#+64
   \        0x2   0xF44F 0x4280      MOV      R2,#+16384
   \        0x6   0x2108             MOVS     R1,#+8
   \        0x8   0x4620             MOV      R0,R4
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \        0x0   0x....'....        DC32     stateTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \        0x0   0x....'....        DC32     emAfCurrentCommand

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x6C 0x65          DC8 "level-control.c"
   \              0x76 0x65    
   \              0x6C 0x2D    
   \              0x63 0x6F    
   \              0x6E 0x74    
   \              0x72 0x6F    
   \              0x6C 0x2E    
   \              0x63 0x00    
   1021          
   1022          #ifdef ZCL_USING_LEVEL_CONTROL_CLUSTER_START_UP_CURRENT_LEVEL_ATTRIBUTE
   1023          static bool areStartUpLevelControlServerAttributesTokenized(uint8_t endpoint)
   1024          {
   1025            EmberAfAttributeMetadata *metadata;
   1026          
   1027            metadata = emberAfLocateAttributeMetadata(endpoint,
   1028                                                      ZCL_LEVEL_CONTROL_CLUSTER_ID,
   1029                                                      ZCL_CURRENT_LEVEL_ATTRIBUTE_ID,
   1030                                                      CLUSTER_MASK_SERVER,
   1031                                                      EMBER_AF_NULL_MANUFACTURER_CODE);
   1032            if (!emberAfAttributeIsTokenized(metadata)) {
   1033              return false;
   1034            }
   1035          
   1036            metadata = emberAfLocateAttributeMetadata(endpoint,
   1037                                                      ZCL_LEVEL_CONTROL_CLUSTER_ID,
   1038                                                      ZCL_START_UP_CURRENT_LEVEL_ATTRIBUTE_ID,
   1039                                                      CLUSTER_MASK_SERVER,
   1040                                                      EMBER_AF_NULL_MANUFACTURER_CODE);
   1041            if (!emberAfAttributeIsTokenized(metadata)) {
   1042              return false;
   1043            }
   1044          
   1045            return true;
   1046          }
   1047          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   deactivate
         0   -> emberAfDeactivateServerTick
       8   emberAfLevelControlClusterMoveCallback
         8   -> moveHandler
      16   emberAfLevelControlClusterMoveToLevelCallback
        16   -> moveToLevelHandler
      16   emberAfLevelControlClusterMoveToLevelWithOnOffCallback
        16   -> moveToLevelHandler
       8   emberAfLevelControlClusterMoveWithOnOffCallback
         8   -> moveHandler
      32   emberAfLevelControlClusterServerInitCallback
        32   -> emberAfLocateAttributeMetadata
        32   -> emberAfPluginLevelControlClusterServerPostInitCallback
        32   -> emberAfReadAttribute
        32   -> emberAfWriteAttribute
      24   emberAfLevelControlClusterServerTickCallback
        24   -> emberAfContainsServer
        24   -> emberAfReadServerAttribute
        24   -> emberAfScenesClusterMakeInvalidCallback
        24   -> emberAfWriteServerAttribute
        24   -> getState
        24   -> halInternalAssertFailed
        24   -> reallyUpdateCoupledColorTemp
        24   -> schedule
        24   -> setOnOffValue
        24   -> writeRemainingTime
      16   emberAfLevelControlClusterStepCallback
        16   -> stepHandler
      16   emberAfLevelControlClusterStepWithOnOffCallback
        16   -> stepHandler
       8   emberAfLevelControlClusterStopCallback
         8   -> stopHandler
       8   emberAfLevelControlClusterStopWithOnOffCallback
         8   -> stopHandler
      32   emberAfOnOffClusterLevelControlEffectCallback
        32   -> emberAfReadServerAttribute
        32   -> emberAfWriteServerAttribute
        32   -> moveToLevelHandler
       8   getState
         8   -> emberAfFindClusterServerEndpointIndex
      40   moveHandler
        40   -> deactivate
        40   -> emberAfReadServerAttribute
        40   -> emberAfSendImmediateDefaultResponse
        40   -> getState
        40   -> schedule
        40   -> setOnOffValue
        40   -> shouldExecuteIfOff
      40   moveToLevelHandler
        40   -> deactivate
        40   -> emberAfPluginZllLevelControlServerMoveToLevelWithOnOffZllExtensions
        40   -> emberAfReadServerAttribute
        40   -> emberAfSendImmediateDefaultResponse
        40   -> getState
        40   -> schedule
        40   -> setOnOffValue
        40   -> shouldExecuteIfOff
      24   reallyUpdateCoupledColorTemp
        24   -> emberAfPluginLevelControlCoupledColorTempChangeCallback
        24   -> emberAfReadServerAttribute
       8   schedule
         8   -> emberAfScheduleServerTickExtended
      16   setOnOffValue
        16   -> emberAfContainsServer
         0   -> emberAfOnOffClusterSetValueCallback
      24   shouldExecuteIfOff
        24   -> emberAfContainsServer
        24   -> emberAfReadServerAttribute
      40   stepHandler
        40   -> deactivate
        40   -> emberAfReadServerAttribute
        40   -> emberAfSendImmediateDefaultResponse
        40   -> getState
        40   -> schedule
        40   -> setOnOffValue
        40   -> shouldExecuteIfOff
      24   stopHandler
        24   -> deactivate
         0   -> emberAfSendImmediateDefaultResponse
        24   -> getState
        24   -> shouldExecuteIfOff
        24   -> writeRemainingTime
      16   writeRemainingTime
        16   -> emberAfWriteServerAttribute


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       8  ?Subroutine0
       8  ?Subroutine1
      16  ?Subroutine2
       8  ?Subroutine3
      10  ?Subroutine4
      10  ?Subroutine5
      10  ?Subroutine6
      10  ?Subroutine7
       6  ?Subroutine8
      12  ?Subroutine9
      16  ?_0
       6  deactivate
      14  emberAfLevelControlClusterMoveCallback
      26  emberAfLevelControlClusterMoveToLevelCallback
      26  emberAfLevelControlClusterMoveToLevelWithOnOffCallback
      14  emberAfLevelControlClusterMoveWithOnOffCallback
     146  emberAfLevelControlClusterServerInitCallback
     298  emberAfLevelControlClusterServerTickCallback
      24  emberAfLevelControlClusterStepCallback
      24  emberAfLevelControlClusterStepWithOnOffCallback
      10  emberAfLevelControlClusterStopCallback
       8  emberAfLevelControlClusterStopWithOnOffCallback
      92  emberAfOnOffClusterLevelControlEffectCallback
      28  getState
     202  moveHandler
     230  moveToLevelHandler
      36  reallyUpdateCoupledColorTemp
      18  schedule
      34  setOnOffValue
     106  shouldExecuteIfOff
      40  stateTable
     256  stepHandler
      66  stopHandler
      30  writeRemainingTime

 
    40 bytes in section .bss
    16 bytes in section .rodata
 1 804 bytes in section .text
 
 1 804 bytes of CODE  memory
    16 bytes of CONST memory
    40 bytes of DATA  memory

Errors: none
Warnings: none
