###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:18:48
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\em_cmu.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW45D6.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\em_cmu.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"em_cmu.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0 -D
#        LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D EMBER_AF_USE_HWCONF
#        -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\em_cmu.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\em_cmu.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\platform\emlib\src\em_cmu.c
      1          /***************************************************************************//**
      2           * @file
      3           * @brief Clock management unit (CMU) Peripheral API
      4           * @version 5.8.0
      5           *******************************************************************************
      6           * # License
      7           * <b>Copyright 2018 Silicon Laboratories Inc. www.silabs.com</b>
      8           *******************************************************************************
      9           *
     10           * SPDX-License-Identifier: Zlib
     11           *
     12           * The licensor of this software is Silicon Laboratories Inc.
     13           *
     14           * This software is provided 'as-is', without any express or implied
     15           * warranty. In no event will the authors be held liable for any damages
     16           * arising from the use of this software.
     17           *
     18           * Permission is granted to anyone to use this software for any purpose,
     19           * including commercial applications, and to alter it and redistribute it
     20           * freely, subject to the following restrictions:
     21           *
     22           * 1. The origin of this software must not be misrepresented; you must not
     23           *    claim that you wrote the original software. If you use this software
     24           *    in a product, an acknowledgment in the product documentation would be
     25           *    appreciated but is not required.
     26           * 2. Altered source versions must be plainly marked as such, and must not be
     27           *    misrepresented as being the original software.
     28           * 3. This notice may not be removed or altered from any source distribution.
     29           *
     30           ******************************************************************************/
     31          
     32          #include "em_cmu.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp uint32_t SystemCoreClockGet(void)
   \                     SystemCoreClockGet: (+1)
   \        0x0   0x....'....        B.W      SystemHCLKGet
     33          #if defined(CMU_PRESENT)
     34          
     35          #include <stddef.h>
     36          #include <limits.h>
     37          #include "em_assert.h"
     38          #include "em_bus.h"
     39          #include "em_cmu.h"
     40          #include "em_common.h"
     41          #include "em_emu.h"
     42          #include "em_gpio.h"
     43          #include "em_system.h"
     44          
     45          /***************************************************************************//**
     46           * @addtogroup emlib
     47           * @{
     48           ******************************************************************************/
     49          
     50          /***************************************************************************//**
     51           * @addtogroup CMU
     52           * @brief Clock management unit (CMU) Peripheral API
     53           * @details
     54           *  This module contains functions for the CMU peripheral of Silicon Labs 32-bit
     55           *  MCUs and SoCs. The CMU module controls oscillators, clocks gates, clock
     56           *  multiplexers, pre-scalers, calibration modules and wait-states.
     57           * @{
     58           ******************************************************************************/
     59          
     60          #if defined(_SILICON_LABS_32B_SERIES_2)
     61          
     62          /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
     63          
     64          /*******************************************************************************
     65           ******************************   DEFINES   ************************************
     66           ******************************************************************************/
     67          
     68          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_1)
     69          // Maximum allowed core frequency vs. wait-states on flash accesses.
     70          #define CMU_MAX_FLASHREAD_FREQ_0WS        39000000UL
     71          #define CMU_MAX_FLASHREAD_FREQ_1WS        80000000UL
     72          
     73          // Maximum allowed core frequency vs. wait-states on sram accesses.
     74          #define CMU_MAX_SRAM_FREQ_0WS             50000000UL
     75          #define CMU_MAX_SRAM_FREQ_1WS             80000000UL
     76          
     77          #elif defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
     78          // Maximum allowed core frequency vs. wait-states on flash accesses.
     79          #define CMU_MAX_FLASHREAD_FREQ_0WS        40000000UL
     80          #define CMU_MAX_FLASHREAD_FREQ_1WS        80000000UL
     81          #endif
     82          
     83          // Maximum allowed PCLK frequency.
     84          #define CMU_MAX_PCLK_FREQ                 50000000UL
     85          
     86          // Maximum allowed RHCLK frequency.
     87          #define CMU_MAX_RHCLK_FREQ                40000000UL
     88          
     89          /*******************************************************************************
     90           **************************   LOCAL VARIABLES   ********************************
     91           ******************************************************************************/
     92          
     93          // Table of HFRCOCAL values and their associated min/max frequencies and
     94          // optional band enumerator.
     95          static const struct hfrcoCalTableElement{
     96            uint32_t  minFreq;
     97            uint32_t  maxFreq;
     98            uint32_t  value;
     99            CMU_HFRCODPLLFreq_TypeDef band;

   \                                 In section .rodata, align 4
    100          } hfrcoCalTable[] =
   \                     hfrcoCalTable:
   \        0x0   0x000D'BBA0        DC32 900000, 1080000, 2185240320, 1000000, 1080000, 1300000, 2722176826
   \              0x0010'7AC0  
   \              0x8240'1F00  
   \              0x000F'4240  
   \              0x0010'7AC0  
   \              0x0013'D620  
   \              0xA241'1F3A  
   \       0x1C   0x0000'0000        DC32 0, 1300000, 1530000, 2722242362, 0, 1530000, 1800000, 3057884986
   \              0x0013'D620  
   \              0x0017'5890  
   \              0xA242'1F3A  
   \              0x0000'0000  
   \              0x0017'5890  
   \              0x001B'7740  
   \              0xB643'9F3A  
   \       0x3C   0x0000'0000        DC32 0, 1800000, 2150000, 2168463104, 2000000, 2150000, 2600000
   \              0x001B'7740  
   \              0x0020'CE70  
   \              0x8140'1F00  
   \              0x001E'8480  
   \              0x0020'CE70  
   \              0x0027'AC40  
   \       0x58   0xA141'1F3A        DC32 2705399610, 0, 2600000, 3050000, 2705465146, 0, 3050000, 3600000
   \              0x0000'0000  
   \              0x0027'AC40  
   \              0x002E'8A10  
   \              0xA142'1F3A  
   \              0x0000'0000  
   \              0x002E'8A10  
   \              0x0036'EE80  
   \       0x78   0xB543'9F3A        DC32 3041107770, 0, 3600000, 4300000, 2151685888, 4000000, 4300000
   \              0x0000'0000  
   \              0x0036'EE80  
   \              0x0041'9CE0  
   \              0x8040'1F00  
   \              0x003D'0900  
   \              0x0041'9CE0  
   \       0x94   0x004F'5880        DC32 5200000, 2688622394, 0, 5200000, 6100000, 2688687930, 0, 6100000
   \              0xA041'1F3A  
   \              0x0000'0000  
   \              0x004F'5880  
   \              0x005D'1420  
   \              0xA042'1F3A  
   \              0x0000'0000  
   \              0x005D'1420  
   \       0xB4   0x0077'04C0        DC32 7800000, 3024330496, 7000000, 7800000, 9800000, 3024396090, 0
   \              0xB443'9F00  
   \              0x006A'CFC0  
   \              0x0077'04C0  
   \              0x0095'8940  
   \              0xB444'9F3A  
   \              0x0000'0000  
   \       0xD0   0x0095'8940        DC32 9800000, 11800000, 3024461626, 0, 11800000, 14400000, 3026624256
   \              0x00B4'0DC0  
   \              0xB445'9F3A  
   \              0x0000'0000  
   \              0x00B4'0DC0  
   \              0x00DB'BA00  
   \              0xB466'9F00  
   \       0xEC   0x00C6'5D40        DC32 13000000, 14400000, 17200000, 3026689792, 16000000, 17200000
   \              0x00DB'BA00  
   \              0x0106'7380  
   \              0xB467'9F00  
   \              0x00F4'2400  
   \              0x0106'7380  
   \      0x104   0x012C'9920        DC32 19700000, 2825428736, 19000000, 19700000, 23800000, 3096026938, 0
   \              0xA868'9F00  
   \              0x0121'EAC0  
   \              0x012C'9920  
   \              0x016B'28C0  
   \              0xB889'9F3A  
   \              0x0000'0000  
   \      0x120   0x016B'28C0        DC32 23800000, 28700000, 3096092416, 26000000, 28700000, 34800000
   \              0x01B5'ED60  
   \              0xB88A'9F00  
   \              0x018C'BA80  
   \              0x01B5'ED60  
   \              0x0213'0180  
   \      0x138   0xB8AB'9F00        DC32 3098255104, 32000000, 34800000, 42800000, 2831982336, 38000000
   \              0x01E8'4800  
   \              0x0213'0180  
   \              0x028D'1380  
   \              0xA8CC'9F00  
   \              0x0243'D580  
   \      0x150   0x028D'1380        DC32 42800000, 51600000, 2901253888, 48000000, 51600000, 60500000
   \              0x0313'5A80  
   \              0xACED'9F00  
   \              0x02DC'6C00  
   \              0x0313'5A80  
   \              0x039B'2820  
   \      0x168   0xBCEE'9F00        DC32 3169754880, 56000000, 60500000, 72600000, 3169820416, 64000000
   \              0x0356'7E00  
   \              0x039B'2820  
   \              0x0453'C9C0  
   \              0xBCEF'9F00  
   \              0x03D0'9000  
   \      0x180   0x0453'C9C0        DC32 72600000, 80000000, 3438321408, 80000000
   \              0x04C4'B400  
   \              0xCCF0'9F00  
   \              0x04C4'B400  
    101          {
    102            //  minFreq   maxFreq    HFRCOCAL value  band
    103            {  900000UL, 1080000UL, 0x82401F00UL, cmuHFRCODPLLFreq_1M0Hz         },
    104            { 1080000UL, 1300000UL, 0xA2411F3AUL, (CMU_HFRCODPLLFreq_TypeDef)0   },
    105            { 1300000UL, 1530000UL, 0xA2421F3AUL, (CMU_HFRCODPLLFreq_TypeDef)0   },
    106            { 1530000UL, 1800000UL, 0xB6439F3AUL, (CMU_HFRCODPLLFreq_TypeDef)0   },
    107            { 1800000UL, 2150000UL, 0x81401F00UL, cmuHFRCODPLLFreq_2M0Hz         },
    108            { 2150000UL, 2600000UL, 0xA1411F3AUL, (CMU_HFRCODPLLFreq_TypeDef)0   },
    109            { 2600000UL, 3050000UL, 0xA1421F3AUL, (CMU_HFRCODPLLFreq_TypeDef)0   },
    110            { 3050000UL, 3600000UL, 0xB5439F3AUL, (CMU_HFRCODPLLFreq_TypeDef)0   },
    111            { 3600000UL, 4300000UL, 0x80401F00UL, cmuHFRCODPLLFreq_4M0Hz         },
    112            { 4300000UL, 5200000UL, 0xA0411F3AUL, (CMU_HFRCODPLLFreq_TypeDef)0   },
    113            { 5200000UL, 6100000UL, 0xA0421F3AUL, (CMU_HFRCODPLLFreq_TypeDef)0   },
    114            { 6100000UL, 7800000UL, 0xB4439F00UL, cmuHFRCODPLLFreq_7M0Hz         },
    115            { 7800000UL, 9800000UL, 0xB4449F3AUL, (CMU_HFRCODPLLFreq_TypeDef)0   },
    116            { 9800000UL, 11800000UL, 0xB4459F3AUL, (CMU_HFRCODPLLFreq_TypeDef)0  },
    117            { 11800000UL, 14400000UL, 0xB4669F00UL, cmuHFRCODPLLFreq_13M0Hz      },
    118            { 14400000UL, 17200000UL, 0xB4679F00UL, cmuHFRCODPLLFreq_16M0Hz      },
    119            { 17200000UL, 19700000UL, 0xA8689F00UL, cmuHFRCODPLLFreq_19M0Hz      },
    120            { 19700000UL, 23800000UL, 0xB8899F3AUL, (CMU_HFRCODPLLFreq_TypeDef)0 },
    121            { 23800000UL, 28700000UL, 0xB88A9F00UL, cmuHFRCODPLLFreq_26M0Hz      },
    122            { 28700000UL, 34800000UL, 0xB8AB9F00UL, cmuHFRCODPLLFreq_32M0Hz      },
    123            { 34800000UL, 42800000UL, 0xA8CC9F00UL, cmuHFRCODPLLFreq_38M0Hz      },
    124            { 42800000UL, 51600000UL, 0xACED9F00UL, cmuHFRCODPLLFreq_48M0Hz      },
    125            { 51600000UL, 60500000UL, 0xBCEE9F00UL, cmuHFRCODPLLFreq_56M0Hz      },
    126            { 60500000UL, 72600000UL, 0xBCEF9F00UL, cmuHFRCODPLLFreq_64M0Hz      },
    127            { 72600000UL, 80000000UL, 0xCCF09F00UL, cmuHFRCODPLLFreq_80M0Hz      }
    128          };
    129          
    130          #define HFRCOCALTABLE_ENTRIES (sizeof(hfrcoCalTable) \
    131                                         / sizeof(struct hfrcoCalTableElement))
    132          
    133          /*******************************************************************************
    134           **************************   LOCAL PROTOTYPES   *******************************
    135           ******************************************************************************/
    136          
    137          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
    138          static void     em01GrpbClkGet(uint32_t *freq, CMU_Select_TypeDef *sel);
    139          static void     euart0ClkGet(uint32_t *freq, CMU_Select_TypeDef *sel);
    140          static void     rhclkPrescMax(void);
    141          static void     rhclkPrescOptimize(void);
    142          #endif
    143          
    144          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_1)
    145          static uint32_t HFRCOEM23DevinfoGet(CMU_HFRCOEM23Freq_TypeDef freq);
    146          static void     traceClkGet(uint32_t *freq, CMU_Select_TypeDef *sel);
    147          static void     wdog1ClkGet(uint32_t *freq, CMU_Select_TypeDef *sel);
    148          #endif
    149          
    150          static void     dpllRefClkGet(uint32_t *freq, CMU_Select_TypeDef *sel);
    151          static void     em01GrpaClkGet(uint32_t *freq, CMU_Select_TypeDef *sel);
    152          static void     em23GrpaClkGet(uint32_t *freq, CMU_Select_TypeDef *sel);
    153          static void     em4GrpaClkGet(uint32_t *freq, CMU_Select_TypeDef *sel);
    154          static void     flashWaitStateControl(uint32_t coreFreq, int vscale);
    155          static uint32_t HFRCODPLLDevinfoGet(CMU_HFRCODPLLFreq_TypeDef freq);
    156          static void     iadcClkGet(uint32_t *freq, CMU_Select_TypeDef *sel);
    157          static void     pclkDivMax(void);
    158          static void     pclkDivOptimize(void);
    159          static void     rtccClkGet(uint32_t *freq, CMU_Select_TypeDef *sel);
    160          static void     waitStateMax(void);
    161          static void     wdog0ClkGet(uint32_t *freq, CMU_Select_TypeDef *sel);
    162          
    163          /** @endcond */
    164          
    165          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
    166          /*******************************************************************************
    167           **************************   GLOBAL FUNCTIONS   *******************************
    168           ******************************************************************************/
    169          
    170          /***************************************************************************//**
    171           * @brief
    172           *   Enable/disable a clock.
    173           *
    174           * @details
    175           *   Module clocks sre disabled after reset. If a module clock is disabled, the
    176           *   registers of that module are not accessible and accessing such registers
    177           *   will hardfault the Cortex core.
    178           *
    179           * @param[in] clock
    180           *   The clock to enable/disable.
    181           *
    182           * @param[in] enable
    183           *   @li true - enable specified clock.
    184           *   @li false - disable specified clock.
    185           ******************************************************************************/
    186          void CMU_ClockEnable(CMU_Clock_TypeDef clock, bool enable)
    187          {
    188            volatile uint32_t *reg = NULL;
    189            uint32_t          bit;
    190          
    191            /* Identify the enable register. */
    192            if (((unsigned)clock >> CMU_EN_REG_POS) == CMU_NO_EN_REG) {
    193              EFM_ASSERT(false);                      /* No enable for this clock. */
    194            } else if (((unsigned)clock >> CMU_EN_REG_POS) == CMU_CLKEN0_EN_REG) {
    195              reg = &CMU->CLKEN0;
    196            } else if (((unsigned)clock >> CMU_EN_REG_POS) == CMU_CLKEN1_EN_REG) {
    197              reg = &CMU->CLKEN1;
    198            } else {
    199              reg = &CMU->CRYPTOACCCLKCTRL;
    200            }
    201          
    202            /* Get the bit position used to enable/disable. */
    203            bit = ((unsigned)clock >> CMU_EN_BIT_POS) & CMU_EN_BIT_MASK;
    204          
    205            /* Set/clear bit as requested. */
    206            BUS_RegBitWrite(reg, bit, (uint32_t)enable);
    207          }
    208          
    209          /***************************************************************************//**
    210           * @brief
    211           *   Get clock frequency for a clock point.
    212           *
    213           * @param[in] clock
    214           *   Clock point to fetch frequency for.
    215           *
    216           * @return
    217           *   The current frequency in Hz.
    218           ******************************************************************************/
    219          uint32_t CMU_ClockFreqGet(CMU_Clock_TypeDef clock)
    220          {
    221            uint32_t ret = 0U;
    222          
    223            switch (clock) {
    224              case cmuClock_SYSCLK:
    225                ret = SystemSYSCLKGet();
    226                break;
    227          
    228              case cmuClock_HCLK:
    229              case cmuClock_CORE:
    230              case cmuClock_ICACHE:
    231              case cmuClock_MSC:
    232              case cmuClock_LDMA:
    233              case cmuClock_SMU:
    234              case cmuClock_CRYPTOACC:
    235              case cmuClock_RADIOAES:
    236              case cmuClock_CRYPTOAES:
    237              case cmuClock_CRYPTOPK:
    238                ret = SystemHCLKGet();
    239                break;
    240          
    241              case cmuClock_EXPCLK:
    242                ret = SystemSYSCLKGet() / CMU_ClockDivGet(cmuClock_EXPCLK);
    243                break;
    244          
    245              case cmuClock_PCLK:
    246              case cmuClock_USART0:
    247              case cmuClock_USART1:
    248              case cmuClock_I2C1:
    249              case cmuClock_PRS:
    250              case cmuClock_GPIO:
    251              case cmuClock_GPCRC:
    252              case cmuClock_LDMAXBAR:
    253              case cmuClock_SYSCFG:
    254              case cmuClock_DCDC:
    255              case cmuClock_BURAM:
    256              case cmuClock_DPLL0:
    257                ret = SystemHCLKGet() / CMU_ClockDivGet(cmuClock_PCLK);
    258                break;
    259          
    260              case cmuClock_LSPCLK:
    261              case cmuClock_I2C0:
    262              case cmuClock_AMUXCP0:
    263                ret = SystemHCLKGet() / CMU_ClockDivGet(cmuClock_PCLK) / 2U;
    264                break;
    265          
    266              case cmuClock_TRACECLK:
    267                ret = SystemSYSCLKGet() / CMU_ClockDivGet(cmuClock_TRACECLK);
    268                break;
    269          
    270              case cmuClock_TIMER0:
    271              case cmuClock_TIMER1:
    272              case cmuClock_TIMER2:
    273              case cmuClock_TIMER3:
    274              case cmuClock_TIMER4:
    275              case cmuClock_EM01GRPACLK:
    276                em01GrpaClkGet(&ret, NULL);
    277                break;
    278          
    279              case cmuClock_PDM:
    280              case cmuClock_EM01GRPBCLK:
    281                em01GrpbClkGet(&ret, NULL);
    282                break;
    283          
    284              case cmuClock_EUART0:
    285              case cmuClock_EUART0CLK:
    286                euart0ClkGet(&ret, NULL);
    287                break;
    288          
    289              case cmuClock_IADC0:
    290              case cmuClock_IADCCLK:
    291                iadcClkGet(&ret, NULL);
    292                break;
    293          
    294              case cmuClock_SYSTICK:
    295              case cmuClock_LETIMER0:
    296              case cmuClock_EM23GRPACLK:
    297                em23GrpaClkGet(&ret, NULL);
    298                break;
    299          
    300              case cmuClock_WDOG0:
    301              case cmuClock_WDOG0CLK:
    302                wdog0ClkGet(&ret, NULL);
    303                break;
    304          
    305              case cmuClock_RTCC:
    306              case cmuClock_RTCCCLK:
    307                rtccClkGet(&ret, NULL);
    308                break;
    309          
    310              case cmuClock_BURTC:
    311              case cmuClock_EM4GRPACLK:
    312                em4GrpaClkGet(&ret, NULL);
    313                break;
    314          
    315              default:
    316                EFM_ASSERT(false);
    317                break;
    318            }
    319            return ret;
    320          }
    321          
    322          /*******************************************************************************
    323           **************************   LOCAL FUNCTIONS   ********************************
    324           ******************************************************************************/
    325          
    326          /***************************************************************************//**
    327           * @brief
    328           *   Get selected oscillator and frequency for @ref cmuClock_EM01GRPBCLK
    329           *   clock tree.
    330           *
    331           * @param[out] freq
    332           *   The frequency.
    333           *
    334           * @param[out] sel
    335           *   The selected oscillator.
    336           ******************************************************************************/
    337          static void em01GrpbClkGet(uint32_t *freq, CMU_Select_TypeDef *sel)
    338          {
    339            uint32_t f = 0U;
    340            CMU_Select_TypeDef s;
    341          
    342            switch (CMU->EM01GRPBCLKCTRL & _CMU_EM01GRPBCLKCTRL_CLKSEL_MASK) {
    343              case _CMU_EM01GRPBCLKCTRL_CLKSEL_HFRCODPLL:
    344                f = SystemHFRCODPLLClockGet();
    345                s = cmuSelect_HFRCODPLL;
    346                break;
    347          
    348              case _CMU_EM01GRPBCLKCTRL_CLKSEL_HFRCODPLLRT:
    349                f = SystemHFRCODPLLClockGet();
    350                s = cmuSelect_HFRCODPLLRT;
    351                break;
    352          
    353              case _CMU_EM01GRPBCLKCTRL_CLKSEL_HFXO:
    354                f = SystemHFXOClockGet();
    355                s = cmuSelect_HFXO;
    356                break;
    357          
    358              case _CMU_EM01GRPBCLKCTRL_CLKSEL_HFXORT:
    359                f = SystemHFXOClockGet();
    360                s = cmuSelect_HFXORT;
    361                break;
    362          
    363              case _CMU_EM01GRPBCLKCTRL_CLKSEL_FSRCO:
    364                f = SystemFSRCOClockGet();
    365                s = cmuSelect_FSRCO;
    366                break;
    367          
    368              case _CMU_EM01GRPBCLKCTRL_CLKSEL_CLKIN0:
    369                f = SystemCLKIN0Get();
    370                s = cmuSelect_CLKIN0;
    371                break;
    372          
    373              default:
    374                s = cmuSelect_Error;
    375                EFM_ASSERT(false);
    376                break;
    377            }
    378          
    379            if (freq != NULL) {
    380              *freq = f;
    381            }
    382            if (sel != NULL) {
    383              *sel = s;
    384            }
    385          }
    386          
    387          /***************************************************************************//**
    388           * @brief
    389           *   Get selected oscillator and frequency for @ref cmuClock_EUART0CLK
    390           *   clock tree.
    391           *
    392           * @param[out] freq
    393           *   The frequency.
    394           *
    395           * @param[out] sel
    396           *   The selected oscillator.
    397           ******************************************************************************/
    398          static void euart0ClkGet(uint32_t *freq, CMU_Select_TypeDef *sel)
    399          {
    400            switch (CMU->EUART0CLKCTRL & _CMU_EUART0CLKCTRL_CLKSEL_MASK) {
    401              case _CMU_EUART0CLKCTRL_CLKSEL_EM01GRPACLK:
    402                em01GrpaClkGet(freq, sel);
    403                break;
    404          
    405              case _CMU_EUART0CLKCTRL_CLKSEL_EM23GRPACLK:
    406                em23GrpaClkGet(freq, sel);
    407                break;
    408          
    409              default:
    410                if (freq != NULL) {
    411                  *freq = 0U;
    412                }
    413                if (sel != NULL) {
    414                  *sel = cmuSelect_Error;
    415                }
    416                EFM_ASSERT(false);
    417                break;
    418            }
    419          }
    420          
    421          /***************************************************************************//**
    422           * @brief
    423           *   Set maximum allowed prescaler for radio clock tree (RHCLK).
    424           ******************************************************************************/
    425          static void rhclkPrescMax(void)
    426          {
    427            // Set largest prescaler (DIV2).
    428            CMU->SYSCLKCTRL_SET = CMU_SYSCLKCTRL_RHCLKPRESC;
    429          }
    430          
    431          /***************************************************************************//**
    432           * @brief
    433           *   Set radio clock tree prescaler to achieve highest possible frequency
    434           *   and still be within spec.
    435           ******************************************************************************/
    436          static void rhclkPrescOptimize(void)
    437          {
    438            if (CMU_ClockFreqGet(cmuClock_SYSCLK) <= CMU_MAX_RHCLK_FREQ) {
    439              // Set smallest prescaler (DIV1).
    440              CMU->SYSCLKCTRL_CLR = CMU_SYSCLKCTRL_RHCLKPRESC;
    441            }
    442          }
    443          
    444          #endif  // defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
    445          
    446          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_1)
    447          /*******************************************************************************
    448           **************************   GLOBAL FUNCTIONS   *******************************
    449           ******************************************************************************/
    450          
    451          /***************************************************************************//**
    452           * @brief
    453           *   Get clock frequency for a clock point.
    454           *
    455           * @param[in] clock
    456           *   Clock point to fetch frequency for.
    457           *
    458           * @return
    459           *   The current frequency in Hz.
    460           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    461          uint32_t CMU_ClockFreqGet(CMU_Clock_TypeDef clock)
    462          {
   \                     CMU_ClockFreqGet: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    463            uint32_t ret = 0U;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x9100             STR      R1,[SP, #+0]
    464          
    465            switch (clock) {
   \        0x6   0x2824             CMP      R0,#+36
   \        0x8   0xD856             BHI.N    ??CMU_ClockFreqGet_1
   \        0xA   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??CMU_ClockFreqGet_0:
   \        0xE   0x13 0x16          DC8      0x13,0x16,0x19,0x1E
   \              0x19 0x1E    
   \       0x12   0x27 0x32          DC8      0x27,0x32,0x36,0x3A
   \              0x36 0x3A    
   \       0x16   0x3E 0x42          DC8      0x3E,0x42,0x46,0x4A
   \              0x46 0x4A    
   \       0x1A   0x4E 0x52          DC8      0x4E,0x52,0x16,0x3A
   \              0x16 0x3A    
   \       0x1E   0x55 0x55          DC8      0x55,0x55,0x3E,0x16
   \              0x3E 0x16    
   \       0x22   0x1E 0x27          DC8      0x1E,0x27,0x1E,0x32
   \              0x1E 0x32    
   \       0x26   0x16 0x3A          DC8      0x16,0x3A,0x1E,0x52
   \              0x1E 0x52    
   \       0x2A   0x36 0x36          DC8      0x36,0x36,0x36,0x36
   \              0x36 0x36    
   \       0x2E   0x1E 0x1E          DC8      0x1E,0x1E,0x1E,0x42
   \              0x1E 0x42    
   \       0x32   0x46 0x00          DC8      0x46,0x0
    466              case cmuClock_SYSCLK:
    467                ret = SystemSYSCLKGet();
   \                     ??CMU_ClockFreqGet_2: (+1)
   \       0x34   0x....'....        BL       SystemSYSCLKGet
   \       0x38   0xE019             B.N      ??CMU_ClockFreqGet_3
    468                break;
    469          
    470              case cmuClock_CORE:
    471              case cmuClock_HCLK:
    472              case cmuClock_LDMA:
    473              case cmuClock_GPCRC:
    474                ret = SystemHCLKGet();
   \                     ??CMU_ClockFreqGet_4: (+1)
   \       0x3A   0x....'....        BL       SystemHCLKGet
   \       0x3E   0xE016             B.N      ??CMU_ClockFreqGet_3
    475                break;
    476          
    477              case cmuClock_EXPCLK:
    478                ret = SystemSYSCLKGet() / CMU_ClockDivGet(cmuClock_EXPCLK);
   \                     ??CMU_ClockFreqGet_5: (+1)
   \       0x40   0x....'....        BL       SystemSYSCLKGet
   \       0x44   0x4604             MOV      R4,R0
   \       0x46   0x2002             MOVS     R0,#+2
   \       0x48   0xE003             B.N      ??CMU_ClockFreqGet_6
    479                break;
    480          
    481              case cmuClock_I2C1:
    482              case cmuClock_PRS:
    483              case cmuClock_PCLK:
    484              case cmuClock_GPIO:
    485              case cmuClock_USART0:
    486              case cmuClock_USART1:
    487              case cmuClock_USART2:
    488                ret = SystemHCLKGet() / CMU_ClockDivGet(cmuClock_PCLK);
   \                     ??CMU_ClockFreqGet_7: (+1)
   \       0x4A   0x....'....        BL       SystemHCLKGet
   \       0x4E   0x4604             MOV      R4,R0
   \       0x50   0x2003             MOVS     R0,#+3
   \                     ??CMU_ClockFreqGet_6: (+1)
   \       0x52   0x....'....        BL       CMU_ClockDivGet
   \       0x56   0xFBB4 0xF0F0      UDIV     R0,R4,R0
   \       0x5A   0xE008             B.N      ??CMU_ClockFreqGet_3
    489                break;
    490          
    491              case cmuClock_I2C0:
    492              case cmuClock_LSPCLK:
    493                ret = SystemHCLKGet() / CMU_ClockDivGet(cmuClock_PCLK) / 2U;
   \                     ??CMU_ClockFreqGet_8: (+1)
   \       0x5C   0x....'....        BL       SystemHCLKGet
   \       0x60   0x4604             MOV      R4,R0
   \       0x62   0x2003             MOVS     R0,#+3
   \       0x64   0x....'....        BL       CMU_ClockDivGet
   \       0x68   0xFBB4 0xF0F0      UDIV     R0,R4,R0
   \       0x6C   0x0840             LSRS     R0,R0,#+1
   \                     ??CMU_ClockFreqGet_3: (+1)
   \       0x6E   0x9000             STR      R0,[SP, #+0]
    494                break;
   \       0x70   0xE022             B.N      ??CMU_ClockFreqGet_1
    495          
    496              case cmuClock_IADC0:
    497              case cmuClock_IADCCLK:
    498                iadcClkGet(&ret, NULL);
   \                     ??CMU_ClockFreqGet_9: (+1)
   \       0x72   0x4668             MOV      R0,SP
   \       0x74   0x....'....        BL       iadcClkGet
    499                break;
   \       0x78   0xE01E             B.N      ??CMU_ClockFreqGet_1
    500          
    501              case cmuClock_TIMER0:
    502              case cmuClock_TIMER1:
    503              case cmuClock_TIMER2:
    504              case cmuClock_TIMER3:
    505              case cmuClock_EM01GRPACLK:
    506                em01GrpaClkGet(&ret, NULL);
   \                     ??CMU_ClockFreqGet_10: (+1)
   \       0x7A   0x4668             MOV      R0,SP
   \       0x7C   0x....'....        BL       em01GrpaClkGet
    507                break;
   \       0x80   0xE01A             B.N      ??CMU_ClockFreqGet_1
    508          
    509              case cmuClock_SYSTICK:
    510              case cmuClock_LETIMER0:
    511              case cmuClock_EM23GRPACLK:
    512                em23GrpaClkGet(&ret, NULL);
   \                     ??CMU_ClockFreqGet_11: (+1)
   \       0x82   0x4668             MOV      R0,SP
   \       0x84   0x....'....        BL       em23GrpaClkGet
    513                break;
   \       0x88   0xE016             B.N      ??CMU_ClockFreqGet_1
    514          
    515              case cmuClock_BURTC:
    516              case cmuClock_EM4GRPACLK:
    517                em4GrpaClkGet(&ret, NULL);
   \                     ??CMU_ClockFreqGet_12: (+1)
   \       0x8A   0x4668             MOV      R0,SP
   \       0x8C   0x....'....        BL       em4GrpaClkGet
    518                break;
   \       0x90   0xE012             B.N      ??CMU_ClockFreqGet_1
    519          
    520              case cmuClock_WDOG0:
    521              case cmuClock_WDOG0CLK:
    522                wdog0ClkGet(&ret, NULL);
   \                     ??CMU_ClockFreqGet_13: (+1)
   \       0x92   0x4668             MOV      R0,SP
   \       0x94   0x....'....        BL       wdog0ClkGet
    523                break;
   \       0x98   0xE00E             B.N      ??CMU_ClockFreqGet_1
    524          
    525              case cmuClock_WDOG1:
    526              case cmuClock_WDOG1CLK:
    527                wdog1ClkGet(&ret, NULL);
   \                     ??CMU_ClockFreqGet_14: (+1)
   \       0x9A   0x4668             MOV      R0,SP
   \       0x9C   0x....'....        BL       wdog1ClkGet
    528                break;
   \       0xA0   0xE00A             B.N      ??CMU_ClockFreqGet_1
    529          
    530              case cmuClock_DPLLREFCLK:
    531                dpllRefClkGet(&ret, NULL);
   \                     ??CMU_ClockFreqGet_15: (+1)
   \       0xA2   0x4668             MOV      R0,SP
   \       0xA4   0x....'....        BL       dpllRefClkGet
    532                break;
   \       0xA8   0xE006             B.N      ??CMU_ClockFreqGet_1
    533          
    534              case cmuClock_TRACECLK:
    535                traceClkGet(&ret, NULL);
   \                     ??CMU_ClockFreqGet_16: (+1)
   \       0xAA   0x4668             MOV      R0,SP
   \       0xAC   0x....'....        BL       traceClkGet
    536                break;
   \       0xB0   0xE002             B.N      ??CMU_ClockFreqGet_1
    537          
    538              case cmuClock_RTCC:
    539              case cmuClock_RTCCCLK:
    540                rtccClkGet(&ret, NULL);
   \                     ??CMU_ClockFreqGet_17: (+1)
   \       0xB2   0x4668             MOV      R0,SP
   \       0xB4   0x....'....        BL       rtccClkGet
    541                break;
    542          
    543              default:
    544                EFM_ASSERT(false);
    545                break;
    546            }
    547            return ret;
   \                     ??CMU_ClockFreqGet_1: (+1)
   \       0xB8   0x9800             LDR      R0,[SP, #+0]
   \       0xBA   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    548          }
    549          
    550          /***************************************************************************//**
    551           * @brief
    552           *   Get HFRCOEM23 band in use.
    553           *
    554           * @return
    555           *   HFRCOEM23 band in use.
    556           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    557          CMU_HFRCOEM23Freq_TypeDef CMU_HFRCOEM23BandGet(void)
    558          {
    559            return (CMU_HFRCOEM23Freq_TypeDef)SystemHFRCOEM23ClockGet();
   \                     CMU_HFRCOEM23BandGet: (+1)
   \        0x0   0x....'....        B.W      SystemHFRCOEM23ClockGet
    560          }
    561          
    562          /***************************************************************************//**
    563           * @brief
    564           *   Set HFRCOEM23 band and the tuning value based on the value in the
    565           *   calibration table made during production.
    566           *
    567           * @param[in] freq
    568           *   HFRCOEM23 frequency band to activate.
    569           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    570          void CMU_HFRCOEM23BandSet(CMU_HFRCOEM23Freq_TypeDef freq)
    571          {
   \                     CMU_HFRCOEM23BandSet: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    572            uint32_t freqCal;
    573          
    574            // Get calibration data from DEVINFO
    575            freqCal = HFRCOEM23DevinfoGet(freq);
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0x....'....        LDR.W    R4,??DataTable22  ;; 0xf4240
   \        0x8   0x42A0             CMP      R0,R4
   \        0xA   0x....'....        LDR.W    R2,??DataTable22_1  ;; 0xfe080a0
   \        0xE   0xBF1F             ITTTT    NE 
   \       0x10   0x....'....        LDRNE.W  R4,??DataTable22_2  ;; 0x1e8480
   \       0x14   0x42A0             CMPNE    R0,R4
   \       0x16   0x....'....        LDRNE.W  R4,??DataTable22_3  ;; 0x3d0900
   \       0x1A   0x42A0             CMPNE    R0,R4
   \       0x1C   0xD025             BEQ.N    ??CMU_HFRCOEM23BandSet_0
   \       0x1E   0x....'....        LDR.W    R4,??DataTable22_4  ;; 0xc65d40
   \       0x22   0x42A0             CMP      R0,R4
   \       0x24   0xD01D             BEQ.N    ??CMU_HFRCOEM23BandSet_1
   \       0x26   0x....'....        LDR.W    R4,??DataTable22_5  ;; 0xf42400
   \       0x2A   0x42A0             CMP      R0,R4
   \       0x2C   0xD017             BEQ.N    ??CMU_HFRCOEM23BandSet_2
   \       0x2E   0x....'....        LDR.W    R4,??DataTable22_6  ;; 0x121eac0
   \       0x32   0x42A0             CMP      R0,R4
   \       0x34   0xD011             BEQ.N    ??CMU_HFRCOEM23BandSet_3
   \       0x36   0x....'....        LDR.W    R4,??DataTable22_7  ;; 0x18cba80
   \       0x3A   0x42A0             CMP      R0,R4
   \       0x3C   0xD00B             BEQ.N    ??CMU_HFRCOEM23BandSet_4
   \       0x3E   0x....'....        LDR.W    R4,??DataTable22_8  ;; 0x1e84800
   \       0x42   0x42A0             CMP      R0,R4
   \       0x44   0xD005             BEQ.N    ??CMU_HFRCOEM23BandSet_5
   \       0x46   0x....'....        LDR.W    R4,??DataTable22_9  ;; 0x2625a00
   \       0x4A   0x42A0             CMP      R0,R4
   \       0x4C   0xD10E             BNE.N    ??CMU_HFRCOEM23BandSet_6
   \       0x4E   0x6B11             LDR      R1,[R2, #+48]
   \       0x50   0xE008             B.N      ??CMU_HFRCOEM23BandSet_7
   \                     ??CMU_HFRCOEM23BandSet_5: (+1)
   \       0x52   0x6AD1             LDR      R1,[R2, #+44]
   \       0x54   0xE006             B.N      ??CMU_HFRCOEM23BandSet_7
   \                     ??CMU_HFRCOEM23BandSet_4: (+1)
   \       0x56   0x6A91             LDR      R1,[R2, #+40]
   \       0x58   0xE004             B.N      ??CMU_HFRCOEM23BandSet_7
   \                     ??CMU_HFRCOEM23BandSet_3: (+1)
   \       0x5A   0x6A11             LDR      R1,[R2, #+32]
   \       0x5C   0xE002             B.N      ??CMU_HFRCOEM23BandSet_7
   \                     ??CMU_HFRCOEM23BandSet_2: (+1)
   \       0x5E   0x69D1             LDR      R1,[R2, #+28]
   \       0x60   0xE000             B.N      ??CMU_HFRCOEM23BandSet_7
   \                     ??CMU_HFRCOEM23BandSet_1: (+1)
   \       0x62   0x6991             LDR      R1,[R2, #+24]
   \                     ??CMU_HFRCOEM23BandSet_7: (+1)
   \       0x64   0xF021 0x7140      BIC      R1,R1,#0x3000000
   \       0x68   0xE00F             B.N      ??CMU_HFRCOEM23BandSet_8
   \                     ??CMU_HFRCOEM23BandSet_0: (+1)
   \       0x6A   0x6811             LDR      R1,[R2, #+0]
    576            EFM_ASSERT((freqCal != 0UL) && (freqCal != UINT_MAX));
    577          
    578            // Set divider for 1, 2 and 4MHz bands
    579            freqCal &= ~_HFRCO_CAL_CLKDIV_MASK;
    580            switch (freq) {
   \                     ??CMU_HFRCOEM23BandSet_6: (+1)
   \       0x6C   0x....'....        LDR.W    R2,??DataTable22  ;; 0xf4240
   \       0x70   0xF021 0x7140      BIC      R1,R1,#0x3000000
   \       0x74   0x4290             CMP      R0,R2
   \       0x76   0xD006             BEQ.N    ??CMU_HFRCOEM23BandSet_9
   \       0x78   0x....'....        LDR.W    R2,??DataTable22_2  ;; 0x1e8480
   \       0x7C   0x4290             CMP      R0,R2
   \       0x7E   0xBF08             IT       EQ 
   \       0x80   0xF041 0x7180      ORREQ    R1,R1,#0x1000000
    581              case cmuHFRCOEM23Freq_1M0Hz:
    582                freqCal |= HFRCO_CAL_CLKDIV_DIV4;
    583                break;
    584          
    585              case cmuHFRCOEM23Freq_2M0Hz:
    586                freqCal |= HFRCO_CAL_CLKDIV_DIV2;
   \       0x84   0xE001             B.N      ??CMU_HFRCOEM23BandSet_8
   \                     ??CMU_HFRCOEM23BandSet_9: (+1)
   \       0x86   0xF041 0x7100      ORR      R1,R1,#0x2000000
    587                break;
    588          
    589              default:
    590                break;
    591            }
    592          
    593            // Activate new band selection
    594            HFRCOEM23->CAL = freqCal;
   \                     ??CMU_HFRCOEM23BandSet_8: (+1)
   \       0x8A   0x....'....        LDR.W    R0,??DataTable26  ;; 0x4a014008
   \       0x8E   0x6001             STR      R1,[R0, #+0]
    595          }
   \       0x90   0xBD10             POP      {R4,PC}          ;; return
    596          
    597          /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
    598          
    599          /*******************************************************************************
    600           **************************   LOCAL FUNCTIONS   ********************************
    601           ******************************************************************************/
    602          
    603          /***************************************************************************//**
    604           * @brief
    605           *   Get calibrated HFRCOEM23 tuning value from Device information (DI) page
    606           *   for a given frequency. Calibration value is not available for all frequency
    607           *   bands.
    608           *
    609           * @param[in] freq
    610           *   HFRCOEM23 frequency band
    611           ******************************************************************************/
    612          static uint32_t HFRCOEM23DevinfoGet(CMU_HFRCOEM23Freq_TypeDef freq)
    613          {
    614            uint32_t ret = 0U;
    615          
    616            switch (freq) {
    617              // 1, 2 and 4MHz share the same calibration word
    618              case cmuHFRCOEM23Freq_1M0Hz:
    619              case cmuHFRCOEM23Freq_2M0Hz:
    620              case cmuHFRCOEM23Freq_4M0Hz:
    621                ret = DEVINFO->HFRCOEM23CAL[0].HFRCOEM23CAL;
    622                break;
    623          
    624              case cmuHFRCOEM23Freq_13M0Hz:
    625                ret = DEVINFO->HFRCOEM23CAL[6].HFRCOEM23CAL;
    626                break;
    627          
    628              case cmuHFRCOEM23Freq_16M0Hz:
    629                ret = DEVINFO->HFRCOEM23CAL[7].HFRCOEM23CAL;
    630                break;
    631          
    632              case cmuHFRCOEM23Freq_19M0Hz:
    633                ret = DEVINFO->HFRCOEM23CAL[8].HFRCOEM23CAL;
    634                break;
    635          
    636              case cmuHFRCOEM23Freq_26M0Hz:
    637                ret = DEVINFO->HFRCOEM23CAL[10].HFRCOEM23CAL;
    638                break;
    639          
    640              case cmuHFRCOEM23Freq_32M0Hz:
    641                ret = DEVINFO->HFRCOEM23CAL[11].HFRCOEM23CAL;
    642                break;
    643          
    644              case cmuHFRCOEM23Freq_40M0Hz:
    645                ret = DEVINFO->HFRCOEM23CAL[12].HFRCOEM23CAL;
    646                break;
    647          
    648              case cmuHFRCOEM23Freq_UserDefined:
    649                break;
    650          
    651              default:
    652                EFM_ASSERT(false);
    653                break;
    654            }
    655            return ret;
    656          }
    657          
    658          /***************************************************************************//**
    659           * @brief
    660           *   Get selected oscillator and frequency for @ref cmuClock_TRACECLK
    661           *   clock tree.
    662           *
    663           * @param[out] freq
    664           *   The frequency.
    665           *
    666           * @param[out] sel
    667           *   The selected oscillator.
    668           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    669          static void traceClkGet(uint32_t *freq, CMU_Select_TypeDef *sel)
    670          {
   \                     traceClkGet: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460C             MOV      R4,R1
    671            uint32_t f = 0U;
    672            CMU_Select_TypeDef s;
    673          
    674            switch (CMU->TRACECLKCTRL & _CMU_TRACECLKCTRL_CLKSEL_MASK) {
   \        0x4   0x....'....        LDR.W    R1,??DataTable26_1  ;; 0x40008080
   \        0x8   0x....'....        BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_6: (+1)
   \        0xC   0x2A02             CMP      R2,#+2
   \        0xE   0xD002             BEQ.N    ??traceClkGet_0
   \       0x10   0x2A03             CMP      R2,#+3
   \       0x12   0xD004             BEQ.N    ??traceClkGet_1
   \       0x14   0xE007             B.N      ??traceClkGet_2
    675              case _CMU_TRACECLKCTRL_CLKSEL_HCLK:
    676                f = SystemHCLKGet();
   \                     ??traceClkGet_0: (+1)
   \       0x16   0x....'....        BL       SystemHCLKGet
    677                s = cmuSelect_HCLK;
   \       0x1A   0x210B             MOVS     R1,#+11
    678                break;
   \       0x1C   0xE004             B.N      ??traceClkGet_3
    679          
    680              case _CMU_TRACECLKCTRL_CLKSEL_HFRCOEM23:
    681                f = SystemHFRCOEM23ClockGet();
   \                     ??traceClkGet_1: (+1)
   \       0x1E   0x....'....        BL       SystemHFRCOEM23ClockGet
    682                s = cmuSelect_HFRCOEM23;
   \       0x22   0x2105             MOVS     R1,#+5
    683                break;
   \       0x24   0xE000             B.N      ??traceClkGet_3
    684          
    685              default:
    686                s = cmuSelect_Error;
   \                     ??traceClkGet_2: (+1)
   \       0x26   0x2100             MOVS     R1,#+0
    687                EFM_ASSERT(false);
    688                break;
    689            }
    690          
    691            if (freq != NULL) {
   \                     ??traceClkGet_3: (+1)
   \       0x28   0x....'....        B.W      ??Subroutine0_0
    692              *freq = f;
    693            }
    694            if (sel != NULL) {
    695              *sel = s;
    696            }
    697          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x680A             LDR      R2,[R1, #+0]
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xF002 0x0203      AND      R2,R2,#0x3
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x680A             LDR      R2,[R1, #+0]
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xF002 0x0203      AND      R2,R2,#0x3
   \        0xA   0x2A01             CMP      R2,#+1
   \        0xC   0xD004             BEQ.N    ??Subroutine0_1
   \        0xE   0xD30F             BCC.N    ??Subroutine0_2
   \       0x10   0x2A03             CMP      R2,#+3
   \       0x12   0xD009             BEQ.N    ??Subroutine0_3
   \       0x14   0xD304             BCC.N    ??Subroutine0_4
   \       0x16   0xE00B             B.N      ??Subroutine0_2
   \                     ??Subroutine0_1: (+1)
   \       0x18   0x....'....        BL       SystemLFRCOClockGet
   \       0x1C   0x2108             MOVS     R1,#+8
   \       0x1E   0xE008             B.N      ??Subroutine0_0
   \                     ??Subroutine0_4: (+1)
   \       0x20   0x....'....        BL       SystemLFXOClockGet
   \       0x24   0x2107             MOVS     R1,#+7
   \       0x26   0xE004             B.N      ??Subroutine0_0
   \                     ??Subroutine0_3: (+1)
   \       0x28   0x....'....        BL       SystemULFRCOClockGet
   \       0x2C   0x2109             MOVS     R1,#+9
   \       0x2E   0xE000             B.N      ??Subroutine0_0
   \                     ??Subroutine0_2: (+1)
   \       0x30   0x2100             MOVS     R1,#+0
   \                     ??Subroutine0_0: (+1)
   \       0x32   0xB105             CBZ.N    R5,??Subroutine0_5
   \       0x34   0x6028             STR      R0,[R5, #+0]
   \                     ??Subroutine0_5: (+1)
   \       0x36   0xB104             CBZ.N    R4,??Subroutine0_6
   \       0x38   0x7021             STRB     R1,[R4, #+0]
   \                     ??Subroutine0_6: (+1)
   \       0x3A   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    698          
    699          /***************************************************************************//**
    700           * @brief
    701           *   Get selected oscillator and frequency for @ref cmuClock_WDOG1CLK
    702           *   clock tree.
    703           *
    704           * @param[out] freq
    705           *   The frequency.
    706           *
    707           * @param[out] sel
    708           *   The selected oscillator.
    709           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    710          static void wdog1ClkGet(uint32_t *freq, CMU_Select_TypeDef *sel)
    711          {
   \                     wdog1ClkGet: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460C             MOV      R4,R1
    712            uint32_t f = 0U;
    713            CMU_Select_TypeDef s;
    714          
    715            switch (CMU->WDOG1CLKCTRL & _CMU_WDOG1CLKCTRL_CLKSEL_MASK) {
   \        0x4   0x....'....        LDR.W    R1,??DataTable27  ;; 0x40008208
   \        0x8   0x....'....        BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_3: (+1)
   \        0xC   0xD814             BHI.N    ??wdog1ClkGet_1
   \        0xE   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??wdog1ClkGet_0:
   \       0x12   0x02 0x06          DC8      0x2,0x6,0xA,0xE
   \              0x0A 0x0E    
    716              case _CMU_WDOG1CLKCTRL_CLKSEL_LFRCO:
    717                f = SystemLFRCOClockGet();
   \                     ??wdog1ClkGet_2: (+1)
   \       0x16   0x....'....        BL       SystemLFRCOClockGet
    718                s = cmuSelect_LFRCO;
   \       0x1A   0x2108             MOVS     R1,#+8
    719                break;
   \       0x1C   0xE00D             B.N      ??wdog1ClkGet_3
    720          
    721              case _CMU_WDOG1CLKCTRL_CLKSEL_LFXO:
    722                f = SystemLFXOClockGet();
   \                     ??wdog1ClkGet_4: (+1)
   \       0x1E   0x....'....        BL       SystemLFXOClockGet
    723                s = cmuSelect_LFXO;
   \       0x22   0x2107             MOVS     R1,#+7
    724                break;
   \       0x24   0xE009             B.N      ??wdog1ClkGet_3
    725          
    726              case _CMU_WDOG1CLKCTRL_CLKSEL_ULFRCO:
    727                f = SystemULFRCOClockGet();
   \                     ??wdog1ClkGet_5: (+1)
   \       0x26   0x....'....        BL       SystemULFRCOClockGet
    728                s = cmuSelect_ULFRCO;
   \       0x2A   0x2109             MOVS     R1,#+9
    729                break;
   \       0x2C   0xE005             B.N      ??wdog1ClkGet_3
    730          
    731              case _CMU_WDOG1CLKCTRL_CLKSEL_HCLKDIV1024:
    732                f = SystemHCLKGet() / 1024U;
   \                     ??wdog1ClkGet_6: (+1)
   \       0x2E   0x....'....        BL       SystemHCLKGet
   \       0x32   0x0A80             LSRS     R0,R0,#+10
    733                s = cmuSelect_HCLKDIV1024;
   \       0x34   0x210C             MOVS     R1,#+12
    734                break;
   \       0x36   0xE000             B.N      ??wdog1ClkGet_3
    735          
    736              default:
    737                s = cmuSelect_Error;
   \                     ??wdog1ClkGet_1: (+1)
   \       0x38   0x2100             MOVS     R1,#+0
    738                EFM_ASSERT(false);
    739                break;
    740            }
    741          
    742            if (freq != NULL) {
   \                     ??wdog1ClkGet_3: (+1)
   \       0x3A   0x....'....        B.W      ??Subroutine0_0
    743              *freq = f;
    744            }
    745            if (sel != NULL) {
    746              *sel = s;
    747            }
    748          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x680A             LDR      R2,[R1, #+0]
   \        0x2   0x4605             MOV      R5,R0
   \        0x4   0x2000             MOVS     R0,#+0
   \        0x6   0xF002 0x0207      AND      R2,R2,#0x7
   \        0xA   0x1E52             SUBS     R2,R2,#+1
   \        0xC   0x2A03             CMP      R2,#+3
   \        0xE   0x4770             BX       LR
    749          
    750          /** @endcond */
    751          
    752          #endif  // defined(_SILICON_LABS_32B_SERIES_2_CONFIG_1)
    753          
    754          // The following code is common for all SERIES_2 configurations.
    755          
    756          /*******************************************************************************
    757           **************************   GLOBAL FUNCTIONS   *******************************
    758           ******************************************************************************/
    759          
    760          /***************************************************************************//**
    761           * @brief
    762           *   Calibrate an oscillator.
    763           *
    764           * @details
    765           *   Run a calibration of a selectable reference clock againt HCLK. Please
    766           *   refer to the reference manual, CMU chapter, for further details.
    767           *
    768           * @note
    769           *   This function will not return until calibration measurement is completed.
    770           *
    771           * @param[in] cycles
    772           *   The number of HCLK cycles to run calibration. Increasing this number
    773           *   increases precision, but the calibration will take more time.
    774           *
    775           * @param[in] ref
    776           *   The reference clock used to compare against HCLK.
    777           *
    778           * @return
    779           *   The number of ticks the selected reference clock ticked while running
    780           *   cycles ticks of the HCLK clock.
    781           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    782          uint32_t CMU_Calibrate(uint32_t cycles, CMU_Select_TypeDef ref)
    783          {
   \                     CMU_Calibrate: (+1)
   \        0x0   0x460A             MOV      R2,R1
   \        0x2   0xB580             PUSH     {R7,LR}
    784            // Check for cycle count overflow
    785            EFM_ASSERT(cycles <= (_CMU_CALCTRL_CALTOP_MASK
    786                                  >> _CMU_CALCTRL_CALTOP_SHIFT));
    787          
    788            CMU_CalibrateConfig(cycles, cmuSelect_HCLK, ref);
   \        0x4   0x210B             MOVS     R1,#+11
   \        0x6   0x....'....        BL       CMU_CalibrateConfig
    789            CMU_CalibrateStart();
   \        0xA   0x2201             MOVS     R2,#+1
   \        0xC   0x....'....        LDR.W    R0,??DataTable27_1  ;; 0x40008050
   \       0x10   0x6002             STR      R2,[R0, #+0]
    790            return CMU_CalibrateCountGet();
   \       0x12   0xE8BD 0x4001      POP      {R0,LR}
   \       0x16   0x....             B.N      CMU_CalibrateCountGet
    791          }
    792          
    793          /***************************************************************************//**
    794           * @brief
    795           *   Configure clock calibration.
    796           *
    797           * @details
    798           *   Configure a calibration for a selectable clock source against another
    799           *   selectable reference clock.
    800           *   Refer to the reference manual, CMU chapter, for further details.
    801           *
    802           * @note
    803           *   After configuration, a call to @ref CMU_CalibrateStart() is required, and
    804           *   the resulting calibration value can be read with the
    805           *   @ref CMU_CalibrateCountGet() function call.
    806           *
    807           * @param[in] downCycles
    808           *   The number of downSel clock cycles to run calibration. Increasing this
    809           *   number increases precision, but the calibration will take more time.
    810           *
    811           * @param[in] downSel
    812           *   The clock which will be counted down downCycles cycles.
    813           *
    814           * @param[in] upSel
    815           *   The reference clock, the number of cycles generated by this clock will
    816           *   be counted and added up, the result can be given with the
    817           *   @ref CMU_CalibrateCountGet() function call.
    818           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    819          void CMU_CalibrateConfig(uint32_t downCycles, CMU_Select_TypeDef downSel,
    820                                   CMU_Select_TypeDef upSel)
    821          {
   \                     CMU_CalibrateConfig: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    822            // Keep untouched configuration settings
    823            uint32_t calCtrl = CMU->CALCTRL
    824                               & ~(_CMU_CALCTRL_UPSEL_MASK
    825                                   | _CMU_CALCTRL_DOWNSEL_MASK
    826                                   | _CMU_CALCTRL_CALTOP_MASK);
   \        0x2   0x....'....        LDR.W    R3,??DataTable27_2  ;; 0x40008054
   \        0x6   0x681C             LDR      R4,[R3, #+0]
    827          
    828            // Check for cycle count overflow
    829            EFM_ASSERT(downCycles <= (_CMU_CALCTRL_CALTOP_MASK
    830                                      >> _CMU_CALCTRL_CALTOP_SHIFT));
    831            calCtrl |= downCycles;
    832          
    833            // Set down counting clock source selector
    834            switch (downSel) {
   \        0x8   0x1E89             SUBS     R1,R1,#+2
   \        0xA   0xF404 0x0470      AND      R4,R4,#0xF00000
   \        0xE   0x4320             ORRS     R0,R0,R4
   \       0x10   0x290D             CMP      R1,#+13
   \       0x12   0xD822             BHI.N    ??CMU_CalibrateConfig_1
   \       0x14   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??CMU_CalibrateConfig_0:
   \       0x18   0x19 0x0D          DC8      0x19,0xD,0x13,0x16
   \              0x13 0x16    
   \       0x1C   0x21 0x10          DC8      0x21,0x10,0x1C,0x1F
   \              0x1C 0x1F    
   \       0x20   0x21 0x07          DC8      0x21,0x7,0x21,0x21
   \              0x21 0x21    
   \       0x24   0x21 0x0A          DC8      0x21,0xA
    835              case cmuSelect_HCLK:
    836                calCtrl |= CMU_CALCTRL_DOWNSEL_HCLK;
   \                     ??CMU_CalibrateConfig_2: (+1)
   \       0x26   0xF040 0x5080      ORR      R0,R0,#0x10000000
    837                break;
   \       0x2A   0xE016             B.N      ??CMU_CalibrateConfig_1
    838          
    839              case cmuSelect_PRS:
    840                calCtrl |= CMU_CALCTRL_DOWNSEL_PRS;
   \                     ??CMU_CalibrateConfig_3: (+1)
   \       0x2C   0xF040 0x5000      ORR      R0,R0,#0x20000000
    841                break;
   \       0x30   0xE013             B.N      ??CMU_CalibrateConfig_1
    842          
    843              case cmuSelect_HFXO:
    844                calCtrl |= CMU_CALCTRL_DOWNSEL_HFXO;
   \                     ??CMU_CalibrateConfig_4: (+1)
   \       0x32   0xF040 0x5040      ORR      R0,R0,#0x30000000
    845                break;
   \       0x36   0xE010             B.N      ??CMU_CalibrateConfig_1
    846          
    847              case cmuSelect_LFXO:
    848                calCtrl |= CMU_CALCTRL_DOWNSEL_LFXO;
   \                     ??CMU_CalibrateConfig_5: (+1)
   \       0x38   0xF040 0x4080      ORR      R0,R0,#0x40000000
    849                break;
   \       0x3C   0xE00D             B.N      ??CMU_CalibrateConfig_1
    850          
    851              case cmuSelect_HFRCODPLL:
    852                calCtrl |= CMU_CALCTRL_DOWNSEL_HFRCODPLL;
   \                     ??CMU_CalibrateConfig_6: (+1)
   \       0x3E   0xF040 0x40A0      ORR      R0,R0,#0x50000000
    853                break;
   \       0x42   0xE00A             B.N      ??CMU_CalibrateConfig_1
    854          
    855          #if defined(HFRCOEM23_PRESENT)
    856              case cmuSelect_HFRCOEM23:
    857                calCtrl |= CMU_CALCTRL_DOWNSEL_HFRCOEM23;
   \                     ??CMU_CalibrateConfig_7: (+1)
   \       0x44   0xF040 0x40C0      ORR      R0,R0,#0x60000000
    858                break;
   \       0x48   0xE007             B.N      ??CMU_CalibrateConfig_1
    859          #endif
    860          
    861              case cmuSelect_FSRCO:
    862                calCtrl |= CMU_CALCTRL_DOWNSEL_FSRCO;
   \                     ??CMU_CalibrateConfig_8: (+1)
   \       0x4A   0xF040 0x4010      ORR      R0,R0,#0x90000000
    863                break;
   \       0x4E   0xE004             B.N      ??CMU_CalibrateConfig_1
    864          
    865              case cmuSelect_LFRCO:
    866                calCtrl |= CMU_CALCTRL_DOWNSEL_LFRCO;
   \                     ??CMU_CalibrateConfig_9: (+1)
   \       0x50   0xF040 0x4020      ORR      R0,R0,#0xA0000000
    867                break;
   \       0x54   0xE001             B.N      ??CMU_CalibrateConfig_1
    868          
    869              case cmuSelect_ULFRCO:
    870                calCtrl |= CMU_CALCTRL_DOWNSEL_ULFRCO;
   \                     ??CMU_CalibrateConfig_10: (+1)
   \       0x56   0xF040 0x4030      ORR      R0,R0,#0xB0000000
    871                break;
    872          
    873              case cmuSelect_Disabled:
    874                break;
    875          
    876              default:
    877                EFM_ASSERT(false);
    878                break;
    879            }
    880          
    881            // Set up counting clock source selector
    882            switch (upSel) {
   \                     ??CMU_CalibrateConfig_1: (+1)
   \       0x5A   0x2A02             CMP      R2,#+2
   \       0x5C   0xD01C             BEQ.N    ??CMU_CalibrateConfig_11
   \       0x5E   0x2A03             CMP      R2,#+3
   \       0x60   0xD00E             BEQ.N    ??CMU_CalibrateConfig_12
   \       0x62   0x2A04             CMP      R2,#+4
   \       0x64   0xD012             BEQ.N    ??CMU_CalibrateConfig_13
   \       0x66   0x2A05             CMP      R2,#+5
   \       0x68   0xD013             BEQ.N    ??CMU_CalibrateConfig_14
   \       0x6A   0x2A07             CMP      R2,#+7
   \       0x6C   0xD00B             BEQ.N    ??CMU_CalibrateConfig_15
   \       0x6E   0x2A08             CMP      R2,#+8
   \       0x70   0xD015             BEQ.N    ??CMU_CalibrateConfig_16
   \       0x72   0x2A09             CMP      R2,#+9
   \       0x74   0xD016             BEQ.N    ??CMU_CalibrateConfig_17
   \       0x76   0x2A0F             CMP      R2,#+15
   \       0x78   0xD116             BNE.N    ??CMU_CalibrateConfig_18
    883              case cmuSelect_PRS:
    884                calCtrl |= CMU_CALCTRL_UPSEL_PRS;
   \       0x7A   0xF040 0x7080      ORR      R0,R0,#0x1000000
    885                break;
   \       0x7E   0xE013             B.N      ??CMU_CalibrateConfig_18
    886          
    887              case cmuSelect_HFXO:
    888                calCtrl |= CMU_CALCTRL_UPSEL_HFXO;
   \                     ??CMU_CalibrateConfig_12: (+1)
   \       0x80   0xF040 0x7000      ORR      R0,R0,#0x2000000
    889                break;
   \       0x84   0xE010             B.N      ??CMU_CalibrateConfig_18
    890          
    891              case cmuSelect_LFXO:
    892                calCtrl |= CMU_CALCTRL_UPSEL_LFXO;
   \                     ??CMU_CalibrateConfig_15: (+1)
   \       0x86   0xF040 0x7040      ORR      R0,R0,#0x3000000
    893                break;
   \       0x8A   0xE00D             B.N      ??CMU_CalibrateConfig_18
    894          
    895              case cmuSelect_HFRCODPLL:
    896                calCtrl |= CMU_CALCTRL_UPSEL_HFRCODPLL;
   \                     ??CMU_CalibrateConfig_13: (+1)
   \       0x8C   0xF040 0x6080      ORR      R0,R0,#0x4000000
    897                break;
   \       0x90   0xE00A             B.N      ??CMU_CalibrateConfig_18
    898          
    899          #if defined(HFRCOEM23_PRESENT)
    900              case cmuSelect_HFRCOEM23:
    901                calCtrl |= CMU_CALCTRL_UPSEL_HFRCOEM23;
   \                     ??CMU_CalibrateConfig_14: (+1)
   \       0x92   0xF040 0x60A0      ORR      R0,R0,#0x5000000
    902                break;
   \       0x96   0xE007             B.N      ??CMU_CalibrateConfig_18
    903          #endif
    904          
    905              case cmuSelect_FSRCO:
    906                calCtrl |= CMU_CALCTRL_UPSEL_FSRCO;
   \                     ??CMU_CalibrateConfig_11: (+1)
   \       0x98   0xF040 0x6000      ORR      R0,R0,#0x8000000
    907                break;
   \       0x9C   0xE004             B.N      ??CMU_CalibrateConfig_18
    908          
    909              case cmuSelect_LFRCO:
    910                calCtrl |= CMU_CALCTRL_UPSEL_LFRCO;
   \                     ??CMU_CalibrateConfig_16: (+1)
   \       0x9E   0xF040 0x6010      ORR      R0,R0,#0x9000000
    911                break;
   \       0xA2   0xE001             B.N      ??CMU_CalibrateConfig_18
    912          
    913              case cmuSelect_ULFRCO:
    914                calCtrl |= CMU_CALCTRL_UPSEL_ULFRCO;
   \                     ??CMU_CalibrateConfig_17: (+1)
   \       0xA4   0xF040 0x6020      ORR      R0,R0,#0xA000000
    915                break;
    916          
    917              case cmuSelect_Disabled:
    918                break;
    919          
    920              default:
    921                EFM_ASSERT(false);
    922                break;
    923            }
    924          
    925            CMU->CALCTRL = calCtrl;
   \                     ??CMU_CalibrateConfig_18: (+1)
   \       0xA8   0x6018             STR      R0,[R3, #+0]
    926          }
   \       0xAA   0xBD10             POP      {R4,PC}          ;; return
    927          
    928          /***************************************************************************//**
    929           * @brief
    930           *    Get calibration count value.
    931           *
    932           * @note
    933           *    If continuous calibrartion mode is active, calibration busy will almost
    934           *    always be off, and we just need to read the value, where the normal case
    935           *    would be that this function call has been triggered by the CALRDY
    936           *    interrupt flag.
    937           *
    938           * @return
    939           *    Calibration count, the number of UPSEL clocks (see @ref CMU_CalibrateConfig())
    940           *    in the period of DOWNSEL oscillator clock cycles configured by a previous
    941           *    write operation to CMU->CALCNT.
    942           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    943          uint32_t CMU_CalibrateCountGet(void)
    944          {
    945            // Wait until calibration completes, UNLESS continuous calibration mode is on
    946            if ((CMU->CALCTRL & CMU_CALCTRL_CONT) == 0UL) {
   \                     CMU_CalibrateCountGet: (+1)
   \        0x0   0x....'....        LDR.W    R0,??DataTable27_3  ;; 0x40008008
   \        0x4   0x6CC1             LDR      R1,[R0, #+76]
   \        0x6   0x020A             LSLS     R2,R1,#+8
   \        0x8   0xD402             BMI.N    ??CMU_CalibrateCountGet_0
    947              // Wait until calibration completes
    948              while ((CMU->STATUS & CMU_STATUS_CALRDY) == 0UL) {
   \                     ??CMU_CalibrateCountGet_1: (+1)
   \        0xA   0x6801             LDR      R1,[R0, #+0]
   \        0xC   0x07CA             LSLS     R2,R1,#+31
   \        0xE   0xD5FC             BPL.N    ??CMU_CalibrateCountGet_1
    949              }
    950            }
    951            return CMU->CALCNT;
   \                     ??CMU_CalibrateCountGet_0: (+1)
   \       0x10   0x6D00             LDR      R0,[R0, #+80]
   \       0x12   0x4770             BX       LR               ;; return
    952          }
    953          
    954          /***************************************************************************//**
    955           * @brief
    956           *    Direct a clock to a GPIO pin.
    957           *
    958           * @param[in] clkNo
    959           *   Selects between CLKOUT0, CLKOUT1 or CLKOUT2 outputs. Use values 0,1or 2.
    960           *
    961           * @param[in] sel
    962           *   Select clock source.
    963           *
    964           * @param[in] clkDiv
    965           *   Select a clock divisor (1..32). Only applicable when cmuSelect_EXPCLK is
    966           *   slexted as clock source.
    967           *
    968           * @param[in] port
    969           *   GPIO port.
    970           *
    971           * @param[in] pin
    972           *   GPIO pin.
    973           *
    974           * @note
    975           *    Refer to the reference manual and the datasheet for details on which
    976           *    GPIO port/pins that are available.
    977           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    978          void CMU_ClkOutPinConfig(uint32_t           clkNo,
    979                                   CMU_Select_TypeDef sel,
    980                                   CMU_ClkDiv_TypeDef clkDiv,
    981                                   GPIO_Port_TypeDef  port,
    982                                   unsigned int       pin)
    983          {
   \                     CMU_ClkOutPinConfig: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0x461C             MOV      R4,R3
    984            uint32_t tmp = 0U, mask;
   \        0x4   0x2300             MOVS     R3,#+0
    985          
    986            EFM_ASSERT(clkNo <= 2U);
    987            EFM_ASSERT(clkDiv <= 32U);
    988            EFM_ASSERT(port <= 3U);
    989            EFM_ASSERT(pin <= 15U);
    990          
    991            switch (sel) {
   \        0x6   0x1E8D             SUBS     R5,R1,#+2
   \        0x8   0x2D0C             CMP      R5,#+12
   \        0xA   0xD819             BHI.N    ??CMU_ClkOutPinConfig_1
   \        0xC   0xE8DF 0xF005      TBB      [PC, R5]
   \                     ??CMU_ClkOutPinConfig_0:
   \       0x10   0x07 0x09          DC8      0x7,0x9,0xB,0xD
   \              0x0B 0x0D    
   \       0x14   0x18 0x11          DC8      0x18,0x11,0x13,0x15
   \              0x13 0x15    
   \       0x18   0x18 0x17          DC8      0x18,0x17,0x18,0x18
   \              0x18 0x18    
   \       0x1C   0x0F 0x00          DC8      0xF,0x0
    992              case cmuSelect_Disabled:
    993                tmp = CMU_EXPORTCLKCTRL_CLKOUTSEL0_DISABLED;
    994                break;
    995          
    996              case cmuSelect_FSRCO:
    997                tmp = CMU_EXPORTCLKCTRL_CLKOUTSEL0_FSRCO;
   \                     ??CMU_ClkOutPinConfig_2: (+1)
   \       0x1E   0x2309             MOVS     R3,#+9
    998                break;
   \       0x20   0xE00E             B.N      ??CMU_ClkOutPinConfig_1
    999          
   1000              case cmuSelect_HFXO:
   1001                tmp = CMU_EXPORTCLKCTRL_CLKOUTSEL0_HFXO;
   \                     ??CMU_ClkOutPinConfig_3: (+1)
   \       0x22   0x2308             MOVS     R3,#+8
   1002                break;
   \       0x24   0xE00C             B.N      ??CMU_ClkOutPinConfig_1
   1003          
   1004              case cmuSelect_HFRCODPLL:
   1005                tmp = CMU_EXPORTCLKCTRL_CLKOUTSEL0_HFRCODPLL;
   \                     ??CMU_ClkOutPinConfig_4: (+1)
   \       0x26   0x2306             MOVS     R3,#+6
   1006                break;
   \       0x28   0xE00A             B.N      ??CMU_ClkOutPinConfig_1
   1007          
   1008          #if defined(HFRCOEM23_PRESENT)
   1009              case cmuSelect_HFRCOEM23:
   1010                tmp = CMU_EXPORTCLKCTRL_CLKOUTSEL0_HFRCOEM23;
   \                     ??CMU_ClkOutPinConfig_5: (+1)
   \       0x2A   0x2307             MOVS     R3,#+7
   1011                break;
   \       0x2C   0xE008             B.N      ??CMU_ClkOutPinConfig_1
   1012          #endif
   1013          
   1014              case cmuSelect_EXPCLK:
   1015                tmp  = CMU_EXPORTCLKCTRL_CLKOUTSEL0_HFEXPCLK;
   \                     ??CMU_ClkOutPinConfig_6: (+1)
   \       0x2E   0x2302             MOVS     R3,#+2
   1016                break;
   \       0x30   0xE006             B.N      ??CMU_ClkOutPinConfig_1
   1017          
   1018              case cmuSelect_LFXO:
   1019                tmp = CMU_EXPORTCLKCTRL_CLKOUTSEL0_LFXO;
   \                     ??CMU_ClkOutPinConfig_7: (+1)
   \       0x32   0x2305             MOVS     R3,#+5
   1020                break;
   \       0x34   0xE004             B.N      ??CMU_ClkOutPinConfig_1
   1021          
   1022              case cmuSelect_LFRCO:
   1023                tmp = CMU_EXPORTCLKCTRL_CLKOUTSEL0_LFRCO;
   \                     ??CMU_ClkOutPinConfig_8: (+1)
   \       0x36   0x2304             MOVS     R3,#+4
   1024                break;
   \       0x38   0xE002             B.N      ??CMU_ClkOutPinConfig_1
   1025          
   1026              case cmuSelect_ULFRCO:
   1027                tmp = CMU_EXPORTCLKCTRL_CLKOUTSEL0_ULFRCO;
   \                     ??CMU_ClkOutPinConfig_9: (+1)
   \       0x3A   0x2303             MOVS     R3,#+3
   1028                break;
   \       0x3C   0xE000             B.N      ??CMU_ClkOutPinConfig_1
   1029          
   1030              case cmuSelect_HCLK:
   1031                tmp = CMU_EXPORTCLKCTRL_CLKOUTSEL0_HCLK;
   \                     ??CMU_ClkOutPinConfig_10: (+1)
   \       0x3E   0x2301             MOVS     R3,#+1
   1032                break;
   1033          
   1034              default:
   1035                EFM_ASSERT(false);
   1036                break;
   1037            }
   1038          
   1039            mask  = _CMU_EXPORTCLKCTRL_CLKOUTSEL0_MASK
   1040                    << (clkNo * _CMU_EXPORTCLKCTRL_CLKOUTSEL1_SHIFT);
   \                     ??CMU_ClkOutPinConfig_1: (+1)
   \       0x40   0x00C6             LSLS     R6,R0,#+3
   \       0x42   0x250F             MOVS     R5,#+15
   \       0x44   0x40B5             LSLS     R5,R5,R6
   1041            tmp <<= clkNo * _CMU_EXPORTCLKCTRL_CLKOUTSEL1_SHIFT;
   \       0x46   0x40B3             LSLS     R3,R3,R6
   1042          
   1043            if (sel == cmuSelect_EXPCLK) {
   \       0x48   0x290E             CMP      R1,#+14
   \       0x4A   0xD104             BNE.N    ??CMU_ClkOutPinConfig_11
   1044              tmp  |= (clkDiv - 1U) << _CMU_EXPORTCLKCTRL_PRESC_SHIFT;
   \       0x4C   0x1E52             SUBS     R2,R2,#+1
   \       0x4E   0xEA43 0x6302      ORR      R3,R3,R2, LSL #+24
   1045              mask |= _CMU_EXPORTCLKCTRL_PRESC_MASK;
   \       0x52   0xF045 0x55F8      ORR      R5,R5,#0x1F000000
   1046            }
   1047          
   1048            CMU->EXPORTCLKCTRL = (CMU->EXPORTCLKCTRL & ~mask) | tmp;
   \                     ??CMU_ClkOutPinConfig_11: (+1)
   \       0x56   0x....'....        LDR.W    R2,??DataTable27_4  ;; 0x40008090
   \       0x5A   0x6816             LDR      R6,[R2, #+0]
   \       0x5C   0xEA26 0x0505      BIC      R5,R6,R5
   \       0x60   0x432B             ORRS     R3,R3,R5
   \       0x62   0x6013             STR      R3,[R2, #+0]
   1049          
   1050            if (sel == cmuSelect_Disabled) {
   \       0x64   0x2201             MOVS     R2,#+1
   \       0x66   0x4082             LSLS     R2,R2,R0
   \       0x68   0x9D04             LDR      R5,[SP, #+16]
   \       0x6A   0x2901             CMP      R1,#+1
   \       0x6C   0xD105             BNE.N    ??CMU_ClkOutPinConfig_12
   1051              GPIO->CMUROUTE_CLR.ROUTEEN = GPIO_CMU_ROUTEEN_CLKOUT0PEN << clkNo;
   \       0x6E   0x....'....        LDR.W    R6,??DataTable27_5  ;; 0x4003e468
   \       0x72   0x6032             STR      R2,[R6, #+0]
   1052              GPIO_PinModeSet(port, pin, gpioModeDisabled, 0);
   \       0x74   0x2300             MOVS     R3,#+0
   \       0x76   0x2200             MOVS     R2,#+0
   \       0x78   0xE00F             B.N      ??CMU_ClkOutPinConfig_13
   1053            } else {
   1054              GPIO->CMUROUTE_SET.ROUTEEN = GPIO_CMU_ROUTEEN_CLKOUT0PEN << clkNo;
   \                     ??CMU_ClkOutPinConfig_12: (+1)
   \       0x7A   0x....'....        LDR.W    R3,??DataTable27_6  ;; 0x4003d468
   \       0x7E   0x601A             STR      R2,[R3, #+0]
   1055              if (clkNo == 0U) {
   \       0x80   0xEA44 0x4105      ORR      R1,R4,R5, LSL #+16
   \       0x84   0x....'....        LDR.W    R2,??DataTable27_7  ;; 0x4003c470
   \       0x88   0xB908             CBNZ.N   R0,??CMU_ClkOutPinConfig_14
   1056                GPIO->CMUROUTE.CLKOUT0ROUTE = (port << _GPIO_CMU_CLKOUT0ROUTE_PORT_SHIFT)
   1057                                              | (pin << _GPIO_CMU_CLKOUT0ROUTE_PIN_SHIFT);
   \       0x8A   0x6011             STR      R1,[R2, #+0]
   \       0x8C   0xE003             B.N      ??CMU_ClkOutPinConfig_15
   1058              } else if (clkNo == 1) {
   \                     ??CMU_ClkOutPinConfig_14: (+1)
   \       0x8E   0x2801             CMP      R0,#+1
   \       0x90   0xBF0C             ITE      EQ 
   \       0x92   0x6051             STREQ    R1,[R2, #+4]
   \       0x94   0x6091             STRNE    R1,[R2, #+8]
   1059                GPIO->CMUROUTE.CLKOUT1ROUTE = (port << _GPIO_CMU_CLKOUT1ROUTE_PORT_SHIFT)
   1060                                              | (pin << _GPIO_CMU_CLKOUT1ROUTE_PIN_SHIFT);
   1061              } else {
   1062                GPIO->CMUROUTE.CLKOUT2ROUTE = (port << _GPIO_CMU_CLKOUT2ROUTE_PORT_SHIFT)
   1063                                              | (pin << _GPIO_CMU_CLKOUT2ROUTE_PIN_SHIFT);
   1064              }
   1065              GPIO_PinModeSet(port, pin, gpioModePushPull, 0);
   \                     ??CMU_ClkOutPinConfig_15: (+1)
   \       0x96   0x2300             MOVS     R3,#+0
   \       0x98   0x2204             MOVS     R2,#+4
   \                     ??CMU_ClkOutPinConfig_13: (+1)
   \       0x9A   0x4629             MOV      R1,R5
   \       0x9C   0x4620             MOV      R0,R4
   \       0x9E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \       0xA2   0x....'....        B.W      GPIO_PinModeSet
   1066            }
   1067          }
   1068          
   1069          /***************************************************************************//**
   1070           * @brief
   1071           *   Get clock divisor.
   1072           *
   1073           * @param[in] clock
   1074           *   Clock point to get divisor for. Notice that not all clock points
   1075           *   have a divisors. Please refer to CMU overview in reference manual.
   1076           *
   1077           * @return
   1078           *   The current clock point divisor. 1 is returned
   1079           *   if @p clock specifies a clock point without divisor.
   1080           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1081          CMU_ClkDiv_TypeDef CMU_ClockDivGet(CMU_Clock_TypeDef clock)
   1082          {
   \                     CMU_ClockDivGet: (+1)
   \        0x0   0x4601             MOV      R1,R0
   1083            uint32_t ret = 0U;
   \        0x2   0x2000             MOVS     R0,#+0
   1084          
   1085            switch (clock) {
   \        0x4   0x....'....        LDR.W    R2,??DataTable27_8  ;; 0x40008070
   \        0x8   0x2901             CMP      R1,#+1
   \        0xA   0xD005             BEQ.N    ??CMU_ClockDivGet_0
   \        0xC   0x2902             CMP      R1,#+2
   \        0xE   0xD007             BEQ.N    ??CMU_ClockDivGet_1
   \       0x10   0x2903             CMP      R1,#+3
   \       0x12   0xD009             BEQ.N    ??CMU_ClockDivGet_2
   \       0x14   0x290E             CMP      R1,#+14
   \       0x16   0xD10A             BNE.N    ??CMU_ClockDivGet_3
   1086              case cmuClock_HCLK:
   1087              case cmuClock_CORE:
   1088                ret = (CMU->SYSCLKCTRL & _CMU_SYSCLKCTRL_HCLKPRESC_MASK)
   1089                      >> _CMU_SYSCLKCTRL_HCLKPRESC_SHIFT;
   \                     ??CMU_ClockDivGet_0: (+1)
   \       0x18   0x6810             LDR      R0,[R2, #+0]
   \       0x1A   0xF3C0 0x3001      UBFX     R0,R0,#+12,#+2
   1090          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_1)
   1091                if (ret == 2U ) {   // Unused value, illegal prescaler
   \       0x1E   0xE006             B.N      ??CMU_ClockDivGet_3
   1092                  EFM_ASSERT(false);
   1093                }
   1094          #elif defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
   1095                if (!((ret == _CMU_SYSCLKCTRL_HCLKPRESC_DIV1)
   1096                      || (ret == _CMU_SYSCLKCTRL_HCLKPRESC_DIV2)
   1097                      || (ret == _CMU_SYSCLKCTRL_HCLKPRESC_DIV4)
   1098                      || (ret == _CMU_SYSCLKCTRL_HCLKPRESC_DIV8)
   1099                      || (ret == _CMU_SYSCLKCTRL_HCLKPRESC_DIV16))) {
   1100                  // Illegal prescaler
   1101                  EFM_ASSERT(false);
   1102                }
   1103          #endif
   1104                break;
   1105          
   1106          #if defined(_CMU_TRACECLKCTRL_PRESC_MASK)
   1107              case cmuClock_TRACECLK:
   1108                ret = (CMU->TRACECLKCTRL & _CMU_TRACECLKCTRL_PRESC_MASK)
   1109                      >> _CMU_TRACECLKCTRL_PRESC_SHIFT;
   1110                if (!((ret == _CMU_TRACECLKCTRL_PRESC_DIV1)
   1111                      || (ret == _CMU_TRACECLKCTRL_PRESC_DIV2)
   1112                      || (ret == _CMU_TRACECLKCTRL_PRESC_DIV4))) {
   1113                  // Illegal prescaler
   1114                  EFM_ASSERT(false);
   1115                }
   1116                break;
   1117          #endif
   1118          
   1119              case cmuClock_EXPCLK:
   1120                ret = (CMU->EXPORTCLKCTRL & _CMU_EXPORTCLKCTRL_PRESC_MASK)
   1121                      >> _CMU_EXPORTCLKCTRL_PRESC_SHIFT;
   \                     ??CMU_ClockDivGet_1: (+1)
   \       0x20   0x6A10             LDR      R0,[R2, #+32]
   \       0x22   0xF3C0 0x6004      UBFX     R0,R0,#+24,#+5
   1122                break;
   \       0x26   0xE002             B.N      ??CMU_ClockDivGet_3
   1123          
   1124              case cmuClock_PCLK:
   1125                ret = (CMU->SYSCLKCTRL & _CMU_SYSCLKCTRL_PCLKPRESC_MASK)
   1126                      >> _CMU_SYSCLKCTRL_PCLKPRESC_SHIFT;
   \                     ??CMU_ClockDivGet_2: (+1)
   \       0x28   0x6810             LDR      R0,[R2, #+0]
   \       0x2A   0xF3C0 0x2080      UBFX     R0,R0,#+10,#+1
   1127                break;
   1128          
   1129              default:
   1130                break;
   1131            }
   1132            return 1U + ret;
   \                     ??CMU_ClockDivGet_3: (+1)
   \       0x2E   0x1C40             ADDS     R0,R0,#+1
   \       0x30   0x4770             BX       LR               ;; return
   1133          }
   1134          
   1135          /***************************************************************************//**
   1136           * @brief
   1137           *   Set clock divisor.
   1138           *
   1139           * @param[in] clock
   1140           *   Clock point to set divisor for. Notice that not all clock points
   1141           *   have a divisor, please refer to CMU overview in the reference
   1142           *   manual.
   1143           *
   1144           * @param[in] div
   1145           *   The clock divisor to use.
   1146           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1147          void CMU_ClockDivSet(CMU_Clock_TypeDef clock, CMU_ClkDiv_TypeDef div)
   1148          {
   \                     CMU_ClockDivSet: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   1149            switch (clock) {
   \        0x2   0x1E4C             SUBS     R4,R1,#+1
   \        0x4   0x....'....        LDR.W    R5,??DataTable27_8  ;; 0x40008070
   \        0x8   0x2801             CMP      R0,#+1
   \        0xA   0xD005             BEQ.N    ??CMU_ClockDivSet_0
   \        0xC   0x2802             CMP      R0,#+2
   \        0xE   0xD00E             BEQ.N    ??CMU_ClockDivSet_1
   \       0x10   0x2803             CMP      R0,#+3
   \       0x12   0xD013             BEQ.N    ??CMU_ClockDivSet_2
   \       0x14   0x280E             CMP      R0,#+14
   \       0x16   0xD117             BNE.N    ??CMU_ClockDivSet_3
   1150              case cmuClock_HCLK:
   1151              case cmuClock_CORE:
   1152          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_1)
   1153                EFM_ASSERT((div == 1U) || (div == 2U) || (div == 4U));
   1154          #elif defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
   1155                EFM_ASSERT((div == 1U) || (div == 2U) || (div == 4U)
   1156                           || (div == 8U) || (div == 16U));
   1157          #endif
   1158          
   1159                // Set max wait-states and PCLK divisor while changing core clock
   1160                waitStateMax();
   \                     ??CMU_ClockDivSet_0: (+1)
   \       0x18   0x....'....        BL       waitStateMax
   1161                pclkDivMax();
   \       0x1C   0x....'....        BL       pclkDivMax
   1162          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
   1163                // Set largest prescaler for radio clock tree
   1164                rhclkPrescMax();
   1165          #endif
   1166          
   1167                // Set new divisor
   1168                CMU->SYSCLKCTRL = (CMU->SYSCLKCTRL & ~_CMU_SYSCLKCTRL_HCLKPRESC_MASK)
   1169                                  | ((div - 1U) << _CMU_SYSCLKCTRL_HCLKPRESC_SHIFT);
   \       0x20   0x6828             LDR      R0,[R5, #+0]
   \       0x22   0xF420 0x5040      BIC      R0,R0,#0x3000
   \       0x26   0xEA40 0x3004      ORR      R0,R0,R4, LSL #+12
   \       0x2A   0x6028             STR      R0,[R5, #+0]
   1170          
   1171                // Update CMSIS core clock variable and set optimum wait-states
   1172                CMU_UpdateWaitStates(SystemCoreClockGet(), 0);
   \       0x2C   0x....             B.N      ?Subroutine1
   1173          
   1174                // Set optimal PCLK divisor
   1175                pclkDivOptimize();
   1176          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
   1177                // Set optimal RHCLK prescaler
   1178                rhclkPrescOptimize();
   1179          #endif
   1180                break;
   1181          
   1182          #if defined(_CMU_TRACECLKCTRL_PRESC_MASK)
   1183              case cmuClock_TRACECLK:
   1184                EFM_ASSERT((div == 1U) || (div == 2U) || (div == 4U));
   1185                CMU->TRACECLKCTRL = (CMU->TRACECLKCTRL & ~_CMU_TRACECLKCTRL_PRESC_MASK)
   1186                                    | ((div - 1U) << _CMU_TRACECLKCTRL_PRESC_SHIFT);
   1187                break;
   1188          #endif
   1189          
   1190              case cmuClock_EXPCLK:
   1191                EFM_ASSERT((div >= 1U) && (div <= 32U));
   1192                CMU->EXPORTCLKCTRL = (CMU->EXPORTCLKCTRL & ~_CMU_EXPORTCLKCTRL_PRESC_MASK)
   1193                                     | ((div - 1U) << _CMU_EXPORTCLKCTRL_PRESC_SHIFT);
   \                     ??CMU_ClockDivSet_1: (+1)
   \       0x2E   0x6A28             LDR      R0,[R5, #+32]
   \       0x30   0xF020 0x50F8      BIC      R0,R0,#0x1F000000
   \       0x34   0xEA40 0x6004      ORR      R0,R0,R4, LSL #+24
   \       0x38   0x6228             STR      R0,[R5, #+32]
   1194                break;
   \       0x3A   0xBD31             POP      {R0,R4,R5,PC}
   1195          
   1196              case cmuClock_PCLK:
   1197                EFM_ASSERT((div == 1U) || (div == 2U));
   1198                CMU->SYSCLKCTRL = (CMU->SYSCLKCTRL & ~_CMU_SYSCLKCTRL_PCLKPRESC_MASK)
   1199                                  | ((div - 1U) << _CMU_SYSCLKCTRL_PCLKPRESC_SHIFT);
   \                     ??CMU_ClockDivSet_2: (+1)
   \       0x3C   0x6828             LDR      R0,[R5, #+0]
   \       0x3E   0xF420 0x6080      BIC      R0,R0,#0x400
   \       0x42   0xEA40 0x2084      ORR      R0,R0,R4, LSL #+10
   \       0x46   0x6028             STR      R0,[R5, #+0]
   1200                break;
   1201          
   1202              default:
   1203                EFM_ASSERT(false);
   1204                break;
   1205            }
   1206          }
   \                     ??CMU_ClockDivSet_3: (+1)
   \       0x48   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x....'....        BL       SystemCoreClockGet
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x....'....        BL       CMU_UpdateWaitStates
   \        0xA   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \        0xE   0x....             B.N      pclkDivOptimize
   1207          
   1208          /***************************************************************************//**
   1209           * @brief
   1210           *   Get currently selected reference clock used for a clock branch.
   1211           *
   1212           * @param[in] clock
   1213           *   Clock branch to fetch selected ref. clock for.
   1214           *
   1215           * @return
   1216           *   Reference clock used for clocking selected branch, #cmuSelect_Error if
   1217           *   invalid @p clock provided.
   1218           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1219          CMU_Select_TypeDef CMU_ClockSelectGet(CMU_Clock_TypeDef clock)
   1220          {
   \                     CMU_ClockSelectGet: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   1221            CMU_Select_TypeDef ret = cmuSelect_Error;
   \        0x2   0x2100             MOVS     R1,#+0
   \        0x4   0xF88D 0x1000      STRB     R1,[SP, #+0]
   1222          
   1223            switch (clock) {
   \        0x8   0x2824             CMP      R0,#+36
   \        0xA   0xD858             BHI.N    ??CMU_ClockSelectGet_2
   \        0xC   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??CMU_ClockSelectGet_0:
   \       0x10   0x13 0x57          DC8      0x13,0x57,0x57,0x57
   \              0x57 0x57    
   \       0x14   0x57 0x2B          DC8      0x57,0x2B,0x30,0x35
   \              0x30 0x35    
   \       0x18   0x3A 0x3F          DC8      0x3A,0x3F,0x44,0x49
   \              0x44 0x49    
   \       0x1C   0x4E 0x53          DC8      0x4E,0x53,0x57,0x35
   \              0x57 0x35    
   \       0x20   0x57 0x57          DC8      0x57,0x57,0x3A,0x57
   \              0x3A 0x57    
   \       0x24   0x57 0x57          DC8      0x57,0x57,0x57,0x2B
   \              0x57 0x2B    
   \       0x28   0x57 0x35          DC8      0x57,0x35,0x57,0x53
   \              0x57 0x53    
   \       0x2C   0x30 0x30          DC8      0x30,0x30,0x30,0x30
   \              0x30 0x30    
   \       0x30   0x57 0x57          DC8      0x57,0x57,0x57,0x3F
   \              0x57 0x3F    
   \       0x34   0x44 0x00          DC8      0x44,0x0
   1224          // -----------------------------------------------------------------------------
   1225              case cmuClock_SYSCLK:
   1226                switch (CMU->SYSCLKCTRL & _CMU_SYSCLKCTRL_CLKSEL_MASK) {
   \                     ??CMU_ClockSelectGet_3: (+1)
   \       0x36   0x....'....        LDR.W    R0,??DataTable27_8  ;; 0x40008070
   \       0x3A   0x6801             LDR      R1,[R0, #+0]
   \       0x3C   0xF001 0x0107      AND      R1,R1,#0x7
   \       0x40   0x1E49             SUBS     R1,R1,#+1
   \       0x42   0x2903             CMP      R1,#+3
   \       0x44   0xD83B             BHI.N    ??CMU_ClockSelectGet_2
   \       0x46   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??CMU_ClockSelectGet_1:
   \       0x4A   0x0A 0x02          DC8      0xA,0x2,0x4,0x6
   \              0x04 0x06    
   1227                  case _CMU_SYSCLKCTRL_CLKSEL_HFRCODPLL:
   1228                    ret = cmuSelect_HFRCODPLL;
   \                     ??CMU_ClockSelectGet_4: (+1)
   \       0x4E   0x2204             MOVS     R2,#+4
   \       0x50   0xE002             B.N      ??CMU_ClockSelectGet_5
   1229                    break;
   1230          
   1231                  case _CMU_SYSCLKCTRL_CLKSEL_HFXO:
   1232                    ret = cmuSelect_HFXO;
   \                     ??CMU_ClockSelectGet_6: (+1)
   \       0x52   0x2103             MOVS     R1,#+3
   \       0x54   0xE004             B.N      ??CMU_ClockSelectGet_7
   1233                    break;
   1234          
   1235                  case _CMU_SYSCLKCTRL_CLKSEL_CLKIN0:
   1236                    ret = cmuSelect_CLKIN0;
   \                     ??CMU_ClockSelectGet_8: (+1)
   \       0x56   0x2206             MOVS     R2,#+6
   \                     ??CMU_ClockSelectGet_5: (+1)
   \       0x58   0xF88D 0x2000      STRB     R2,[SP, #+0]
   1237                    break;
   \       0x5C   0xE02F             B.N      ??CMU_ClockSelectGet_2
   1238          
   1239                  case _CMU_SYSCLKCTRL_CLKSEL_FSRCO:
   1240                    ret = cmuSelect_FSRCO;
   \                     ??CMU_ClockSelectGet_9: (+1)
   \       0x5E   0x2102             MOVS     R1,#+2
   \                     ??CMU_ClockSelectGet_7: (+1)
   \       0x60   0xF88D 0x1000      STRB     R1,[SP, #+0]
   1241                    break;
   \       0x64   0xE02B             B.N      ??CMU_ClockSelectGet_2
   1242          
   1243                  default:
   1244                    ret = cmuSelect_Error;
   1245                    EFM_ASSERT(false);
   1246                    break;
   1247                }
   1248                break;
   1249          
   1250          // -----------------------------------------------------------------------------
   1251              case cmuClock_IADC0:
   1252              case cmuClock_IADCCLK:
   1253                iadcClkGet(NULL, &ret);
   \                     ??CMU_ClockSelectGet_10: (+1)
   \       0x66   0x4669             MOV      R1,SP
   \       0x68   0x2000             MOVS     R0,#+0
   \       0x6A   0x....'....        BL       iadcClkGet
   1254                break;
   \       0x6E   0xE026             B.N      ??CMU_ClockSelectGet_2
   1255          
   1256          // -----------------------------------------------------------------------------
   1257              case cmuClock_TIMER0:
   1258              case cmuClock_TIMER1:
   1259              case cmuClock_TIMER2:
   1260              case cmuClock_TIMER3:
   1261              case cmuClock_EM01GRPACLK:
   1262                em01GrpaClkGet(NULL, &ret);
   \                     ??CMU_ClockSelectGet_11: (+1)
   \       0x70   0x4669             MOV      R1,SP
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0x....'....        BL       em01GrpaClkGet
   1263                break;
   \       0x78   0xE021             B.N      ??CMU_ClockSelectGet_2
   1264          
   1265          // -----------------------------------------------------------------------------
   1266              case cmuClock_SYSTICK:
   1267              case cmuClock_LETIMER0:
   1268              case cmuClock_EM23GRPACLK:
   1269                em23GrpaClkGet(NULL, &ret);
   \                     ??CMU_ClockSelectGet_12: (+1)
   \       0x7A   0x4669             MOV      R1,SP
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0x....'....        BL       em23GrpaClkGet
   1270                break;
   \       0x82   0xE01C             B.N      ??CMU_ClockSelectGet_2
   1271          
   1272          // -----------------------------------------------------------------------------
   1273              case cmuClock_BURTC:
   1274              case cmuClock_EM4GRPACLK:
   1275                em4GrpaClkGet(NULL, &ret);
   \                     ??CMU_ClockSelectGet_13: (+1)
   \       0x84   0x4669             MOV      R1,SP
   \       0x86   0x2000             MOVS     R0,#+0
   \       0x88   0x....'....        BL       em4GrpaClkGet
   1276                break;
   \       0x8C   0xE017             B.N      ??CMU_ClockSelectGet_2
   1277          
   1278          #if defined(_CMU_EM01GRPBCLKCTRL_CLKSEL_MASK)
   1279          // -----------------------------------------------------------------------------
   1280              case cmuClock_PDMREF:
   1281              case cmuClock_EM01GRPBCLK:
   1282                em01GrpbClkGet(NULL, &ret);
   1283                break;
   1284          #endif
   1285          
   1286          // -----------------------------------------------------------------------------
   1287              case cmuClock_WDOG0:
   1288              case cmuClock_WDOG0CLK:
   1289                wdog0ClkGet(NULL, &ret);
   \                     ??CMU_ClockSelectGet_14: (+1)
   \       0x8E   0x4669             MOV      R1,SP
   \       0x90   0x2000             MOVS     R0,#+0
   \       0x92   0x....'....        BL       wdog0ClkGet
   1290                break;
   \       0x96   0xE012             B.N      ??CMU_ClockSelectGet_2
   1291          
   1292          #if defined(_CMU_WDOG1CLKCTRL_CLKSEL_MASK)
   1293          // -----------------------------------------------------------------------------
   1294              case cmuClock_WDOG1:
   1295              case cmuClock_WDOG1CLK:
   1296                wdog1ClkGet(NULL, &ret);
   \                     ??CMU_ClockSelectGet_15: (+1)
   \       0x98   0x4669             MOV      R1,SP
   \       0x9A   0x2000             MOVS     R0,#+0
   \       0x9C   0x....'....        BL       wdog1ClkGet
   1297                break;
   \       0xA0   0xE00D             B.N      ??CMU_ClockSelectGet_2
   1298          #endif
   1299          
   1300          // -----------------------------------------------------------------------------
   1301              case cmuClock_DPLLREFCLK:
   1302                dpllRefClkGet(NULL, &ret);
   \                     ??CMU_ClockSelectGet_16: (+1)
   \       0xA2   0x4669             MOV      R1,SP
   \       0xA4   0x2000             MOVS     R0,#+0
   \       0xA6   0x....'....        BL       dpllRefClkGet
   1303                break;
   \       0xAA   0xE008             B.N      ??CMU_ClockSelectGet_2
   1304          
   1305          #if defined(_CMU_TRACECLKCTRL_CLKSEL_MASK)
   1306          // -----------------------------------------------------------------------------
   1307              case cmuClock_TRACECLK:
   1308                traceClkGet(NULL, &ret);
   \                     ??CMU_ClockSelectGet_17: (+1)
   \       0xAC   0x4669             MOV      R1,SP
   \       0xAE   0x2000             MOVS     R0,#+0
   \       0xB0   0x....'....        BL       traceClkGet
   1309                break;
   \       0xB4   0xE003             B.N      ??CMU_ClockSelectGet_2
   1310          #endif
   1311          
   1312          #if defined(_CMU_EUART0CLKCTRL_CLKSEL_MASK)
   1313          // -----------------------------------------------------------------------------
   1314              case cmuClock_EUART0:
   1315              case cmuClock_EUART0CLK:
   1316                euart0ClkGet(NULL, &ret);
   1317                break;
   1318          #endif
   1319          
   1320          // -----------------------------------------------------------------------------
   1321              case cmuClock_RTCC:
   1322              case cmuClock_RTCCCLK:
   1323                rtccClkGet(NULL, &ret);
   \                     ??CMU_ClockSelectGet_18: (+1)
   \       0xB6   0x4669             MOV      R1,SP
   \       0xB8   0x2000             MOVS     R0,#+0
   \       0xBA   0x....'....        BL       rtccClkGet
   1324                break;
   1325          
   1326          // -----------------------------------------------------------------------------
   1327              default:
   1328                EFM_ASSERT(false);
   1329                break;
   1330            }
   1331            return ret;
   \                     ??CMU_ClockSelectGet_2: (+1)
   \       0xBE   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \       0xC2   0xBD02             POP      {R1,PC}          ;; return
   1332          }
   1333          
   1334          /***************************************************************************//**
   1335           * @brief
   1336           *   Select reference clock/oscillator used for a clock branch.
   1337           *
   1338           * @param[in] clock
   1339           *   Clock branch to select reference clock for.
   1340           *
   1341           * @param[in] ref
   1342           *   Reference selected for clocking, please refer to reference manual for
   1343           *   for details on which reference is available for a specific clock branch.
   1344           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   1345          void CMU_ClockSelectSet(CMU_Clock_TypeDef clock, CMU_Select_TypeDef ref)
   1346          {
   \                     CMU_ClockSelectSet: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   1347            uint32_t tmp = 0U;
   \        0x2   0x2500             MOVS     R5,#+0
   1348            bool oscForceEnStatus = false;
   \        0x4   0x2600             MOVS     R6,#+0
   \        0x6   0x460C             MOV      R4,R1
   1349          
   1350            switch (clock) {
   \        0x8   0x....'....        LDR.W    R7,??DataTable27_8  ;; 0x40008070
   \        0xC   0x....'....        LDR.W    R2,??DataTable27_9  ;; 0x40008200
   \       0x10   0x....'....        LDR.W    R3,??DataTable27_10  ;; 0x40008100
   \       0x14   0x2824             CMP      R0,#+36
   \       0x16   0xD844             BHI.N    ??CMU_ClockSelectSet_2
   \       0x18   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??CMU_ClockSelectSet_0:
   \       0x1C   0x13 0xC2          DC8      0x13,0xC2,0xC2,0xC2
   \              0xC2 0xC2    
   \       0x20   0xC2 0x44          DC8      0xC2,0x44,0x57,0x6A
   \              0x57 0x6A    
   \       0x24   0x71 0x78          DC8      0x71,0x78,0x8C,0xA0
   \              0x8C 0xA0    
   \       0x28   0xB0 0xBC          DC8      0xB0,0xBC,0xC2,0x6A
   \              0xC2 0x6A    
   \       0x2C   0xC2 0xC2          DC8      0xC2,0xC2,0x71,0xC2
   \              0x71 0xC2    
   \       0x30   0xC2 0xC2          DC8      0xC2,0xC2,0xC2,0x44
   \              0xC2 0x44    
   \       0x34   0xC2 0x6A          DC8      0xC2,0x6A,0xC2,0xBC
   \              0xC2 0xBC    
   \       0x38   0x57 0x57          DC8      0x57,0x57,0x57,0x57
   \              0x57 0x57    
   \       0x3C   0xC2 0xC2          DC8      0xC2,0xC2,0xC2,0x78
   \              0xC2 0x78    
   \       0x40   0x8C 0x00          DC8      0x8C,0x0
   1351          // -----------------------------------------------------------------------------
   1352              case cmuClock_SYSCLK:
   1353                switch (ref) {
   \                     ??CMU_ClockSelectSet_3: (+1)
   \       0x42   0x2902             CMP      R1,#+2
   \       0x44   0xD015             BEQ.N    ??CMU_ClockSelectSet_4
   \       0x46   0x2903             CMP      R1,#+3
   \       0x48   0xD007             BEQ.N    ??CMU_ClockSelectSet_5
   \       0x4A   0x2904             CMP      R1,#+4
   \       0x4C   0xD003             BEQ.N    ??CMU_ClockSelectSet_6
   \       0x4E   0x2906             CMP      R1,#+6
   \       0x50   0xBF08             IT       EQ 
   \       0x52   0x2504             MOVEQ    R5,#+4
   1354                  case cmuSelect_HFRCODPLL:
   1355                    tmp = CMU_SYSCLKCTRL_CLKSEL_HFRCODPLL;
   1356                    break;
   1357          
   1358                  case cmuSelect_HFXO:
   1359                    tmp = CMU_SYSCLKCTRL_CLKSEL_HFXO;
   1360          #if defined(_CMU_CLKEN0_MASK)
   1361                    CMU->CLKEN0_SET = CMU_CLKEN0_HFXO0;
   1362          #endif
   1363                    // Make sure HFXO is enabled.
   1364                    oscForceEnStatus = (HFXO0->CTRL & HFXO_CTRL_DISONDEMAND) != 0;
   1365                    HFXO0->CTRL_SET = HFXO_CTRL_FORCEEN;
   1366                    break;
   1367          
   1368                  case cmuSelect_CLKIN0:
   1369                    tmp = CMU_SYSCLKCTRL_CLKSEL_CLKIN0;
   \       0x54   0xE00E             B.N      ??CMU_ClockSelectSet_7
   \                     ??CMU_ClockSelectSet_6: (+1)
   \       0x56   0x2502             MOVS     R5,#+2
   \       0x58   0xE00C             B.N      ??CMU_ClockSelectSet_7
   \                     ??CMU_ClockSelectSet_5: (+1)
   \       0x5A   0x....'....        LDR.W    R0,??DataTable27_11  ;; 0x4000c028
   \       0x5E   0x6806             LDR      R6,[R0, #+0]
   \       0x60   0x2001             MOVS     R0,#+1
   \       0x62   0x....'....        LDR.W    R1,??DataTable27_12  ;; 0x4000d028
   \       0x66   0x0876             LSRS     R6,R6,#+1
   \       0x68   0x2503             MOVS     R5,#+3
   \       0x6A   0xF006 0x0601      AND      R6,R6,#0x1
   \       0x6E   0x6008             STR      R0,[R1, #+0]
   \       0x70   0xE000             B.N      ??CMU_ClockSelectSet_7
   1370                    break;
   1371          
   1372                  case cmuSelect_FSRCO:
   1373                    tmp = CMU_SYSCLKCTRL_CLKSEL_FSRCO;
   \                     ??CMU_ClockSelectSet_4: (+1)
   \       0x72   0x2501             MOVS     R5,#+1
   1374                    break;
   1375          
   1376                  default:
   1377                    EFM_ASSERT(false);
   1378                    break;
   1379                }
   1380          
   1381                // Set max wait-states and PCLK divisor while changing core clock.
   1382                waitStateMax();
   \                     ??CMU_ClockSelectSet_7: (+1)
   \       0x74   0x....'....        BL       waitStateMax
   1383                pclkDivMax();
   \       0x78   0x....'....        BL       pclkDivMax
   1384          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
   1385                // Set largest prescaler for radio clock tree
   1386                rhclkPrescMax();
   1387          #endif
   1388          
   1389                // Switch to selected oscillator.
   1390                CMU->SYSCLKCTRL = (CMU->SYSCLKCTRL & ~_CMU_SYSCLKCTRL_CLKSEL_MASK) | tmp;
   \       0x7C   0x6838             LDR      R0,[R7, #+0]
   \       0x7E   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x82   0x603D             STR      R5,[R7, #+0]
   1391          
   1392                // Update CMSIS core clock variable and set optimum wait-states.
   1393                CMU_UpdateWaitStates(SystemCoreClockGet(), 0);
   \       0x84   0x....'....        BL       SystemCoreClockGet
   \       0x88   0x2100             MOVS     R1,#+0
   \       0x8A   0x....'....        BL       CMU_UpdateWaitStates
   1394          
   1395                // Set optimal PCLK divisor
   1396                pclkDivOptimize();
   \       0x8E   0x....'....        BL       pclkDivOptimize
   1397          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
   1398                // Set optimal RHCLK prescaler
   1399                rhclkPrescOptimize();
   1400          #endif
   1401          
   1402                if (oscForceEnStatus == false) {
   \       0x92   0x2E00             CMP      R6,#+0
   \       0x94   0xBF08             IT       EQ 
   \       0x96   0x2C03             CMPEQ    R4,#+3
   1403                  switch (ref) {
   \       0x98   0xD103             BNE.N    ??CMU_ClockSelectSet_2
   1404                    case cmuSelect_HFXO:
   1405                      HFXO0->CTRL_CLR = HFXO_CTRL_FORCEEN;
   \       0x9A   0x2001             MOVS     R0,#+1
   \       0x9C   0x....'....        LDR.W    R1,??DataTable27_13  ;; 0x4000e028
   \       0xA0   0x6008             STR      R0,[R1, #+0]
   1406                      break;
   \                     ??CMU_ClockSelectSet_2: (+1)
   \       0xA2   0xBDF1             POP      {R0,R4-R7,PC}
   1407          
   1408                    default:
   1409                      break;
   1410                  }
   1411                }
   1412                break;
   1413          
   1414          // -----------------------------------------------------------------------------
   1415              case cmuClock_IADC0:
   1416              case cmuClock_IADCCLK:
   1417                switch (ref) {
   \                     ??CMU_ClockSelectSet_8: (+1)
   \       0xA4   0x2902             CMP      R1,#+2
   \       0xA6   0xD007             BEQ.N    ??CMU_ClockSelectSet_9
   \       0xA8   0x2905             CMP      R1,#+5
   \       0xAA   0xD003             BEQ.N    ??CMU_ClockSelectSet_10
   \       0xAC   0x290D             CMP      R1,#+13
   \       0xAE   0xD104             BNE.N    ??CMU_ClockSelectSet_11
   1418                  case cmuSelect_EM01GRPACLK:
   1419                    tmp = CMU_IADCCLKCTRL_CLKSEL_EM01GRPACLK;
   \       0xB0   0x2501             MOVS     R5,#+1
   1420                    break;
   \       0xB2   0xE002             B.N      ??CMU_ClockSelectSet_11
   1421          
   1422          #if defined(HFRCOEM23_PRESENT)
   1423                  case cmuSelect_HFRCOEM23:
   1424                    tmp = CMU_IADCCLKCTRL_CLKSEL_HFRCOEM23;
   \                     ??CMU_ClockSelectSet_10: (+1)
   \       0xB4   0x2502             MOVS     R5,#+2
   1425                    break;
   \       0xB6   0xE000             B.N      ??CMU_ClockSelectSet_11
   1426          #endif
   1427          
   1428                  case cmuSelect_FSRCO:
   1429                    tmp = CMU_IADCCLKCTRL_CLKSEL_FSRCO;
   \                     ??CMU_ClockSelectSet_9: (+1)
   \       0xB8   0x2503             MOVS     R5,#+3
   1430                    break;
   1431          
   1432                  default:
   1433                    EFM_ASSERT(false);
   1434                    break;
   1435                }
   1436                CMU->IADCCLKCTRL = (CMU->IADCCLKCTRL & ~_CMU_IADCCLKCTRL_CLKSEL_MASK)
   1437                                   | tmp;
   \                     ??CMU_ClockSelectSet_11: (+1)
   \       0xBA   0x....'....        LDR.W    R0,??DataTable27_14  ;; 0x40008180
   \       0xBE   0x6801             LDR      R1,[R0, #+0]
   \       0xC0   0x0889             LSRS     R1,R1,#+2
   \       0xC2   0xEA45 0x0581      ORR      R5,R5,R1, LSL #+2
   \       0xC6   0x6005             STR      R5,[R0, #+0]
   1438                break;
   \       0xC8   0xBDF1             POP      {R0,R4-R7,PC}
   1439          
   1440          // -----------------------------------------------------------------------------
   1441              case cmuClock_TIMER0:
   1442              case cmuClock_TIMER1:
   1443              case cmuClock_TIMER2:
   1444              case cmuClock_TIMER3:
   1445              case cmuClock_EM01GRPACLK:
   1446                switch (ref) {
   \                     ??CMU_ClockSelectSet_12: (+1)
   \       0xCA   0x1E89             SUBS     R1,R1,#+2
   \       0xCC   0x2903             CMP      R1,#+3
   \       0xCE   0xD80A             BHI.N    ??CMU_ClockSelectSet_13
   \       0xD0   0xE8DF 0xF001      TBB      [PC, R1]
   \                     ??CMU_ClockSelectSet_1:
   \       0xD4   0x08 0x04          DC8      0x8,0x4,0x2,0x6
   \              0x02 0x06    
   1447                  case cmuSelect_HFRCODPLL:
   1448                    tmp = CMU_EM01GRPACLKCTRL_CLKSEL_HFRCODPLL;
   \                     ??CMU_ClockSelectSet_14: (+1)
   \       0xD8   0x2501             MOVS     R5,#+1
   1449                    break;
   \       0xDA   0xE004             B.N      ??CMU_ClockSelectSet_13
   1450          
   1451                  case cmuSelect_HFXO:
   1452                    tmp = CMU_EM01GRPACLKCTRL_CLKSEL_HFXO;
   \                     ??CMU_ClockSelectSet_15: (+1)
   \       0xDC   0x2502             MOVS     R5,#+2
   1453                    break;
   \       0xDE   0xE002             B.N      ??CMU_ClockSelectSet_13
   1454          
   1455          #if defined(HFRCOEM23_PRESENT)
   1456                  case cmuSelect_HFRCOEM23:
   1457                    tmp = CMU_EM01GRPACLKCTRL_CLKSEL_HFRCOEM23;
   \                     ??CMU_ClockSelectSet_16: (+1)
   \       0xE0   0x2503             MOVS     R5,#+3
   1458                    break;
   \       0xE2   0xE000             B.N      ??CMU_ClockSelectSet_13
   1459          #endif
   1460          
   1461                  case cmuSelect_FSRCO:
   1462                    tmp = CMU_EM01GRPACLKCTRL_CLKSEL_FSRCO;
   \                     ??CMU_ClockSelectSet_17: (+1)
   \       0xE4   0x2504             MOVS     R5,#+4
   1463                    break;
   1464          
   1465                  default:
   1466                    EFM_ASSERT(false);
   1467                    break;
   1468                }
   1469                CMU->EM01GRPACLKCTRL = (CMU->EM01GRPACLKCTRL
   1470                                        & ~_CMU_EM01GRPACLKCTRL_CLKSEL_MASK) | tmp;
   \                     ??CMU_ClockSelectSet_13: (+1)
   \       0xE6   0x6A18             LDR      R0,[R3, #+32]
   \       0xE8   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0xEC   0x621D             STR      R5,[R3, #+32]
   1471                break;
   \       0xEE   0xBDF1             POP      {R0,R4-R7,PC}
   1472          
   1473          // -----------------------------------------------------------------------------
   1474              case cmuClock_SYSTICK:
   1475              case cmuClock_LETIMER0:
   1476              case cmuClock_EM23GRPACLK:
   1477                switch (ref) {
   \                     ??CMU_ClockSelectSet_18: (+1)
   \       0xF0   0x....'....        BL       ?Subroutine2
   1478                  case cmuSelect_LFRCO:
   1479                    tmp = CMU_EM23GRPACLKCTRL_CLKSEL_LFRCO;
   1480                    break;
   1481          
   1482                  case cmuSelect_LFXO:
   1483                    tmp = CMU_EM23GRPACLKCTRL_CLKSEL_LFXO;
   1484                    break;
   1485          
   1486                  case cmuSelect_ULFRCO:
   1487                    tmp = CMU_EM23GRPACLKCTRL_CLKSEL_ULFRCO;
   1488                    break;
   1489          
   1490                  default:
   1491                    EFM_ASSERT(false);
   1492                    break;
   1493                }
   1494                CMU->EM23GRPACLKCTRL = (CMU->EM23GRPACLKCTRL
   1495                                        & ~_CMU_EM23GRPACLKCTRL_CLKSEL_MASK) | tmp;
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0xF4   0x6C18             LDR      R0,[R3, #+64]
   \       0xF6   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0xFA   0x641D             STR      R5,[R3, #+64]
   1496                break;
   \       0xFC   0xBDF1             POP      {R0,R4-R7,PC}
   1497          
   1498          // -----------------------------------------------------------------------------
   1499              case cmuClock_BURTC:
   1500              case cmuClock_EM4GRPACLK:
   1501                switch (ref) {
   \                     ??CMU_ClockSelectSet_19: (+1)
   \       0xFE   0x....'....        BL       ?Subroutine2
   1502                  case cmuSelect_LFRCO:
   1503                    tmp = CMU_EM4GRPACLKCTRL_CLKSEL_LFRCO;
   1504                    break;
   1505          
   1506                  case cmuSelect_LFXO:
   1507                    tmp = CMU_EM4GRPACLKCTRL_CLKSEL_LFXO;
   1508                    break;
   1509          
   1510                  case cmuSelect_ULFRCO:
   1511                    tmp = CMU_EM4GRPACLKCTRL_CLKSEL_ULFRCO;
   1512                    break;
   1513          
   1514                  default:
   1515                    EFM_ASSERT(false);
   1516                    break;
   1517                }
   1518                CMU->EM4GRPACLKCTRL = (CMU->EM4GRPACLKCTRL
   1519                                       & ~_CMU_EM4GRPACLKCTRL_CLKSEL_MASK) | tmp;
   \                     ??CrossCallReturnLabel_1: (+1)
   \      0x102   0x6E18             LDR      R0,[R3, #+96]
   \      0x104   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_18: (+1)
   \      0x108   0x661D             STR      R5,[R3, #+96]
   1520                break;
   \      0x10A   0xBDF1             POP      {R0,R4-R7,PC}
   1521          
   1522          #if defined(_CMU_EM01GRPBCLKCTRL_CLKSEL_MASK)
   1523          // -----------------------------------------------------------------------------
   1524              case cmuClock_PDMREF:
   1525              case cmuClock_EM01GRPBCLK:
   1526                switch (ref) {
   1527                  case cmuSelect_HFRCODPLL:
   1528                    tmp = CMU_EM01GRPBCLKCTRL_CLKSEL_HFRCODPLL;
   1529                    break;
   1530          
   1531                  case cmuSelect_HFXO:
   1532                    tmp = CMU_EM01GRPBCLKCTRL_CLKSEL_HFXO;
   1533                    break;
   1534          
   1535                  case cmuSelect_FSRCO:
   1536                    tmp = CMU_EM01GRPBCLKCTRL_CLKSEL_FSRCO;
   1537                    break;
   1538          
   1539                  case cmuSelect_CLKIN0:
   1540                    tmp = CMU_EM01GRPBCLKCTRL_CLKSEL_CLKIN0;
   1541                    break;
   1542          
   1543                  case cmuSelect_HFRCODPLLRT:
   1544                    tmp = CMU_EM01GRPBCLKCTRL_CLKSEL_HFRCODPLLRT;
   1545                    break;
   1546          
   1547                  case cmuSelect_HFXORT:
   1548                    tmp = CMU_EM01GRPBCLKCTRL_CLKSEL_HFXORT;
   1549                    break;
   1550          
   1551                  default:
   1552                    EFM_ASSERT(false);
   1553                    break;
   1554                }
   1555                CMU->EM01GRPBCLKCTRL = (CMU->EM01GRPBCLKCTRL
   1556                                        & ~_CMU_EM01GRPBCLKCTRL_CLKSEL_MASK) | tmp;
   1557                break;
   1558          #endif
   1559          
   1560          // -----------------------------------------------------------------------------
   1561              case cmuClock_WDOG0:
   1562              case cmuClock_WDOG0CLK:
   1563                switch (ref) {
   \                     ??CMU_ClockSelectSet_20: (+1)
   \      0x10C   0x2907             CMP      R1,#+7
   \      0x10E   0xD009             BEQ.N    ??CMU_ClockSelectSet_21
   \      0x110   0x2908             CMP      R1,#+8
   \      0x112   0xD005             BEQ.N    ??CMU_ClockSelectSet_22
   \      0x114   0x2909             CMP      R1,#+9
   \      0x116   0xD007             BEQ.N    ??CMU_ClockSelectSet_23
   \      0x118   0x290C             CMP      R1,#+12
   \      0x11A   0xBF08             IT       EQ 
   \      0x11C   0x2504             MOVEQ    R5,#+4
   1564                  case cmuSelect_LFRCO:
   1565                    tmp = CMU_WDOG0CLKCTRL_CLKSEL_LFRCO;
   1566                    break;
   1567          
   1568                  case cmuSelect_LFXO:
   1569                    tmp = CMU_WDOG0CLKCTRL_CLKSEL_LFXO;
   1570                    break;
   1571          
   1572                  case cmuSelect_ULFRCO:
   1573                    tmp = CMU_WDOG0CLKCTRL_CLKSEL_ULFRCO;
   1574                    break;
   1575          
   1576                  case cmuSelect_HCLKDIV1024:
   1577                    tmp = CMU_WDOG0CLKCTRL_CLKSEL_HCLKDIV1024;
   \      0x11E   0xE004             B.N      ??CMU_ClockSelectSet_24
   \                     ??CMU_ClockSelectSet_22: (+1)
   \      0x120   0x2501             MOVS     R5,#+1
   \      0x122   0xE002             B.N      ??CMU_ClockSelectSet_24
   \                     ??CMU_ClockSelectSet_21: (+1)
   \      0x124   0x2502             MOVS     R5,#+2
   \      0x126   0xE000             B.N      ??CMU_ClockSelectSet_24
   \                     ??CMU_ClockSelectSet_23: (+1)
   \      0x128   0x2503             MOVS     R5,#+3
   1578                    break;
   1579          
   1580                  default:
   1581                    EFM_ASSERT(false);
   1582                    break;
   1583                }
   1584                CMU->WDOG0CLKCTRL = (CMU->WDOG0CLKCTRL & ~_CMU_WDOG0CLKCTRL_CLKSEL_MASK)
   1585                                    | tmp;
   \                     ??CMU_ClockSelectSet_24: (+1)
   \      0x12A   0x6810             LDR      R0,[R2, #+0]
   \      0x12C   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_15: (+1)
   \      0x130   0x6015             STR      R5,[R2, #+0]
   1586                break;
   \      0x132   0xBDF1             POP      {R0,R4-R7,PC}
   1587          
   1588          #if defined(_CMU_WDOG1CLKCTRL_CLKSEL_MASK)
   1589          // -----------------------------------------------------------------------------
   1590              case cmuClock_WDOG1:
   1591              case cmuClock_WDOG1CLK:
   1592                switch (ref) {
   \                     ??CMU_ClockSelectSet_25: (+1)
   \      0x134   0x2907             CMP      R1,#+7
   \      0x136   0xD009             BEQ.N    ??CMU_ClockSelectSet_26
   \      0x138   0x2908             CMP      R1,#+8
   \      0x13A   0xD005             BEQ.N    ??CMU_ClockSelectSet_27
   \      0x13C   0x2909             CMP      R1,#+9
   \      0x13E   0xD007             BEQ.N    ??CMU_ClockSelectSet_28
   \      0x140   0x290C             CMP      R1,#+12
   \      0x142   0xBF08             IT       EQ 
   \      0x144   0x2504             MOVEQ    R5,#+4
   1593                  case cmuSelect_LFRCO:
   1594                    tmp = CMU_WDOG1CLKCTRL_CLKSEL_LFRCO;
   1595                    break;
   1596          
   1597                  case cmuSelect_LFXO:
   1598                    tmp = CMU_WDOG1CLKCTRL_CLKSEL_LFXO;
   1599                    break;
   1600          
   1601                  case cmuSelect_ULFRCO:
   1602                    tmp = CMU_WDOG1CLKCTRL_CLKSEL_ULFRCO;
   1603                    break;
   1604          
   1605                  case cmuSelect_HCLKDIV1024:
   1606                    tmp = CMU_WDOG1CLKCTRL_CLKSEL_HCLKDIV1024;
   \      0x146   0xE004             B.N      ??CMU_ClockSelectSet_29
   \                     ??CMU_ClockSelectSet_27: (+1)
   \      0x148   0x2501             MOVS     R5,#+1
   \      0x14A   0xE002             B.N      ??CMU_ClockSelectSet_29
   \                     ??CMU_ClockSelectSet_26: (+1)
   \      0x14C   0x2502             MOVS     R5,#+2
   \      0x14E   0xE000             B.N      ??CMU_ClockSelectSet_29
   \                     ??CMU_ClockSelectSet_28: (+1)
   \      0x150   0x2503             MOVS     R5,#+3
   1607                    break;
   1608          
   1609                  default:
   1610                    EFM_ASSERT(false);
   1611                    break;
   1612                }
   1613                CMU->WDOG1CLKCTRL = (CMU->WDOG1CLKCTRL & ~_CMU_WDOG1CLKCTRL_CLKSEL_MASK)
   1614                                    | tmp;
   \                     ??CMU_ClockSelectSet_29: (+1)
   \      0x152   0x6890             LDR      R0,[R2, #+8]
   \      0x154   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_16: (+1)
   \      0x158   0x6095             STR      R5,[R2, #+8]
   1615                break;
   \      0x15A   0xBDF1             POP      {R0,R4-R7,PC}
   1616          #endif
   1617          
   1618          // -----------------------------------------------------------------------------
   1619              case cmuClock_DPLLREFCLK:
   1620                switch (ref) {
   \                     ??CMU_ClockSelectSet_30: (+1)
   \      0x15C   0x2903             CMP      R1,#+3
   \      0x15E   0xD005             BEQ.N    ??CMU_ClockSelectSet_31
   \      0x160   0x2906             CMP      R1,#+6
   \      0x162   0xD005             BEQ.N    ??CMU_ClockSelectSet_32
   \      0x164   0x2907             CMP      R1,#+7
   \      0x166   0xBF08             IT       EQ 
   \      0x168   0x2502             MOVEQ    R5,#+2
   1621                  case cmuSelect_HFXO:
   1622                    tmp = CMU_DPLLREFCLKCTRL_CLKSEL_HFXO;
   1623                    break;
   1624          
   1625                  case cmuSelect_LFXO:
   1626                    tmp = CMU_DPLLREFCLKCTRL_CLKSEL_LFXO;
   \      0x16A   0xE002             B.N      ??CMU_ClockSelectSet_33
   \                     ??CMU_ClockSelectSet_31: (+1)
   \      0x16C   0x2501             MOVS     R5,#+1
   \      0x16E   0xE000             B.N      ??CMU_ClockSelectSet_33
   1627                    break;
   1628          
   1629                  case cmuSelect_CLKIN0:
   1630                    tmp = CMU_DPLLREFCLKCTRL_CLKSEL_CLKIN0;
   \                     ??CMU_ClockSelectSet_32: (+1)
   \      0x170   0x2503             MOVS     R5,#+3
   1631                    break;
   1632          
   1633                  case cmuSelect_Disabled:
   1634                    tmp = CMU_DPLLREFCLKCTRL_CLKSEL_DISABLED;
   1635                    break;
   1636          
   1637                  default:
   1638                    EFM_ASSERT(false);
   1639                    break;
   1640                }
   1641                CMU->DPLLREFCLKCTRL = (CMU->DPLLREFCLKCTRL
   1642                                       & ~_CMU_DPLLREFCLKCTRL_CLKSEL_MASK) | tmp;
   \                     ??CMU_ClockSelectSet_33: (+1)
   \      0x172   0x6818             LDR      R0,[R3, #+0]
   \      0x174   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_19: (+1)
   \      0x178   0x601D             STR      R5,[R3, #+0]
   1643                break;
   \      0x17A   0xBDF1             POP      {R0,R4-R7,PC}
   1644          
   1645          #if defined(_CMU_TRACECLKCTRL_CLKSEL_MASK)
   1646          // -----------------------------------------------------------------------------
   1647              case cmuClock_TRACECLK:
   1648                switch (ref) {
   \                     ??CMU_ClockSelectSet_34: (+1)
   \      0x17C   0x2905             CMP      R1,#+5
   \      0x17E   0xD003             BEQ.N    ??CMU_ClockSelectSet_35
   \      0x180   0x290B             CMP      R1,#+11
   \      0x182   0xD102             BNE.N    ??CMU_ClockSelectSet_36
   1649                  case cmuSelect_HCLK:
   1650                    tmp = CMU_TRACECLKCTRL_CLKSEL_HCLK;
   \      0x184   0x2502             MOVS     R5,#+2
   1651                    break;
   \      0x186   0xE000             B.N      ??CMU_ClockSelectSet_36
   1652          
   1653                  case cmuSelect_HFRCOEM23:
   1654                    tmp = CMU_TRACECLKCTRL_CLKSEL_HFRCOEM23;
   \                     ??CMU_ClockSelectSet_35: (+1)
   \      0x188   0x2503             MOVS     R5,#+3
   1655                    break;
   1656          
   1657                  default:
   1658                    EFM_ASSERT(false);
   1659                    break;
   1660                }
   1661                CMU->TRACECLKCTRL = (CMU->TRACECLKCTRL & ~_CMU_TRACECLKCTRL_CLKSEL_MASK)
   1662                                    | tmp;
   \                     ??CMU_ClockSelectSet_36: (+1)
   \      0x18A   0x6938             LDR      R0,[R7, #+16]
   \      0x18C   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_20: (+1)
   \      0x190   0x613D             STR      R5,[R7, #+16]
   1663                break;
   \      0x192   0xBDF1             POP      {R0,R4-R7,PC}
   1664          #endif
   1665          
   1666          #if defined(_CMU_EUART0CLKCTRL_CLKSEL_MASK)
   1667          // -----------------------------------------------------------------------------
   1668              case cmuClock_EUART0:
   1669              case cmuClock_EUART0CLK:
   1670                switch (ref) {
   1671                  case cmuSelect_EM01GRPACLK:
   1672                    tmp = _CMU_EUART0CLKCTRL_CLKSEL_EM01GRPACLK;
   1673                    break;
   1674          
   1675                  case cmuSelect_EM23GRPACLK:
   1676                    tmp = _CMU_EUART0CLKCTRL_CLKSEL_EM23GRPACLK;
   1677                    break;
   1678          
   1679                  default:
   1680                    EFM_ASSERT(false);
   1681                    break;
   1682                }
   1683                CMU->EUART0CLKCTRL = (CMU->EUART0CLKCTRL & ~_CMU_EUART0CLKCTRL_CLKSEL_MASK)
   1684                                     | tmp;
   1685                break;
   1686          #endif
   1687          
   1688          // -----------------------------------------------------------------------------
   1689              case cmuClock_RTCC:
   1690              case cmuClock_RTCCCLK:
   1691                switch (ref) {
   \                     ??CMU_ClockSelectSet_37: (+1)
   \      0x194   0x....'....        BL       ?Subroutine2
   1692                  case cmuSelect_LFRCO:
   1693                    tmp = CMU_RTCCCLKCTRL_CLKSEL_LFRCO;
   1694                    break;
   1695          
   1696                  case cmuSelect_LFXO:
   1697                    tmp = CMU_RTCCCLKCTRL_CLKSEL_LFXO;
   1698                    break;
   1699          
   1700                  case cmuSelect_ULFRCO:
   1701                    tmp = CMU_RTCCCLKCTRL_CLKSEL_ULFRCO;
   1702                    break;
   1703          
   1704                  default:
   1705                    EFM_ASSERT(false);
   1706                    break;
   1707                }
   1708                CMU->RTCCCLKCTRL = (CMU->RTCCCLKCTRL & ~_CMU_RTCCCLKCTRL_CLKSEL_MASK)
   1709                                   | tmp;
   \                     ??CrossCallReturnLabel_2: (+1)
   \      0x198   0x6C10             LDR      R0,[R2, #+64]
   \      0x19A   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_21: (+1)
   \      0x19E   0x6415             STR      R5,[R2, #+64]
   1710                break;
   1711          
   1712          // -----------------------------------------------------------------------------
   1713              default:
   1714                EFM_ASSERT(false);
   1715                break;
   1716            }
   1717          }
   \                     ??CMU_ClockSelectSet_38: (+1)
   \      0x1A0   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0x0880             LSRS     R0,R0,#+2
   \        0x2   0xEA45 0x0580      ORR      R5,R5,R0, LSL #+2
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x08C0             LSRS     R0,R0,#+3
   \        0x2   0xEA45 0x05C0      ORR      R5,R5,R0, LSL #+3
   \        0x6   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x2907             CMP      R1,#+7
   \        0x2   0xD005             BEQ.N    ??Subroutine2_0
   \        0x4   0xD307             BCC.N    ??Subroutine2_1
   \        0x6   0x2909             CMP      R1,#+9
   \        0x8   0xD004             BEQ.N    ??Subroutine2_2
   \        0xA   0xD204             BCS.N    ??Subroutine2_1
   \        0xC   0x2501             MOVS     R5,#+1
   \        0xE   0x4770             BX       LR
   \                     ??Subroutine2_0: (+1)
   \       0x10   0x2502             MOVS     R5,#+2
   \       0x12   0x4770             BX       LR
   \                     ??Subroutine2_2: (+1)
   \       0x14   0x2503             MOVS     R5,#+3
   \                     ??Subroutine2_1: (+1)
   \       0x16   0x4770             BX       LR
   1718          
   1719          /**************************************************************************//**
   1720           * @brief
   1721           *   Lock the DPLL to a given frequency.
   1722           *   The frequency is given by: Fout = Fref * (N+1) / (M+1).
   1723           *
   1724           * @note
   1725           *   This function does not check if the given N & M values will actually
   1726           *   produce the desired target frequency. @n
   1727           *   N & M limitations: @n
   1728           *     300 < N <= 4095 @n
   1729           *     0 <= M <= 4095 @n
   1730           *   Any peripheral running off HFRCODPLL should be switched to a lower
   1731           *   frequency clock (if possible) prior to calling this function to avoid
   1732           *   over-clocking.
   1733           *
   1734           * @param[in] init
   1735           *    DPLL setup parameter struct.
   1736           *
   1737           * @return
   1738           *   Returns false on invalid target frequency or DPLL locking error.
   1739           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1740          bool CMU_DPLLLock(const CMU_DPLLInit_TypeDef *init)
   1741          {
   \                     CMU_DPLLLock: (+1)
   \        0x0   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \        0x4   0x4604             MOV      R4,R0
   1742            int index = 0;
   \        0x6   0x2000             MOVS     R0,#+0
   1743            unsigned int i;
   1744            bool hclkDivIncreased = false;
   \        0x8   0x2500             MOVS     R5,#+0
   1745            uint32_t hfrcoCalVal, lockStatus, hclkDiv = 0, sysFreq;
   \        0xA   0x4680             MOV      R8,R0
   1746          
   1747            EFM_ASSERT(init->frequency >= hfrcoCalTable[0].minFreq);
   1748            EFM_ASSERT(init->frequency
   1749                       <= hfrcoCalTable[HFRCOCALTABLE_ENTRIES - 1U].maxFreq);
   1750          
   1751            EFM_ASSERT(init->n > 300U);
   1752            EFM_ASSERT(init->n <= (_DPLL_CFG1_N_MASK >> _DPLL_CFG1_N_SHIFT));
   1753            EFM_ASSERT(init->m <= (_DPLL_CFG1_M_MASK >> _DPLL_CFG1_M_SHIFT));
   1754          
   1755            // Find correct HFRCODPLL band, and retrieve a HFRCOCAL value.
   1756            for (i = 0; i < HFRCOCALTABLE_ENTRIES; i++) {
   \        0xC   0x2100             MOVS     R1,#+0
   \        0xE   0x....'....        LDR.W    R2,??DataTable27_15
   \       0x12   0x6827             LDR      R7,[R4, #+0]
   1757              if ((init->frequency    >= hfrcoCalTable[i].minFreq)
   1758                  && (init->frequency <= hfrcoCalTable[i].maxFreq)) {
   \                     ??CMU_DPLLLock_0: (+1)
   \       0x14   0x010B             LSLS     R3,R1,#+4
   \       0x16   0x58D6             LDR      R6,[R2, R3]
   \       0x18   0x42B7             CMP      R7,R6
   \       0x1A   0xBF22             ITTT     CS 
   \       0x1C   0x18D3             ADDCS    R3,R2,R3
   \       0x1E   0x685B             LDRCS    R3,[R3, #+4]
   \       0x20   0x42BB             CMPCS    R3,R7
   \       0x22   0xD221             BCS.N    ??CMU_DPLLLock_1
   \       0x24   0x1C49             ADDS     R1,R1,#+1
   \       0x26   0x2919             CMP      R1,#+25
   \       0x28   0xD3F4             BCC.N    ??CMU_DPLLLock_0
   1759                index = (int)i;                       // Correct band found
   1760                break;
   1761              }
   1762            }
   1763            if ((uint32_t)index == HFRCOCALTABLE_ENTRIES) {
   1764              EFM_ASSERT(false);
   1765              return false;                           // Target frequency out of spec.
   1766            }
   1767            hfrcoCalVal = hfrcoCalTable[index].value;
   \                     ??CMU_DPLLLock_2: (+1)
   \       0x2A   0xEB02 0x1000      ADD      R0,R2,R0, LSL #+4
   \       0x2E   0x6886             LDR      R6,[R0, #+8]
   1768          
   1769            // Check if we have a calibrated HFRCOCAL.TUNING value in device DI page.
   1770            if (hfrcoCalTable[index].band != (CMU_HFRCODPLLFreq_TypeDef)0) {
   \       0x30   0x68C0             LDR      R0,[R0, #+12]
   \       0x32   0xB120             CBZ.N    R0,??CMU_DPLLLock_3
   1771              uint32_t tuning;
   1772          
   1773              tuning = (HFRCODPLLDevinfoGet(hfrcoCalTable[index].band)
   1774                        & _HFRCO_CAL_TUNING_MASK)
   1775                       >> _HFRCO_CAL_TUNING_SHIFT;
   1776              hfrcoCalVal |= tuning << _HFRCO_CAL_TUNING_SHIFT;
   \       0x34   0x....'....        BL       HFRCODPLLDevinfoGet
   \       0x38   0xF000 0x007F      AND      R0,R0,#0x7F
   \       0x3C   0x4306             ORRS     R6,R0,R6
   1777            }
   1778          
   1779            // Update CMSIS HFRCODPLL frequency.
   1780            SystemHFRCODPLLClockSet(init->frequency);
   \                     ??CMU_DPLLLock_3: (+1)
   \       0x3E   0x6820             LDR      R0,[R4, #+0]
   \       0x40   0x....'....        BL       SystemHFRCODPLLClockSet
   1781          
   1782            if (CMU_ClockSelectGet(cmuClock_SYSCLK) == cmuSelect_HFRCODPLL) {
   \       0x44   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x48   0x2804             CMP      R0,#+4
   \       0x4A   0xD11B             BNE.N    ??CMU_DPLLLock_4
   1783              // Set max wait-states and PCLK divisor while changing core clock
   1784              waitStateMax();
   \       0x4C   0x....'....        BL       waitStateMax
   1785              pclkDivMax();
   \       0x50   0x....'....        BL       pclkDivMax
   1786          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
   1787              // Set largest prescaler for radio clock tree
   1788              rhclkPrescMax();
   1789          #endif
   1790          
   1791              // Increase HCLK divider value (if possible) while locking DPLL to
   1792              // avoid over-clocking.
   1793              hclkDiv = CMU_ClockDivGet(cmuClock_HCLK);
   \       0x54   0x2001             MOVS     R0,#+1
   \       0x56   0x....'....        BL       CMU_ClockDivGet
   \       0x5A   0x4680             MOV      R8,R0
   1794              hclkDivIncreased = true;
   \       0x5C   0x2501             MOVS     R5,#+1
   1795              if (hclkDiv == 1U) {
   \       0x5E   0xF1B8 0x0F01      CMP      R8,#+1
   \       0x62   0xD106             BNE.N    ??CMU_DPLLLock_5
   1796                CMU_ClockDivSet(cmuClock_HCLK, 2U);
   \       0x64   0x2102             MOVS     R1,#+2
   \       0x66   0xE009             B.N      ??CMU_DPLLLock_6
   1797              } else if (hclkDiv == 2U) {
   \                     ??CMU_DPLLLock_1: (+1)
   \       0x68   0x4608             MOV      R0,R1
   \       0x6A   0x2819             CMP      R0,#+25
   \       0x6C   0xD1DD             BNE.N    ??CMU_DPLLLock_2
   \       0x6E   0x2000             MOVS     R0,#+0
   \       0x70   0xE051             B.N      ??CMU_DPLLLock_7
   \                     ??CMU_DPLLLock_5: (+1)
   \       0x72   0xF1B8 0x0F02      CMP      R8,#+2
   \       0x76   0xD104             BNE.N    ??CMU_DPLLLock_8
   1798                CMU_ClockDivSet(cmuClock_HCLK, 4U);
   \       0x78   0x2104             MOVS     R1,#+4
   \       0x7A   0x2001             MOVS     R0,#+1
   \                     ??CMU_DPLLLock_6: (+1)
   \       0x7C   0x....'....        BL       CMU_ClockDivSet
   \       0x80   0xE000             B.N      ??CMU_DPLLLock_4
   1799              } else {
   1800                hclkDivIncreased = false;
   \                     ??CMU_DPLLLock_8: (+1)
   \       0x82   0x2500             MOVS     R5,#+0
   1801              }
   1802            }
   1803          
   1804          #if defined(CMU_CLKEN0_DPLL0)
   1805            CMU->CLKEN0_SET = CMU_CLKEN0_DPLL0 | CMU_CLKEN0_HFRCO0;
   1806          #endif
   1807          
   1808            // Make sure DPLL is disabled before configuring
   1809            DPLL0->EN_CLR = DPLL_EN_EN;
   \                     ??CMU_DPLLLock_4: (+1)
   \       0x84   0x....'....        LDR.W    R0,??DataTable27_16  ;; 0x4001e004
   \       0x88   0x2101             MOVS     R1,#+1
   \       0x8A   0x6001             STR      R1,[R0, #+0]
   \       0x8C   0x....'....        LDR.W    R7,??DataTable27_17  ;; 0x4001c008
   1810            while ((DPLL0->STATUS & (DPLL_STATUS_ENS | DPLL_STATUS_RDY)) != 0UL) {
   \                     ??CMU_DPLLLock_9: (+1)
   \       0x90   0x6939             LDR      R1,[R7, #+16]
   \       0x92   0xF011 0x0F03      TST      R1,#0x3
   \       0x96   0xD1FB             BNE.N    ??CMU_DPLLLock_9
   1811            }
   1812            DPLL0->IF_CLR = DPLL_IF_LOCK | DPLL_IF_LOCKFAILLOW | DPLL_IF_LOCKFAILHIGH;
   \       0x98   0x2107             MOVS     R1,#+7
   \       0x9A   0x60C1             STR      R1,[R0, #+12]
   1813            DPLL0->CFG1   = ((uint32_t)init->n   << _DPLL_CFG1_N_SHIFT)
   1814                            | ((uint32_t)init->m << _DPLL_CFG1_M_SHIFT);
   \       0x9C   0x88A0             LDRH     R0,[R4, #+4]
   \       0x9E   0x88E1             LDRH     R1,[R4, #+6]
   \       0xA0   0xEA41 0x4100      ORR      R1,R1,R0, LSL #+16
   1815            HFRCO0->CAL = hfrcoCalVal;
   \       0xA4   0x....'....        LDR.W    R0,??DataTable27_18  ;; 0x40010008
   \       0xA8   0x6079             STR      R1,[R7, #+4]
   \       0xAA   0x6006             STR      R6,[R0, #+0]
   1816            CMU_ClockSelectSet(cmuClock_DPLLREFCLK, init->refClk);
   \       0xAC   0x7A21             LDRB     R1,[R4, #+8]
   \       0xAE   0x200B             MOVS     R0,#+11
   \       0xB0   0x....'....        BL       CMU_ClockSelectSet
   1817            DPLL0->CFG = ((init->autoRecover ? 1UL : 0UL) << _DPLL_CFG_AUTORECOVER_SHIFT)
   1818                         | ((init->ditherEn ? 1UL : 0UL)  << _DPLL_CFG_DITHEN_SHIFT)
   1819                         | ((uint32_t)init->edgeSel  << _DPLL_CFG_EDGESEL_SHIFT)
   1820                         | ((uint32_t)init->lockMode << _DPLL_CFG_MODE_SHIFT);
   \       0xB4   0x7AE0             LDRB     R0,[R4, #+11]
   \       0xB6   0xB100             CBZ.N    R0,??CMU_DPLLLock_10
   \       0xB8   0x2001             MOVS     R0,#+1
   \                     ??CMU_DPLLLock_10: (+1)
   \       0xBA   0x7B21             LDRB     R1,[R4, #+12]
   \       0xBC   0xB101             CBZ.N    R1,??CMU_DPLLLock_11
   \       0xBE   0x2101             MOVS     R1,#+1
   \                     ??CMU_DPLLLock_11: (+1)
   \       0xC0   0x7A62             LDRB     R2,[R4, #+9]
   \       0xC2   0x0189             LSLS     R1,R1,#+6
   \       0xC4   0xEA41 0x0180      ORR      R1,R1,R0, LSL #+2
   \       0xC8   0x7AA0             LDRB     R0,[R4, #+10]
   \       0xCA   0xEA41 0x0142      ORR      R1,R1,R2, LSL #+1
   1821            // Lock DPLL
   1822            DPLL0->EN_SET = DPLL_EN_EN;
   \       0xCE   0x....'....        LDR.W    R2,??DataTable27_19  ;; 0x4001d004
   \       0xD2   0x4301             ORRS     R1,R0,R1
   \       0xD4   0x6039             STR      R1,[R7, #+0]
   \       0xD6   0x2101             MOVS     R1,#+1
   \       0xD8   0x6011             STR      R1,[R2, #+0]
   1823            while ((lockStatus = (DPLL0->IF & (DPLL_IF_LOCK
   1824                                               | DPLL_IF_LOCKFAILLOW
   1825                                               | DPLL_IF_LOCKFAILHIGH))) == 0UL) {
   \                     ??CMU_DPLLLock_12: (+1)
   \       0xDA   0x68BC             LDR      R4,[R7, #+8]
   \       0xDC   0xF014 0x0407      ANDS     R4,R4,#0x7
   \       0xE0   0xD0FB             BEQ.N    ??CMU_DPLLLock_12
   1826            }
   1827          
   1828            if (CMU_ClockSelectGet(cmuClock_SYSCLK) == cmuSelect_HFRCODPLL) {
   \       0xE2   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0xE6   0x2804             CMP      R0,#+4
   \       0xE8   0xD111             BNE.N    ??CMU_DPLLLock_13
   1829              if (hclkDivIncreased) {
   \       0xEA   0xB11D             CBZ.N    R5,??CMU_DPLLLock_14
   1830                // Restore original HCLK divider
   1831                CMU_ClockDivSet(cmuClock_HCLK, hclkDiv);
   \       0xEC   0x4641             MOV      R1,R8
   \       0xEE   0x2001             MOVS     R0,#+1
   \       0xF0   0x....'....        BL       CMU_ClockDivSet
   1832              }
   1833          
   1834              // Call @ref SystemCoreClockGet() to update CMSIS core clock variable.
   1835              sysFreq = SystemCoreClockGet();
   \                     ??CMU_DPLLLock_14: (+1)
   \       0xF4   0x....'....        BL       SystemCoreClockGet
   \       0xF8   0x4605             MOV      R5,R0
   1836              EFM_ASSERT(sysFreq <= init->frequency);
   1837              EFM_ASSERT(sysFreq <= SystemHFRCODPLLClockGet());
   \       0xFA   0x....'....        BL       SystemHFRCODPLLClockGet
   1838              EFM_ASSERT(init->frequency == SystemHFRCODPLLClockGet());
   \       0xFE   0x....'....        BL       SystemHFRCODPLLClockGet
   1839          
   1840              // Set optimal wait-states and PCLK divisor
   1841              CMU_UpdateWaitStates(sysFreq, 0);
   \      0x102   0x2100             MOVS     R1,#+0
   \      0x104   0x4628             MOV      R0,R5
   \      0x106   0x....'....        BL       CMU_UpdateWaitStates
   1842              pclkDivOptimize();
   \      0x10A   0x....'....        BL       pclkDivOptimize
   1843          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
   1844              // Set optimal RHCLK prescaler
   1845              rhclkPrescOptimize();
   1846          #endif
   1847            }
   1848          
   1849            if (lockStatus == DPLL_IF_LOCK) {
   \                     ??CMU_DPLLLock_13: (+1)
   \      0x10E   0x2C01             CMP      R4,#+1
   \      0x110   0xBF0C             ITE      EQ 
   \      0x112   0x2001             MOVEQ    R0,#+1
   \      0x114   0x2000             MOVNE    R0,#+0
   1850              return true;
   1851            }
   1852            return false;
   \                     ??CMU_DPLLLock_7: (+1)
   \      0x116   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1853          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0x....             B.N      CMU_ClockSelectGet
   1854          
   1855          /***************************************************************************//**
   1856           * @brief
   1857           *   Get HFRCODPLL band in use.
   1858           *
   1859           * @return
   1860           *   HFRCODPLL band in use.
   1861           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1862          CMU_HFRCODPLLFreq_TypeDef CMU_HFRCODPLLBandGet(void)
   1863          {
   1864            return (CMU_HFRCODPLLFreq_TypeDef)SystemHFRCODPLLClockGet();
   \                     CMU_HFRCODPLLBandGet: (+1)
   \        0x0   0x....'....        B.W      SystemHFRCODPLLClockGet
   1865          }
   1866          
   1867          /***************************************************************************//**
   1868           * @brief
   1869           *   Set HFRCODPLL band and the tuning value based on the value in the
   1870           *   calibration table made during production.
   1871           *
   1872           * @param[in] freq
   1873           *   HFRCODPLL frequency band to activate.
   1874           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1875          void CMU_HFRCODPLLBandSet(CMU_HFRCODPLLFreq_TypeDef freq)
   1876          {
   \                     CMU_HFRCODPLLBandSet: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4605             MOV      R5,R0
   1877            uint32_t freqCal, sysFreq;
   1878          
   1879            // Get calibration data from DEVINFO
   1880            freqCal = HFRCODPLLDevinfoGet(freq);
   \        0x4   0x....'....        BL       HFRCODPLLDevinfoGet
   \        0x8   0x4604             MOV      R4,R0
   1881            EFM_ASSERT((freqCal != 0UL) && (freqCal != UINT_MAX));
   1882          
   1883          #if defined(CMU_CLKEN0_DPLL0)
   1884            CMU->CLKEN0_SET = CMU_CLKEN0_DPLL0 | CMU_CLKEN0_HFRCO0;
   1885          #endif
   1886          
   1887            // Make sure DPLL is disabled before configuring
   1888            if (DPLL0->EN_CLR == DPLL_EN_EN) {
   \        0xA   0x....'....        LDR.W    R0,??DataTable27_16  ;; 0x4001e004
   \        0xE   0x6801             LDR      R1,[R0, #+0]
   \       0x10   0x2901             CMP      R1,#+1
   \       0x12   0xD107             BNE.N    ??CMU_HFRCODPLLBandSet_0
   1889              DPLL0->EN_CLR = DPLL_EN_EN;
   \       0x14   0x2201             MOVS     R2,#+1
   \       0x16   0x6002             STR      R2,[R0, #+0]
   \       0x18   0x....'....        LDR.W    R0,??DataTable27_20  ;; 0x4001c018
   1890              while ((DPLL0->STATUS & (DPLL_STATUS_ENS | DPLL_STATUS_RDY)) != 0UL) {
   \                     ??CMU_HFRCODPLLBandSet_1: (+1)
   \       0x1C   0x6801             LDR      R1,[R0, #+0]
   \       0x1E   0xF011 0x0F03      TST      R1,#0x3
   \       0x22   0xD1FB             BNE.N    ??CMU_HFRCODPLLBandSet_1
   1891              }
   1892            }
   1893          
   1894            // Update CMSIS HFRCODPLL frequency.
   1895            SystemHFRCODPLLClockSet(freq);
   \                     ??CMU_HFRCODPLLBandSet_0: (+1)
   \       0x24   0x4628             MOV      R0,R5
   \       0x26   0x....'....        BL       SystemHFRCODPLLClockSet
   1896          
   1897            // Set max wait-states and PCLK divisor while changing core clock
   1898            if (CMU_ClockSelectGet(cmuClock_SYSCLK) == cmuSelect_HFRCODPLL) {
   \       0x2A   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x2E   0x2804             CMP      R0,#+4
   \       0x30   0xD103             BNE.N    ??CMU_HFRCODPLLBandSet_2
   1899              waitStateMax();
   \       0x32   0x....'....        BL       waitStateMax
   1900              pclkDivMax();
   \       0x36   0x....'....        BL       pclkDivMax
   1901          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
   1902              // Set largest prescaler for radio clock tree
   1903              rhclkPrescMax();
   1904          #endif
   1905            }
   1906          
   1907            // Set divider for 1, 2 and 4MHz bands
   1908            freqCal &= ~_HFRCO_CAL_CLKDIV_MASK;
   1909            switch (freq) {
   \                     ??CMU_HFRCODPLLBandSet_2: (+1)
   \       0x3A   0x....'....        LDR.W    R0,??DataTable27_21  ;; 0xf4240
   \       0x3E   0xF024 0x7440      BIC      R4,R4,#0x3000000
   \       0x42   0x4285             CMP      R5,R0
   \       0x44   0xD006             BEQ.N    ??CMU_HFRCODPLLBandSet_3
   \       0x46   0x....'....        LDR.W    R0,??DataTable22_2  ;; 0x1e8480
   \       0x4A   0x4285             CMP      R5,R0
   \       0x4C   0xBF08             IT       EQ 
   \       0x4E   0xF044 0x7480      ORREQ    R4,R4,#0x1000000
   1910              case cmuHFRCODPLLFreq_1M0Hz:
   1911                freqCal |= HFRCO_CAL_CLKDIV_DIV4;
   1912                break;
   1913          
   1914              case cmuHFRCODPLLFreq_2M0Hz:
   1915                freqCal |= HFRCO_CAL_CLKDIV_DIV2;
   \       0x52   0xE001             B.N      ??CMU_HFRCODPLLBandSet_4
   \                     ??CMU_HFRCODPLLBandSet_3: (+1)
   \       0x54   0xF044 0x7400      ORR      R4,R4,#0x2000000
   1916                break;
   1917          
   1918              default:
   1919                break;
   1920            }
   1921          
   1922            // Activate new band selection
   1923            HFRCO0->CAL = freqCal;
   \                     ??CMU_HFRCODPLLBandSet_4: (+1)
   \       0x58   0x....'....        LDR.W    R0,??DataTable27_18  ;; 0x40010008
   \       0x5C   0x6004             STR      R4,[R0, #+0]
   1924          
   1925            // If HFRCODPLL is selected as SYSCLK (and HCLK), optimize flash access
   1926            // wait-state configuration and PCLK divisor for this frequency.
   1927            if (CMU_ClockSelectGet(cmuClock_SYSCLK) == cmuSelect_HFRCODPLL) {
   \       0x5E   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x62   0x2804             CMP      R0,#+4
   \       0x64   0xD100             BNE.N    ??CMU_HFRCODPLLBandSet_5
   1928              // Call @ref SystemCoreClockGet() to update CMSIS core clock variable.
   1929              sysFreq = SystemCoreClockGet();
   \       0x66   0x....             B.N      ?Subroutine1
   1930              EFM_ASSERT(sysFreq <= (uint32_t)freq);
   1931              CMU_UpdateWaitStates(sysFreq, 0);
   1932              pclkDivOptimize();
   1933          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_2)
   1934              // Set optimal RHCLK prescaler
   1935              rhclkPrescOptimize();
   1936          #endif
   1937            }
   1938          }
   \                     ??CMU_HFRCODPLLBandSet_5: (+1)
   \       0x68   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1939          
   1940          /**************************************************************************//**
   1941           * @brief
   1942           *   Initialize all HFXO control registers.
   1943           *
   1944           * @note
   1945           *   HFXO configuration should be obtained from a configuration tool,
   1946           *   app note or xtal datasheet. This function returns early if HFXO is
   1947           *   already selected as SYSCLK.
   1948           *
   1949           * @param[in] hfxoInit
   1950           *    HFXO setup parameters.
   1951           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   1952          void CMU_HFXOInit(const CMU_HFXOInit_TypeDef *hfxoInit)
   1953          {
   \                     CMU_HFXOInit: (+1)
   \        0x0   0xB5F8             PUSH     {R3-R7,LR}
   \        0x2   0x4604             MOV      R4,R0
   1954            // Check all initialization structure members which may overflow target
   1955            // bitfield.
   1956            EFM_ASSERT(hfxoInit->timeoutCbLsb
   1957                       <= (_HFXO_XTALCFG_TIMEOUTCBLSB_MASK
   1958                           >> _HFXO_XTALCFG_TIMEOUTCBLSB_SHIFT));
   1959            EFM_ASSERT(hfxoInit->timeoutSteadyFirstLock
   1960                       <= (_HFXO_XTALCFG_TIMEOUTSTEADY_MASK
   1961                           >> _HFXO_XTALCFG_TIMEOUTSTEADY_SHIFT));
   1962            EFM_ASSERT(hfxoInit->timeoutSteady
   1963                       <= (_HFXO_XTALCFG_TIMEOUTSTEADY_MASK
   1964                           >> _HFXO_XTALCFG_TIMEOUTSTEADY_SHIFT));
   1965            EFM_ASSERT(hfxoInit->ctuneXoStartup
   1966                       <= (_HFXO_XTALCFG_CTUNEXOSTARTUP_MASK
   1967                           >> _HFXO_XTALCFG_CTUNEXOSTARTUP_SHIFT));
   1968            EFM_ASSERT(hfxoInit->ctuneXiStartup
   1969                       <= (_HFXO_XTALCFG_CTUNEXISTARTUP_MASK
   1970                           >> _HFXO_XTALCFG_CTUNEXISTARTUP_SHIFT));
   1971            EFM_ASSERT(hfxoInit->coreBiasStartup
   1972                       <= (_HFXO_XTALCFG_COREBIASSTARTUP_MASK
   1973                           >> _HFXO_XTALCFG_COREBIASSTARTUP_SHIFT));
   1974            EFM_ASSERT(hfxoInit->imCoreBiasStartup
   1975                       <= (_HFXO_XTALCFG_COREBIASSTARTUPI_MASK
   1976                           >> _HFXO_XTALCFG_COREBIASSTARTUPI_SHIFT));
   1977            EFM_ASSERT(hfxoInit->coreDegenAna
   1978                       <= (_HFXO_XTALCTRL_COREDGENANA_MASK
   1979                           >> _HFXO_XTALCTRL_COREDGENANA_SHIFT));
   1980            EFM_ASSERT(hfxoInit->ctuneFixAna
   1981                       <= (_HFXO_XTALCTRL_CTUNEFIXANA_MASK
   1982                           >> _HFXO_XTALCTRL_CTUNEFIXANA_SHIFT));
   1983            EFM_ASSERT(hfxoInit->mode
   1984                       <= (_HFXO_CFG_MODE_MASK >> _HFXO_CFG_MODE_SHIFT));
   1985          
   1986            // Return early if HFXO is already selected as SYSCLK.
   1987            if (CMU_ClockSelectGet(cmuClock_SYSCLK) == cmuSelect_HFXO) {
   \        0x4   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_8: (+1)
   \        0x8   0x2803             CMP      R0,#+3
   \        0xA   0xD074             BEQ.N    ??CMU_HFXOInit_0
   1988              return;
   1989            }
   1990          
   1991          #if defined(CMU_CLKEN0_HFXO0)
   1992            // Enable HFXO module clock.
   1993            CMU->CLKEN0_SET = CMU_CLKEN0_HFXO0;
   1994          #endif
   1995          
   1996            // Unlock register interface.
   1997            HFXO0->LOCK = HFXO_LOCK_LOCKKEY_UNLOCK;
   \        0xC   0x....'....        LDR.W    R1,??DataTable27_22  ;; 0x4000c010
   \       0x10   0xF645 0x000E      MOVW     R0,#+22542
   \       0x14   0x6708             STR      R0,[R1, #+112]
   1998          
   1999            // Disable HFXO.
   2000            HFXO0->CTRL_SET = HFXO_CTRL_DISONDEMAND;
   \       0x16   0x....'....        LDR.W    R3,??DataTable27_23  ;; 0x4000d018
   \       0x1A   0x2202             MOVS     R2,#+2
   \       0x1C   0x611A             STR      R2,[R3, #+16]
   2001            HFXO0->CTRL_CLR = HFXO_CTRL_FORCEEN;
   \       0x1E   0x....'....        LDR.W    R2,??DataTable27_13  ;; 0x4000e028
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0x6010             STR      R0,[R2, #+0]
   2002            while ((HFXO0->STATUS & _HFXO_STATUS_ENS_MASK) != 0U) {
   \                     ??CMU_HFXOInit_1: (+1)
   \       0x26   0x6C8D             LDR      R5,[R1, #+72]
   \       0x28   0x03E8             LSLS     R0,R5,#+15
   \       0x2A   0xD4FC             BMI.N    ??CMU_HFXOInit_1
   2003            }
   2004          
   2005            // Configure HFXO as specified in initialization struct, use
   2006            // timeoutSteadyFirstLock as TIMEOUTSTEADY value.
   2007            HFXO0->XTALCFG =
   2008              (hfxoInit->timeoutCbLsb        << _HFXO_XTALCFG_TIMEOUTCBLSB_SHIFT)
   2009              | (hfxoInit->timeoutSteadyFirstLock
   2010                 << _HFXO_XTALCFG_TIMEOUTSTEADY_SHIFT)
   2011              | (hfxoInit->ctuneXoStartup    << _HFXO_XTALCFG_CTUNEXOSTARTUP_SHIFT)
   2012              | (hfxoInit->ctuneXiStartup    << _HFXO_XTALCFG_CTUNEXISTARTUP_SHIFT)
   2013              | (hfxoInit->coreBiasStartup   << _HFXO_XTALCFG_COREBIASSTARTUP_SHIFT)
   2014              | (hfxoInit->imCoreBiasStartup << _HFXO_XTALCFG_COREBIASSTARTUPI_SHIFT);
   \       0x2C   0x7866             LDRB     R6,[R4, #+1]
   \       0x2E   0x7825             LDRB     R5,[R4, #+0]
   \       0x30   0x78E0             LDRB     R0,[R4, #+3]
   \       0x32   0x0536             LSLS     R6,R6,#+20
   \       0x34   0xEA46 0x6605      ORR      R6,R6,R5, LSL #+24
   \       0x38   0x7925             LDRB     R5,[R4, #+4]
   \       0x3A   0x7967             LDRB     R7,[R4, #+5]
   \       0x3C   0xEA46 0x4600      ORR      R6,R6,R0, LSL #+16
   \       0x40   0x79A0             LDRB     R0,[R4, #+6]
   \       0x42   0xEA46 0x3605      ORR      R6,R6,R5, LSL #+12
   \       0x46   0xEA46 0x1687      ORR      R6,R6,R7, LSL #+6
   \       0x4A   0x4306             ORRS     R6,R0,R6
   \       0x4C   0x600E             STR      R6,[R1, #+0]
   2015          
   2016            HFXO0->XTALCTRL =
   2017              (hfxoInit->coreDegenAna    << _HFXO_XTALCTRL_COREDGENANA_SHIFT)
   2018              | (hfxoInit->ctuneFixAna   << _HFXO_XTALCTRL_CTUNEFIXANA_SHIFT)
   2019              | (hfxoInit->ctuneXoAna    << _HFXO_XTALCTRL_CTUNEXOANA_SHIFT)
   2020              | (hfxoInit->ctuneXiAna    << _HFXO_XTALCTRL_CTUNEXIANA_SHIFT)
   2021              | (hfxoInit->coreBiasAna   << _HFXO_XTALCTRL_COREBIASANA_SHIFT);
   \       0x4E   0x7A26             LDRB     R6,[R4, #+8]
   \       0x50   0x79E5             LDRB     R5,[R4, #+7]
   \       0x52   0x7A60             LDRB     R0,[R4, #+9]
   \       0x54   0x0636             LSLS     R6,R6,#+24
   \       0x56   0xEA46 0x6685      ORR      R6,R6,R5, LSL #+26
   \       0x5A   0x7AA5             LDRB     R5,[R4, #+10]
   \       0x5C   0xEA46 0x4600      ORR      R6,R6,R0, LSL #+16
   \       0x60   0x7AE0             LDRB     R0,[R4, #+11]
   \       0x62   0xEA46 0x2605      ORR      R6,R6,R5, LSL #+8
   \       0x66   0x4306             ORRS     R6,R0,R6
   \       0x68   0x608E             STR      R6,[R1, #+8]
   2022          
   2023            HFXO0->CFG = (HFXO0->CFG & ~(_HFXO_CFG_SQBUFSCHTRGANA_MASK
   2024                                         | _HFXO_CFG_ENXIDCBIASANA_MASK
   2025                                         | _HFXO_CFG_MODE_MASK))
   2026                         | ((hfxoInit->mode == cmuHfxoOscMode_Crystal)
   2027                            ? 0 : HFXO_CFG_SQBUFSCHTRGANA)
   2028                         | (hfxoInit->enXiDcBiasAna    << _HFXO_CFG_ENXIDCBIASANA_SHIFT)
   2029                         | (hfxoInit->mode             << _HFXO_CFG_MODE_SHIFT);
   \       0x6A   0x690D             LDR      R5,[R1, #+16]
   \       0x6C   0x7B60             LDRB     R0,[R4, #+13]
   \       0x6E   0x2800             CMP      R0,#+0
   \       0x70   0xF025 0x050D      BIC      R5,R5,#0xD
   \       0x74   0xBF0C             ITE      EQ 
   \       0x76   0x2600             MOVEQ    R6,#+0
   \       0x78   0x2608             MOVNE    R6,#+8
   \       0x7A   0x4335             ORRS     R5,R6,R5
   \       0x7C   0x7B26             LDRB     R6,[R4, #+12]
   \       0x7E   0xEA45 0x0586      ORR      R5,R5,R6, LSL #+2
   \       0x82   0x4305             ORRS     R5,R0,R5
   \       0x84   0x610D             STR      R5,[R1, #+16]
   2030          
   2031            if (hfxoInit->mode == cmuHfxoOscMode_Crystal) {
   \       0x86   0x7B60             LDRB     R0,[R4, #+13]
   \       0x88   0x7BE5             LDRB     R5,[R4, #+15]
   \       0x8A   0x7BA6             LDRB     R6,[R4, #+14]
   \       0x8C   0x2800             CMP      R0,#+0
   \       0x8E   0x6988             LDR      R0,[R1, #+24]
   \       0x90   0xF020 0x0033      BIC      R0,R0,#0x33
   \       0x94   0xEA40 0x1646      ORR      R6,R0,R6, LSL #+5
   \       0x98   0xEA46 0x1505      ORR      R5,R6,R5, LSL #+4
   \       0x9C   0xD120             BNE.N    ??CMU_HFXOInit_2
   2032              // Lock HFXO with FORCEEN bit set and DISONDEMAND bit cleared.
   2033              HFXO0->CTRL = (HFXO0->CTRL & ~(_HFXO_CTRL_FORCEXO2GNDANA_MASK
   2034                                             | _HFXO_CTRL_FORCEXI2GNDANA_MASK
   2035                                             | _HFXO_CTRL_DISONDEMAND_MASK
   2036                                             | _HFXO_CTRL_FORCEEN_MASK))
   2037                            | (hfxoInit->forceXo2GndAna << _HFXO_CTRL_FORCEXO2GNDANA_SHIFT)
   2038                            | (hfxoInit->forceXi2GndAna << _HFXO_CTRL_FORCEXI2GNDANA_SHIFT)
   2039                            | HFXO_CTRL_FORCEEN;
   \       0x9E   0xF045 0x0501      ORR      R5,R5,#0x1
   \       0xA2   0x618D             STR      R5,[R1, #+24]
   \       0xA4   0x....'....        LDR.W    R0,??DataTable27_24  ;; 0x40010003
   2040          
   2041              // Wait for HFXO lock and core bias algorithm to complete.
   2042              while ((HFXO0->STATUS & (HFXO_STATUS_RDY | HFXO_STATUS_COREBIASOPTRDY
   2043                                       | HFXO_STATUS_ENS | HFXO_STATUS_FSMLOCK))
   2044                     != (HFXO_STATUS_RDY | HFXO_STATUS_COREBIASOPTRDY | HFXO_STATUS_ENS
   2045                         | HFXO_STATUS_FSMLOCK)) {
   \                     ??CMU_HFXOInit_3: (+1)
   \       0xA8   0x6C8D             LDR      R5,[R1, #+72]
   \       0xAA   0x4005             ANDS     R5,R0,R5
   \       0xAC   0x4285             CMP      R5,R0
   \       0xAE   0xD1FB             BNE.N    ??CMU_HFXOInit_3
   2046              }
   2047          
   2048              // We must set DISONDEMAND to be able to enter new values for use on
   2049              // subsequent locks.
   2050              HFXO0->CTRL_SET = HFXO_CTRL_DISONDEMAND;
   \       0xB0   0x2002             MOVS     R0,#+2
   \       0xB2   0x6118             STR      R0,[R3, #+16]
   2051          #if defined(HFXO_CMD_MANUALOVERRIDE)
   2052              HFXO0->CMD = HFXO_CMD_MANUALOVERRIDE;
   2053          #endif
   2054              while ((HFXO0->STATUS & HFXO_STATUS_FSMLOCK) != 0) {
   \                     ??CMU_HFXOInit_4: (+1)
   \       0xB4   0x6C88             LDR      R0,[R1, #+72]
   \       0xB6   0x0045             LSLS     R5,R0,#+1
   \       0xB8   0xD4FC             BMI.N    ??CMU_HFXOInit_4
   2055              }
   2056          
   2057              // Set new TIMEOUTSTEADY value for use on subsequent locks.
   2058              HFXO0->XTALCFG = (HFXO0->XTALCFG & ~_HFXO_XTALCFG_TIMEOUTSTEADY_MASK)
   2059                               | (hfxoInit->timeoutSteady
   2060                                  << _HFXO_XTALCFG_TIMEOUTSTEADY_SHIFT);
   \       0xBA   0x6808             LDR      R0,[R1, #+0]
   \       0xBC   0x78A5             LDRB     R5,[R4, #+2]
   2061          
   2062              // Skip core bias algorithm on subsequent locks.
   2063              HFXO0->XTALCTRL_SET = HFXO_XTALCTRL_SKIPCOREBIASOPT;
   \       0xBE   0xF04F 0x4600      MOV      R6,#-2147483648
   \       0xC2   0xF420 0x0070      BIC      R0,R0,#0xF00000
   \       0xC6   0xEA40 0x5005      ORR      R0,R0,R5, LSL #+20
   \       0xCA   0x6008             STR      R0,[R1, #+0]
   \       0xCC   0x601E             STR      R6,[R3, #+0]
   2064          
   2065              if (hfxoInit->disOnDemand == false) {
   \       0xCE   0x7C20             LDRB     R0,[R4, #+16]
   \       0xD0   0xB908             CBNZ.N   R0,??CMU_HFXOInit_5
   2066                HFXO0->CTRL_CLR = HFXO_CTRL_DISONDEMAND;
   \       0xD2   0x2302             MOVS     R3,#+2
   \       0xD4   0x6013             STR      R3,[R2, #+0]
   2067              }
   2068          
   2069              if (hfxoInit->forceEn == false) {
   \                     ??CMU_HFXOInit_5: (+1)
   \       0xD6   0x7C60             LDRB     R0,[R4, #+17]
   \       0xD8   0xB940             CBNZ.N   R0,??CMU_HFXOInit_6
   2070                HFXO0->CTRL_CLR = HFXO_CTRL_FORCEEN;
   \       0xDA   0x2301             MOVS     R3,#+1
   \       0xDC   0x6013             STR      R3,[R2, #+0]
   \       0xDE   0xE005             B.N      ??CMU_HFXOInit_6
   2071              }
   2072            } else {
   2073              // Lock HFXO in EXTERNAL SINE mode.
   2074              HFXO0->CTRL = (HFXO0->CTRL & ~(_HFXO_CTRL_FORCEXO2GNDANA_MASK
   2075                                             | _HFXO_CTRL_FORCEXI2GNDANA_MASK
   2076                                             | _HFXO_CTRL_DISONDEMAND_MASK
   2077                                             | _HFXO_CTRL_FORCEEN_MASK))
   2078                            | (hfxoInit->forceXo2GndAna << _HFXO_CTRL_FORCEXO2GNDANA_SHIFT)
   2079                            | (hfxoInit->forceXi2GndAna << _HFXO_CTRL_FORCEXI2GNDANA_SHIFT)
   2080                            | (hfxoInit->disOnDemand    << _HFXO_CTRL_DISONDEMAND_SHIFT)
   2081                            | (hfxoInit->forceEn        << _HFXO_CTRL_FORCEEN_SHIFT);
   \                     ??CMU_HFXOInit_2: (+1)
   \       0xE0   0x7C22             LDRB     R2,[R4, #+16]
   \       0xE2   0x7C60             LDRB     R0,[R4, #+17]
   \       0xE4   0xEA45 0x0542      ORR      R5,R5,R2, LSL #+1
   \       0xE8   0x4305             ORRS     R5,R0,R5
   \       0xEA   0x618D             STR      R5,[R1, #+24]
   2082            }
   2083          
   2084            if (hfxoInit->regLock) {
   \                     ??CMU_HFXOInit_6: (+1)
   \       0xEC   0x7CA0             LDRB     R0,[R4, #+18]
   \       0xEE   0xB110             CBZ.N    R0,??CMU_HFXOInit_0
   2085              HFXO0->LOCK = ~HFXO_LOCK_LOCKKEY_UNLOCK;
   \       0xF0   0x....'....        LDR.W    R2,??DataTable27_25  ;; 0xffffa7f1
   \       0xF4   0x670A             STR      R2,[R1, #+112]
   2086            }
   2087          }
   \                     ??CMU_HFXOInit_0: (+1)
   \       0xF6   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   2088          
   2089          /**************************************************************************//**
   2090           * @brief
   2091           *   Initialize LFXO control registers.
   2092           *
   2093           * @note
   2094           *   LFXO configuration should be obtained from a configuration tool,
   2095           *   app note or xtal datasheet. This function disables the LFXO to ensure
   2096           *   a valid state before update.
   2097           *
   2098           * @param[in] lfxoInit
   2099           *    LFXO setup parameters
   2100           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2101          void CMU_LFXOInit(const CMU_LFXOInit_TypeDef *lfxoInit)
   2102          {
   \                     CMU_LFXOInit: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   2103            EFM_ASSERT(lfxoInit->timeout
   2104                       <= (_LFXO_CFG_TIMEOUT_MASK  >> _LFXO_CFG_TIMEOUT_SHIFT));
   2105            EFM_ASSERT(lfxoInit->mode
   2106                       <= (_LFXO_CFG_MODE_MASK >> _LFXO_CFG_MODE_SHIFT));
   2107            EFM_ASSERT(lfxoInit->gain
   2108                       <= (_LFXO_CAL_GAIN_MASK >> _LFXO_CAL_GAIN_SHIFT));
   2109            EFM_ASSERT(lfxoInit->capTune
   2110                       <= (_LFXO_CAL_CAPTUNE_MASK >> _LFXO_CAL_CAPTUNE_SHIFT));
   2111          
   2112            // Max internal capacitance tuning value is 0x4F (20 pF)
   2113            uint8_t ctune = SL_MIN(0x4FU, lfxoInit->capTune);
   \        0x2   0x7841             LDRB     R1,[R0, #+1]
   2114          
   2115          #if defined(CMU_CLKEN0_LFXO)
   2116            // Enable LFXO module clock.
   2117            CMU->CLKEN0_SET = CMU_CLKEN0_LFXO;
   2118          #endif
   2119          
   2120            // Unlock register interface
   2121            LFXO->LOCK = LFXO_LOCK_LOCKKEY_UNLOCK;
   \        0x4   0x....'....        LDR.W    R2,??DataTable27_26  ;; 0x40020004
   \        0x8   0xF44F 0x53D1      MOV      R3,#+6688
   \        0xC   0x2950             CMP      R1,#+80
   \        0xE   0x6213             STR      R3,[R2, #+32]
   2122          
   2123            // Disable LFXO
   2124            LFXO->CTRL_SET = LFXO_CTRL_DISONDEMAND;
   \       0x10   0x....'....        LDR.W    R5,??DataTable27_27  ;; 0x40021004
   \       0x14   0xBF28             IT       CS 
   \       0x16   0x214F             MOVCS    R1,#+79
   \       0x18   0x2402             MOVS     R4,#+2
   \       0x1A   0x602C             STR      R4,[R5, #+0]
   2125            LFXO->CTRL_CLR = LFXO_CTRL_FORCEEN;
   \       0x1C   0x2301             MOVS     R3,#+1
   \       0x1E   0x....'....        LDR.W    R6,??DataTable27_28  ;; 0x40022004
   \       0x22   0x6033             STR      R3,[R6, #+0]
   2126            while ((LFXO->STATUS & _LFXO_STATUS_ENS_MASK) != 0U) {
   \                     ??CMU_LFXOInit_0: (+1)
   \       0x24   0x68D3             LDR      R3,[R2, #+12]
   \       0x26   0x03DC             LSLS     R4,R3,#+15
   \       0x28   0xD4FC             BMI.N    ??CMU_LFXOInit_0
   2127            }
   2128          
   2129            // Configure LFXO as specified
   2130            LFXO->CAL = (lfxoInit->gain  << _LFXO_CAL_GAIN_SHIFT)
   2131                        | (ctune         << _LFXO_CAL_CAPTUNE_SHIFT);
   \       0x2A   0x7803             LDRB     R3,[R0, #+0]
   \       0x2C   0xEA41 0x2103      ORR      R1,R1,R3, LSL #+8
   \       0x30   0x6111             STR      R1,[R2, #+16]
   2132          
   2133            LFXO->CFG = (lfxoInit->timeout           << _LFXO_CFG_TIMEOUT_SHIFT)
   2134                        | (lfxoInit->mode            << _LFXO_CFG_MODE_SHIFT)
   2135                        | (lfxoInit->highAmplitudeEn << _LFXO_CFG_HIGHAMPL_SHIFT)
   2136                        | (lfxoInit->agcEn           << _LFXO_CFG_AGC_SHIFT);
   \       0x32   0x78C3             LDRB     R3,[R0, #+3]
   \       0x34   0x7881             LDRB     R1,[R0, #+2]
   \       0x36   0x7904             LDRB     R4,[R0, #+4]
   \       0x38   0x011B             LSLS     R3,R3,#+4
   \       0x3A   0xEA43 0x2301      ORR      R3,R3,R1, LSL #+8
   \       0x3E   0x7941             LDRB     R1,[R0, #+5]
   \       0x40   0xEA43 0x0344      ORR      R3,R3,R4, LSL #+1
   \       0x44   0x430B             ORRS     R3,R1,R3
   \       0x46   0x6053             STR      R3,[R2, #+4]
   2137          
   2138            LFXO->CTRL = (lfxoInit->failDetEM4WUEn   << _LFXO_CTRL_FAILDETEM4WUEN_SHIFT)
   2139                         | (lfxoInit->failDetEn      << _LFXO_CTRL_FAILDETEN_SHIFT)
   2140                         | (lfxoInit->disOnDemand    << _LFXO_CTRL_DISONDEMAND_SHIFT)
   2141                         | (lfxoInit->forceEn        << _LFXO_CTRL_FORCEEN_SHIFT);
   \       0x48   0x79C4             LDRB     R4,[R0, #+7]
   \       0x4A   0x7983             LDRB     R3,[R0, #+6]
   \       0x4C   0x7A41             LDRB     R1,[R0, #+9]
   \       0x4E   0x0124             LSLS     R4,R4,#+4
   \       0x50   0xEA44 0x1443      ORR      R4,R4,R3, LSL #+5
   \       0x54   0x7A03             LDRB     R3,[R0, #+8]
   \       0x56   0xEA44 0x0443      ORR      R4,R4,R3, LSL #+1
   \       0x5A   0x430C             ORRS     R4,R1,R4
   \       0x5C   0x6014             STR      R4,[R2, #+0]
   2142          
   2143            if (lfxoInit->regLock) {
   \       0x5E   0x7A80             LDRB     R0,[R0, #+10]
   \       0x60   0xB110             CBZ.N    R0,??CMU_LFXOInit_1
   2144              LFXO->LOCK = ~LFXO_LOCK_LOCKKEY_UNLOCK;
   \       0x62   0xF46F 0x51D1      MVN      R1,#+6688
   \       0x66   0x6211             STR      R1,[R2, #+32]
   2145            }
   2146          }
   \                     ??CMU_LFXOInit_1: (+1)
   \       0x68   0xBD70             POP      {R4-R6,PC}       ;; return
   2147          
   2148          /**************************************************************************//**
   2149           * @brief
   2150           *   Configure the LFRCO precision.
   2151           *
   2152           * @details
   2153           *   When enabling high precision mode on the LFRCO the hardware will tune
   2154           *   the oscillator automatically using the HFXO as a reference.
   2155           *
   2156           * @param[in] precision
   2157           *    LFRCO precision, this can be either high or default.
   2158           *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2159          void CMU_LFRCOSetPrecision(CMU_Precision_TypeDef precision)
   2160          {
   2161          #if defined(LFRCO_CFG_HIGHPRECEN)
   2162            EFM_ASSERT(38400000 == SystemHFXOClockGet());
   2163            CMU->CLKEN0_SET = CMU_CLKEN0_LFRCO;
   2164            LFRCO->CTRL = LFRCO_CTRL_DISONDEMAND; // Force disable
   2165            while ((LFRCO->STATUS & LFRCO_STATUS_ENS) != 0U) {
   2166              // Wait for LFRCO to stop
   2167            }
   2168          
   2169            if (precision == cmuPrecisionHigh) {
   2170              LFRCO->CFG = LFRCO_CFG_HIGHPRECEN;
   2171            } else {
   2172              LFRCO->CFG = 0;
   2173            }
   2174            LFRCO->CTRL = _LFRCO_CTRL_RESETVALUE;
   2175          #else
   2176            (void) precision;
   2177          #endif
   2178          }
   \                     CMU_LFRCOSetPrecision: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   2179          
   2180          /***************************************************************************//**
   2181           * @brief
   2182           *   Get oscillator frequency tuning setting.
   2183           *
   2184           * @param[in] osc
   2185           *   Oscillator to get tuning value for.
   2186           *
   2187           * @return
   2188           *   The oscillator frequency tuning setting in use.
   2189           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2190          uint32_t CMU_OscillatorTuningGet(CMU_Osc_TypeDef osc)
   2191          {
   \                     CMU_OscillatorTuningGet: (+1)
   \        0x0   0x4601             MOV      R1,R0
   2192            uint32_t ret = 0U;
   \        0x2   0x2000             MOVS     R0,#+0
   2193          
   2194            switch (osc) {
   \        0x4   0x2901             CMP      R1,#+1
   \        0x6   0xD004             BEQ.N    ??CMU_OscillatorTuningGet_0
   \        0x8   0x2904             CMP      R1,#+4
   \        0xA   0xD008             BEQ.N    ??CMU_OscillatorTuningGet_1
   \        0xC   0x2905             CMP      R1,#+5
   \        0xE   0xD009             BEQ.N    ??CMU_OscillatorTuningGet_2
   \       0x10   0x4770             BX       LR
   2195          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_1)
   2196              case cmuOsc_LFRCO:
   2197                ret = (LFRCO->CAL & _LFRCO_CAL_FREQTRIM_MASK)
   2198                      >> _LFRCO_CAL_FREQTRIM_SHIFT;
   \                     ??CMU_OscillatorTuningGet_0: (+1)
   \       0x12   0x....'....        LDR.W    R0,??DataTable27_29  ;; 0x4002400c
   \       0x16   0x6800             LDR      R0,[R0, #+0]
   \       0x18   0xF000 0x00FF      AND      R0,R0,#0xFF
   2199                break;
   \       0x1C   0x4770             BX       LR
   2200          #endif
   2201          
   2202              case cmuOsc_HFRCODPLL:
   2203          #if defined(CMU_CLKEN0_HFRCO0)
   2204                CMU->CLKEN0_SET = CMU_CLKEN0_HFRCO0;
   2205          #endif
   2206                ret = (HFRCO0->CAL & _HFRCO_CAL_TUNING_MASK) >> _HFRCO_CAL_TUNING_SHIFT;
   \                     ??CMU_OscillatorTuningGet_1: (+1)
   \       0x1E   0x....'....        LDR.W    R0,??DataTable27_18  ;; 0x40010008
   \       0x22   0xE000             B.N      ??CMU_OscillatorTuningGet_3
   2207                break;
   2208          
   2209          #if defined(HFRCOEM23_PRESENT)
   2210              case cmuOsc_HFRCOEM23:
   2211                ret = (HFRCOEM23->CAL & _HFRCO_CAL_TUNING_MASK)
   2212                      >> _HFRCO_CAL_TUNING_SHIFT;
   \                     ??CMU_OscillatorTuningGet_2: (+1)
   \       0x24   0x....             LDR.N    R0,??DataTable26  ;; 0x4a014008
   \                     ??CMU_OscillatorTuningGet_3: (+1)
   \       0x26   0x6800             LDR      R0,[R0, #+0]
   \       0x28   0xF000 0x007F      AND      R0,R0,#0x7F
   2213                break;
   2214          #endif
   2215          
   2216              default:
   2217                EFM_ASSERT(false);
   2218                break;
   2219            }
   2220          
   2221            return ret;
   \       0x2C   0x4770             BX       LR               ;; return
   2222          }
   2223          
   2224          /***************************************************************************//**
   2225           * @brief
   2226           *   Set the oscillator frequency tuning control.
   2227           *
   2228           * @note
   2229           *   Oscillator tuning is done during production, and the tuning value is
   2230           *   automatically loaded after a reset. Changing the tuning value from the
   2231           *   calibrated value is for more advanced use. Certain oscillators also have
   2232           *   build-in tuning optimization.
   2233           *
   2234           * @param[in] osc
   2235           *   Oscillator to set tuning value for.
   2236           *
   2237           * @param[in] val
   2238           *   The oscillator frequency tuning setting to use.
   2239           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2240          void CMU_OscillatorTuningSet(CMU_Osc_TypeDef osc, uint32_t val)
   2241          {
   2242            switch (osc) {
   \                     CMU_OscillatorTuningSet: (+1)
   \        0x0   0xF001 0x027F      AND      R2,R1,#0x7F
   \        0x4   0x2801             CMP      R0,#+1
   \        0x6   0xD004             BEQ.N    ??CMU_OscillatorTuningSet_0
   \        0x8   0x2804             CMP      R0,#+4
   \        0xA   0xD00F             BEQ.N    ??CMU_OscillatorTuningSet_1
   \        0xC   0x2805             CMP      R0,#+5
   \        0xE   0xD013             BEQ.N    ??CMU_OscillatorTuningSet_2
   \       0x10   0x4770             BX       LR
   2243          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_1)
   2244              case cmuOsc_LFRCO:
   2245                EFM_ASSERT(val <= (_LFRCO_CAL_FREQTRIM_MASK
   2246                                   >> _LFRCO_CAL_FREQTRIM_SHIFT));
   2247                val &= _LFRCO_CAL_FREQTRIM_MASK >> _LFRCO_CAL_FREQTRIM_SHIFT;
   \                     ??CMU_OscillatorTuningSet_0: (+1)
   \       0x12   0xF001 0x01FF      AND      R1,R1,#0xFF
   \       0x16   0x....'....        LDR.W    R2,??DataTable27_29  ;; 0x4002400c
   2248                while (LFRCO->SYNCBUSY != 0U) {
   \                     ??CMU_OscillatorTuningSet_3: (+1)
   \       0x1A   0x6910             LDR      R0,[R2, #+16]
   \       0x1C   0x2800             CMP      R0,#+0
   \       0x1E   0xD1FC             BNE.N    ??CMU_OscillatorTuningSet_3
   2249                }
   2250                LFRCO->CAL = (LFRCO->CAL & ~_LFRCO_CAL_FREQTRIM_MASK)
   2251                             | (val << _LFRCO_CAL_FREQTRIM_SHIFT);
   \       0x20   0x6813             LDR      R3,[R2, #+0]
   \       0x22   0x0A1B             LSRS     R3,R3,#+8
   \       0x24   0xEA41 0x2103      ORR      R1,R1,R3, LSL #+8
   \       0x28   0x6011             STR      R1,[R2, #+0]
   2252                break;
   \       0x2A   0x4770             BX       LR
   2253          #endif
   2254          
   2255              case cmuOsc_HFRCODPLL:
   2256          #if defined(CMU_CLKEN0_HFRCO0)
   2257                CMU->CLKEN0_SET = CMU_CLKEN0_HFRCO0;
   2258          #endif
   2259                EFM_ASSERT(val <= (_HFRCO_CAL_TUNING_MASK >> _HFRCO_CAL_TUNING_SHIFT));
   2260                val &= _HFRCO_CAL_TUNING_MASK >> _HFRCO_CAL_TUNING_SHIFT;
   2261                while ((HFRCO0->STATUS & HFRCO_STATUS_SYNCBUSY) != 0UL) {
   \                     ??CMU_OscillatorTuningSet_1: (+1)
   \       0x2C   0x....'....        LDR.W    R0,??DataTable27_18  ;; 0x40010008
   \       0x30   0x6841             LDR      R1,[R0, #+4]
   \       0x32   0x074B             LSLS     R3,R1,#+29
   \       0x34   0xD4FA             BMI.N    ??CMU_OscillatorTuningSet_1
   2262                }
   2263                HFRCO0->CAL = (HFRCO0->CAL & ~_HFRCO_CAL_TUNING_MASK)
   2264                              | (val << _HFRCO_CAL_TUNING_SHIFT);
   \       0x36   0xE003             B.N      ??CMU_OscillatorTuningSet_4
   2265                break;
   2266          
   2267          #if defined(HFRCOEM23_PRESENT)
   2268              case cmuOsc_HFRCOEM23:
   2269                EFM_ASSERT(val <= (_HFRCO_CAL_TUNING_MASK >> _HFRCO_CAL_TUNING_SHIFT));
   2270                val &= _HFRCO_CAL_TUNING_MASK >> _HFRCO_CAL_TUNING_SHIFT;
   2271                while ((HFRCOEM23->STATUS & HFRCO_STATUS_SYNCBUSY) != 0UL) {
   \                     ??CMU_OscillatorTuningSet_2: (+1)
   \       0x38   0x....             LDR.N    R0,??DataTable26  ;; 0x4a014008
   \       0x3A   0x6841             LDR      R1,[R0, #+4]
   \       0x3C   0x074B             LSLS     R3,R1,#+29
   \       0x3E   0xD4FB             BMI.N    ??CMU_OscillatorTuningSet_2
   2272                }
   2273                HFRCOEM23->CAL = (HFRCOEM23->CAL & ~_HFRCO_CAL_TUNING_MASK)
   2274                                 | (val << _HFRCO_CAL_TUNING_SHIFT);
   \                     ??CMU_OscillatorTuningSet_4: (+1)
   \       0x40   0x6801             LDR      R1,[R0, #+0]
   \       0x42   0x09C9             LSRS     R1,R1,#+7
   \       0x44   0xEA42 0x12C1      ORR      R2,R2,R1, LSL #+7
   \       0x48   0x6002             STR      R2,[R0, #+0]
   2275                break;
   2276          #endif
   2277          
   2278              default:
   2279                EFM_ASSERT(false);
   2280                break;
   2281            }
   2282          }
   \       0x4A   0x4770             BX       LR               ;; return
   2283          
   2284          /***************************************************************************//**
   2285           * @brief
   2286           *   Configure wait state settings necessary to switch to a given core clock
   2287           *   frequency at a certain voltage scale level.
   2288           *
   2289           * @details
   2290           *   This function will set up the necessary flash wait states. Updating the
   2291           *   wait state configuration must be done before increasing the clock
   2292           *   frequency and it must be done after decreasing the clock frequency.
   2293           *   Updating the wait state configuration must be done before core voltage is
   2294           *   decreased and it must be done after a core voltage is increased.
   2295           *
   2296           * @param[in] freq
   2297           *   The core clock frequency to configure wait-states.
   2298           *
   2299           * @param[in] vscale
   2300           *   The voltage scale to configure wait-states. Expected values are
   2301           *   0 or 1, higher number is lower voltage.
   2302           *   @li 0 = 1.1 V (VSCALE2)
   2303           *   @li 1 = 1.0 V (VSCALE1)
   2304           *
   2305           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2306          void CMU_UpdateWaitStates(uint32_t freq, int vscale)
   2307          {
   2308            flashWaitStateControl(freq, vscale);
   \                     CMU_UpdateWaitStates: (+1)
   \        0x0   0x....             B.N      flashWaitStateControl
   2309          }
   2310          
   2311          /*******************************************************************************
   2312           **************************   LOCAL FUNCTIONS   ********************************
   2313           ******************************************************************************/
   2314          
   2315          /***************************************************************************//**
   2316           * @brief
   2317           *   Get selected oscillator and frequency for @ref cmuClock_DPLLREFCLK
   2318           *   clock tree.
   2319           *
   2320           * @param[out] freq
   2321           *   The frequency.
   2322           *
   2323           * @param[out] sel
   2324           *   The selected oscillator.
   2325           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   2326          static void dpllRefClkGet(uint32_t *freq, CMU_Select_TypeDef *sel)
   2327          {
   \                     dpllRefClkGet: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460C             MOV      R4,R1
   2328            uint32_t f = 0U;
   2329            CMU_Select_TypeDef s;
   2330          
   2331            switch (CMU->DPLLREFCLKCTRL & _CMU_DPLLREFCLKCTRL_CLKSEL_MASK) {
   \        0x4   0x....             LDR.N    R1,??DataTable27_10  ;; 0x40008100
   \        0x6   0x....'....        BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_7: (+1)
   \        0xA   0x2A03             CMP      R2,#+3
   \        0xC   0xD811             BHI.N    ??dpllRefClkGet_1
   \        0xE   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??dpllRefClkGet_0:
   \       0x12   0x0E 0x02          DC8      0xE,0x2,0x6,0xA
   \              0x06 0x0A    
   2332              case _CMU_DPLLREFCLKCTRL_CLKSEL_HFXO:
   2333                f = SystemHFXOClockGet();
   \                     ??dpllRefClkGet_2: (+1)
   \       0x16   0x....'....        BL       SystemHFXOClockGet
   2334                s = cmuSelect_HFXO;
   \       0x1A   0x2103             MOVS     R1,#+3
   2335                break;
   \       0x1C   0xE00A             B.N      ??dpllRefClkGet_3
   2336          
   2337              case _CMU_DPLLREFCLKCTRL_CLKSEL_LFXO:
   2338                f = SystemLFXOClockGet();
   \                     ??dpllRefClkGet_4: (+1)
   \       0x1E   0x....'....        BL       SystemLFXOClockGet
   2339                s = cmuSelect_LFXO;
   \       0x22   0x2107             MOVS     R1,#+7
   2340                break;
   \       0x24   0xE006             B.N      ??dpllRefClkGet_3
   2341          
   2342              case _CMU_DPLLREFCLKCTRL_CLKSEL_CLKIN0:
   2343                f = SystemCLKIN0Get();
   \                     ??dpllRefClkGet_5: (+1)
   \       0x26   0x....'....        BL       SystemCLKIN0Get
   2344                s = cmuSelect_CLKIN0;
   \       0x2A   0x2106             MOVS     R1,#+6
   2345                break;
   \       0x2C   0xE002             B.N      ??dpllRefClkGet_3
   2346          
   2347              case _CMU_DPLLREFCLKCTRL_CLKSEL_DISABLED:
   2348                s = cmuSelect_Disabled;
   \                     ??dpllRefClkGet_6: (+1)
   \       0x2E   0x2101             MOVS     R1,#+1
   2349                break;
   \       0x30   0xE000             B.N      ??dpllRefClkGet_3
   2350          
   2351              default:
   2352                s = cmuSelect_Error;
   \                     ??dpllRefClkGet_1: (+1)
   \       0x32   0x2100             MOVS     R1,#+0
   2353                EFM_ASSERT(false);
   2354                break;
   2355            }
   2356          
   2357            if (freq != NULL) {
   \                     ??dpllRefClkGet_3: (+1)
   \       0x34   0x....             B.N      ??Subroutine0_0
   2358              *freq = f;
   2359            }
   2360            if (sel != NULL) {
   2361              *sel = s;
   2362            }
   2363          }
   2364          
   2365          /***************************************************************************//**
   2366           * @brief
   2367           *   Get selected oscillator and frequency for @ref cmuClock_EM01GRPACLK
   2368           *   clock tree.
   2369           *
   2370           * @param[out] freq
   2371           *   The frequency.
   2372           *
   2373           * @param[out] sel
   2374           *   The selected oscillator.
   2375           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   2376          static void em01GrpaClkGet(uint32_t *freq, CMU_Select_TypeDef *sel)
   2377          {
   \                     em01GrpaClkGet: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460C             MOV      R4,R1
   2378            uint32_t f = 0U;
   2379            CMU_Select_TypeDef s;
   2380          
   2381            switch (CMU->EM01GRPACLKCTRL & _CMU_EM01GRPACLKCTRL_CLKSEL_MASK) {
   \        0x4   0x....             LDR.N    R1,??DataTable27_30  ;; 0x40008120
   \        0x6   0x....'....        BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_4: (+1)
   \        0xA   0xD813             BHI.N    ??em01GrpaClkGet_1
   \        0xC   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??em01GrpaClkGet_0:
   \       0x10   0x02 0x06          DC8      0x2,0x6,0xA,0xE
   \              0x0A 0x0E    
   2382              case _CMU_EM01GRPACLKCTRL_CLKSEL_HFRCODPLL:
   2383                f = SystemHFRCODPLLClockGet();
   \                     ??em01GrpaClkGet_2: (+1)
   \       0x14   0x....'....        BL       SystemHFRCODPLLClockGet
   2384                s = cmuSelect_HFRCODPLL;
   \       0x18   0x2104             MOVS     R1,#+4
   2385                break;
   \       0x1A   0xE00C             B.N      ??em01GrpaClkGet_3
   2386          
   2387              case _CMU_EM01GRPACLKCTRL_CLKSEL_HFXO:
   2388                f = SystemHFXOClockGet();
   \                     ??em01GrpaClkGet_4: (+1)
   \       0x1C   0x....'....        BL       SystemHFXOClockGet
   2389                s = cmuSelect_HFXO;
   \       0x20   0x2103             MOVS     R1,#+3
   2390                break;
   \       0x22   0xE008             B.N      ??em01GrpaClkGet_3
   2391          
   2392          #if defined(HFRCOEM23_PRESENT)
   2393              case _CMU_EM01GRPACLKCTRL_CLKSEL_HFRCOEM23:
   2394                f = SystemHFRCOEM23ClockGet();
   \                     ??em01GrpaClkGet_5: (+1)
   \       0x24   0x....'....        BL       SystemHFRCOEM23ClockGet
   2395                s = cmuSelect_HFRCOEM23;
   \       0x28   0x2105             MOVS     R1,#+5
   2396                break;
   \       0x2A   0xE004             B.N      ??em01GrpaClkGet_3
   2397          #endif
   2398          
   2399              case _CMU_EM01GRPACLKCTRL_CLKSEL_FSRCO:
   2400                f = SystemFSRCOClockGet();
   \                     ??em01GrpaClkGet_6: (+1)
   \       0x2C   0x....'....        BL       SystemFSRCOClockGet
   2401                s = cmuSelect_FSRCO;
   \       0x30   0x2102             MOVS     R1,#+2
   2402                break;
   \       0x32   0xE000             B.N      ??em01GrpaClkGet_3
   2403          
   2404              default:
   2405                s = cmuSelect_Error;
   \                     ??em01GrpaClkGet_1: (+1)
   \       0x34   0x2100             MOVS     R1,#+0
   2406                EFM_ASSERT(false);
   2407                break;
   2408            }
   2409          
   2410            if (freq != NULL) {
   \                     ??em01GrpaClkGet_3: (+1)
   \       0x36   0x....             B.N      ??Subroutine0_0
   2411              *freq = f;
   2412            }
   2413            if (sel != NULL) {
   2414              *sel = s;
   2415            }
   2416          }
   2417          
   2418          /***************************************************************************//**
   2419           * @brief
   2420           *   Get selected oscillator and frequency for @ref cmuClock_EM23GRPACLK
   2421           *   clock tree.
   2422           *
   2423           * @param[out] freq
   2424           *   The frequency.
   2425           *
   2426           * @param[out] sel
   2427           *   The selected oscillator.
   2428           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2429          static void em23GrpaClkGet(uint32_t *freq, CMU_Select_TypeDef *sel)
   2430          {
   \                     em23GrpaClkGet: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460C             MOV      R4,R1
   2431            uint32_t f = 0U;
   2432            CMU_Select_TypeDef s;
   2433          
   2434            switch (CMU->EM23GRPACLKCTRL & _CMU_EM23GRPACLKCTRL_CLKSEL_MASK) {
   \        0x4   0x....             LDR.N    R1,??DataTable27_31  ;; 0x40008140
   \        0x6   0x....             B.N      ?Subroutine0
   2435              case _CMU_EM23GRPACLKCTRL_CLKSEL_LFRCO:
   2436                f = SystemLFRCOClockGet();
   2437                s = cmuSelect_LFRCO;
   2438                break;
   2439          
   2440              case _CMU_EM23GRPACLKCTRL_CLKSEL_LFXO:
   2441                f = SystemLFXOClockGet();
   2442                s = cmuSelect_LFXO;
   2443                break;
   2444          
   2445              case _CMU_EM23GRPACLKCTRL_CLKSEL_ULFRCO:
   2446                f = SystemULFRCOClockGet();
   2447                s = cmuSelect_ULFRCO;
   2448                break;
   2449          
   2450              default:
   2451                s = cmuSelect_Error;
   2452                EFM_ASSERT(false);
   2453                break;
   2454            }
   2455          
   2456            if (freq != NULL) {
   2457              *freq = f;
   2458            }
   2459            if (sel != NULL) {
   2460              *sel = s;
   2461            }
   2462          }
   2463          
   2464          /***************************************************************************//**
   2465           * @brief
   2466           *   Get selected oscillator and frequency for @ref cmuClock_EM4GRPACLK
   2467           *   clock tree.
   2468           *
   2469           * @param[out] freq
   2470           *   The frequency.
   2471           *
   2472           * @param[out] sel
   2473           *   The selected oscillator.
   2474           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2475          static void em4GrpaClkGet(uint32_t *freq, CMU_Select_TypeDef *sel)
   2476          {
   \                     em4GrpaClkGet: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460C             MOV      R4,R1
   2477            uint32_t f = 0U;
   2478            CMU_Select_TypeDef s;
   2479          
   2480            switch (CMU->EM4GRPACLKCTRL & _CMU_EM4GRPACLKCTRL_CLKSEL_MASK) {
   \        0x4   0x....             LDR.N    R1,??DataTable27_32  ;; 0x40008160
   \        0x6                      REQUIRE ?Subroutine0
   \        0x6                      ;; // Fall through to label ?Subroutine0
   2481              case _CMU_EM4GRPACLKCTRL_CLKSEL_LFRCO:
   2482                f = SystemLFRCOClockGet();
   2483                s = cmuSelect_LFRCO;
   2484                break;
   2485          
   2486              case _CMU_EM4GRPACLKCTRL_CLKSEL_LFXO:
   2487                f = SystemLFXOClockGet();
   2488                s = cmuSelect_LFXO;
   2489                break;
   2490          
   2491              case _CMU_EM4GRPACLKCTRL_CLKSEL_ULFRCO:
   2492                f = SystemULFRCOClockGet();
   2493                s = cmuSelect_ULFRCO;
   2494                break;
   2495          
   2496              default:
   2497                s = cmuSelect_Error;
   2498                EFM_ASSERT(false);
   2499                break;
   2500            }
   2501          
   2502            if (freq != NULL) {
   2503              *freq = f;
   2504            }
   2505            if (sel != NULL) {
   2506              *sel = s;
   2507            }
   2508          }
   2509          
   2510          /***************************************************************************//**
   2511           * @brief
   2512           *   Configure flash access wait states to support the given core clock
   2513           *   frequency and vscale level.
   2514           *
   2515           * @note Current implementation sets wait states depending on frequency only.
   2516           *   This assumes that applications running on Series 2 Config 2 devices
   2517           *   never attemtps to set core frequency above 40MHz at VSCALE1 (1.0V).
   2518           *   Series 2 Config 1 devices does not support vscale.
   2519           *
   2520           * @param[in] coreFreq
   2521           *   The core clock frequency to configure flash wait-states.
   2522           *
   2523           * @param[in] vscale
   2524           *   Voltage Scale level. Supported levels are 0 and 1 where 0 is the default.
   2525           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2526          static void flashWaitStateControl(uint32_t coreFreq, int vscale)
   2527          {
   2528            (void)vscale;
   2529            uint32_t mode;
   2530            bool mscLocked;
   2531          
   2532          #if defined(CMU_CLKEN1_MSC)
   2533            CMU->CLKEN1_SET = CMU_CLKEN1_MSC;
   2534          #endif
   2535          
   2536            // Make sure the MSC is unlocked
   2537            mscLocked = (MSC->STATUS & _MSC_STATUS_REGLOCK_MASK)
   2538                        == MSC_STATUS_REGLOCK_LOCKED;
   2539            MSC->LOCK = MSC_LOCK_LOCKKEY_UNLOCK;
   \                     flashWaitStateControl: (+1)
   \        0x0   0xF641 0x3371      MOVW     R3,#+7025
   \        0x4   0xB530             PUSH     {R4,R5,LR}
   2540          
   2541            // Get current flash read setting
   2542            mode = MSC->READCTRL & ~_MSC_READCTRL_MODE_MASK;
   2543          
   2544            // Set new mode based on the core clock frequency
   2545            if (coreFreq <= CMU_MAX_FLASHREAD_FREQ_0WS) {
   \        0x6   0x....             LDR.N    R4,??DataTable27_33  ;; 0x25317c1
   \        0x8   0x....             LDR.N    R1,??DataTable27_34  ;; 0x40030008
   2546              mode |= MSC_READCTRL_MODE_WS0;
   2547            } else {
   2548              mode |= MSC_READCTRL_MODE_WS1;
   2549            }
   2550            MSC->READCTRL = mode;
   2551          
   2552          #if defined(_SILICON_LABS_32B_SERIES_2_CONFIG_1)
   2553            // Get current sram read setting
   2554            mode = SYSCFG->DMEM0RAMCTRL & ~_SYSCFG_DMEM0RAMCTRL_RAMWSEN_MASK;
   2555          
   2556            // Set new mode based on the core clock frequency
   2557            if (coreFreq > CMU_MAX_SRAM_FREQ_0WS) {
   \        0xA   0x....             LDR.N    R5,??DataTable27_35  ;; 0x2faf081
   \        0xC   0x694A             LDR      R2,[R1, #+20]
   \        0xE   0x634B             STR      R3,[R1, #+52]
   \       0x10   0x680B             LDR      R3,[R1, #+0]
   \       0x12   0x0C12             LSRS     R2,R2,#+16
   \       0x14   0x42A0             CMP      R0,R4
   \       0x16   0xF423 0x1340      BIC      R3,R3,#0x300000
   \       0x1A   0x....             LDR.N    R4,??DataTable27_36  ;; 0x4007c218
   \       0x1C   0xF002 0x0201      AND      R2,R2,#0x1
   \       0x20   0xBF28             IT       CS 
   \       0x22   0xF443 0x1380      ORRCS    R3,R3,#0x100000
   \       0x26   0x600B             STR      R3,[R1, #+0]
   \       0x28   0x6823             LDR      R3,[R4, #+0]
   \       0x2A   0x42A8             CMP      R0,R5
   \       0x2C   0xF023 0x0302      BIC      R3,R3,#0x2
   \       0x30   0xBF28             IT       CS 
   \       0x32   0xF043 0x0302      ORRCS    R3,R3,#0x2
   2558              mode |= 1 << _SYSCFG_DMEM0RAMCTRL_RAMWSEN_SHIFT;
   2559            }
   2560            SYSCFG->DMEM0RAMCTRL = mode;
   \       0x36   0x6023             STR      R3,[R4, #+0]
   2561          #endif
   2562          
   2563            if (mscLocked) {
   \       0x38   0xB10A             CBZ.N    R2,??flashWaitStateControl_0
   2564              MSC->LOCK = MSC_LOCK_LOCKKEY_LOCK;
   \       0x3A   0x2000             MOVS     R0,#+0
   \       0x3C   0x6348             STR      R0,[R1, #+52]
   2565            }
   2566          }
   \                     ??flashWaitStateControl_0: (+1)
   \       0x3E   0xBD30             POP      {R4,R5,PC}       ;; return
   2567          
   2568          /***************************************************************************//**
   2569           * @brief
   2570           *   Get calibrated HFRCODPLL tuning value from Device information (DI) page
   2571           *   for a given frequency. Calibration value is not available for all frequency
   2572           *   bands.
   2573           *
   2574           * @param[in] freq
   2575           *   HFRCODPLL frequency band
   2576           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2577          static uint32_t HFRCODPLLDevinfoGet(CMU_HFRCODPLLFreq_TypeDef freq)
   2578          {
   \                     HFRCODPLLDevinfoGet: (+1)
   \        0x0   0x4601             MOV      R1,R0
   2579            uint32_t ret = 0U;
   \        0x2   0x2000             MOVS     R0,#+0
   2580          
   2581            switch (freq) {
   \        0x4   0x....             LDR.N    R3,??DataTable27_21  ;; 0xf4240
   \        0x6   0x4299             CMP      R1,R3
   \        0x8   0x....             LDR.N    R2,??DataTable27_37  ;; 0xfe08058
   \        0xA   0xBF1F             ITTTT    NE 
   \        0xC   0x....             LDRNE.N  R3,??DataTable27_38  ;; 0x1e8480
   \        0xE   0x4299             CMPNE    R1,R3
   \       0x10   0x....             LDRNE.N  R3,??DataTable27_39  ;; 0x3d0900
   \       0x12   0x4299             CMPNE    R1,R3
   \       0x14   0xD021             BEQ.N    ??HFRCODPLLDevinfoGet_0
   \       0x16   0x....             LDR.N    R3,??DataTable27_40  ;; 0x6acfc0
   \       0x18   0x4299             CMP      R1,R3
   \       0x1A   0xD020             BEQ.N    ??HFRCODPLLDevinfoGet_1
   \       0x1C   0x....             LDR.N    R3,??DataTable27_41  ;; 0xc65d40
   \       0x1E   0x4299             CMP      R1,R3
   \       0x20   0xD01F             BEQ.N    ??HFRCODPLLDevinfoGet_2
   \       0x22   0x....             LDR.N    R3,??DataTable27_42  ;; 0xf42400
   \       0x24   0x4299             CMP      R1,R3
   \       0x26   0xD01E             BEQ.N    ??HFRCODPLLDevinfoGet_3
   \       0x28   0x....             LDR.N    R3,??DataTable27_43  ;; 0x121eac0
   \       0x2A   0x4299             CMP      R1,R3
   \       0x2C   0xD01D             BEQ.N    ??HFRCODPLLDevinfoGet_4
   \       0x2E   0x....             LDR.N    R3,??DataTable27_44  ;; 0x18cba80
   \       0x30   0x4299             CMP      R1,R3
   \       0x32   0xD01C             BEQ.N    ??HFRCODPLLDevinfoGet_5
   \       0x34   0x....             LDR.N    R3,??DataTable27_45  ;; 0x1e84800
   \       0x36   0x4299             CMP      R1,R3
   \       0x38   0xD01B             BEQ.N    ??HFRCODPLLDevinfoGet_6
   \       0x3A   0x....             LDR.N    R3,??DataTable27_46  ;; 0x243d580
   \       0x3C   0x4299             CMP      R1,R3
   \       0x3E   0xD01A             BEQ.N    ??HFRCODPLLDevinfoGet_7
   \       0x40   0x....             LDR.N    R3,??DataTable27_47  ;; 0x2dc6c00
   \       0x42   0x4299             CMP      R1,R3
   \       0x44   0xD019             BEQ.N    ??HFRCODPLLDevinfoGet_8
   \       0x46   0x....             LDR.N    R3,??DataTable27_48  ;; 0x3567e00
   \       0x48   0x4299             CMP      R1,R3
   \       0x4A   0xD018             BEQ.N    ??HFRCODPLLDevinfoGet_9
   \       0x4C   0x....             LDR.N    R3,??DataTable27_49  ;; 0x3d09000
   \       0x4E   0x4299             CMP      R1,R3
   \       0x50   0xD017             BEQ.N    ??HFRCODPLLDevinfoGet_10
   \       0x52   0x....             LDR.N    R3,??DataTable27_50  ;; 0x4c4b400
   \       0x54   0x4299             CMP      R1,R3
   \       0x56   0xD016             BEQ.N    ??HFRCODPLLDevinfoGet_11
   \       0x58   0x4770             BX       LR
   2582              // 1, 2 and 4MHz share the same calibration word
   2583              case cmuHFRCODPLLFreq_1M0Hz:
   2584              case cmuHFRCODPLLFreq_2M0Hz:
   2585              case cmuHFRCODPLLFreq_4M0Hz:
   2586                ret = DEVINFO->HFRCODPLLCAL[0].HFRCODPLLCAL;
   \                     ??HFRCODPLLDevinfoGet_0: (+1)
   \       0x5A   0x6810             LDR      R0,[R2, #+0]
   2587                break;
   \       0x5C   0x4770             BX       LR
   2588          
   2589              case cmuHFRCODPLLFreq_7M0Hz:
   2590                ret = DEVINFO->HFRCODPLLCAL[3].HFRCODPLLCAL;
   \                     ??HFRCODPLLDevinfoGet_1: (+1)
   \       0x5E   0x68D0             LDR      R0,[R2, #+12]
   2591                break;
   \       0x60   0x4770             BX       LR
   2592          
   2593              case cmuHFRCODPLLFreq_13M0Hz:
   2594                ret = DEVINFO->HFRCODPLLCAL[6].HFRCODPLLCAL;
   \                     ??HFRCODPLLDevinfoGet_2: (+1)
   \       0x62   0x6990             LDR      R0,[R2, #+24]
   2595                break;
   \       0x64   0x4770             BX       LR
   2596          
   2597              case cmuHFRCODPLLFreq_16M0Hz:
   2598                ret = DEVINFO->HFRCODPLLCAL[7].HFRCODPLLCAL;
   \                     ??HFRCODPLLDevinfoGet_3: (+1)
   \       0x66   0x69D0             LDR      R0,[R2, #+28]
   2599                break;
   \       0x68   0x4770             BX       LR
   2600          
   2601              case cmuHFRCODPLLFreq_19M0Hz:
   2602                ret = DEVINFO->HFRCODPLLCAL[8].HFRCODPLLCAL;
   \                     ??HFRCODPLLDevinfoGet_4: (+1)
   \       0x6A   0x6A10             LDR      R0,[R2, #+32]
   2603                break;
   \       0x6C   0x4770             BX       LR
   2604          
   2605              case cmuHFRCODPLLFreq_26M0Hz:
   2606                ret = DEVINFO->HFRCODPLLCAL[10].HFRCODPLLCAL;
   \                     ??HFRCODPLLDevinfoGet_5: (+1)
   \       0x6E   0x6A90             LDR      R0,[R2, #+40]
   2607                break;
   \       0x70   0x4770             BX       LR
   2608          
   2609              case cmuHFRCODPLLFreq_32M0Hz:
   2610                ret = DEVINFO->HFRCODPLLCAL[11].HFRCODPLLCAL;
   \                     ??HFRCODPLLDevinfoGet_6: (+1)
   \       0x72   0x6AD0             LDR      R0,[R2, #+44]
   2611                break;
   \       0x74   0x4770             BX       LR
   2612          
   2613              case cmuHFRCODPLLFreq_38M0Hz:
   2614                ret = DEVINFO->HFRCODPLLCAL[12].HFRCODPLLCAL;
   \                     ??HFRCODPLLDevinfoGet_7: (+1)
   \       0x76   0x6B10             LDR      R0,[R2, #+48]
   2615                break;
   \       0x78   0x4770             BX       LR
   2616          
   2617              case cmuHFRCODPLLFreq_48M0Hz:
   2618                ret = DEVINFO->HFRCODPLLCAL[13].HFRCODPLLCAL;
   \                     ??HFRCODPLLDevinfoGet_8: (+1)
   \       0x7A   0x6B50             LDR      R0,[R2, #+52]
   2619                break;
   \       0x7C   0x4770             BX       LR
   2620          
   2621              case cmuHFRCODPLLFreq_56M0Hz:
   2622                ret = DEVINFO->HFRCODPLLCAL[14].HFRCODPLLCAL;
   \                     ??HFRCODPLLDevinfoGet_9: (+1)
   \       0x7E   0x6B90             LDR      R0,[R2, #+56]
   2623                break;
   \       0x80   0x4770             BX       LR
   2624          
   2625              case cmuHFRCODPLLFreq_64M0Hz:
   2626                ret = DEVINFO->HFRCODPLLCAL[15].HFRCODPLLCAL;
   \                     ??HFRCODPLLDevinfoGet_10: (+1)
   \       0x82   0x6BD0             LDR      R0,[R2, #+60]
   2627                break;
   \       0x84   0x4770             BX       LR
   2628          
   2629              case cmuHFRCODPLLFreq_80M0Hz:
   2630                ret = DEVINFO->HFRCODPLLCAL[16].HFRCODPLLCAL;
   \                     ??HFRCODPLLDevinfoGet_11: (+1)
   \       0x86   0x6C10             LDR      R0,[R2, #+64]
   2631                break;
   2632          
   2633              case cmuHFRCODPLLFreq_UserDefined:
   2634                break;
   2635          
   2636              default:
   2637                EFM_ASSERT(false);
   2638                break;
   2639            }
   2640            return ret;
   \       0x88   0x4770             BX       LR               ;; return
   2641          }
   2642          
   2643          /***************************************************************************//**
   2644           * @brief
   2645           *   Get selected oscillator and frequency for @ref cmuClock_IADCCLK
   2646           *   clock tree.
   2647           *
   2648           * @param[out] freq
   2649           *   The frequency.
   2650           *
   2651           * @param[out] sel
   2652           *   The selected oscillator.
   2653           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2654          static void iadcClkGet(uint32_t *freq, CMU_Select_TypeDef *sel)
   2655          {
   \                     iadcClkGet: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x4604             MOV      R4,R0
   \        0x4   0x460D             MOV      R5,R1
   2656            uint32_t f = 0U;
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x9000             STR      R0,[SP, #+0]
   2657            CMU_Select_TypeDef s;
   2658          
   2659            switch (CMU->IADCCLKCTRL & _CMU_IADCCLKCTRL_CLKSEL_MASK) {
   \        0xA   0x....             LDR.N    R1,??DataTable27_14  ;; 0x40008180
   \        0xC   0x680A             LDR      R2,[R1, #+0]
   \        0xE   0xF002 0x0203      AND      R2,R2,#0x3
   \       0x12   0x2A01             CMP      R2,#+1
   \       0x14   0xD004             BEQ.N    ??iadcClkGet_0
   \       0x16   0xD312             BCC.N    ??iadcClkGet_1
   \       0x18   0x2A03             CMP      R2,#+3
   \       0x1A   0xD00C             BEQ.N    ??iadcClkGet_2
   \       0x1C   0xD306             BCC.N    ??iadcClkGet_3
   \       0x1E   0xE00E             B.N      ??iadcClkGet_1
   2660              case _CMU_IADCCLKCTRL_CLKSEL_EM01GRPACLK:
   2661                em01GrpaClkGet(&f, NULL);
   \                     ??iadcClkGet_0: (+1)
   \       0x20   0x2100             MOVS     R1,#+0
   \       0x22   0x4668             MOV      R0,SP
   \       0x24   0x....'....        BL       em01GrpaClkGet
   2662                s = cmuSelect_EM01GRPACLK;
   \       0x28   0x200D             MOVS     R0,#+13
   2663                break;
   \       0x2A   0xE008             B.N      ??iadcClkGet_1
   2664          
   2665          #if defined(HFRCOEM23_PRESENT)
   2666              case _CMU_IADCCLKCTRL_CLKSEL_HFRCOEM23:
   2667                f = SystemHFRCOEM23ClockGet();
   \                     ??iadcClkGet_3: (+1)
   \       0x2C   0x....'....        BL       SystemHFRCOEM23ClockGet
   \       0x30   0x9000             STR      R0,[SP, #+0]
   2668                s = cmuSelect_HFRCOEM23;
   \       0x32   0x2005             MOVS     R0,#+5
   2669                break;
   \       0x34   0xE003             B.N      ??iadcClkGet_1
   2670          #endif
   2671          
   2672              case _CMU_IADCCLKCTRL_CLKSEL_FSRCO:
   2673                f = SystemFSRCOClockGet();
   \                     ??iadcClkGet_2: (+1)
   \       0x36   0x....'....        BL       SystemFSRCOClockGet
   \       0x3A   0x9000             STR      R0,[SP, #+0]
   2674                s = cmuSelect_FSRCO;
   \       0x3C   0x2002             MOVS     R0,#+2
   2675                break;
   2676          
   2677              default:
   2678                s = cmuSelect_Error;
   2679                EFM_ASSERT(false);
   2680                break;
   2681            }
   2682          
   2683            if (freq != NULL) {
   \                     ??iadcClkGet_1: (+1)
   \       0x3E   0xB10C             CBZ.N    R4,??iadcClkGet_4
   2684              *freq = f;
   \       0x40   0x9900             LDR      R1,[SP, #+0]
   \       0x42   0x6021             STR      R1,[R4, #+0]
   2685            }
   2686            if (sel != NULL) {
   \                     ??iadcClkGet_4: (+1)
   \       0x44   0xB105             CBZ.N    R5,??iadcClkGet_5
   2687              *sel = s;
   \       0x46   0x7028             STRB     R0,[R5, #+0]
   2688            }
   2689          }
   \                     ??iadcClkGet_5: (+1)
   \       0x48   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   2690          
   2691          /***************************************************************************//**
   2692           * @brief
   2693           *   Set maximum allowed divisor for @ref cmuClock_PCLK clock tree.
   2694           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2695          static void pclkDivMax(void)
   2696          {
   2697            // Set largest divisor for PCLK clock tree.
   2698            CMU_ClockDivSet(cmuClock_PCLK, 2U);
   \                     pclkDivMax: (+1)
   \        0x0   0x2102             MOVS     R1,#+2
   \        0x2   0x2003             MOVS     R0,#+3
   \        0x4   0x....'....        B.W      CMU_ClockDivSet
   2699          }
   2700          
   2701          /***************************************************************************//**
   2702           * @brief
   2703           *   Set @ref cmuClock_PCLK clock tree divisor to achieve highest possible
   2704           *  frequency and still be within spec.
   2705           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2706          static void pclkDivOptimize(void)
   2707          {
   2708            CMU_ClkDiv_TypeDef div = 2U;
   2709          
   2710            if (CMU_ClockFreqGet(cmuClock_HCLK) <= CMU_MAX_PCLK_FREQ) {
   \                     pclkDivOptimize: (+1)
   \        0x0   0x2001             MOVS     R0,#+1
   \        0x2   0xB510             PUSH     {R4,LR}
   \        0x4   0x....'....        BL       CMU_ClockFreqGet
   \        0x8   0x2402             MOVS     R4,#+2
   \        0xA   0x....             LDR.N    R1,??DataTable27_35  ;; 0x2faf081
   \        0xC   0x4288             CMP      R0,R1
   \        0xE   0xBF38             IT       CC 
   \       0x10   0x2401             MOVCC    R4,#+1
   2711              div = 1U;
   2712            }
   2713            CMU_ClockDivSet(cmuClock_PCLK, div);
   \       0x12   0x4621             MOV      R1,R4
   \       0x14   0x2003             MOVS     R0,#+3
   \       0x16   0xE8BD 0x4010      POP      {R4,LR}
   \       0x1A   0x....'....        B.W      CMU_ClockDivSet
   2714          }
   2715          
   2716          /***************************************************************************//**
   2717           * @brief
   2718           *   Get selected oscillator and frequency for @ref cmuClock_RTCCCLK
   2719           *   clock tree.
   2720           *
   2721           * @param[out] freq
   2722           *   The frequency.
   2723           *
   2724           * @param[out] sel
   2725           *   The selected oscillator.
   2726           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2727          static void rtccClkGet(uint32_t *freq, CMU_Select_TypeDef *sel)
   2728          {
   \                     rtccClkGet: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460C             MOV      R4,R1
   2729            uint32_t f = 0U;
   2730            CMU_Select_TypeDef s;
   2731          
   2732            switch (CMU->RTCCCLKCTRL & _CMU_RTCCCLKCTRL_CLKSEL_MASK) {
   \        0x4   0x....             LDR.N    R1,??DataTable27_51  ;; 0x40008240
   \        0x6   0x....             B.N      ?Subroutine0
   2733              case _CMU_RTCCCLKCTRL_CLKSEL_LFRCO:
   2734                f = SystemLFRCOClockGet();
   2735                s = cmuSelect_LFRCO;
   2736                break;
   2737          
   2738              case _CMU_RTCCCLKCTRL_CLKSEL_LFXO:
   2739                f = SystemLFXOClockGet();
   2740                s = cmuSelect_LFXO;
   2741                break;
   2742          
   2743              case _CMU_RTCCCLKCTRL_CLKSEL_ULFRCO:
   2744                f = SystemULFRCOClockGet();
   2745                s = cmuSelect_ULFRCO;
   2746                break;
   2747          
   2748              default:
   2749                s = cmuSelect_Error;
   2750                EFM_ASSERT(false);
   2751                break;
   2752            }
   2753          
   2754            if (freq != NULL) {
   2755              *freq = f;
   2756            }
   2757            if (sel != NULL) {
   2758              *sel = s;
   2759            }
   2760          }
   2761          
   2762          /***************************************************************************//**
   2763           * @brief
   2764           *   Set wait-states to values valid for maximum allowable core clock frequency.
   2765           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
   2766          static void waitStateMax(void)
   2767          {
   \                     waitStateMax: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   2768            flashWaitStateControl(SystemMaxCoreClockGet(), 0);
   \        0x2   0x....'....        BL       SystemMaxCoreClockGet
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0xE8BD 0x4004      POP      {R2,LR}
   \        0xC   0x....             B.N      flashWaitStateControl
   2769          }
   2770          
   2771          /***************************************************************************//**
   2772           * @brief
   2773           *   Get selected oscillator and frequency for @ref cmuClock_WDOG0CLK
   2774           *   clock tree.
   2775           *
   2776           * @param[out] freq
   2777           *   The frequency.
   2778           *
   2779           * @param[out] sel
   2780           *   The selected oscillator.
   2781           ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
   2782          static void wdog0ClkGet(uint32_t *freq, CMU_Select_TypeDef *sel)
   2783          {
   \                     wdog0ClkGet: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
   \        0x2   0x460C             MOV      R4,R1
   2784            uint32_t f = 0U;
   2785            CMU_Select_TypeDef s;
   2786          
   2787            switch (CMU->WDOG0CLKCTRL & _CMU_WDOG0CLKCTRL_CLKSEL_MASK) {
   \        0x4   0x....             LDR.N    R1,??DataTable27_9  ;; 0x40008200
   \        0x6   0x....'....        BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_5: (+1)
   \        0xA   0xD814             BHI.N    ??wdog0ClkGet_1
   \        0xC   0xE8DF 0xF002      TBB      [PC, R2]
   \                     ??wdog0ClkGet_0:
   \       0x10   0x02 0x06          DC8      0x2,0x6,0xA,0xE
   \              0x0A 0x0E    
   2788              case _CMU_WDOG0CLKCTRL_CLKSEL_LFRCO:
   2789                f = SystemLFRCOClockGet();
   \                     ??wdog0ClkGet_2: (+1)
   \       0x14   0x....'....        BL       SystemLFRCOClockGet
   2790                s = cmuSelect_LFRCO;
   \       0x18   0x2108             MOVS     R1,#+8
   2791                break;
   \       0x1A   0xE00D             B.N      ??wdog0ClkGet_3
   2792          
   2793              case _CMU_WDOG0CLKCTRL_CLKSEL_LFXO:
   2794                f = SystemLFXOClockGet();
   \                     ??wdog0ClkGet_4: (+1)
   \       0x1C   0x....'....        BL       SystemLFXOClockGet
   2795                s = cmuSelect_LFXO;
   \       0x20   0x2107             MOVS     R1,#+7
   2796                break;
   \       0x22   0xE009             B.N      ??wdog0ClkGet_3
   2797          
   2798              case _CMU_WDOG0CLKCTRL_CLKSEL_ULFRCO:
   2799                f = SystemULFRCOClockGet();
   \                     ??wdog0ClkGet_5: (+1)
   \       0x24   0x....'....        BL       SystemULFRCOClockGet
   2800                s = cmuSelect_ULFRCO;
   \       0x28   0x2109             MOVS     R1,#+9
   2801                break;
   \       0x2A   0xE005             B.N      ??wdog0ClkGet_3
   2802          
   2803              case _CMU_WDOG0CLKCTRL_CLKSEL_HCLKDIV1024:
   2804                f = SystemHCLKGet() / 1024U;
   \                     ??wdog0ClkGet_6: (+1)
   \       0x2C   0x....'....        BL       SystemHCLKGet
   \       0x30   0x0A80             LSRS     R0,R0,#+10
   2805                s = cmuSelect_HCLKDIV1024;
   \       0x32   0x210C             MOVS     R1,#+12
   2806                break;
   \       0x34   0xE000             B.N      ??wdog0ClkGet_3
   2807          
   2808              default:
   2809                s = cmuSelect_Error;
   \                     ??wdog0ClkGet_1: (+1)
   \       0x36   0x2100             MOVS     R1,#+0
   2810                EFM_ASSERT(false);
   2811                break;
   2812            }
   2813          
   2814            if (freq != NULL) {
   \                     ??wdog0ClkGet_3: (+1)
   \       0x38   0x....             B.N      ??Subroutine0_0
   2815              *freq = f;
   2816            }
   2817            if (sel != NULL) {
   2818              *sel = s;
   2819            }
   2820          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22:
   \        0x0   0x000F'4240        DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_1:
   \        0x0   0x0FE0'80A0        DC32     0xfe080a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_2:
   \        0x0   0x001E'8480        DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_3:
   \        0x0   0x003D'0900        DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_4:
   \        0x0   0x00C6'5D40        DC32     0xc65d40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_5:
   \        0x0   0x00F4'2400        DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_6:
   \        0x0   0x0121'EAC0        DC32     0x121eac0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_7:
   \        0x0   0x018C'BA80        DC32     0x18cba80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_8:
   \        0x0   0x01E8'4800        DC32     0x1e84800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable22_9:
   \        0x0   0x0262'5A00        DC32     0x2625a00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26:
   \        0x0   0x4A01'4008        DC32     0x4a014008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable26_1:
   \        0x0   0x4000'8080        DC32     0x40008080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27:
   \        0x0   0x4000'8208        DC32     0x40008208

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_1:
   \        0x0   0x4000'8050        DC32     0x40008050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_2:
   \        0x0   0x4000'8054        DC32     0x40008054

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_3:
   \        0x0   0x4000'8008        DC32     0x40008008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_4:
   \        0x0   0x4000'8090        DC32     0x40008090

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_5:
   \        0x0   0x4003'E468        DC32     0x4003e468

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_6:
   \        0x0   0x4003'D468        DC32     0x4003d468

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_7:
   \        0x0   0x4003'C470        DC32     0x4003c470

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_8:
   \        0x0   0x4000'8070        DC32     0x40008070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_9:
   \        0x0   0x4000'8200        DC32     0x40008200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_10:
   \        0x0   0x4000'8100        DC32     0x40008100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_11:
   \        0x0   0x4000'C028        DC32     0x4000c028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_12:
   \        0x0   0x4000'D028        DC32     0x4000d028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_13:
   \        0x0   0x4000'E028        DC32     0x4000e028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_14:
   \        0x0   0x4000'8180        DC32     0x40008180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_15:
   \        0x0   0x....'....        DC32     hfrcoCalTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_16:
   \        0x0   0x4001'E004        DC32     0x4001e004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_17:
   \        0x0   0x4001'C008        DC32     0x4001c008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_18:
   \        0x0   0x4001'0008        DC32     0x40010008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_19:
   \        0x0   0x4001'D004        DC32     0x4001d004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_20:
   \        0x0   0x4001'C018        DC32     0x4001c018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_21:
   \        0x0   0x000F'4240        DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_22:
   \        0x0   0x4000'C010        DC32     0x4000c010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_23:
   \        0x0   0x4000'D018        DC32     0x4000d018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_24:
   \        0x0   0x4001'0003        DC32     0x40010003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_25:
   \        0x0   0xFFFF'A7F1        DC32     0xffffa7f1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_26:
   \        0x0   0x4002'0004        DC32     0x40020004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_27:
   \        0x0   0x4002'1004        DC32     0x40021004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_28:
   \        0x0   0x4002'2004        DC32     0x40022004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_29:
   \        0x0   0x4002'400C        DC32     0x4002400c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_30:
   \        0x0   0x4000'8120        DC32     0x40008120

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_31:
   \        0x0   0x4000'8140        DC32     0x40008140

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_32:
   \        0x0   0x4000'8160        DC32     0x40008160

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_33:
   \        0x0   0x0253'17C1        DC32     0x25317c1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_34:
   \        0x0   0x4003'0008        DC32     0x40030008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_35:
   \        0x0   0x02FA'F081        DC32     0x2faf081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_36:
   \        0x0   0x4007'C218        DC32     0x4007c218

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_37:
   \        0x0   0x0FE0'8058        DC32     0xfe08058

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_38:
   \        0x0   0x001E'8480        DC32     0x1e8480

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_39:
   \        0x0   0x003D'0900        DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_40:
   \        0x0   0x006A'CFC0        DC32     0x6acfc0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_41:
   \        0x0   0x00C6'5D40        DC32     0xc65d40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_42:
   \        0x0   0x00F4'2400        DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_43:
   \        0x0   0x0121'EAC0        DC32     0x121eac0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_44:
   \        0x0   0x018C'BA80        DC32     0x18cba80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_45:
   \        0x0   0x01E8'4800        DC32     0x1e84800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_46:
   \        0x0   0x0243'D580        DC32     0x243d580

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_47:
   \        0x0   0x02DC'6C00        DC32     0x2dc6c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_48:
   \        0x0   0x0356'7E00        DC32     0x3567e00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_49:
   \        0x0   0x03D0'9000        DC32     0x3d09000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_50:
   \        0x0   0x04C4'B400        DC32     0x4c4b400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable27_51:
   \        0x0   0x4000'8240        DC32     0x40008240
   2821          
   2822          #else   // defined(_SILICON_LABS_32B_SERIES_2)
   2823          
   2824          /*******************************************************************************
   2825           ******************************   DEFINES   ************************************
   2826           ******************************************************************************/
   2827          
   2828          /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
   2829          
   2830          #if defined(_SILICON_LABS_32B_SERIES_0)
   2831          /** The maximum allowed core frequency when using 0 wait-states on flash access. */
   2832          #define CMU_MAX_FREQ_0WS        16000000
   2833          /** The maximum allowed core frequency when using 1 wait-states on flash access */
   2834          #define CMU_MAX_FREQ_1WS        32000000
   2835          
   2836          #elif (_SILICON_LABS_GECKO_INTERNAL_SDID == 80)
   2837          // EFR32xG1x and EFM32xG1x
   2838          #define CMU_MAX_FREQ_0WS_1V2    25000000
   2839          #define CMU_MAX_FREQ_1WS_1V2    40000000
   2840          
   2841          #elif (_SILICON_LABS_GECKO_INTERNAL_SDID == 84)
   2842          // EFR32xG12x and EFM32xG12x
   2843          #define CMU_MAX_FREQ_0WS_1V2    25000000
   2844          #define CMU_MAX_FREQ_1WS_1V2    40000000
   2845          #define CMU_MAX_FREQ_0WS_1V1    21330000
   2846          #define CMU_MAX_FREQ_1WS_1V1    32000000
   2847          #define CMU_MAX_FREQ_0WS_1V0     7000000
   2848          #define CMU_MAX_FREQ_1WS_1V0    14000000
   2849          #define CMU_MAX_FREQ_2WS_1V0    20000000
   2850          
   2851          #elif (_SILICON_LABS_GECKO_INTERNAL_SDID == 89)
   2852          // EFR32xG13x and EFM32xG13x
   2853          #define CMU_MAX_FREQ_0WS_1V2    25000000
   2854          #define CMU_MAX_FREQ_1WS_1V2    40000000
   2855          #define CMU_MAX_FREQ_0WS_1V0     7000000
   2856          #define CMU_MAX_FREQ_1WS_1V0    14000000
   2857          #define CMU_MAX_FREQ_2WS_1V0    20000000
   2858          
   2859          #elif (_SILICON_LABS_GECKO_INTERNAL_SDID == 95)
   2860          // EFR32xG14x and EFM32xG14x
   2861          #define CMU_MAX_FREQ_0WS_1V2    25000000
   2862          #define CMU_MAX_FREQ_1WS_1V2    40000000
   2863          #define CMU_MAX_FREQ_0WS_1V0     7000000
   2864          #define CMU_MAX_FREQ_1WS_1V0    14000000
   2865          #define CMU_MAX_FREQ_2WS_1V0    20000000
   2866          
   2867          #elif (_SILICON_LABS_GECKO_INTERNAL_SDID == 100)
   2868          // EFM32GG11x
   2869          #define CMU_MAX_FREQ_0WS_1V2    18000000
   2870          #define CMU_MAX_FREQ_1WS_1V2    36000000
   2871          #define CMU_MAX_FREQ_2WS_1V2    54000000
   2872          #define CMU_MAX_FREQ_3WS_1V2    72000000
   2873          #define CMU_MAX_FREQ_0WS_1V0     7000000
   2874          #define CMU_MAX_FREQ_1WS_1V0    14000000
   2875          #define CMU_MAX_FREQ_2WS_1V0    20000000
   2876          
   2877          #elif (_SILICON_LABS_GECKO_INTERNAL_SDID == 103)
   2878          // EFM32TG11x
   2879          #define CMU_MAX_FREQ_0WS_1V2    25000000
   2880          #define CMU_MAX_FREQ_1WS_1V2    48000000
   2881          #define CMU_MAX_FREQ_0WS_1V0    10000000
   2882          #define CMU_MAX_FREQ_1WS_1V0    21000000
   2883          #define CMU_MAX_FREQ_2WS_1V0    20000000
   2884          
   2885          #elif (_SILICON_LABS_GECKO_INTERNAL_SDID == 106)
   2886          // EFM32GG12x
   2887          #define CMU_MAX_FREQ_0WS_1V2    18000000
   2888          #define CMU_MAX_FREQ_1WS_1V2    36000000
   2889          #define CMU_MAX_FREQ_2WS_1V2    54000000
   2890          #define CMU_MAX_FREQ_3WS_1V2    72000000
   2891          #define CMU_MAX_FREQ_0WS_1V0    7000000
   2892          #define CMU_MAX_FREQ_1WS_1V0    14000000
   2893          #define CMU_MAX_FREQ_2WS_1V0    20000000
   2894          
   2895          #else
   2896          #error "Max Flash wait-state frequencies are not defined for this platform."
   2897          #endif
   2898          
   2899          /** The maximum frequency for the HFLE interface. */
   2900          #if defined(CMU_CTRL_HFLE)
   2901          /** The maximum HFLE frequency for series 0 EFM32 and EZR32 Wonder Gecko. */
   2902          #if defined(_SILICON_LABS_32B_SERIES_0) \
   2903            && (defined(_EFM32_WONDER_FAMILY)     \
   2904            || defined(_EZR32_WONDER_FAMILY))
   2905          #define CMU_MAX_FREQ_HFLE                       24000000UL
   2906          /** The maximum HFLE frequency for other series 0 parts with maximum core clock
   2907              higher than 32 MHz. */
   2908          #elif defined(_SILICON_LABS_32B_SERIES_0) \
   2909            && (defined(_EFM32_GIANT_FAMILY)        \
   2910            || defined(_EZR32_LEOPARD_FAMILY))
   2911          #define CMU_MAX_FREQ_HFLE                       maxFreqHfle()
   2912          #endif
   2913          #elif defined(CMU_CTRL_WSHFLE)
   2914          /** The maximum HFLE frequency for series 1 parts. */
   2915          #define CMU_MAX_FREQ_HFLE                       32000000UL
   2916          #endif
   2917          
   2918          #if defined(CMU_STATUS_HFXOSHUNTOPTRDY)
   2919          #define HFXO_TUNING_READY_FLAGS  (CMU_STATUS_HFXOPEAKDETRDY | CMU_STATUS_HFXOSHUNTOPTRDY)
   2920          #define HFXO_TUNING_MODE_AUTO    (_CMU_HFXOCTRL_PEAKDETSHUNTOPTMODE_AUTOCMD)
   2921          #define HFXO_TUNING_MODE_CMD     (_CMU_HFXOCTRL_PEAKDETSHUNTOPTMODE_CMD)
   2922          #elif defined(CMU_STATUS_HFXOPEAKDETRDY)
   2923          #define HFXO_TUNING_READY_FLAGS  (CMU_STATUS_HFXOPEAKDETRDY)
   2924          #define HFXO_TUNING_MODE_AUTO    (_CMU_HFXOCTRL_PEAKDETMODE_AUTOCMD)
   2925          #define HFXO_TUNING_MODE_CMD     (_CMU_HFXOCTRL_PEAKDETMODE_CMD)
   2926          #endif
   2927          
   2928          #if defined(CMU_HFXOCTRL_MODE_EXTCLK)
   2929          /** HFXO external clock mode is renamed from EXTCLK to DIGEXTCLK. */
   2930          #define CMU_HFXOCTRL_MODE_DIGEXTCLK     CMU_HFXOCTRL_MODE_EXTCLK
   2931          #endif
   2932          
   2933          #if defined(_EMU_CMD_EM01VSCALE0_MASK)
   2934          #define VSCALE_DEFAULT    (EMU_VScaleGet())
   2935          #else
   2936          #define VSCALE_DEFAULT    0
   2937          #endif
   2938          
   2939          /*******************************************************************************
   2940           **************************   LOCAL VARIABLES   ********************************
   2941           ******************************************************************************/
   2942          
   2943          #if defined(_CMU_AUXHFRCOCTRL_FREQRANGE_MASK)
   2944          static CMU_AUXHFRCOFreq_TypeDef auxHfrcoFreq = cmuAUXHFRCOFreq_19M0Hz;
   2945          #endif
   2946          #if defined(_CMU_STATUS_HFXOSHUNTOPTRDY_MASK)
   2947          #define HFXO_INVALID_TRIM   (~_CMU_HFXOTRIMSTATUS_MASK)
   2948          #endif
   2949          
   2950          #if defined(CMU_OSCENCMD_DPLLEN)
   2951          /** A table of HFRCOCTRL values and their associated minimum/maximum frequencies and
   2952              an optional band enumerator. */
   2953          static const struct hfrcoCtrlTableElement{
   2954            uint32_t              minFreq;
   2955            uint32_t              maxFreq;
   2956            uint32_t              value;
   2957            CMU_HFRCOFreq_TypeDef band;
   2958          } hfrcoCtrlTable[] =
   2959          {
   2960            // minFreq  maxFreq   HFRCOCTRL value  band
   2961            {  860000UL, 1050000UL, 0xBC601F00UL, cmuHFRCOFreq_1M0Hz       },
   2962            { 1050000UL, 1280000UL, 0xBC611F35UL, (CMU_HFRCOFreq_TypeDef)0 },
   2963            { 1280000UL, 1480000UL, 0xBCA21F35UL, (CMU_HFRCOFreq_TypeDef)0 },
   2964            { 1480000UL, 1800000UL, 0xAD231F35UL, (CMU_HFRCOFreq_TypeDef)0 },
   2965            { 1800000UL, 2110000UL, 0xBA601F00UL, cmuHFRCOFreq_2M0Hz       },
   2966            { 2110000UL, 2560000UL, 0xBA611F35UL, (CMU_HFRCOFreq_TypeDef)0 },
   2967            { 2560000UL, 2970000UL, 0xBAA21F35UL, (CMU_HFRCOFreq_TypeDef)0 },
   2968            { 2970000UL, 3600000UL, 0xAB231F35UL, (CMU_HFRCOFreq_TypeDef)0 },
   2969            { 3600000UL, 4220000UL, 0xB8601F00UL, cmuHFRCOFreq_4M0Hz       },
   2970            { 4220000UL, 5120000UL, 0xB8611F35UL, (CMU_HFRCOFreq_TypeDef)0 },
   2971            { 5120000UL, 5930000UL, 0xB8A21F35UL, (CMU_HFRCOFreq_TypeDef)0 },
   2972            { 5930000UL, 7520000UL, 0xA9231F00UL, cmuHFRCOFreq_7M0Hz       },
   2973            { 7520000UL, 9520000UL, 0x99241F35UL, (CMU_HFRCOFreq_TypeDef)0 },
   2974            { 9520000UL, 11800000UL, 0x99251F35UL, (CMU_HFRCOFreq_TypeDef)0 },
   2975            { 11800000UL, 14400000UL, 0x99261F00UL, cmuHFRCOFreq_13M0Hz     },
   2976            { 14400000UL, 17200000UL, 0x99271F00UL, cmuHFRCOFreq_16M0Hz     },
   2977            { 17200000UL, 19700000UL, 0x99481F00UL, cmuHFRCOFreq_19M0Hz     },
   2978            { 19700000UL, 23800000UL, 0x99491F35UL, (CMU_HFRCOFreq_TypeDef)0 },
   2979            { 23800000UL, 28700000UL, 0x994A1F00UL, cmuHFRCOFreq_26M0Hz      },
   2980            { 28700000UL, 34800000UL, 0x996B1F00UL, cmuHFRCOFreq_32M0Hz      },
   2981          #if defined(_SILICON_LABS_GECKO_INTERNAL_SDID_84)  \
   2982            || defined(_SILICON_LABS_GECKO_INTERNAL_SDID_89) \
   2983            || defined(_SILICON_LABS_GECKO_INTERNAL_SDID_95)
   2984            { 34800000UL, 40000000UL, 0x996C1F00UL, cmuHFRCOFreq_38M0Hz      }
   2985          #elif defined(_SILICON_LABS_GECKO_INTERNAL_SDID_100) \
   2986            || defined(_SILICON_LABS_GECKO_INTERNAL_SDID_106)
   2987            { 34800000UL, 42800000UL, 0x996C1F00UL, cmuHFRCOFreq_38M0Hz      },
   2988            { 42800000UL, 51600000UL, 0x996D1F00UL, cmuHFRCOFreq_48M0Hz      },
   2989            { 51600000UL, 60500000UL, 0x998E1F00UL, cmuHFRCOFreq_56M0Hz      },
   2990            { 60500000UL, 72000000UL, 0xA98F1F00UL, cmuHFRCOFreq_64M0Hz      }
   2991          #elif defined(_SILICON_LABS_GECKO_INTERNAL_SDID_103)
   2992            { 34800000UL, 42800000UL, 0x996C1F00UL, cmuHFRCOFreq_38M0Hz      },
   2993            { 42800000UL, 48000000UL, 0x996D1F00UL, cmuHFRCOFreq_48M0Hz      }
   2994          #else
   2995            #error "HFRCOCTRL values not set for this platform."
   2996          #endif
   2997          };
   2998          
   2999          #define HFRCOCTRLTABLE_ENTRIES (sizeof(hfrcoCtrlTable) \
   3000                                          / sizeof(struct hfrcoCtrlTableElement))
   3001          #endif // CMU_OSCENCMD_DPLLEN
   3002          
   3003          #if defined(_SILICON_LABS_32B_SERIES_1) && defined(_EMU_STATUS_VSCALE_MASK)
   3004          /* Devices with Voltage Scaling needs extra handling of wait states. */
   3005          static const struct flashWsTableElement{
   3006            uint32_t maxFreq;
   3007            uint8_t  vscale;
   3008            uint8_t  ws;
   3009          } flashWsTable[] =
   3010          {
   3011          #if (_SILICON_LABS_GECKO_INTERNAL_SDID == 100 || _SILICON_LABS_GECKO_INTERNAL_SDID == 106)
   3012            { CMU_MAX_FREQ_0WS_1V2, 0, 0 },  /* 0 wait states at max frequency 18 MHz and 1.2V */
   3013            { CMU_MAX_FREQ_1WS_1V2, 0, 1 },  /* 1 wait states at max frequency 36 MHz and 1.2V */
   3014            { CMU_MAX_FREQ_2WS_1V2, 0, 2 },  /* 2 wait states at max frequency 54 MHz and 1.2V */
   3015            { CMU_MAX_FREQ_3WS_1V2, 0, 3 },  /* 3 wait states at max frequency 72 MHz and 1.2V */
   3016            { CMU_MAX_FREQ_0WS_1V0, 2, 0 },  /* 0 wait states at max frequency 7 MHz and 1.0V */
   3017            { CMU_MAX_FREQ_1WS_1V0, 2, 1 },  /* 1 wait states at max frequency 14 MHz and 1.0V */
   3018            { CMU_MAX_FREQ_2WS_1V0, 2, 2 },  /* 2 wait states at max frequency 21 MHz and 1.0V */
   3019          #else
   3020            { CMU_MAX_FREQ_0WS_1V2, 0, 0 },  /* 0 wait states at 1.2V */
   3021            { CMU_MAX_FREQ_1WS_1V2, 0, 1 },  /* 1 wait states at 1.2V */
   3022            { CMU_MAX_FREQ_0WS_1V0, 2, 0 },  /* 0 wait states at 1.0V */
   3023            { CMU_MAX_FREQ_1WS_1V0, 2, 1 },  /* 1 wait states at 1.0V */
   3024            { CMU_MAX_FREQ_2WS_1V0, 2, 2 },  /* 2 wait states at 1.0V */
   3025          #endif
   3026          };
   3027          
   3028          #define FLASH_WS_TABLE_ENTRIES (sizeof(flashWsTable) / sizeof(flashWsTable[0]))
   3029          #endif
   3030          
   3031          #if defined(_CMU_USHFRCOCTRL_FREQRANGE_MASK) \
   3032            || defined(_CMU_USHFRCOTUNE_MASK)
   3033          #ifndef EFM32_USHFRCO_STARTUP_FREQ
   3034          #define EFM32_USHFRCO_STARTUP_FREQ        (48000000UL)
   3035          #endif
   3036          
   3037          static uint32_t ushfrcoFreq = EFM32_USHFRCO_STARTUP_FREQ;
   3038          #endif
   3039          
   3040          /*******************************************************************************
   3041           **************************   LOCAL PROTOTYPES   *******************************
   3042           ******************************************************************************/
   3043          #if defined(_CMU_HFRCOCTRL_FREQRANGE_MASK)
   3044          static uint32_t CMU_HFRCODevinfoGet(CMU_HFRCOFreq_TypeDef freq);
   3045          #endif
   3046          
   3047          #if defined(_CMU_USHFRCOCTRL_FREQRANGE_MASK)
   3048          static uint32_t CMU_USHFRCODevinfoGet(CMU_USHFRCOFreq_TypeDef freq);
   3049          #endif
   3050          
   3051          static void hfperClkSafePrescaler(void);
   3052          static void hfperClkOptimizedPrescaler(void);
   3053          
   3054          /** @endcond */
   3055          
   3056          /*******************************************************************************
   3057           **************************   LOCAL FUNCTIONS   ********************************
   3058           ******************************************************************************/
   3059          
   3060          /** @cond DO_NOT_INCLUDE_WITH_DOXYGEN */
   3061          
   3062          #if defined(_SILICON_LABS_32B_SERIES_0) \
   3063            && (defined(_EFM32_GIANT_FAMILY)      \
   3064            || defined(_EZR32_LEOPARD_FAMILY))
   3065          /***************************************************************************//**
   3066           * @brief
   3067           *   Return maximum allowed frequency for low energy peripherals.
   3068           ******************************************************************************/
   3069          static uint32_t maxFreqHfle(void)
   3070          {
   3071            uint16_t majorMinorRev;
   3072          
   3073            switch (SYSTEM_GetFamily()) {
   3074              case systemPartFamilyEfm32Leopard:
   3075              case systemPartFamilyEzr32Leopard:
   3076                /* CHIP MAJOR bit [5:0] */
   3077                majorMinorRev = (((ROMTABLE->PID0 & _ROMTABLE_PID0_REVMAJOR_MASK)
   3078                                  >> _ROMTABLE_PID0_REVMAJOR_SHIFT) << 8);
   3079                /* CHIP MINOR bit [7:4] */
   3080                majorMinorRev |= (((ROMTABLE->PID2 & _ROMTABLE_PID2_REVMINORMSB_MASK)
   3081                                   >> _ROMTABLE_PID2_REVMINORMSB_SHIFT) << 4);
   3082                /* CHIP MINOR bit [3:0] */
   3083                majorMinorRev |=  ((ROMTABLE->PID3 & _ROMTABLE_PID3_REVMINORLSB_MASK)
   3084                                   >> _ROMTABLE_PID3_REVMINORLSB_SHIFT);
   3085          
   3086                if (majorMinorRev >= 0x0204) {
   3087                  return 24000000;
   3088                } else {
   3089                  return 32000000;
   3090                }
   3091          
   3092              case systemPartFamilyEfm32Giant:
   3093                return 32000000;
   3094          
   3095              default:
   3096                /* Invalid device family. */
   3097                EFM_ASSERT(false);
   3098                return 0;
   3099            }
   3100          }
   3101          #endif
   3102          
   3103          #if defined(CMU_MAX_FREQ_HFLE)
   3104          
   3105          /* Unified definitions for the HFLE wait-state and prescaler fields. */
   3106          #if defined(CMU_CTRL_HFLE)
   3107          #define _GENERIC_HFLE_WS_MASK           _CMU_CTRL_HFLE_MASK
   3108          #define _GENERIC_HFLE_WS_SHIFT          _CMU_CTRL_HFLE_SHIFT
   3109          #define GENERIC_HFLE_PRESC_REG          CMU->HFCORECLKDIV
   3110          #define _GENERIC_HFLE_PRESC_MASK        _CMU_HFCORECLKDIV_HFCORECLKLEDIV_MASK
   3111          #define _GENERIC_HFLE_PRESC_SHIFT       _CMU_HFCORECLKDIV_HFCORECLKLEDIV_SHIFT
   3112          #elif defined(CMU_CTRL_WSHFLE)
   3113          #define _GENERIC_HFLE_WS_MASK           _CMU_CTRL_WSHFLE_MASK
   3114          #define _GENERIC_HFLE_WS_SHIFT          _CMU_CTRL_WSHFLE_SHIFT
   3115          #define GENERIC_HFLE_PRESC_REG          CMU->HFPRESC
   3116          #define _GENERIC_HFLE_PRESC_MASK        _CMU_HFPRESC_HFCLKLEPRESC_MASK
   3117          #define _GENERIC_HFLE_PRESC_SHIFT       _CMU_HFPRESC_HFCLKLEPRESC_SHIFT
   3118          #endif
   3119          
   3120          /***************************************************************************//**
   3121           * @brief
   3122           *   Set HFLE wait-states and HFCLKLE prescaler.
   3123           *
   3124           * @param[in] maxLeFreq
   3125           *   The maximum LE frequency.
   3126           ******************************************************************************/
   3127          static void setHfLeConfig(uint32_t hfFreq)
   3128          {
   3129            unsigned int hfleWs;
   3130            uint32_t hflePresc;
   3131          
   3132            /* Check for 1 bit fields. @ref BUS_RegBitWrite() below are going to fail if the
   3133               fields are changed to more than 1 bit. */
   3134            EFM_ASSERT((_GENERIC_HFLE_WS_MASK >> _GENERIC_HFLE_WS_SHIFT) == 0x1U);
   3135          
   3136            /* - Enable HFLE wait-state to allow access to LE peripherals when HFBUSCLK is
   3137                 above maxLeFreq.
   3138               - Set HFLE prescaler. Allowed HFLE clock frequency is maxLeFreq. */
   3139          
   3140            hfleWs = 1;
   3141            if (hfFreq <= CMU_MAX_FREQ_HFLE) {
   3142              hfleWs = 0;
   3143              hflePresc = 0;
   3144            } else if (hfFreq <= (2UL * CMU_MAX_FREQ_HFLE)) {
   3145              hflePresc = 1;
   3146            } else {
   3147              hflePresc = 2;
   3148            }
   3149            BUS_RegBitWrite(&CMU->CTRL, _GENERIC_HFLE_WS_SHIFT, hfleWs);
   3150            GENERIC_HFLE_PRESC_REG = (GENERIC_HFLE_PRESC_REG & ~_GENERIC_HFLE_PRESC_MASK)
   3151                                     | (hflePresc << _GENERIC_HFLE_PRESC_SHIFT);
   3152          }
   3153          
   3154          #if defined(_CMU_CTRL_HFLE_MASK)
   3155          /***************************************************************************//**
   3156           * @brief
   3157           *   Get HFLE wait-state configuration.
   3158           *
   3159           * @return
   3160           *   The current wait-state configuration.
   3161           ******************************************************************************/
   3162          static uint32_t getHfLeConfig(void)
   3163          {
   3164            uint32_t ws = BUS_RegBitRead(&CMU->CTRL, _GENERIC_HFLE_WS_SHIFT);
   3165            return ws;
   3166          }
   3167          #endif
   3168          #endif
   3169          
   3170          /***************************************************************************//**
   3171           * @brief
   3172           *   Get the AUX clock frequency. Used by MSC flash programming and LESENSE,
   3173           *   by default also as a debug clock.
   3174           *
   3175           * @return
   3176           *   AUX Frequency in Hz.
   3177           ******************************************************************************/
   3178          static uint32_t auxClkGet(void)
   3179          {
   3180            uint32_t ret;
   3181          
   3182          #if defined(_CMU_AUXHFRCOCTRL_FREQRANGE_MASK)
   3183            ret = (uint32_t)auxHfrcoFreq;
   3184          
   3185          #elif defined(_CMU_AUXHFRCOCTRL_BAND_MASK)
   3186            /* All series 0 families except EFM32G */
   3187            switch (CMU->AUXHFRCOCTRL & _CMU_AUXHFRCOCTRL_BAND_MASK) {
   3188              case CMU_AUXHFRCOCTRL_BAND_1MHZ:
   3189                if ( SYSTEM_GetProdRev() >= 19 ) {
   3190                  ret = 1200000;
   3191                } else {
   3192                  ret = 1000000;
   3193                }
   3194                break;
   3195          
   3196              case CMU_AUXHFRCOCTRL_BAND_7MHZ:
   3197                if ( SYSTEM_GetProdRev() >= 19 ) {
   3198                  ret = 6600000;
   3199                } else {
   3200                  ret = 7000000;
   3201                }
   3202                break;
   3203          
   3204              case CMU_AUXHFRCOCTRL_BAND_11MHZ:
   3205                ret = 11000000;
   3206                break;
   3207          
   3208              case CMU_AUXHFRCOCTRL_BAND_14MHZ:
   3209                ret = 14000000;
   3210                break;
   3211          
   3212              case CMU_AUXHFRCOCTRL_BAND_21MHZ:
   3213                ret = 21000000;
   3214                break;
   3215          
   3216          #if defined(_CMU_AUXHFRCOCTRL_BAND_28MHZ)
   3217              case CMU_AUXHFRCOCTRL_BAND_28MHZ:
   3218                ret = 28000000;
   3219                break;
   3220          #endif
   3221          
   3222              default:
   3223                ret = 0;
   3224                EFM_ASSERT(false);
   3225                break;
   3226            }
   3227          
   3228          #else
   3229            /* Gecko has a fixed 14 MHz AUXHFRCO clock. */
   3230            ret = 14000000;
   3231          
   3232          #endif
   3233          
   3234            return ret;
   3235          }
   3236          
   3237          #if defined (_CMU_ADCCTRL_ADC0CLKSEL_HFSRCCLK) \
   3238            || defined (_CMU_ADCCTRL_ADC1CLKSEL_HFSRCCLK)
   3239          /***************************************************************************//**
   3240           * @brief
   3241           *   Get the HFSRCCLK frequency.
   3242           *
   3243           * @return
   3244           *   HFSRCCLK Frequency in Hz.
   3245           ******************************************************************************/
   3246          static uint32_t hfSrcClkGet(void)
   3247          {
   3248            uint32_t ret;
   3249          
   3250            ret = SystemHFClockGet();
   3251            return ret * (1U + ((CMU->HFPRESC & _CMU_HFPRESC_PRESC_MASK)
   3252                                >> _CMU_HFPRESC_PRESC_SHIFT));
   3253          }
   3254          #endif
   3255          
   3256          /***************************************************************************//**
   3257           * @brief
   3258           *   Get the Debug Trace clock frequency.
   3259           *
   3260           * @return
   3261           *   Debug Trace frequency in Hz.
   3262           ******************************************************************************/
   3263          static uint32_t dbgClkGet(void)
   3264          {
   3265            uint32_t ret;
   3266            CMU_Select_TypeDef clk;
   3267          
   3268            /* Get selected clock source */
   3269            clk = CMU_ClockSelectGet(cmuClock_DBG);
   3270          
   3271            switch (clk) {
   3272              case cmuSelect_HFCLK:
   3273                ret = SystemHFClockGet();
   3274                break;
   3275          
   3276              case cmuSelect_AUXHFRCO:
   3277                ret = auxClkGet();
   3278                break;
   3279          
   3280              default:
   3281                ret = 0;
   3282                EFM_ASSERT(false);
   3283                break;
   3284            }
   3285            return ret;
   3286          }
   3287          
   3288          #if defined(_CMU_ADCCTRL_ADC0CLKSEL_MASK)
   3289          /***************************************************************************//**
   3290           * @brief
   3291           *   Get the ADC n asynchronous clock frequency.
   3292           *
   3293           * @return
   3294           *   ADC n asynchronous frequency in Hz.
   3295           ******************************************************************************/
   3296          static uint32_t adcAsyncClkGet(uint32_t adc)
   3297          {
   3298            uint32_t ret;
   3299            CMU_Select_TypeDef clk;
   3300          
   3301            /* Get the selected clock source. */
   3302            switch (adc) {
   3303              case 0:
   3304                clk = CMU_ClockSelectGet(cmuClock_ADC0ASYNC);
   3305                break;
   3306          
   3307          #if defined(_CMU_ADCCTRL_ADC1CLKSEL_MASK)
   3308              case 1:
   3309                clk = CMU_ClockSelectGet(cmuClock_ADC1ASYNC);
   3310                break;
   3311          #endif
   3312          
   3313              default:
   3314                EFM_ASSERT(false);
   3315                return 0;
   3316            }
   3317          
   3318            switch (clk) {
   3319              case cmuSelect_Disabled:
   3320                ret = 0;
   3321                break;
   3322          
   3323              case cmuSelect_AUXHFRCO:
   3324                ret = auxClkGet();
   3325                break;
   3326          
   3327              case cmuSelect_HFXO:
   3328                ret = SystemHFXOClockGet();
   3329                break;
   3330          
   3331              case cmuSelect_HFSRCCLK:
   3332                ret = hfSrcClkGet();
   3333                break;
   3334          
   3335              default:
   3336                ret = 0;
   3337                EFM_ASSERT(false);
   3338                break;
   3339            }
   3340            return ret;
   3341          }
   3342          #endif
   3343          
   3344          #if defined(_CMU_SDIOCTRL_MASK)
   3345          /***************************************************************************//**
   3346           * @brief
   3347           *   Get the SDIO reference clock frequency.
   3348           *
   3349           * @return
   3350           *   SDIO reference clock frequency in Hz.
   3351           ******************************************************************************/
   3352          static uint32_t sdioRefClkGet(void)
   3353          {
   3354            uint32_t ret;
   3355            CMU_Select_TypeDef clk;
   3356          
   3357            /* Get the selected clock source. */
   3358            clk = CMU_ClockSelectGet(cmuClock_SDIOREF);
   3359          
   3360            switch (clk) {
   3361              case cmuSelect_HFRCO:
   3362                ret = SystemHfrcoFreq;
   3363                break;
   3364          
   3365              case cmuSelect_HFXO:
   3366                ret = SystemHFXOClockGet();
   3367                break;
   3368          
   3369              case cmuSelect_AUXHFRCO:
   3370                ret = auxClkGet();
   3371                break;
   3372          
   3373              case cmuSelect_USHFRCO:
   3374                ret = ushfrcoFreq;
   3375                break;
   3376          
   3377              default:
   3378                ret = 0;
   3379                EFM_ASSERT(false);
   3380                break;
   3381            }
   3382            return ret;
   3383          }
   3384          #endif
   3385          
   3386          #if defined(_CMU_QSPICTRL_MASK)
   3387          /***************************************************************************//**
   3388           * @brief
   3389           *   Get the QSPI n reference clock frequency.
   3390           *
   3391           * @return
   3392           *   QSPI n reference clock frequency in Hz.
   3393           ******************************************************************************/
   3394          static uint32_t qspiRefClkGet(uint32_t qspi)
   3395          {
   3396            uint32_t ret;
   3397            CMU_Select_TypeDef clk;
   3398          
   3399            /* Get the selected clock source. */
   3400            switch (qspi) {
   3401              case 0:
   3402                clk = CMU_ClockSelectGet(cmuClock_QSPI0REF);
   3403                break;
   3404          
   3405              default:
   3406                EFM_ASSERT(false);
   3407                return 0;
   3408            }
   3409          
   3410            switch (clk) {
   3411              case cmuSelect_HFRCO:
   3412                ret = SystemHfrcoFreq;
   3413                break;
   3414          
   3415              case cmuSelect_HFXO:
   3416                ret = SystemHFXOClockGet();
   3417                break;
   3418          
   3419              case cmuSelect_AUXHFRCO:
   3420                ret = auxClkGet();
   3421                break;
   3422          
   3423              case cmuSelect_USHFRCO:
   3424                ret = ushfrcoFreq;
   3425                break;
   3426          
   3427              default:
   3428                ret = 0;
   3429                EFM_ASSERT(false);
   3430                break;
   3431            }
   3432            return ret;
   3433          }
   3434          #endif
   3435          
   3436          #if defined(_CMU_PDMCTRL_MASK)
   3437          /***************************************************************************//**
   3438           * @brief
   3439           *   Get the PDM reference clock frequency.
   3440           *
   3441           * @return
   3442           *   PDM reference clock frequency in Hz.
   3443           ******************************************************************************/
   3444          static uint32_t pdmRefClkGet(void)
   3445          {
   3446            uint32_t ret;
   3447            CMU_Select_TypeDef clk;
   3448          
   3449            /* Get the selected clock source. */
   3450            clk = CMU_ClockSelectGet(cmuClock_PDMREF);
   3451          
   3452            switch (clk) {
   3453              case cmuSelect_HFRCO:
   3454                ret = SystemHfrcoFreq;
   3455                break;
   3456          
   3457              case cmuSelect_HFXO:
   3458                ret = SystemHFXOClockGet();
   3459                break;
   3460          
   3461              case cmuSelect_USHFRCO:
   3462                ret = ushfrcoFreq;
   3463                break;
   3464          
   3465              default:
   3466                ret = 0;
   3467                EFM_ASSERT(false);
   3468                break;
   3469            }
   3470            return ret;
   3471          }
   3472          #endif
   3473          
   3474          #if defined(USBR_CLOCK_PRESENT)
   3475          /***************************************************************************//**
   3476           * @brief
   3477           *   Get the USB rate clock frequency.
   3478           *
   3479           * @return
   3480           *   USB rate clock frequency in Hz.
   3481           ******************************************************************************/
   3482          static uint32_t usbRateClkGet(void)
   3483          {
   3484            uint32_t ret;
   3485            CMU_Select_TypeDef clk;
   3486          
   3487            clk = CMU_ClockSelectGet(cmuClock_USBR);
   3488          
   3489            switch (clk) {
   3490              case cmuSelect_USHFRCO:
   3491                ret = ushfrcoFreq;
   3492                break;
   3493          
   3494              case cmuSelect_HFXO:
   3495                ret = SystemHFXOClockGet();
   3496                break;
   3497          
   3498              case cmuSelect_HFXOX2:
   3499                ret = 2u * SystemHFXOClockGet();
   3500                break;
   3501          
   3502              case cmuSelect_HFRCO:
   3503                ret = SystemHfrcoFreq;
   3504                break;
   3505          
   3506              case cmuSelect_LFXO:
   3507                ret = SystemLFXOClockGet();
   3508                break;
   3509          
   3510              case cmuSelect_LFRCO:
   3511                ret = SystemLFRCOClockGet();
   3512                break;
   3513          
   3514              default:
   3515                ret = 0;
   3516                EFM_ASSERT(false);
   3517                break;
   3518            }
   3519            return ret;
   3520          }
   3521          #endif
   3522          
   3523          /***************************************************************************//**
   3524           * @brief
   3525           *   Configure flash access wait states to support the given core clock
   3526           *   frequency.
   3527           *
   3528           * @param[in] coreFreq
   3529           *   The core clock frequency to configure flash wait-states.
   3530           *
   3531           * @param[in] vscale
   3532           *   Voltage Scale level. Supported levels are 0 and 2 where 0 is the default.
   3533           ******************************************************************************/
   3534          static void flashWaitStateControl(uint32_t coreFreq, int vscale)
   3535          {
   3536            uint32_t mode;
   3537          #if defined(MSC_READCTRL_MODE_WS0SCBTP)
   3538            bool scbtpEn;   /* Suppressed Conditional Branch Target Prefetch setting. */
   3539          #endif
   3540            (void) vscale;  /* vscale parameter is only used on some devices. */
   3541          
   3542            /* Get mode and SCBTP enable. */
   3543            mode = MSC->READCTRL & _MSC_READCTRL_MODE_MASK;
   3544          
   3545          #if defined(_SILICON_LABS_32B_SERIES_0)
   3546          #if defined(MSC_READCTRL_MODE_WS0SCBTP)
   3547            /* Devices with MODE and SCBTP in the same register field. */
   3548            switch (mode) {
   3549              case MSC_READCTRL_MODE_WS0:
   3550              case MSC_READCTRL_MODE_WS1:
   3551          #if defined(MSC_READCTRL_MODE_WS2)
   3552              case MSC_READCTRL_MODE_WS2:
   3553          #endif
   3554                scbtpEn = false;
   3555                break;
   3556          
   3557              default: /* WSxSCBTP */
   3558                scbtpEn = true;
   3559                break;
   3560            }
   3561          
   3562            /* Set mode based on the core clock frequency and SCBTP enable. */
   3563            if (false) {
   3564            }
   3565          #if defined(MSC_READCTRL_MODE_WS2)
   3566            else if (coreFreq > CMU_MAX_FREQ_1WS) {
   3567              mode = (scbtpEn ? MSC_READCTRL_MODE_WS2SCBTP : MSC_READCTRL_MODE_WS2);
   3568            }
   3569          #endif
   3570            else if ((coreFreq <= CMU_MAX_FREQ_1WS) && (coreFreq > CMU_MAX_FREQ_0WS)) {
   3571              mode = (scbtpEn ? MSC_READCTRL_MODE_WS1SCBTP : MSC_READCTRL_MODE_WS1);
   3572            } else {
   3573              mode = (scbtpEn ? MSC_READCTRL_MODE_WS0SCBTP : MSC_READCTRL_MODE_WS0);
   3574            }
   3575          #else /* defined(MSC_READCTRL_MODE_WS0SCBTP) */
   3576          
   3577            if (coreFreq <= CMU_MAX_FREQ_0WS) {
   3578              mode = 0;
   3579            } else if (coreFreq <= CMU_MAX_FREQ_1WS) {
   3580              mode = 1;
   3581            }
   3582          #endif /* defined(MSC_READCTRL_MODE_WS0SCBTP) */
   3583          // End defined(_SILICON_LABS_32B_SERIES_0)
   3584          
   3585          #elif defined(_SILICON_LABS_32B_SERIES_1)
   3586          #if defined(_EMU_STATUS_VSCALE_MASK)
   3587          
   3588            /* These devices have specific requirements on the supported flash wait state
   3589             * depending on the frequency and voltage scale level. */
   3590            uint32_t i;
   3591            for (i = 0; i < FLASH_WS_TABLE_ENTRIES; i++) {
   3592              if ((flashWsTable[i].vscale == (uint8_t)vscale)
   3593                  && (coreFreq <= flashWsTable[i].maxFreq)) {
   3594                break; // Found a matching entry.
   3595              }
   3596            }
   3597          
   3598            if (i == FLASH_WS_TABLE_ENTRIES) {
   3599              mode = 3; // Worst case flash wait state for unsupported cases.
   3600              EFM_ASSERT(false);
   3601            } else {
   3602              mode = flashWsTable[i].ws;
   3603            }
   3604            mode = mode << _MSC_READCTRL_MODE_SHIFT;
   3605          
   3606          #else
   3607            /* Devices where MODE and SCBTP are in separate fields and where the device
   3608             * either does not support voltage scale or where the voltage scale does
   3609             * not impact the flash wait state configuration. */
   3610            if (coreFreq <= CMU_MAX_FREQ_0WS_1V2) {
   3611              mode = 0;
   3612            } else if (coreFreq <= CMU_MAX_FREQ_1WS_1V2) {
   3613              mode = 1;
   3614            }
   3615          #if defined(MSC_READCTRL_MODE_WS2)
   3616            else if (coreFreq <= CMU_MAX_FREQ_2WS) {
   3617              mode = 2;
   3618            }
   3619          #endif
   3620          #if defined(MSC_READCTRL_MODE_WS3)
   3621            else if (coreFreq <= CMU_MAX_FREQ_3WS) {
   3622              mode = 3;
   3623            }
   3624          #endif
   3625            mode = mode << _MSC_READCTRL_MODE_SHIFT;
   3626          #endif
   3627          // End defined(_SILICON_LABS_32B_SERIES_1)
   3628          
   3629          #else
   3630          #error "Undefined 32B SERIES!"
   3631          #endif
   3632          
   3633            /* BUS_RegMaskedWrite cannot be used as it would temporarily set the
   3634               mode field to WS0. */
   3635            MSC->READCTRL = (MSC->READCTRL & ~_MSC_READCTRL_MODE_MASK) | mode;
   3636          }
   3637          
   3638          /***************************************************************************//**
   3639           * @brief
   3640           *   Configure flash access wait states to the most conservative setting for
   3641           *   this target. Retain SCBTP (Suppressed Conditional Branch Target Prefetch)
   3642           *   setting.
   3643           ******************************************************************************/
   3644          static void flashWaitStateMax(void)
   3645          {
   3646            /* Make sure the MSC is unlocked */
   3647            bool mscLocked = MSC->LOCK != 0UL;
   3648            MSC->LOCK = MSC_UNLOCK_CODE;
   3649          
   3650            flashWaitStateControl(SystemMaxCoreClockGet(), 0);
   3651          
   3652            if (mscLocked) {
   3653              MSC->LOCK = 0;
   3654            }
   3655          }
   3656          
   3657          #if defined(_MSC_RAMCTRL_RAMWSEN_MASK)
   3658          /***************************************************************************//**
   3659           * @brief
   3660           *   Configure RAM access wait states to support the given core clock
   3661           *   frequency.
   3662           *
   3663           * @param[in] coreFreq
   3664           *   The core clock frequency to configure RAM wait-states.
   3665           *
   3666           * @param[in] vscale
   3667           *   A voltage scale level. Supported levels are 0 and 2 where 0 is the default.
   3668           ******************************************************************************/
   3669          static void setRamWaitState(uint32_t coreFreq, int vscale)
   3670          {
   3671            uint32_t limit = 38000000;
   3672            if (vscale == 2) {
   3673              limit = 16000000;
   3674            }
   3675          
   3676            if (coreFreq > limit) {
   3677              BUS_RegMaskedSet(&MSC->RAMCTRL, (MSC_RAMCTRL_RAMWSEN
   3678                                               | MSC_RAMCTRL_RAM1WSEN
   3679                                               | MSC_RAMCTRL_RAM2WSEN));
   3680            } else {
   3681              BUS_RegMaskedClear(&MSC->RAMCTRL, (MSC_RAMCTRL_RAMWSEN
   3682                                                 | MSC_RAMCTRL_RAM1WSEN
   3683                                                 | MSC_RAMCTRL_RAM2WSEN));
   3684            }
   3685          }
   3686          #endif
   3687          
   3688          #if defined(_MSC_CTRL_WAITMODE_MASK)
   3689          /***************************************************************************//**
   3690           * @brief
   3691           *   Configure the wait state for peripheral accesses over the bus to support
   3692           *   the given bus clock frequency.
   3693           *
   3694           * @param[in] busFreq
   3695           *   A peripheral bus clock frequency to configure wait-states.
   3696           *
   3697           * @param[in] vscale
   3698           *   The voltage scale to configure wait-states. Expected values are
   3699           *   0 or 2.
   3700           *
   3701           *   @li 0 = 1.2 V (VSCALE2)
   3702           *   @li 2 = 1.0 V (VSCALE0)
   3703           * ******************************************************************************/
   3704          static void setBusWaitState(uint32_t busFreq, int vscale)
   3705          {
   3706            if ((busFreq > 50000000) && (vscale == 0)) {
   3707              BUS_RegMaskedSet(&MSC->CTRL, MSC_CTRL_WAITMODE_WS1);
   3708            } else {
   3709              BUS_RegMaskedClear(&MSC->CTRL, MSC_CTRL_WAITMODE_WS1);
   3710            }
   3711          }
   3712          #endif
   3713          
   3714          #if defined(PLFRCO_PRESENT)
   3715          static bool deviceHasPlfrco(void)
   3716          {
   3717            SYSTEM_ChipRevision_TypeDef rev;
   3718          
   3719            if (_SILICON_LABS_GECKO_INTERNAL_SDID == 89) {
   3720              // check the xG13 rev and check if it's >= Rev A3
   3721              SYSTEM_ChipRevisionGet(&rev);
   3722              return (rev.major > 1) || (rev.minor >= 3);
   3723            } else {
   3724              return false;
   3725            }
   3726          }
   3727          #endif
   3728          
   3729          /***************************************************************************//**
   3730           * @brief
   3731           *   Configure various wait states to switch to a certain frequency
   3732           *   and a certain voltage scale.
   3733           *
   3734           * @details
   3735           *   This function will set up the necessary flash, bus, and RAM wait states.
   3736           *   Updating the wait state configuration must be done before
   3737           *   increasing the clock frequency and it must be done after decreasing the
   3738           *   clock frequency. Updating the wait state configuration must be done before
   3739           *   core voltage is decreased and it must be done after a core voltage is
   3740           *   increased.
   3741           *
   3742           * @param[in] coreFreq
   3743           *   The core clock frequency to configure wait-states.
   3744           *
   3745           * @param[in] vscale
   3746           *   The voltage scale to configure wait-states. Expected values are
   3747           *   0 or 2, higher number is lower voltage.
   3748           *
   3749           *   @li 0 = 1.2 V (VSCALE2)
   3750           *   @li 2 = 1.0 V (VSCALE0)
   3751           *
   3752           ******************************************************************************/
   3753          void CMU_UpdateWaitStates(uint32_t freq, int vscale)
   3754          {
   3755            /* Make sure the MSC is unlocked */
   3756            bool mscLocked = MSC->LOCK != 0UL;
   3757            MSC->LOCK = MSC_UNLOCK_CODE;
   3758          
   3759            flashWaitStateControl(freq, vscale);
   3760          #if defined(_MSC_RAMCTRL_RAMWSEN_MASK)
   3761            setRamWaitState(freq, vscale);
   3762          #endif
   3763          #if defined(_MSC_CTRL_WAITMODE_MASK)
   3764            setBusWaitState(freq, vscale);
   3765          #endif
   3766          
   3767            if (mscLocked) {
   3768              MSC->LOCK = 0;
   3769            }
   3770          }
   3771          
   3772          #if defined(_CMU_HFXOSTEADYSTATECTRL_REGISHUPPER_MASK)
   3773          /***************************************************************************//**
   3774           * @brief
   3775           *   Return the upper value for CMU_HFXOSTEADYSTATECTRL_REGISH.
   3776           ******************************************************************************/
   3777          static uint32_t getRegIshUpperVal(uint32_t steadyStateRegIsh)
   3778          {
   3779            uint32_t regIshUpper;
   3780            const uint32_t upperMax = _CMU_HFXOSTEADYSTATECTRL_REGISHUPPER_MASK
   3781                                      >> _CMU_HFXOSTEADYSTATECTRL_REGISHUPPER_SHIFT;
   3782            /* Add 3 as specified in the register description for CMU_HFXOSTEADYSTATECTRL_REGISHUPPER. */
   3783            regIshUpper = SL_MIN(steadyStateRegIsh + 3UL, upperMax);
   3784            regIshUpper <<= _CMU_HFXOSTEADYSTATECTRL_REGISHUPPER_SHIFT;
   3785            return regIshUpper;
   3786          }
   3787          #endif
   3788          
   3789          #if defined(_CMU_HFXOCTRL_MASK)
   3790          /***************************************************************************//**
   3791           * @brief
   3792           *   Get the HFXO tuning mode.
   3793           *
   3794           * @return
   3795           *   The current HFXO tuning mode from the HFXOCTRL register.
   3796           ******************************************************************************/
   3797          __STATIC_INLINE uint32_t getHfxoTuningMode(void)
   3798          {
   3799          #if defined(_CMU_HFXOCTRL_PEAKDETSHUNTOPTMODE_MASK)
   3800            return (CMU->HFXOCTRL & _CMU_HFXOCTRL_PEAKDETSHUNTOPTMODE_MASK)
   3801                   >> _CMU_HFXOCTRL_PEAKDETSHUNTOPTMODE_SHIFT;
   3802          #else
   3803            return (CMU->HFXOCTRL & _CMU_HFXOCTRL_PEAKDETMODE_MASK)
   3804                   >> _CMU_HFXOCTRL_PEAKDETMODE_SHIFT;
   3805          #endif
   3806          }
   3807          
   3808          /***************************************************************************//**
   3809           * @brief
   3810           *   Set the HFXO tuning mode.
   3811           *
   3812           * @param[in] mode
   3813           *   The new HFXO tuning mode. This can be HFXO_TUNING_MODE_AUTO or
   3814           *   HFXO_TUNING_MODE_CMD.
   3815           ******************************************************************************/
   3816          __STATIC_INLINE void setHfxoTuningMode(uint32_t mode)
   3817          {
   3818          #if defined(_CMU_HFXOCTRL_PEAKDETSHUNTOPTMODE_MASK)
   3819            CMU->HFXOCTRL = (CMU->HFXOCTRL & ~_CMU_HFXOCTRL_PEAKDETSHUNTOPTMODE_MASK)
   3820                            | (mode << _CMU_HFXOCTRL_PEAKDETSHUNTOPTMODE_SHIFT);
   3821          #else
   3822            CMU->HFXOCTRL = (CMU->HFXOCTRL & ~_CMU_HFXOCTRL_PEAKDETMODE_MASK)
   3823                            | (mode << _CMU_HFXOCTRL_PEAKDETMODE_SHIFT);
   3824          #endif
   3825          }
   3826          #endif
   3827          
   3828          /***************************************************************************//**
   3829           * @brief
   3830           *   Get the LFnCLK frequency based on the current configuration.
   3831           *
   3832           * @param[in] lfClkBranch
   3833           *   Selected LF branch.
   3834           *
   3835           * @return
   3836           *   The LFnCLK frequency in Hz. If no LFnCLK is selected (disabled), 0 is
   3837           *   returned.
   3838           ******************************************************************************/
   3839          static uint32_t lfClkGet(CMU_Clock_TypeDef lfClkBranch)
   3840          {
   3841            uint32_t sel;
   3842            uint32_t ret = 0;
   3843          
   3844            switch (lfClkBranch) {
   3845              case cmuClock_LFA:
   3846              case cmuClock_LFB:
   3847          #if defined(_CMU_LFCCLKEN0_MASK)
   3848              case cmuClock_LFC:
   3849          #endif
   3850          #if defined(_CMU_LFECLKSEL_MASK)
   3851              case cmuClock_LFE:
   3852          #endif
   3853                break;
   3854          
   3855              default:
   3856                EFM_ASSERT(false);
   3857                break;
   3858            }
   3859          
   3860            sel = (uint32_t)CMU_ClockSelectGet(lfClkBranch);
   3861          
   3862            /* Get clock select field */
   3863            switch (lfClkBranch) {
   3864              case cmuClock_LFA:
   3865          #if defined(_CMU_LFCLKSEL_MASK)
   3866                sel = (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFA_MASK) >> _CMU_LFCLKSEL_LFA_SHIFT;
   3867          #elif defined(_CMU_LFACLKSEL_MASK)
   3868                sel = (CMU->LFACLKSEL & _CMU_LFACLKSEL_LFA_MASK) >> _CMU_LFACLKSEL_LFA_SHIFT;
   3869          #else
   3870                EFM_ASSERT(false);
   3871          #endif
   3872                break;
   3873          
   3874              case cmuClock_LFB:
   3875          #if defined(_CMU_LFCLKSEL_MASK)
   3876                sel = (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFB_MASK) >> _CMU_LFCLKSEL_LFB_SHIFT;
   3877          #elif defined(_CMU_LFBCLKSEL_MASK)
   3878                sel = (CMU->LFBCLKSEL & _CMU_LFBCLKSEL_LFB_MASK) >> _CMU_LFBCLKSEL_LFB_SHIFT;
   3879          #else
   3880                EFM_ASSERT(false);
   3881          #endif
   3882                break;
   3883          
   3884          #if defined(_CMU_LFCCLKEN0_MASK)
   3885              case cmuClock_LFC:
   3886          #if defined(_CMU_LFCLKSEL_LFC_MASK)
   3887                sel = (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFC_MASK) >> _CMU_LFCLKSEL_LFC_SHIFT;
   3888          #elif defined(_CMU_LFCCLKSEL_LFC_MASK)
   3889                sel = (CMU->LFCCLKSEL & _CMU_LFCCLKSEL_LFC_MASK) >> _CMU_LFCCLKSEL_LFC_SHIFT;
   3890          #else
   3891                EFM_ASSERT(false);
   3892          #endif
   3893                break;
   3894          #endif
   3895          
   3896          #if defined(_CMU_LFECLKSEL_MASK)
   3897              case cmuClock_LFE:
   3898                sel = (CMU->LFECLKSEL & _CMU_LFECLKSEL_LFE_MASK) >> _CMU_LFECLKSEL_LFE_SHIFT;
   3899                break;
   3900          #endif
   3901          
   3902              default:
   3903                EFM_ASSERT(false);
   3904                break;
   3905            }
   3906          
   3907            /* Get the clock frequency. */
   3908          #if defined(_CMU_LFCLKSEL_MASK)
   3909            switch (sel) {
   3910              case _CMU_LFCLKSEL_LFA_LFRCO:
   3911                ret = SystemLFRCOClockGet();
   3912                break;
   3913          
   3914              case _CMU_LFCLKSEL_LFA_LFXO:
   3915                ret = SystemLFXOClockGet();
   3916                break;
   3917          
   3918          #if defined(_CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2)
   3919              case _CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2:
   3920          #if defined(CMU_MAX_FREQ_HFLE)
   3921                /* HFLE bit is or'ed by hardware with HFCORECLKLEDIV to reduce the
   3922                 * frequency of CMU_HFCORECLKLEDIV2. */
   3923                ret = SystemCoreClockGet() / (1U << (getHfLeConfig() + 1));
   3924          #else
   3925                ret = SystemCoreClockGet() / 2U;
   3926          #endif
   3927                break;
   3928          #endif
   3929          
   3930              case _CMU_LFCLKSEL_LFA_DISABLED:
   3931                ret = 0;
   3932          #if defined(CMU_LFCLKSEL_LFAE)
   3933                /* Check LF Extended bit setting for LFA or LFB ULFRCO clock. */
   3934                if ((lfClkBranch == cmuClock_LFA) || (lfClkBranch == cmuClock_LFB)) {
   3935                  if (CMU->LFCLKSEL >> (lfClkBranch == cmuClock_LFA
   3936                                        ? _CMU_LFCLKSEL_LFAE_SHIFT
   3937                                        : _CMU_LFCLKSEL_LFBE_SHIFT)) {
   3938                    ret = SystemULFRCOClockGet();
   3939                  }
   3940                }
   3941          #endif
   3942                break;
   3943          
   3944              default:
   3945                ret = 0U;
   3946                EFM_ASSERT(false);
   3947                break;
   3948            }
   3949          #endif /* _CMU_LFCLKSEL_MASK */
   3950          
   3951          #if defined(_CMU_LFACLKSEL_MASK)
   3952            switch (sel) {
   3953              case _CMU_LFACLKSEL_LFA_LFRCO:
   3954                ret = SystemLFRCOClockGet();
   3955                break;
   3956          
   3957              case _CMU_LFACLKSEL_LFA_LFXO:
   3958                ret = SystemLFXOClockGet();
   3959                break;
   3960          
   3961              case _CMU_LFACLKSEL_LFA_ULFRCO:
   3962                ret = SystemULFRCOClockGet();
   3963                break;
   3964          
   3965          #if defined(PLFRCO_PRESENT)
   3966              case _CMU_LFACLKSEL_LFA_PLFRCO:
   3967                ret = SystemLFRCOClockGet();
   3968                break;
   3969          #endif
   3970          
   3971          #if defined(_CMU_LFACLKSEL_LFA_HFCLKLE)
   3972              case _CMU_LFACLKSEL_LFA_HFCLKLE:
   3973                ret = SystemCoreClockGet()
   3974                      / SL_Log2ToDiv(((CMU->HFPRESC & _CMU_HFPRESC_HFCLKLEPRESC_MASK)
   3975                                      >> _CMU_HFPRESC_HFCLKLEPRESC_SHIFT) + 1);
   3976                break;
   3977          #elif defined(_CMU_LFBCLKSEL_LFB_HFCLKLE)
   3978              case _CMU_LFBCLKSEL_LFB_HFCLKLE:
   3979                ret = SystemCoreClockGet()
   3980                      / SL_Log2ToDiv(((CMU->HFPRESC & _CMU_HFPRESC_HFCLKLEPRESC_MASK)
   3981                                      >> _CMU_HFPRESC_HFCLKLEPRESC_SHIFT) + 1UL);
   3982                break;
   3983          #endif
   3984          
   3985              case _CMU_LFACLKSEL_LFA_DISABLED:
   3986                ret = 0;
   3987                break;
   3988          
   3989              default:
   3990                ret = 0U;
   3991                EFM_ASSERT(false);
   3992                break;
   3993            }
   3994          #endif
   3995          
   3996            return ret;
   3997          }
   3998          
   3999          /***************************************************************************//**
   4000           * @brief
   4001           *   Wait for an ongoing sync of register(s) to low-frequency domain to complete.
   4002           *
   4003           * @param[in] mask
   4004           *   A bitmask corresponding to SYNCBUSY register defined bits, indicating
   4005           *   registers that must complete any ongoing synchronization.
   4006           ******************************************************************************/
   4007          __STATIC_INLINE void syncReg(uint32_t mask)
   4008          {
   4009            /* Avoid a deadlock if modifying the same register twice when freeze mode is */
   4010            /* activated. */
   4011            if ((CMU->FREEZE & CMU_FREEZE_REGFREEZE) != 0UL) {
   4012              return;
   4013            }
   4014          
   4015            /* Wait for any pending previous write operation to complete */
   4016            /* in low-frequency domain. */
   4017            while ((CMU->SYNCBUSY & mask) != 0UL) {
   4018            }
   4019          }
   4020          
   4021          #if defined(USBC_CLOCK_PRESENT)
   4022          /***************************************************************************//**
   4023           * @brief
   4024           *   Get the USBC frequency.
   4025           *
   4026           * @return
   4027           *   USBC frequency in Hz.
   4028           ******************************************************************************/
   4029          static uint32_t usbCClkGet(void)
   4030          {
   4031            uint32_t ret;
   4032            CMU_Select_TypeDef clk;
   4033          
   4034            /* Get the selected clock source. */
   4035            clk = CMU_ClockSelectGet(cmuClock_USBC);
   4036          
   4037            switch (clk) {
   4038              case cmuSelect_LFXO:
   4039                ret = SystemLFXOClockGet();
   4040                break;
   4041              case cmuSelect_LFRCO:
   4042                ret = SystemLFRCOClockGet();
   4043                break;
   4044          #if defined (_CMU_USHFRCOCTRL_MASK)
   4045              case cmuSelect_USHFRCO:
   4046                ret = ushfrcoFreq;
   4047                break;
   4048          #endif
   4049              case cmuSelect_HFCLK:
   4050                ret = SystemHFClockGet();
   4051                break;
   4052              default:
   4053                /* Clock is not enabled */
   4054                ret = 0;
   4055                break;
   4056            }
   4057            return ret;
   4058          }
   4059          #endif
   4060          
   4061          /***************************************************************************//**
   4062           * @brief
   4063           *   Set HFPER clock tree prescalers to safe values.
   4064           *
   4065           * @note
   4066           *   This function applies to EFM32GG11B. There are 3 HFPER clock trees with
   4067           *   these frequency limits:
   4068           *     HFPERCLK  (A-tree): 20MHz in VSCALE0 mode, 50MHz in VSCALE2 mode.
   4069           *     HFPERBCLK (B-tree): 20MHz in VSCALE0 mode, 72MHz in VSCALE2 mode.
   4070           *     HFPERCCLK (C-tree): 20MHz in VSCALE0 mode, 50MHz in VSCALE2 mode.
   4071           ******************************************************************************/
   4072          static void hfperClkSafePrescaler(void)
   4073          {
   4074          #if defined(_CMU_HFPERPRESC_MASK) && defined(_CMU_HFPERPRESCB_MASK) \
   4075            && defined(_CMU_HFPERPRESCC_MASK)
   4076            // Assuming a max. HFCLK of 72MHz, we need to set prescalers to DIV4.
   4077            CMU_ClockPrescSet(cmuClock_HFPER, 3U);
   4078            CMU_ClockPrescSet(cmuClock_HFPERB, 3U);
   4079            CMU_ClockPrescSet(cmuClock_HFPERC, 3U);
   4080          #endif
   4081          }
   4082          
   4083          /***************************************************************************//**
   4084           * @brief
   4085           *   Set HFPER clock tree prescalers to give highest possible clock node
   4086           *   frequency while still beeing within spec.
   4087           *
   4088           * @note
   4089           *   This function applies to EFM32GG11B. There are 3 HFPER clock trees with
   4090           *   these frequency limits:
   4091           *     HFPERCLK  (A-tree): 20MHz in VSCALE0 mode, 50MHz in VSCALE2 mode.
   4092           *     HFPERBCLK (B-tree): 20MHz in VSCALE0 mode, 72MHz in VSCALE2 mode.
   4093           *     HFPERCCLK (C-tree): 20MHz in VSCALE0 mode, 50MHz in VSCALE2 mode.
   4094           ******************************************************************************/
   4095          static void hfperClkOptimizedPrescaler(void)
   4096          {
   4097          #if defined(_CMU_HFPERPRESC_MASK) && defined(_CMU_HFPERPRESCB_MASK) \
   4098            && defined(_CMU_HFPERPRESCC_MASK)
   4099            uint32_t hfClkFreq, divisor;
   4100          
   4101            hfClkFreq = SystemHFClockGet();
   4102          
   4103            if ( EMU_VScaleGet() == emuVScaleEM01_LowPower) {
   4104              divisor = (hfClkFreq + 20000000U - 1U) / 20000000U; // ceil(x)
   4105              if (divisor > 0U) {
   4106                divisor--;                                        // Convert to prescaler
   4107              }
   4108              CMU_ClockPrescSet(cmuClock_HFPER, divisor);
   4109              CMU_ClockPrescSet(cmuClock_HFPERB, divisor);
   4110              CMU_ClockPrescSet(cmuClock_HFPERC, divisor);
   4111            } else {
   4112              divisor = (hfClkFreq + 50000000U - 1U) / 50000000U;
   4113              if (divisor > 0U) {
   4114                divisor--;
   4115              }
   4116              CMU_ClockPrescSet(cmuClock_HFPER, divisor);
   4117              CMU_ClockPrescSet(cmuClock_HFPERC, divisor);
   4118          
   4119              divisor = (hfClkFreq + 72000000U - 1U) / 72000000U;
   4120              if (divisor > 0U) {
   4121                divisor--;
   4122              }
   4123              CMU_ClockPrescSet(cmuClock_HFPERB, divisor);
   4124            }
   4125          #endif
   4126          }
   4127          
   4128          /** @endcond */
   4129          
   4130          /*******************************************************************************
   4131           **************************   GLOBAL FUNCTIONS   *******************************
   4132           ******************************************************************************/
   4133          
   4134          #if defined(_CMU_AUXHFRCOCTRL_BAND_MASK)
   4135          /***************************************************************************//**
   4136           * @brief
   4137           *   Get the AUXHFRCO band in use.
   4138           *
   4139           * @return
   4140           *   AUXHFRCO band in use.
   4141           ******************************************************************************/
   4142          CMU_AUXHFRCOBand_TypeDef CMU_AUXHFRCOBandGet(void)
   4143          {
   4144            return (CMU_AUXHFRCOBand_TypeDef)((CMU->AUXHFRCOCTRL
   4145                                               & _CMU_AUXHFRCOCTRL_BAND_MASK)
   4146                                              >> _CMU_AUXHFRCOCTRL_BAND_SHIFT);
   4147          }
   4148          #endif /* _CMU_AUXHFRCOCTRL_BAND_MASK */
   4149          
   4150          #if defined(_CMU_AUXHFRCOCTRL_BAND_MASK)
   4151          /***************************************************************************//**
   4152           * @brief
   4153           *   Set the AUXHFRCO band and the tuning value based on the value in the
   4154           *   calibration table made during production.
   4155           *
   4156           * @param[in] band
   4157           *   AUXHFRCO band to activate.
   4158           ******************************************************************************/
   4159          void CMU_AUXHFRCOBandSet(CMU_AUXHFRCOBand_TypeDef band)
   4160          {
   4161            uint32_t tuning;
   4162          
   4163            /* Read a tuning value from the calibration table. */
   4164            switch (band) {
   4165              case cmuAUXHFRCOBand_1MHz:
   4166                tuning = (DEVINFO->AUXHFRCOCAL0 & _DEVINFO_AUXHFRCOCAL0_BAND1_MASK)
   4167                         >> _DEVINFO_AUXHFRCOCAL0_BAND1_SHIFT;
   4168                break;
   4169          
   4170              case cmuAUXHFRCOBand_7MHz:
   4171                tuning = (DEVINFO->AUXHFRCOCAL0 & _DEVINFO_AUXHFRCOCAL0_BAND7_MASK)
   4172                         >> _DEVINFO_AUXHFRCOCAL0_BAND7_SHIFT;
   4173                break;
   4174          
   4175              case cmuAUXHFRCOBand_11MHz:
   4176                tuning = (DEVINFO->AUXHFRCOCAL0 & _DEVINFO_AUXHFRCOCAL0_BAND11_MASK)
   4177                         >> _DEVINFO_AUXHFRCOCAL0_BAND11_SHIFT;
   4178                break;
   4179          
   4180              case cmuAUXHFRCOBand_14MHz:
   4181                tuning = (DEVINFO->AUXHFRCOCAL0 & _DEVINFO_AUXHFRCOCAL0_BAND14_MASK)
   4182                         >> _DEVINFO_AUXHFRCOCAL0_BAND14_SHIFT;
   4183                break;
   4184          
   4185              case cmuAUXHFRCOBand_21MHz:
   4186                tuning = (DEVINFO->AUXHFRCOCAL1 & _DEVINFO_AUXHFRCOCAL1_BAND21_MASK)
   4187                         >> _DEVINFO_AUXHFRCOCAL1_BAND21_SHIFT;
   4188                break;
   4189          
   4190          #if defined(_CMU_AUXHFRCOCTRL_BAND_28MHZ)
   4191              case cmuAUXHFRCOBand_28MHz:
   4192                tuning = (DEVINFO->AUXHFRCOCAL1 & _DEVINFO_AUXHFRCOCAL1_BAND28_MASK)
   4193                         >> _DEVINFO_AUXHFRCOCAL1_BAND28_SHIFT;
   4194                break;
   4195          #endif
   4196          
   4197              default:
   4198                EFM_ASSERT(false);
   4199                return;
   4200            }
   4201          
   4202            /* Set band/tuning. */
   4203            CMU->AUXHFRCOCTRL = (CMU->AUXHFRCOCTRL
   4204                                 & ~(_CMU_AUXHFRCOCTRL_BAND_MASK
   4205                                     | _CMU_AUXHFRCOCTRL_TUNING_MASK))
   4206                                | (band << _CMU_AUXHFRCOCTRL_BAND_SHIFT)
   4207                                | (tuning << _CMU_AUXHFRCOCTRL_TUNING_SHIFT);
   4208          }
   4209          #endif /* _CMU_AUXHFRCOCTRL_BAND_MASK */
   4210          
   4211          #if defined(_CMU_AUXHFRCOCTRL_FREQRANGE_MASK)
   4212          /**************************************************************************//**
   4213           * @brief
   4214           *   Get the AUXHFRCO frequency calibration word in DEVINFO.
   4215           *
   4216           * @param[in] freq
   4217           *   Frequency in Hz.
   4218           *
   4219           * @return
   4220           *   AUXHFRCO calibration word for a given frequency.
   4221           *****************************************************************************/
   4222          static uint32_t CMU_AUXHFRCODevinfoGet(CMU_AUXHFRCOFreq_TypeDef freq)
   4223          {
   4224            switch (freq) {
   4225              /* 1, 2, and 4 MHz share the same calibration word. */
   4226              case cmuAUXHFRCOFreq_1M0Hz:
   4227              case cmuAUXHFRCOFreq_2M0Hz:
   4228              case cmuAUXHFRCOFreq_4M0Hz:
   4229                return DEVINFO->AUXHFRCOCAL0;
   4230          
   4231              case cmuAUXHFRCOFreq_7M0Hz:
   4232                return DEVINFO->AUXHFRCOCAL3;
   4233          
   4234              case cmuAUXHFRCOFreq_13M0Hz:
   4235                return DEVINFO->AUXHFRCOCAL6;
   4236          
   4237              case cmuAUXHFRCOFreq_16M0Hz:
   4238                return DEVINFO->AUXHFRCOCAL7;
   4239          
   4240              case cmuAUXHFRCOFreq_19M0Hz:
   4241                return DEVINFO->AUXHFRCOCAL8;
   4242          
   4243              case cmuAUXHFRCOFreq_26M0Hz:
   4244                return DEVINFO->AUXHFRCOCAL10;
   4245          
   4246              case cmuAUXHFRCOFreq_32M0Hz:
   4247                return DEVINFO->AUXHFRCOCAL11;
   4248          
   4249              case cmuAUXHFRCOFreq_38M0Hz:
   4250                return DEVINFO->AUXHFRCOCAL12;
   4251          
   4252          #if defined(_DEVINFO_AUXHFRCOCAL13_MASK)
   4253              case cmuAUXHFRCOFreq_48M0Hz:
   4254                return DEVINFO->AUXHFRCOCAL13;
   4255          #endif
   4256          #if defined(_DEVINFO_AUXHFRCOCAL14_MASK)
   4257              case cmuAUXHFRCOFreq_50M0Hz:
   4258                return DEVINFO->AUXHFRCOCAL14;
   4259          #endif
   4260          
   4261              default: /* cmuAUXHFRCOFreq_UserDefined */
   4262                return 0;
   4263            }
   4264          }
   4265          #endif /* _CMU_AUXHFRCOCTRL_FREQRANGE_MASK */
   4266          
   4267          #if defined(_CMU_AUXHFRCOCTRL_FREQRANGE_MASK)
   4268          /***************************************************************************//**
   4269           * @brief
   4270           *   Get the current AUXHFRCO frequency.
   4271           *
   4272           * @return
   4273           *   AUXHFRCO frequency.
   4274           ******************************************************************************/
   4275          CMU_AUXHFRCOFreq_TypeDef CMU_AUXHFRCOBandGet(void)
   4276          {
   4277            return auxHfrcoFreq;
   4278          }
   4279          #endif /* _CMU_AUXHFRCOCTRL_FREQRANGE_MASK */
   4280          
   4281          #if defined(_CMU_AUXHFRCOCTRL_FREQRANGE_MASK)
   4282          /***************************************************************************//**
   4283           * @brief
   4284           *   Set AUXHFRCO calibration for the selected target frequency.
   4285           *
   4286           * @param[in] setFreq
   4287           *   AUXHFRCO frequency to set
   4288           ******************************************************************************/
   4289          void CMU_AUXHFRCOBandSet(CMU_AUXHFRCOFreq_TypeDef setFreq)
   4290          {
   4291            uint32_t freqCal;
   4292          
   4293            /* Get DEVINFO index and set global auxHfrcoFreq. */
   4294            freqCal = CMU_AUXHFRCODevinfoGet(setFreq);
   4295            EFM_ASSERT((freqCal != 0UL) && (freqCal != UINT_MAX));
   4296            auxHfrcoFreq = setFreq;
   4297          
   4298            /* Wait for any previous sync to complete, then set calibration data
   4299               for the selected frequency.  */
   4300            while (BUS_RegBitRead(&CMU->SYNCBUSY,
   4301                                  _CMU_SYNCBUSY_AUXHFRCOBSY_SHIFT) != 0UL) {
   4302            }
   4303          
   4304            /* Set a divider in AUXHFRCOCTRL for 1, 2, and 4 MHz. */
   4305            switch (setFreq) {
   4306              case cmuAUXHFRCOFreq_1M0Hz:
   4307                freqCal = (freqCal & ~_CMU_AUXHFRCOCTRL_CLKDIV_MASK)
   4308                          | CMU_AUXHFRCOCTRL_CLKDIV_DIV4;
   4309                break;
   4310          
   4311              case cmuAUXHFRCOFreq_2M0Hz:
   4312                freqCal = (freqCal & ~_CMU_AUXHFRCOCTRL_CLKDIV_MASK)
   4313                          | CMU_AUXHFRCOCTRL_CLKDIV_DIV2;
   4314                break;
   4315          
   4316              case cmuAUXHFRCOFreq_4M0Hz:
   4317                freqCal = (freqCal & ~_CMU_AUXHFRCOCTRL_CLKDIV_MASK)
   4318                          | CMU_AUXHFRCOCTRL_CLKDIV_DIV1;
   4319                break;
   4320          
   4321              default:
   4322                break;
   4323            }
   4324            CMU->AUXHFRCOCTRL = freqCal;
   4325          }
   4326          #endif /* _CMU_AUXHFRCOCTRL_FREQRANGE_MASK */
   4327          
   4328          /***************************************************************************//**
   4329           * @brief
   4330           *   Calibrate the clock.
   4331           *
   4332           * @details
   4333           *   Run a calibration for HFCLK against a selectable reference clock.
   4334           *   See the reference manual, CMU chapter, for more details.
   4335           *
   4336           * @note
   4337           *   This function will not return until the calibration measurement is completed.
   4338           *
   4339           * @param[in] HFCycles
   4340           *   The number of HFCLK cycles to run the calibration. Increasing this number
   4341           *   increases precision but the calibration will take more time.
   4342           *
   4343           * @param[in] ref
   4344           *   The reference clock used to compare HFCLK.
   4345           *
   4346           * @return
   4347           *   The number of ticks the reference clock after HFCycles ticks on the HF
   4348           *   clock.
   4349           ******************************************************************************/
   4350          uint32_t CMU_Calibrate(uint32_t HFCycles, CMU_Osc_TypeDef reference)
   4351          {
   4352            EFM_ASSERT(HFCycles <= (_CMU_CALCNT_CALCNT_MASK >> _CMU_CALCNT_CALCNT_SHIFT));
   4353          
   4354            /* Set the reference clock source. */
   4355            switch (reference) {
   4356              case cmuOsc_LFXO:
   4357                CMU->CALCTRL = CMU_CALCTRL_UPSEL_LFXO;
   4358                break;
   4359          
   4360              case cmuOsc_LFRCO:
   4361                CMU->CALCTRL = CMU_CALCTRL_UPSEL_LFRCO;
   4362                break;
   4363          
   4364          #if defined(PLFRCO_PRESENT)
   4365              case cmuOsc_PLFRCO:
   4366                CMU->CALCTRL = CMU_CALCTRL_UPSEL_PLFRCO;
   4367                break;
   4368          #endif
   4369          
   4370              case cmuOsc_HFXO:
   4371                CMU->CALCTRL = CMU_CALCTRL_UPSEL_HFXO;
   4372                break;
   4373          
   4374              case cmuOsc_HFRCO:
   4375                CMU->CALCTRL = CMU_CALCTRL_UPSEL_HFRCO;
   4376                break;
   4377          
   4378              case cmuOsc_AUXHFRCO:
   4379                CMU->CALCTRL = CMU_CALCTRL_UPSEL_AUXHFRCO;
   4380                break;
   4381          
   4382          #if defined (_CMU_USHFRCOCTRL_MASK)
   4383              case cmuOsc_USHFRCO:
   4384                CMU->CALCTRL = CMU_CALCTRL_UPSEL_USHFRCO;
   4385                break;
   4386          #endif
   4387          
   4388              default:
   4389                EFM_ASSERT(false);
   4390                return 0;
   4391            }
   4392          
   4393            /* Set the top value. */
   4394            CMU->CALCNT = HFCycles;
   4395          
   4396            /* Start the calibration. */
   4397            CMU->CMD = CMU_CMD_CALSTART;
   4398          
   4399          #if defined(CMU_STATUS_CALRDY)
   4400            /* Wait until calibration completes. */
   4401            while (BUS_RegBitRead(&CMU->STATUS, _CMU_STATUS_CALRDY_SHIFT) == 0UL) {
   4402            }
   4403          #else
   4404            /* Wait until calibration completes. */
   4405            while (BUS_RegBitRead(&CMU->STATUS, _CMU_STATUS_CALBSY_SHIFT) != 0UL) {
   4406            }
   4407          #endif
   4408          
   4409            return CMU->CALCNT;
   4410          }
   4411          
   4412          #if defined(_CMU_CALCTRL_UPSEL_MASK) && defined(_CMU_CALCTRL_DOWNSEL_MASK)
   4413          /***************************************************************************//**
   4414           * @brief
   4415           *   Configure the clock calibration.
   4416           *
   4417           * @details
   4418           *   Configure a calibration for a selectable clock source against another
   4419           *   selectable reference clock.
   4420           *   See the reference manual, CMU chapter, for more details.
   4421           *
   4422           * @note
   4423           *   After configuration, a call to @ref CMU_CalibrateStart() is required and
   4424           *   the resulting calibration value can be read out with the
   4425           *   @ref CMU_CalibrateCountGet() function call.
   4426           *
   4427           * @param[in] downCycles
   4428           *   The number of downSel clock cycles to run the calibration. Increasing this
   4429           *   number increases precision but the calibration will take more time.
   4430           *
   4431           * @param[in] downSel
   4432           *   The clock, which will be counted down downCycles.
   4433           *
   4434           * @param[in] upSel
   4435           *   The reference clock; the number of cycles generated by this clock will
   4436           *   be counted and added up and the result can be given with the
   4437           *   @ref CMU_CalibrateCountGet() function call.
   4438           ******************************************************************************/
   4439          void CMU_CalibrateConfig(uint32_t downCycles, CMU_Osc_TypeDef downSel,
   4440                                   CMU_Osc_TypeDef upSel)
   4441          {
   4442            /* Keep configuration settings untouched. */
   4443            uint32_t calCtrl = CMU->CALCTRL
   4444                               & ~(_CMU_CALCTRL_UPSEL_MASK | _CMU_CALCTRL_DOWNSEL_MASK);
   4445          
   4446            /* 20 bits of precision to calibration count register. */
   4447            EFM_ASSERT(downCycles <= (_CMU_CALCNT_CALCNT_MASK >> _CMU_CALCNT_CALCNT_SHIFT));
   4448          
   4449            /* Set down counting clock source - down counter. */
   4450            switch (downSel) {
   4451              case cmuOsc_LFXO:
   4452                calCtrl |= CMU_CALCTRL_DOWNSEL_LFXO;
   4453                break;
   4454          
   4455              case cmuOsc_LFRCO:
   4456                calCtrl |= CMU_CALCTRL_DOWNSEL_LFRCO;
   4457                break;
   4458          
   4459          #if defined(PLFRCO_PRESENT)
   4460              case cmuOsc_PLFRCO:
   4461                calCtrl |= CMU_CALCTRL_DOWNSEL_PLFRCO;
   4462                break;
   4463          #endif
   4464          
   4465              case cmuOsc_HFXO:
   4466                calCtrl |= CMU_CALCTRL_DOWNSEL_HFXO;
   4467                break;
   4468          
   4469              case cmuOsc_HFRCO:
   4470                calCtrl |= CMU_CALCTRL_DOWNSEL_HFRCO;
   4471                break;
   4472          
   4473              case cmuOsc_AUXHFRCO:
   4474                calCtrl |= CMU_CALCTRL_DOWNSEL_AUXHFRCO;
   4475                break;
   4476          
   4477          #if defined (_CMU_USHFRCOCTRL_MASK)
   4478              case cmuOsc_USHFRCO:
   4479                calCtrl |= CMU_CALCTRL_DOWNSEL_USHFRCO;
   4480                break;
   4481          #endif
   4482          
   4483              default:
   4484                EFM_ASSERT(false);
   4485                break;
   4486            }
   4487          
   4488            /* Set the top value to be counted down by the downSel clock. */
   4489            CMU->CALCNT = downCycles;
   4490          
   4491            /* Set the reference clock source - up counter. */
   4492            switch (upSel) {
   4493              case cmuOsc_LFXO:
   4494                calCtrl |= CMU_CALCTRL_UPSEL_LFXO;
   4495                break;
   4496          
   4497              case cmuOsc_LFRCO:
   4498                calCtrl |= CMU_CALCTRL_UPSEL_LFRCO;
   4499                break;
   4500          
   4501          #if defined(PLFRCO_PRESENT)
   4502              case cmuOsc_PLFRCO:
   4503                calCtrl |= CMU_CALCTRL_UPSEL_PLFRCO;
   4504                break;
   4505          #endif
   4506          
   4507              case cmuOsc_HFXO:
   4508                calCtrl |= CMU_CALCTRL_UPSEL_HFXO;
   4509                break;
   4510          
   4511              case cmuOsc_HFRCO:
   4512                calCtrl |= CMU_CALCTRL_UPSEL_HFRCO;
   4513                break;
   4514          
   4515              case cmuOsc_AUXHFRCO:
   4516                calCtrl |= CMU_CALCTRL_UPSEL_AUXHFRCO;
   4517                break;
   4518          
   4519          #if defined (_CMU_USHFRCOCTRL_MASK)
   4520              case cmuOsc_USHFRCO:
   4521                calCtrl |= CMU_CALCTRL_UPSEL_USHFRCO;
   4522                break;
   4523          #endif
   4524          
   4525              default:
   4526                EFM_ASSERT(false);
   4527                break;
   4528            }
   4529          
   4530            CMU->CALCTRL = calCtrl;
   4531          }
   4532          #endif
   4533          
   4534          /***************************************************************************//**
   4535           * @brief
   4536           *    Get the calibration count register.
   4537           * @note
   4538           *    If continuous calibration mode is active, calibration busy will almost
   4539           *    always be off and only the value needs to be read. In a normal case,
   4540           *    this function call is triggered by the CALRDY
   4541           *    interrupt flag.
   4542           * @return
   4543           *    The calibration count, the number of UPSEL clocks (see @ref CMU_CalibrateConfig())
   4544           *    in the period of DOWNSEL oscillator clock cycles configured by a previous
   4545           *    write operation to CMU->CALCNT.
   4546           ******************************************************************************/
   4547          uint32_t CMU_CalibrateCountGet(void)
   4548          {
   4549            /* Wait until calibration completes, UNLESS continuous calibration mode is  */
   4550            /* active. */
   4551          #if defined(CMU_CALCTRL_CONT)
   4552            if (BUS_RegBitRead(&CMU->CALCTRL, _CMU_CALCTRL_CONT_SHIFT) == 0UL) {
   4553          #if defined(CMU_STATUS_CALRDY)
   4554              /* Wait until calibration completes */
   4555              while (BUS_RegBitRead(&CMU->STATUS, _CMU_STATUS_CALRDY_SHIFT) == 0UL) {
   4556              }
   4557          #else
   4558              /* Wait until calibration completes */
   4559              while (BUS_RegBitRead(&CMU->STATUS, _CMU_STATUS_CALBSY_SHIFT) != 0UL) {
   4560              }
   4561          #endif
   4562            }
   4563          #else
   4564            while (BUS_RegBitRead(&CMU->STATUS, _CMU_STATUS_CALBSY_SHIFT) != 0UL) {
   4565            }
   4566          #endif
   4567            return CMU->CALCNT;
   4568          }
   4569          
   4570          /***************************************************************************//**
   4571           * @brief
   4572           *   Get the clock divisor/prescaler.
   4573           *
   4574           * @param[in] clock
   4575           *   A clock point to get the divisor/prescaler for. Notice that not all clock points
   4576           *   have a divisor/prescaler. See the CMU overview in the reference manual.
   4577           *
   4578           * @return
   4579           *   The current clock point divisor/prescaler. 1 is returned
   4580           *   if @p clock specifies a clock point without a divisor/prescaler.
   4581           ******************************************************************************/
   4582          CMU_ClkDiv_TypeDef CMU_ClockDivGet(CMU_Clock_TypeDef clock)
   4583          {
   4584          #if defined(_SILICON_LABS_32B_SERIES_1)
   4585            return 1UL + (uint32_t)CMU_ClockPrescGet(clock);
   4586          
   4587          #elif defined(_SILICON_LABS_32B_SERIES_0)
   4588            uint32_t           divReg;
   4589            CMU_ClkDiv_TypeDef ret;
   4590          
   4591            /* Get divisor reg ID. */
   4592            divReg = (clock >> CMU_DIV_REG_POS) & CMU_DIV_REG_MASK;
   4593          
   4594            switch (divReg) {
   4595          #if defined(_CMU_CTRL_HFCLKDIV_MASK)
   4596              case CMU_HFCLKDIV_REG:
   4597                ret = 1 + ((CMU->CTRL & _CMU_CTRL_HFCLKDIV_MASK)
   4598                           >> _CMU_CTRL_HFCLKDIV_SHIFT);
   4599                break;
   4600          #endif
   4601          
   4602              case CMU_HFPERCLKDIV_REG:
   4603                ret = (CMU_ClkDiv_TypeDef)((CMU->HFPERCLKDIV
   4604                                            & _CMU_HFPERCLKDIV_HFPERCLKDIV_MASK)
   4605                                           >> _CMU_HFPERCLKDIV_HFPERCLKDIV_SHIFT);
   4606                ret = SL_Log2ToDiv(ret);
   4607                break;
   4608          
   4609              case CMU_HFCORECLKDIV_REG:
   4610                ret = (CMU_ClkDiv_TypeDef)((CMU->HFCORECLKDIV
   4611                                            & _CMU_HFCORECLKDIV_HFCORECLKDIV_MASK)
   4612                                           >> _CMU_HFCORECLKDIV_HFCORECLKDIV_SHIFT);
   4613                ret = SL_Log2ToDiv(ret);
   4614                break;
   4615          
   4616              case CMU_LFAPRESC0_REG:
   4617                switch (clock) {
   4618                  case cmuClock_RTC:
   4619                    ret = (CMU_ClkDiv_TypeDef)((CMU->LFAPRESC0 & _CMU_LFAPRESC0_RTC_MASK)
   4620                                               >> _CMU_LFAPRESC0_RTC_SHIFT);
   4621                    ret = SL_Log2ToDiv(ret);
   4622                    break;
   4623          
   4624          #if defined(_CMU_LFAPRESC0_LETIMER0_MASK)
   4625                  case cmuClock_LETIMER0:
   4626                    ret = (CMU_ClkDiv_TypeDef)((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LETIMER0_MASK)
   4627                                               >> _CMU_LFAPRESC0_LETIMER0_SHIFT);
   4628                    ret = SL_Log2ToDiv(ret);
   4629                    break;
   4630          #endif
   4631          
   4632          #if defined(_CMU_LFAPRESC0_LCD_MASK)
   4633                  case cmuClock_LCDpre:
   4634                    ret = (CMU_ClkDiv_TypeDef)(((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LCD_MASK)
   4635                                                >> _CMU_LFAPRESC0_LCD_SHIFT)
   4636                                               + CMU_DivToLog2(cmuClkDiv_16));
   4637                    ret = SL_Log2ToDiv(ret);
   4638                    break;
   4639          #endif
   4640          
   4641          #if defined(_CMU_LFAPRESC0_LESENSE_MASK)
   4642                  case cmuClock_LESENSE:
   4643                    ret = (CMU_ClkDiv_TypeDef)((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LESENSE_MASK)
   4644                                               >> _CMU_LFAPRESC0_LESENSE_SHIFT);
   4645                    ret = SL_Log2ToDiv(ret);
   4646                    break;
   4647          #endif
   4648          
   4649                  default:
   4650                    ret = cmuClkDiv_1;
   4651                    EFM_ASSERT(false);
   4652                    break;
   4653                }
   4654                break;
   4655          
   4656              case CMU_LFBPRESC0_REG:
   4657                switch (clock) {
   4658          #if defined(_CMU_LFBPRESC0_LEUART0_MASK)
   4659                  case cmuClock_LEUART0:
   4660                    ret = (CMU_ClkDiv_TypeDef)((CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART0_MASK)
   4661                                               >> _CMU_LFBPRESC0_LEUART0_SHIFT);
   4662                    ret = SL_Log2ToDiv(ret);
   4663                    break;
   4664          #endif
   4665          
   4666          #if defined(_CMU_LFBPRESC0_LEUART1_MASK)
   4667                  case cmuClock_LEUART1:
   4668                    ret = (CMU_ClkDiv_TypeDef)((CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART1_MASK)
   4669                                               >> _CMU_LFBPRESC0_LEUART1_SHIFT);
   4670                    ret = SL_Log2ToDiv(ret);
   4671                    break;
   4672          #endif
   4673          
   4674                  default:
   4675                    ret = cmuClkDiv_1;
   4676                    EFM_ASSERT(false);
   4677                    break;
   4678                }
   4679                break;
   4680          
   4681              default:
   4682                ret = cmuClkDiv_1;
   4683                EFM_ASSERT(false);
   4684                break;
   4685            }
   4686          
   4687            return ret;
   4688          #endif
   4689          }
   4690          
   4691          /***************************************************************************//**
   4692           * @brief
   4693           *   Set the clock divisor/prescaler.
   4694           *
   4695           * @note
   4696           *   If setting an LF clock prescaler, synchronization into the low-frequency
   4697           *   domain is required. If the same register is modified before a previous
   4698           *   update has completed, this function will stall until the previous
   4699           *   synchronization has completed. See @ref CMU_FreezeEnable() for
   4700           *   a suggestion on how to reduce the stalling time in some use cases.
   4701           *
   4702           *   HFCLKLE prescaler is automatically modified when peripherals with clock
   4703           *   domain HFBUSCLK is chosen based on the maximum HFLE frequency allowed.
   4704           *
   4705           * @param[in] clock
   4706           *   Clock point to set divisor/prescaler for. Notice that not all clock points
   4707           *   have a divisor/prescaler. See the CMU overview in the reference
   4708           *   manual.
   4709           *
   4710           * @param[in] div
   4711           *   The clock divisor to use (<= cmuClkDiv_512).
   4712           ******************************************************************************/
   4713          void CMU_ClockDivSet(CMU_Clock_TypeDef clock, CMU_ClkDiv_TypeDef div)
   4714          {
   4715          #if defined(_SILICON_LABS_32B_SERIES_1)
   4716            CMU_ClockPrescSet(clock, (CMU_ClkPresc_TypeDef)(div - 1U));
   4717          
   4718          #elif defined(_SILICON_LABS_32B_SERIES_0)
   4719            uint32_t freq;
   4720            uint32_t divReg;
   4721          
   4722            /* Get the divisor reg ID. */
   4723            divReg = (clock >> CMU_DIV_REG_POS) & CMU_DIV_REG_MASK;
   4724          
   4725            switch (divReg) {
   4726          #if defined(_CMU_CTRL_HFCLKDIV_MASK)
   4727              case CMU_HFCLKDIV_REG:
   4728                EFM_ASSERT((div >= cmuClkDiv_1) && (div <= cmuClkDiv_8));
   4729          
   4730                /* Configure worst case wait states for flash access before setting divisor. */
   4731                flashWaitStateMax();
   4732          
   4733                /* Set the divider. */
   4734                CMU->CTRL = (CMU->CTRL & ~_CMU_CTRL_HFCLKDIV_MASK)
   4735                            | ((div - 1) << _CMU_CTRL_HFCLKDIV_SHIFT);
   4736          
   4737                /* Update the CMSIS core clock variable. */
   4738                /* (The function will update the global variable). */
   4739                freq = SystemCoreClockGet();
   4740          
   4741                /* Optimize flash access wait state setting for the current core clk. */
   4742                CMU_UpdateWaitStates(freq, (int)VSCALE_DEFAULT);
   4743                break;
   4744          #endif
   4745          
   4746              case CMU_HFPERCLKDIV_REG:
   4747                EFM_ASSERT((div >= cmuClkDiv_1) && (div <= cmuClkDiv_512));
   4748                /* Convert to the correct scale. */
   4749                div = CMU_DivToLog2(div);
   4750                CMU->HFPERCLKDIV = (CMU->HFPERCLKDIV & ~_CMU_HFPERCLKDIV_HFPERCLKDIV_MASK)
   4751                                   | (div << _CMU_HFPERCLKDIV_HFPERCLKDIV_SHIFT);
   4752                break;
   4753          
   4754              case CMU_HFCORECLKDIV_REG:
   4755                EFM_ASSERT((div >= cmuClkDiv_1) && (div <= cmuClkDiv_512));
   4756          
   4757                /* Configure worst case wait states for flash access before setting the divisor. */
   4758                flashWaitStateMax();
   4759          
   4760          #if defined(CMU_MAX_FREQ_HFLE)
   4761                setHfLeConfig(SystemHFClockGet() / div);
   4762          #endif
   4763          
   4764                /* Convert to the correct scale. */
   4765                div = CMU_DivToLog2(div);
   4766          
   4767                CMU->HFCORECLKDIV = (CMU->HFCORECLKDIV
   4768                                     & ~_CMU_HFCORECLKDIV_HFCORECLKDIV_MASK)
   4769                                    | (div << _CMU_HFCORECLKDIV_HFCORECLKDIV_SHIFT);
   4770          
   4771                /* Update the CMSIS core clock variable. */
   4772                /* (The function will update the global variable). */
   4773                freq = SystemCoreClockGet();
   4774          
   4775                /* Optimize wait state setting for the current core clk. */
   4776                CMU_UpdateWaitStates(freq, (int)VSCALE_DEFAULT);
   4777                break;
   4778          
   4779              case CMU_LFAPRESC0_REG:
   4780                switch (clock) {
   4781                  case cmuClock_RTC:
   4782                    EFM_ASSERT(div <= cmuClkDiv_32768);
   4783          
   4784                    /* LF register about to be modified requires sync. busy check. */
   4785                    syncReg(CMU_SYNCBUSY_LFAPRESC0);
   4786          
   4787                    /* Convert to the correct scale. */
   4788                    div = CMU_DivToLog2(div);
   4789          
   4790                    CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_RTC_MASK)
   4791                                     | (div << _CMU_LFAPRESC0_RTC_SHIFT);
   4792                    break;
   4793          
   4794          #if defined(_CMU_LFAPRESC0_LETIMER0_MASK)
   4795                  case cmuClock_LETIMER0:
   4796                    EFM_ASSERT(div <= cmuClkDiv_32768);
   4797          
   4798                    /* LF register about to be modified requires sync. busy check. */
   4799                    syncReg(CMU_SYNCBUSY_LFAPRESC0);
   4800          
   4801                    /* Convert to the correct scale. */
   4802                    div = CMU_DivToLog2(div);
   4803          
   4804                    CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_LETIMER0_MASK)
   4805                                     | (div << _CMU_LFAPRESC0_LETIMER0_SHIFT);
   4806                    break;
   4807          #endif
   4808          
   4809          #if defined(LCD_PRESENT)
   4810                  case cmuClock_LCDpre:
   4811                    EFM_ASSERT((div >= cmuClkDiv_16) && (div <= cmuClkDiv_128));
   4812          
   4813                    /* LF register about to be modified requires sync. busy check. */
   4814                    syncReg(CMU_SYNCBUSY_LFAPRESC0);
   4815          
   4816                    /* Convert to the correct scale. */
   4817                    div = CMU_DivToLog2(div);
   4818          
   4819                    CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_LCD_MASK)
   4820                                     | ((div - CMU_DivToLog2(cmuClkDiv_16))
   4821                                        << _CMU_LFAPRESC0_LCD_SHIFT);
   4822                    break;
   4823          #endif /* defined(LCD_PRESENT) */
   4824          
   4825          #if defined(LESENSE_PRESENT)
   4826                  case cmuClock_LESENSE:
   4827                    EFM_ASSERT(div <= cmuClkDiv_8);
   4828          
   4829                    /* LF register about to be modified requires sync. busy check. */
   4830                    syncReg(CMU_SYNCBUSY_LFAPRESC0);
   4831          
   4832                    /* Convert to the correct scale. */
   4833                    div = CMU_DivToLog2(div);
   4834          
   4835                    CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_LESENSE_MASK)
   4836                                     | (div << _CMU_LFAPRESC0_LESENSE_SHIFT);
   4837                    break;
   4838          #endif /* defined(LESENSE_PRESENT) */
   4839          
   4840                  default:
   4841                    EFM_ASSERT(false);
   4842                    break;
   4843                }
   4844                break;
   4845          
   4846              case CMU_LFBPRESC0_REG:
   4847                switch (clock) {
   4848          #if defined(_CMU_LFBPRESC0_LEUART0_MASK)
   4849                  case cmuClock_LEUART0:
   4850                    EFM_ASSERT(div <= cmuClkDiv_8);
   4851          
   4852                    /* LF register about to be modified requires sync. busy check. */
   4853                    syncReg(CMU_SYNCBUSY_LFBPRESC0);
   4854          
   4855                    /* Convert to the correct scale. */
   4856                    div = CMU_DivToLog2(div);
   4857          
   4858                    CMU->LFBPRESC0 = (CMU->LFBPRESC0 & ~_CMU_LFBPRESC0_LEUART0_MASK)
   4859                                     | (((uint32_t)div) << _CMU_LFBPRESC0_LEUART0_SHIFT);
   4860                    break;
   4861          #endif
   4862          
   4863          #if defined(_CMU_LFBPRESC0_LEUART1_MASK)
   4864                  case cmuClock_LEUART1:
   4865                    EFM_ASSERT(div <= cmuClkDiv_8);
   4866          
   4867                    /* LF register about to be modified requires sync. busy check. */
   4868                    syncReg(CMU_SYNCBUSY_LFBPRESC0);
   4869          
   4870                    /* Convert to the correct scale. */
   4871                    div = CMU_DivToLog2(div);
   4872          
   4873                    CMU->LFBPRESC0 = (CMU->LFBPRESC0 & ~_CMU_LFBPRESC0_LEUART1_MASK)
   4874                                     | (((uint32_t)div) << _CMU_LFBPRESC0_LEUART1_SHIFT);
   4875                    break;
   4876          #endif
   4877          
   4878                  default:
   4879                    EFM_ASSERT(false);
   4880                    break;
   4881                }
   4882                break;
   4883          
   4884              default:
   4885                EFM_ASSERT(false);
   4886                break;
   4887            }
   4888          #endif
   4889          }
   4890          
   4891          /***************************************************************************//**
   4892           * @brief
   4893           *   Enable/disable a clock.
   4894           *
   4895           * @details
   4896           *   In general, module clocking is disabled after a reset. If a module
   4897           *   clock is disabled, the registers of that module are not accessible and
   4898           *   reading from such registers may return undefined values. Writing to
   4899           *   registers of clock-disabled modules has no effect.
   4900           *   Avoid accessing module registers of a module with a disabled clock.
   4901           *
   4902           * @note
   4903           *   If enabling/disabling an LF clock, synchronization into the low-frequency
   4904           *   domain is required. If the same register is modified before a previous
   4905           *   update has completed, this function will stall until the previous
   4906           *   synchronization has completed. See @ref CMU_FreezeEnable() for
   4907           *   a suggestion on how to reduce the stalling time in some use cases.
   4908           *
   4909           *   HFCLKLE prescaler is automatically modified when peripherals with clock
   4910           *   domain HFBUSCLK is chosen based on the maximum HFLE frequency allowed.
   4911           *
   4912           * @param[in] clock
   4913           *   The clock to enable/disable. Notice that not all defined clock
   4914           *   points have separate enable/disable control. See the CMU overview
   4915           *   in the reference manual.
   4916           *
   4917           * @param[in] enable
   4918           *   @li true - enable specified clock.
   4919           *   @li false - disable specified clock.
   4920           ******************************************************************************/
   4921          void CMU_ClockEnable(CMU_Clock_TypeDef clock, bool enable)
   4922          {
   4923            volatile uint32_t *reg;
   4924            uint32_t          bit;
   4925            uint32_t          sync = 0;
   4926          
   4927            /* Identify enable register */
   4928            switch (((unsigned)clock >> CMU_EN_REG_POS) & CMU_EN_REG_MASK) {
   4929          #if defined(_CMU_CTRL_HFPERCLKEN_MASK)
   4930              case CMU_CTRL_EN_REG:
   4931                reg = &CMU->CTRL;
   4932                break;
   4933          #endif
   4934          
   4935          #if defined(_CMU_HFCORECLKEN0_MASK)
   4936              case CMU_HFCORECLKEN0_EN_REG:
   4937                reg = &CMU->HFCORECLKEN0;
   4938          #if defined(CMU_MAX_FREQ_HFLE)
   4939                setHfLeConfig(CMU_ClockFreqGet(cmuClock_HFLE));
   4940          #endif
   4941                break;
   4942          #endif
   4943          
   4944          #if defined(_CMU_HFBUSCLKEN0_MASK)
   4945              case CMU_HFBUSCLKEN0_EN_REG:
   4946                reg = &CMU->HFBUSCLKEN0;
   4947                break;
   4948          #endif
   4949          
   4950          #if defined(_CMU_HFPERCLKDIV_MASK)
   4951              case CMU_HFPERCLKDIV_EN_REG:
   4952                reg = &CMU->HFPERCLKDIV;
   4953                break;
   4954          #endif
   4955          
   4956              case CMU_HFPERCLKEN0_EN_REG:
   4957                reg = &CMU->HFPERCLKEN0;
   4958                break;
   4959          
   4960          #if defined(_CMU_HFPERCLKEN1_MASK)
   4961              case CMU_HFPERCLKEN1_EN_REG:
   4962                reg = &CMU->HFPERCLKEN1;
   4963                break;
   4964          #endif
   4965          
   4966              case CMU_LFACLKEN0_EN_REG:
   4967                reg  = &CMU->LFACLKEN0;
   4968                sync = CMU_SYNCBUSY_LFACLKEN0;
   4969                break;
   4970          
   4971              case CMU_LFBCLKEN0_EN_REG:
   4972                reg  = &CMU->LFBCLKEN0;
   4973                sync = CMU_SYNCBUSY_LFBCLKEN0;
   4974                break;
   4975          
   4976          #if defined(_CMU_LFCCLKEN0_MASK)
   4977              case CMU_LFCCLKEN0_EN_REG:
   4978                reg = &CMU->LFCCLKEN0;
   4979                sync = CMU_SYNCBUSY_LFCCLKEN0;
   4980                break;
   4981          #endif
   4982          
   4983          #if defined(_CMU_LFECLKEN0_MASK)
   4984              case CMU_LFECLKEN0_EN_REG:
   4985                reg  = &CMU->LFECLKEN0;
   4986                sync = CMU_SYNCBUSY_LFECLKEN0;
   4987                break;
   4988          #endif
   4989          
   4990          #if defined(_CMU_SDIOCTRL_MASK)
   4991              case CMU_SDIOREF_EN_REG:
   4992                reg = &CMU->SDIOCTRL;
   4993                enable = !enable;
   4994                break;
   4995          #endif
   4996          
   4997          #if defined(_CMU_QSPICTRL_MASK)
   4998              case CMU_QSPI0REF_EN_REG:
   4999                reg = &CMU->QSPICTRL;
   5000                enable = !enable;
   5001                break;
   5002          #endif
   5003          #if defined(_CMU_USBCTRL_MASK)
   5004              case CMU_USBRCLK_EN_REG:
   5005                reg = &CMU->USBCTRL;
   5006                break;
   5007          #endif
   5008          #if defined(_CMU_PDMCTRL_MASK)
   5009              case CMU_PDMREF_EN_REG:
   5010                reg = &CMU->PDMCTRL;
   5011                break;
   5012          #endif
   5013          
   5014              case CMU_PCNT_EN_REG:
   5015                reg = &CMU->PCNTCTRL;
   5016                break;
   5017          
   5018              default: /* Cannot enable/disable a clock point. */
   5019                EFM_ASSERT(false);
   5020                return;
   5021            }
   5022          
   5023            /* Get the bit position used to enable/disable. */
   5024            bit = ((unsigned)clock >> CMU_EN_BIT_POS) & CMU_EN_BIT_MASK;
   5025          
   5026            /* LF synchronization required. */
   5027            if (sync > 0UL) {
   5028              syncReg(sync);
   5029            }
   5030          
   5031            /* Set/clear bit as requested. */
   5032            BUS_RegBitWrite(reg, bit, (uint32_t)enable);
   5033          }
   5034          
   5035          /***************************************************************************//**
   5036           * @brief
   5037           *   Get the clock frequency for a clock point.
   5038           *
   5039           * @param[in] clock
   5040           *   A clock point to fetch the frequency for.
   5041           *
   5042           * @return
   5043           *   The current frequency in Hz.
   5044           ******************************************************************************/
   5045          uint32_t CMU_ClockFreqGet(CMU_Clock_TypeDef clock)
   5046          {
   5047            uint32_t ret;
   5048          
   5049            switch ((unsigned)clock & (CMU_CLK_BRANCH_MASK << CMU_CLK_BRANCH_POS)) {
   5050              case (CMU_HF_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5051                ret = SystemHFClockGet();
   5052                break;
   5053          
   5054              case (CMU_HFPER_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5055                ret = SystemHFClockGet();
   5056                /* Calculate frequency after HFPER divider. */
   5057          #if defined(_CMU_HFPERCLKDIV_HFPERCLKDIV_MASK)
   5058                ret >>= (CMU->HFPERCLKDIV & _CMU_HFPERCLKDIV_HFPERCLKDIV_MASK)
   5059                        >> _CMU_HFPERCLKDIV_HFPERCLKDIV_SHIFT;
   5060          #endif
   5061          #if defined(_CMU_HFPERPRESC_PRESC_MASK)
   5062                ret /= 1U + ((CMU->HFPERPRESC & _CMU_HFPERPRESC_PRESC_MASK)
   5063                             >> _CMU_HFPERPRESC_PRESC_SHIFT);
   5064          #endif
   5065                break;
   5066          
   5067          #if defined(_CMU_HFPERPRESCB_MASK)
   5068              case (CMU_HFPERB_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5069                ret = SystemHFClockGet();
   5070                /* Calculate frequency after HFPERB prescaler. */
   5071                ret /= 1U + ((CMU->HFPERPRESCB & _CMU_HFPERPRESCB_PRESC_MASK)
   5072                             >> _CMU_HFPERPRESCB_PRESC_SHIFT);
   5073                break;
   5074          #endif
   5075          
   5076          #if defined(_CMU_HFPERPRESCC_MASK)
   5077              case (CMU_HFPERC_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5078                ret = SystemHFClockGet();
   5079                /* Calculate frequency after HFPERC prescaler. */
   5080                ret /= 1U + ((CMU->HFPERPRESCC & _CMU_HFPERPRESCC_PRESC_MASK)
   5081                             >> _CMU_HFPERPRESCC_PRESC_SHIFT);
   5082                break;
   5083          #endif
   5084          
   5085          #if defined(_SILICON_LABS_32B_SERIES_1)
   5086          #if defined(CRYPTO_PRESENT)     \
   5087                || defined(LDMA_PRESENT)  \
   5088                || defined(GPCRC_PRESENT) \
   5089                || defined(PRS_PRESENT)   \
   5090                || defined(GPIO_PRESENT)
   5091              case (CMU_HFBUS_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5092                ret = SystemHFClockGet();
   5093          #if defined(_CMU_HFBUSPRESC_MASK)
   5094                ret /= 1U + ((CMU->HFBUSPRESC & _CMU_HFBUSPRESC_MASK)
   5095                             >> _CMU_HFBUSPRESC_PRESC_SHIFT);
   5096          #endif
   5097                break;
   5098          #endif
   5099          
   5100              case (CMU_HFCORE_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5101                ret = SystemHFClockGet();
   5102                ret /= 1U + ((CMU->HFCOREPRESC & _CMU_HFCOREPRESC_PRESC_MASK)
   5103                             >> _CMU_HFCOREPRESC_PRESC_SHIFT);
   5104                break;
   5105          
   5106              case (CMU_HFEXP_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5107                ret = SystemHFClockGet();
   5108                ret /= 1U + ((CMU->HFEXPPRESC & _CMU_HFEXPPRESC_PRESC_MASK)
   5109                             >> _CMU_HFEXPPRESC_PRESC_SHIFT);
   5110                break;
   5111          #endif
   5112          
   5113          #if defined(_SILICON_LABS_32B_SERIES_0)
   5114          #if defined(AES_PRESENT)      \
   5115                || defined(DMA_PRESENT) \
   5116                || defined(EBI_PRESENT) \
   5117                || defined(USB_PRESENT)
   5118              case (CMU_HFCORE_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5119              {
   5120                ret = SystemCoreClockGet();
   5121              } break;
   5122          #endif
   5123          #endif
   5124          
   5125              case (CMU_LFA_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5126                ret = lfClkGet(cmuClock_LFA);
   5127                break;
   5128          
   5129          #if defined(_CMU_LFACLKEN0_RTC_MASK)
   5130              case (CMU_RTC_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5131                ret = lfClkGet(cmuClock_LFA);
   5132                ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_RTC_MASK)
   5133                        >> _CMU_LFAPRESC0_RTC_SHIFT;
   5134                break;
   5135          #endif
   5136          
   5137          #if defined(_CMU_LFECLKEN0_RTCC_MASK)
   5138              case (CMU_RTCC_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5139                ret = lfClkGet(cmuClock_LFE);
   5140                ret >>= (CMU->LFEPRESC0 & _CMU_LFEPRESC0_RTCC_MASK)
   5141                        >> _CMU_LFEPRESC0_RTCC_SHIFT;
   5142                break;
   5143          #endif
   5144          
   5145          #if defined(_CMU_LFACLKEN0_LETIMER0_MASK)
   5146              case (CMU_LETIMER0_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5147                ret = lfClkGet(cmuClock_LFA);
   5148          #if defined(_SILICON_LABS_32B_SERIES_0)
   5149                ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LETIMER0_MASK)
   5150                        >> _CMU_LFAPRESC0_LETIMER0_SHIFT;
   5151          #else
   5152                ret /= SL_Log2ToDiv((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LETIMER0_MASK)
   5153                                    >> _CMU_LFAPRESC0_LETIMER0_SHIFT);
   5154          #endif
   5155                break;
   5156          #endif
   5157          
   5158          #if defined(_CMU_LFACLKEN0_LETIMER1_MASK)
   5159              case (CMU_LETIMER1_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5160                ret = lfClkGet(cmuClock_LFA);
   5161          #if defined(_SILICON_LABS_32B_SERIES_0)
   5162                ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LETIMER1_MASK)
   5163                        >> _CMU_LFAPRESC0_LETIMER1_SHIFT;
   5164          #else
   5165                ret /= SL_Log2ToDiv((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LETIMER1_MASK)
   5166                                    >> _CMU_LFAPRESC0_LETIMER1_SHIFT);
   5167          #endif
   5168                break;
   5169          #endif
   5170          
   5171          #if defined(_CMU_LFACLKEN0_LCD_MASK)
   5172              case (CMU_LCDPRE_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5173                ret = lfClkGet(cmuClock_LFA);
   5174          #if defined(_SILICON_LABS_32B_SERIES_0)
   5175                ret >>= ((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LCD_MASK)
   5176                         >> _CMU_LFAPRESC0_LCD_SHIFT)
   5177                        + CMU_DivToLog2(cmuClkDiv_16);
   5178          #else
   5179                ret /= SL_Log2ToDiv((CMU->LFAPRESC0 & _CMU_LFAPRESC0_LCD_MASK)
   5180                                    >> _CMU_LFAPRESC0_LCD_SHIFT);
   5181          #endif
   5182                break;
   5183          
   5184          #if defined(_CMU_LCDCTRL_MASK)
   5185              case (CMU_LCD_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5186                ret = lfClkGet(cmuClock_LFA);
   5187                ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LCD_MASK)
   5188                        >> _CMU_LFAPRESC0_LCD_SHIFT;
   5189                ret /= 1U + ((CMU->LCDCTRL & _CMU_LCDCTRL_FDIV_MASK)
   5190                             >> _CMU_LCDCTRL_FDIV_SHIFT);
   5191                break;
   5192          #endif
   5193          #endif
   5194          
   5195          #if defined(_CMU_LFACLKEN0_LESENSE_MASK)
   5196              case (CMU_LESENSE_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5197                ret = lfClkGet(cmuClock_LFA);
   5198                ret >>= (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LESENSE_MASK)
   5199                        >> _CMU_LFAPRESC0_LESENSE_SHIFT;
   5200                break;
   5201          #endif
   5202          
   5203              case (CMU_LFB_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5204                ret = lfClkGet(cmuClock_LFB);
   5205                break;
   5206          
   5207          #if defined(_CMU_LFBCLKEN0_LEUART0_MASK)
   5208              case (CMU_LEUART0_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5209                ret = lfClkGet(cmuClock_LFB);
   5210          #if defined(_SILICON_LABS_32B_SERIES_0)
   5211                ret >>= (CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART0_MASK)
   5212                        >> _CMU_LFBPRESC0_LEUART0_SHIFT;
   5213          #else
   5214                ret /= SL_Log2ToDiv((CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART0_MASK)
   5215                                    >> _CMU_LFBPRESC0_LEUART0_SHIFT);
   5216          #endif
   5217                break;
   5218          #endif
   5219          
   5220          #if defined(_CMU_LFBCLKEN0_LEUART1_MASK)
   5221              case (CMU_LEUART1_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5222                ret = lfClkGet(cmuClock_LFB);
   5223          #if defined(_SILICON_LABS_32B_SERIES_0)
   5224                ret >>= (CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART1_MASK)
   5225                        >> _CMU_LFBPRESC0_LEUART1_SHIFT;
   5226          #else
   5227                ret /= SL_Log2ToDiv((CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART1_MASK)
   5228                                    >> _CMU_LFBPRESC0_LEUART1_SHIFT);
   5229          #endif
   5230                break;
   5231          #endif
   5232          
   5233          #if defined(_CMU_LFBCLKEN0_CSEN_MASK)
   5234              case (CMU_CSEN_LF_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5235                ret = lfClkGet(cmuClock_LFB);
   5236                ret /= SL_Log2ToDiv(((CMU->LFBPRESC0 & _CMU_LFBPRESC0_CSEN_MASK)
   5237                                     >> _CMU_LFBPRESC0_CSEN_SHIFT) + 4UL);
   5238                break;
   5239          #endif
   5240          
   5241          #if defined(CMU_LFCCLKEN0_USB)
   5242              case (CMU_USBLE_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5243                ret = lfClkGet(cmuClock_LFC);
   5244                break;
   5245          #endif
   5246          
   5247          #if defined(_SILICON_LABS_32B_SERIES_1)
   5248              case (CMU_LFE_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5249                ret = lfClkGet(cmuClock_LFE);
   5250                break;
   5251          #endif
   5252          
   5253              case (CMU_DBG_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5254                ret = dbgClkGet();
   5255                break;
   5256          
   5257              case (CMU_AUX_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5258                ret = auxClkGet();
   5259                break;
   5260          
   5261          #if defined(USBC_CLOCK_PRESENT)
   5262              case (CMU_USBC_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5263                ret = usbCClkGet();
   5264                break;
   5265          #endif
   5266          
   5267          #if defined(_CMU_ADCCTRL_ADC0CLKSEL_MASK)
   5268              case (CMU_ADC0ASYNC_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5269                ret = adcAsyncClkGet(0);
   5270          #if defined(_CMU_ADCCTRL_ADC0CLKDIV_MASK)
   5271                ret /= 1U + ((CMU->ADCCTRL & _CMU_ADCCTRL_ADC0CLKDIV_MASK)
   5272                             >> _CMU_ADCCTRL_ADC0CLKDIV_SHIFT);
   5273          #endif
   5274                break;
   5275          #endif
   5276          
   5277          #if defined(_CMU_ADCCTRL_ADC1CLKSEL_MASK)
   5278              case (CMU_ADC1ASYNC_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5279                ret = adcAsyncClkGet(1);
   5280          #if defined(_CMU_ADCCTRL_ADC1CLKDIV_MASK)
   5281                ret /= 1U + ((CMU->ADCCTRL & _CMU_ADCCTRL_ADC1CLKDIV_MASK)
   5282                             >> _CMU_ADCCTRL_ADC1CLKDIV_SHIFT);
   5283          #endif
   5284                break;
   5285          #endif
   5286          
   5287          #if defined(_CMU_SDIOCTRL_SDIOCLKSEL_MASK)
   5288              case (CMU_SDIOREF_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5289                ret = sdioRefClkGet();
   5290                break;
   5291          #endif
   5292          
   5293          #if defined(_CMU_QSPICTRL_QSPI0CLKSEL_MASK)
   5294              case (CMU_QSPI0REF_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5295                ret = qspiRefClkGet(0);
   5296                break;
   5297          #endif
   5298          
   5299          #if defined(USBR_CLOCK_PRESENT)
   5300              case (CMU_USBR_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5301                ret = usbRateClkGet();
   5302                break;
   5303          #endif
   5304          
   5305          #if defined(_CMU_PDMCTRL_PDMCLKSEL_MASK)
   5306              case (CMU_PDMREF_CLK_BRANCH << CMU_CLK_BRANCH_POS):
   5307                ret = pdmRefClkGet();
   5308                break;
   5309          #endif
   5310          
   5311              default:
   5312                ret = 0;
   5313                EFM_ASSERT(false);
   5314                break;
   5315            }
   5316          
   5317            return ret;
   5318          }
   5319          
   5320          #if defined(_SILICON_LABS_32B_SERIES_1)
   5321          /***************************************************************************//**
   5322           * @brief
   5323           *   Get the clock prescaler.
   5324           *
   5325           * @param[in] clock
   5326           *   A clock point to get the prescaler for. Notice that not all clock points
   5327           *   have a prescaler. See the CMU overview in the reference manual.
   5328           *
   5329           * @return
   5330           *   The prescaler value of the current clock point. 0 is returned
   5331           *   if @p clock specifies a clock point without a prescaler.
   5332           ******************************************************************************/
   5333          uint32_t CMU_ClockPrescGet(CMU_Clock_TypeDef clock)
   5334          {
   5335            uint32_t  prescReg;
   5336            uint32_t  ret;
   5337          
   5338            /* Get the prescaler register ID. */
   5339            prescReg = ((unsigned)clock >> CMU_PRESC_REG_POS) & CMU_PRESC_REG_MASK;
   5340          
   5341            switch (prescReg) {
   5342              case CMU_HFPRESC_REG:
   5343                ret = (CMU->HFPRESC & _CMU_HFPRESC_PRESC_MASK)
   5344                      >> _CMU_HFPRESC_PRESC_SHIFT;
   5345                break;
   5346          
   5347              case CMU_HFEXPPRESC_REG:
   5348                ret = (CMU->HFEXPPRESC & _CMU_HFEXPPRESC_PRESC_MASK)
   5349                      >> _CMU_HFEXPPRESC_PRESC_SHIFT;
   5350                break;
   5351          
   5352              case CMU_HFCLKLEPRESC_REG:
   5353                ret = (CMU->HFPRESC & _CMU_HFPRESC_HFCLKLEPRESC_MASK)
   5354                      >> _CMU_HFPRESC_HFCLKLEPRESC_SHIFT;
   5355                break;
   5356          
   5357              case CMU_HFPERPRESC_REG:
   5358                ret = (CMU->HFPERPRESC & _CMU_HFPERPRESC_PRESC_MASK)
   5359                      >> _CMU_HFPERPRESC_PRESC_SHIFT;
   5360                break;
   5361          
   5362          #if defined(_CMU_HFPERPRESCB_MASK)
   5363              case CMU_HFPERPRESCB_REG:
   5364                ret = (CMU->HFPERPRESCB & _CMU_HFPERPRESCB_PRESC_MASK)
   5365                      >> _CMU_HFPERPRESCB_PRESC_SHIFT;
   5366                break;
   5367          #endif
   5368          
   5369          #if defined(_CMU_HFPERPRESCC_MASK)
   5370              case CMU_HFPERPRESCC_REG:
   5371                ret = (CMU->HFPERPRESCC & _CMU_HFPERPRESCC_PRESC_MASK)
   5372                      >> _CMU_HFPERPRESCC_PRESC_SHIFT;
   5373                break;
   5374          #endif
   5375          
   5376              case CMU_HFCOREPRESC_REG:
   5377                ret = (CMU->HFCOREPRESC & _CMU_HFCOREPRESC_PRESC_MASK)
   5378                      >> _CMU_HFCOREPRESC_PRESC_SHIFT;
   5379                break;
   5380          
   5381              case CMU_LFAPRESC0_REG:
   5382                switch (clock) {
   5383          #if defined(_CMU_LFAPRESC0_LETIMER0_MASK)
   5384                  case cmuClock_LETIMER0:
   5385                    ret = (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LETIMER0_MASK)
   5386                          >> _CMU_LFAPRESC0_LETIMER0_SHIFT;
   5387                    /* Convert the exponent to a prescaler value. */
   5388                    ret = SL_Log2ToDiv(ret) - 1U;
   5389                    break;
   5390          #endif
   5391          
   5392          #if defined(_CMU_LFAPRESC0_LESENSE_MASK)
   5393                  case cmuClock_LESENSE:
   5394                    ret = (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LESENSE_MASK)
   5395                          >> _CMU_LFAPRESC0_LESENSE_SHIFT;
   5396                    /* Convert the exponent to a prescaler value. */
   5397                    ret = SL_Log2ToDiv(ret) - 1U;
   5398                    break;
   5399          #endif
   5400          
   5401          #if defined(_CMU_LFAPRESC0_LETIMER1_MASK)
   5402                  case cmuClock_LETIMER1:
   5403                    ret = (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LETIMER1_MASK)
   5404                          >> _CMU_LFAPRESC0_LETIMER1_SHIFT;
   5405                    ret = SL_Log2ToDiv(ret) - 1U;
   5406                    break;
   5407          #endif
   5408          
   5409          #if defined(_CMU_LFAPRESC0_LCD_MASK)
   5410                  case cmuClock_LCD:
   5411                  case cmuClock_LCDpre:
   5412                    ret = (CMU->LFAPRESC0 & _CMU_LFAPRESC0_LCD_MASK)
   5413                          >> _CMU_LFAPRESC0_LCD_SHIFT;
   5414                    ret = SL_Log2ToDiv(ret) - 1U;
   5415                    break;
   5416          #endif
   5417          
   5418          #if defined(_CMU_LFAPRESC0_RTC_MASK)
   5419                  case cmuClock_RTC:
   5420                    ret = (CMU->LFAPRESC0 & _CMU_LFAPRESC0_RTC_MASK)
   5421                          >> _CMU_LFAPRESC0_RTC_SHIFT;
   5422                    ret = SL_Log2ToDiv(ret) - 1U;
   5423                    break;
   5424          #endif
   5425          
   5426                  default:
   5427                    ret = 0U;
   5428                    EFM_ASSERT(false);
   5429                    break;
   5430                }
   5431                break;
   5432          
   5433              case CMU_LFBPRESC0_REG:
   5434                switch (clock) {
   5435          #if defined(_CMU_LFBPRESC0_LEUART0_MASK)
   5436                  case cmuClock_LEUART0:
   5437                    ret = (CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART0_MASK)
   5438                          >> _CMU_LFBPRESC0_LEUART0_SHIFT;
   5439                    /* Convert the exponent to a prescaler value. */
   5440                    ret = SL_Log2ToDiv(ret) - 1U;
   5441                    break;
   5442          #endif
   5443          
   5444          #if defined(_CMU_LFBPRESC0_LEUART1_MASK)
   5445                  case cmuClock_LEUART1:
   5446                    ret = (CMU->LFBPRESC0 & _CMU_LFBPRESC0_LEUART1_MASK)
   5447                          >> _CMU_LFBPRESC0_LEUART1_SHIFT;
   5448                    /* Convert the exponent to a prescaler value. */
   5449                    ret = SL_Log2ToDiv(ret) - 1U;
   5450                    break;
   5451          #endif
   5452          
   5453          #if defined(_CMU_LFBPRESC0_CSEN_MASK)
   5454                  case cmuClock_CSEN_LF:
   5455                    ret = (CMU->LFBPRESC0 & _CMU_LFBPRESC0_CSEN_MASK)
   5456                          >> _CMU_LFBPRESC0_CSEN_SHIFT;
   5457                    /* Convert the exponent to a prescaler value. */
   5458                    ret = SL_Log2ToDiv(ret + 4U) - 1U;
   5459                    break;
   5460          #endif
   5461          
   5462                  default:
   5463                    ret = 0U;
   5464                    EFM_ASSERT(false);
   5465                    break;
   5466                }
   5467                break;
   5468          
   5469              case CMU_LFEPRESC0_REG:
   5470                switch (clock) {
   5471          #if defined(RTCC_PRESENT)
   5472                  case cmuClock_RTCC:
   5473                    ret = (CMU->LFEPRESC0 & _CMU_LFEPRESC0_RTCC_MASK)
   5474                          >> _CMU_LFEPRESC0_RTCC_SHIFT;
   5475                    break;
   5476          
   5477                  default:
   5478                    ret = 0U;
   5479                    EFM_ASSERT(false);
   5480                    break;
   5481          #endif
   5482                }
   5483                break;
   5484          
   5485          #if defined(_CMU_ADCCTRL_ADC0CLKDIV_MASK) \
   5486                || defined(_CMU_ADCCTRL_ADC1CLKDIV_MASK)
   5487              case CMU_ADCASYNCDIV_REG:
   5488                switch (clock) {
   5489          #if defined(_CMU_ADCCTRL_ADC0CLKDIV_MASK)
   5490                  case cmuClock_ADC0ASYNC:
   5491                    ret = (CMU->ADCCTRL & _CMU_ADCCTRL_ADC0CLKDIV_MASK)
   5492                          >> _CMU_ADCCTRL_ADC0CLKDIV_SHIFT;
   5493                    break;
   5494          #endif
   5495          #if defined(_CMU_ADCCTRL_ADC1CLKDIV_MASK)
   5496                  case cmuClock_ADC1ASYNC:
   5497                    ret = (CMU->ADCCTRL & _CMU_ADCCTRL_ADC1CLKDIV_MASK)
   5498                          >> _CMU_ADCCTRL_ADC1CLKDIV_SHIFT;
   5499                    break;
   5500          #endif
   5501                  default:
   5502                    ret = 0U;
   5503                    EFM_ASSERT(false);
   5504                    break;
   5505                }
   5506                break;
   5507          #endif
   5508          #if defined(_CMU_HFBUSPRESC_MASK)
   5509              case CMU_HFBUSPRESC_REG:
   5510                ret = (CMU->HFBUSPRESC & _CMU_HFBUSPRESC_MASK)
   5511                      >> _CMU_HFBUSPRESC_PRESC_SHIFT;
   5512                break;
   5513          #endif
   5514              default:
   5515                ret = 0U;
   5516                EFM_ASSERT(false);
   5517                break;
   5518            }
   5519          
   5520            return ret;
   5521          }
   5522          #endif
   5523          
   5524          #if defined(_SILICON_LABS_32B_SERIES_1)
   5525          /***************************************************************************//**
   5526           * @brief
   5527           *   Set the clock prescaler.
   5528           *
   5529           * @note
   5530           *   If setting an LF clock prescaler, synchronization into the low-frequency
   5531           *   domain is required. If the same register is modified before a previous
   5532           *   update has completed, this function will stall until the previous
   5533           *   synchronization has completed. See @ref CMU_FreezeEnable() for
   5534           *   a suggestion on how to reduce the stalling time in some use cases.
   5535           *
   5536           *   HFCLKLE prescaler is automatically modified when peripherals with clock
   5537           *   domain HFBUSCLK is chosen based on the maximum HFLE frequency allowed.
   5538           *
   5539           * @param[in] clock
   5540           *   A clock point to set the prescaler for. Notice that not all clock points
   5541           *   have a prescaler. See the CMU overview in the reference manual.
   5542           *
   5543           * @param[in] presc
   5544           *   The clock prescaler.
   5545           ******************************************************************************/
   5546          void CMU_ClockPrescSet(CMU_Clock_TypeDef clock, CMU_ClkPresc_TypeDef presc)
   5547          {
   5548            uint32_t freq;
   5549            uint32_t prescReg;
   5550          
   5551            /* Get the divisor reg ID. */
   5552            prescReg = ((unsigned)clock >> CMU_PRESC_REG_POS) & CMU_PRESC_REG_MASK;
   5553          
   5554            switch (prescReg) {
   5555              case CMU_HFPRESC_REG:
   5556                EFM_ASSERT(presc < 32U);
   5557          
   5558                /* Configure worst case wait-states for flash and HFLE, set safe HFPER
   5559                   clock-tree prescalers. */
   5560                flashWaitStateMax();
   5561                setHfLeConfig(CMU_MAX_FREQ_HFLE + 1UL);
   5562                hfperClkSafePrescaler();
   5563          
   5564                CMU->HFPRESC = (CMU->HFPRESC & ~_CMU_HFPRESC_PRESC_MASK)
   5565                               | (presc << _CMU_HFPRESC_PRESC_SHIFT);
   5566          
   5567                /* Update the CMSIS core clock variable (this function updates the global
   5568                   variable). */
   5569                freq = SystemCoreClockGet();
   5570                /* Optimize flash and HFLE wait states and set optimized HFPER clock-tree
   5571                   prescalers. */
   5572                CMU_UpdateWaitStates(freq, (int)VSCALE_DEFAULT);
   5573                setHfLeConfig(CMU_ClockFreqGet(cmuClock_HFLE));
   5574                hfperClkOptimizedPrescaler();
   5575                break;
   5576          
   5577              case CMU_HFEXPPRESC_REG:
   5578                EFM_ASSERT(presc < 32U);
   5579          
   5580                CMU->HFEXPPRESC = (CMU->HFEXPPRESC & ~_CMU_HFEXPPRESC_PRESC_MASK)
   5581                                  | (presc << _CMU_HFEXPPRESC_PRESC_SHIFT);
   5582                break;
   5583          
   5584              case CMU_HFPERPRESC_REG:
   5585                EFM_ASSERT(presc < 512U);
   5586                CMU->HFPERPRESC = (CMU->HFPERPRESC & ~_CMU_HFPERPRESC_PRESC_MASK)
   5587                                  | (presc << _CMU_HFPERPRESC_PRESC_SHIFT);
   5588                break;
   5589          
   5590          #if defined(_CMU_HFPERPRESCB_MASK)
   5591              case CMU_HFPERPRESCB_REG:
   5592                EFM_ASSERT(presc < 512U);
   5593                CMU->HFPERPRESCB = (CMU->HFPERPRESCB & ~_CMU_HFPERPRESCB_PRESC_MASK)
   5594                                   | (presc << _CMU_HFPERPRESCB_PRESC_SHIFT);
   5595                break;
   5596          #endif
   5597          
   5598          #if defined(_CMU_HFPERPRESCC_MASK)
   5599              case CMU_HFPERPRESCC_REG:
   5600                EFM_ASSERT(presc < 512U);
   5601                CMU->HFPERPRESCC = (CMU->HFPERPRESCC & ~_CMU_HFPERPRESCC_PRESC_MASK)
   5602                                   | (presc << _CMU_HFPERPRESCC_PRESC_SHIFT);
   5603                break;
   5604          #endif
   5605          
   5606              case CMU_HFCOREPRESC_REG:
   5607                EFM_ASSERT(presc < 512U);
   5608          
   5609                /* Configure worst case wait-states for flash and HFLE. */
   5610                flashWaitStateMax();
   5611                setHfLeConfig(CMU_MAX_FREQ_HFLE + 1UL);
   5612          
   5613                CMU->HFCOREPRESC = (CMU->HFCOREPRESC & ~_CMU_HFCOREPRESC_PRESC_MASK)
   5614                                   | (presc << _CMU_HFCOREPRESC_PRESC_SHIFT);
   5615          
   5616                /* Update the CMSIS core clock variable (this function updates the global variable).
   5617                   Optimize flash and HFLE wait states. */
   5618                freq = SystemCoreClockGet();
   5619                CMU_UpdateWaitStates(freq, (int)VSCALE_DEFAULT);
   5620                setHfLeConfig(CMU_ClockFreqGet(cmuClock_HFLE));
   5621                break;
   5622          
   5623              case CMU_LFAPRESC0_REG:
   5624                switch (clock) {
   5625          #if defined(RTC_PRESENT)
   5626                  case cmuClock_RTC:
   5627                    EFM_ASSERT(presc <= 32768U);
   5628          
   5629                    /* Convert the prescaler value to a DIV exponent scale. */
   5630                    presc = CMU_PrescToLog2(presc);
   5631          
   5632                    /* LF register about to be modified requires sync. Busy check. */
   5633                    syncReg(CMU_SYNCBUSY_LFAPRESC0);
   5634          
   5635                    CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_RTC_MASK)
   5636                                     | (presc << _CMU_LFAPRESC0_RTC_SHIFT);
   5637                    break;
   5638          #endif
   5639          
   5640          #if defined(RTCC_PRESENT)
   5641                  case cmuClock_RTCC:
   5642          #if defined(_CMU_LFEPRESC0_RTCC_MASK)
   5643          #if defined(_CMU_LFEPRESC0_RTCC_DIV4)
   5644                    EFM_ASSERT(presc <= _CMU_LFEPRESC0_RTCC_DIV4);
   5645          #elif defined(_CMU_LFEPRESC0_RTCC_DIV2)
   5646                    EFM_ASSERT(presc <= _CMU_LFEPRESC0_RTCC_DIV2);
   5647          #else
   5648                    EFM_ASSERT(presc <= 0U);
   5649          #endif
   5650          
   5651                    /* LF register about to be modified requires sync. Busy check. */
   5652                    syncReg(CMU_SYNCBUSY_LFEPRESC0);
   5653          
   5654                    CMU->LFEPRESC0 = (CMU->LFEPRESC0 & ~_CMU_LFEPRESC0_RTCC_MASK)
   5655                                     | (presc << _CMU_LFEPRESC0_RTCC_SHIFT);
   5656          #else
   5657                    EFM_ASSERT(presc <= 32768U);
   5658          
   5659                    /* Convert the prescaler value to a DIV exponent scale. */
   5660                    presc = CMU_PrescToLog2(presc);
   5661          
   5662                    /* LF register about to be modified requires sync. Busy check. */
   5663                    syncReg(CMU_SYNCBUSY_LFAPRESC0);
   5664          
   5665                    CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_RTCC_MASK)
   5666                                     | (presc << _CMU_LFAPRESC0_RTCC_SHIFT);
   5667          #endif
   5668                    break;
   5669          #endif
   5670          
   5671          #if defined(_CMU_LFAPRESC0_LETIMER0_MASK)
   5672                  case cmuClock_LETIMER0:
   5673                    EFM_ASSERT(presc <= 32768U);
   5674          
   5675                    /* Convert the prescaler value to a DIV exponent scale. */
   5676                    presc = CMU_PrescToLog2(presc);
   5677          
   5678                    /* LF register about to be modified requires sync. Busy check. */
   5679                    syncReg(CMU_SYNCBUSY_LFAPRESC0);
   5680          
   5681                    CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_LETIMER0_MASK)
   5682                                     | (presc << _CMU_LFAPRESC0_LETIMER0_SHIFT);
   5683                    break;
   5684          #endif
   5685          
   5686          #if defined(_CMU_LFAPRESC0_LETIMER1_MASK)
   5687                  case cmuClock_LETIMER1:
   5688                    EFM_ASSERT(presc <= 32768U);
   5689          
   5690                    /* Convert the prescaler value to a DIV exponent scale. */
   5691                    presc = CMU_PrescToLog2(presc);
   5692          
   5693                    /* LF register about to be modified requires sync. Busy check. */
   5694                    syncReg(CMU_SYNCBUSY_LFAPRESC0);
   5695          
   5696                    CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_LETIMER1_MASK)
   5697                                     | (presc << _CMU_LFAPRESC0_LETIMER1_SHIFT);
   5698                    break;
   5699          #endif
   5700          
   5701          #if defined(_CMU_LFAPRESC0_LESENSE_MASK)
   5702                  case cmuClock_LESENSE:
   5703                    EFM_ASSERT(presc <= 8U);
   5704          
   5705                    /* Convert the prescaler value to a DIV exponent scale. */
   5706                    presc = CMU_PrescToLog2(presc);
   5707          
   5708                    /* LF register about to be modified requires sync. Busy check. */
   5709                    syncReg(CMU_SYNCBUSY_LFAPRESC0);
   5710          
   5711                    CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_LESENSE_MASK)
   5712                                     | (presc << _CMU_LFAPRESC0_LESENSE_SHIFT);
   5713                    break;
   5714          #endif
   5715          
   5716          #if defined(_CMU_LFAPRESC0_LCD_MASK)
   5717                  case cmuClock_LCDpre:
   5718                  case cmuClock_LCD:
   5719                    EFM_ASSERT(presc <= 32768U);
   5720          
   5721                    /* Convert the prescaler value to a DIV exponent scale. */
   5722                    presc = CMU_PrescToLog2(presc);
   5723          
   5724                    /* LF register about to be modified requires sync. Busy check. */
   5725                    syncReg(CMU_SYNCBUSY_LFAPRESC0);
   5726          
   5727                    CMU->LFAPRESC0 = (CMU->LFAPRESC0 & ~_CMU_LFAPRESC0_LCD_MASK)
   5728                                     | (presc << _CMU_LFAPRESC0_LCD_SHIFT);
   5729                    break;
   5730          #endif
   5731          
   5732                  default:
   5733                    EFM_ASSERT(false);
   5734                    break;
   5735                }
   5736                break;
   5737          
   5738              case CMU_LFBPRESC0_REG:
   5739                switch (clock) {
   5740          #if defined(_CMU_LFBPRESC0_LEUART0_MASK)
   5741                  case cmuClock_LEUART0:
   5742                    EFM_ASSERT(presc <= 8U);
   5743          
   5744                    /* Convert the prescaler value to a DIV exponent scale. */
   5745                    presc = CMU_PrescToLog2(presc);
   5746          
   5747                    /* LF register about to be modified requires sync. Busy check. */
   5748                    syncReg(CMU_SYNCBUSY_LFBPRESC0);
   5749          
   5750                    CMU->LFBPRESC0 = (CMU->LFBPRESC0 & ~_CMU_LFBPRESC0_LEUART0_MASK)
   5751                                     | (presc << _CMU_LFBPRESC0_LEUART0_SHIFT);
   5752                    break;
   5753          #endif
   5754          
   5755          #if defined(_CMU_LFBPRESC0_LEUART1_MASK)
   5756                  case cmuClock_LEUART1:
   5757                    EFM_ASSERT(presc <= 8U);
   5758          
   5759                    /* Convert the prescaler value to a DIV exponent scale. */
   5760                    presc = CMU_PrescToLog2(presc);
   5761          
   5762                    /* LF register about to be modified requires sync. Busy check. */
   5763                    syncReg(CMU_SYNCBUSY_LFBPRESC0);
   5764          
   5765                    CMU->LFBPRESC0 = (CMU->LFBPRESC0 & ~_CMU_LFBPRESC0_LEUART1_MASK)
   5766                                     | (presc << _CMU_LFBPRESC0_LEUART1_SHIFT);
   5767                    break;
   5768          #endif
   5769          
   5770          #if defined(_CMU_LFBPRESC0_CSEN_MASK)
   5771                  case cmuClock_CSEN_LF:
   5772                    EFM_ASSERT((presc <= 127U) && (presc >= 15U));
   5773          
   5774                    /* Convert the prescaler value to a DIV exponent scale.
   5775                     * DIV16 is the lowest supported prescaler. */
   5776                    presc = CMU_PrescToLog2(presc) - 4U;
   5777          
   5778                    /* LF register about to be modified requires sync. Busy check. */
   5779                    syncReg(CMU_SYNCBUSY_LFBPRESC0);
   5780          
   5781                    CMU->LFBPRESC0 = (CMU->LFBPRESC0 & ~_CMU_LFBPRESC0_CSEN_MASK)
   5782                                     | (presc << _CMU_LFBPRESC0_CSEN_SHIFT);
   5783                    break;
   5784          #endif
   5785          
   5786                  default:
   5787                    EFM_ASSERT(false);
   5788                    break;
   5789                }
   5790                break;
   5791          
   5792              case CMU_LFEPRESC0_REG:
   5793                switch (clock) {
   5794          #if defined(_CMU_LFEPRESC0_RTCC_MASK)
   5795                  case cmuClock_RTCC:
   5796          #if defined(_CMU_LFEPRESC0_RTCC_DIV4)
   5797                    EFM_ASSERT(presc <= _CMU_LFEPRESC0_RTCC_DIV4);
   5798          #elif defined(_CMU_LFEPRESC0_RTCC_DIV2)
   5799                    EFM_ASSERT(presc <= _CMU_LFEPRESC0_RTCC_DIV2);
   5800          #else
   5801                    EFM_ASSERT(presc <= 0U);
   5802          #endif
   5803          
   5804                    /* LF register about to be modified requires sync. Busy check. */
   5805                    syncReg(CMU_SYNCBUSY_LFEPRESC0);
   5806          
   5807                    CMU->LFEPRESC0 = (CMU->LFEPRESC0 & ~_CMU_LFEPRESC0_RTCC_MASK)
   5808                                     | (presc << _CMU_LFEPRESC0_RTCC_SHIFT);
   5809                    break;
   5810          #endif
   5811          
   5812                  default:
   5813                    EFM_ASSERT(false);
   5814                    break;
   5815                }
   5816                break;
   5817          
   5818          #if defined(_CMU_ADCCTRL_ADC0CLKDIV_MASK) \
   5819                ||  defined(_CMU_ADCCTRL_ADC1CLKDIV_MASK)
   5820              case CMU_ADCASYNCDIV_REG:
   5821                switch (clock) {
   5822          #if defined(_CMU_ADCCTRL_ADC0CLKDIV_MASK)
   5823                  case cmuClock_ADC0ASYNC:
   5824                    EFM_ASSERT(presc <= 3);
   5825                    CMU->ADCCTRL = (CMU->ADCCTRL & ~_CMU_ADCCTRL_ADC0CLKDIV_MASK)
   5826                                   | (presc << _CMU_ADCCTRL_ADC0CLKDIV_SHIFT);
   5827                    break;
   5828          #endif
   5829          
   5830          #if defined(_CMU_ADCCTRL_ADC1CLKDIV_MASK)
   5831                  case cmuClock_ADC1ASYNC:
   5832                    EFM_ASSERT(presc <= 3);
   5833                    CMU->ADCCTRL = (CMU->ADCCTRL & ~_CMU_ADCCTRL_ADC1CLKDIV_MASK)
   5834                                   | (presc << _CMU_ADCCTRL_ADC1CLKDIV_SHIFT);
   5835                    break;
   5836          #endif
   5837                  default:
   5838                    EFM_ASSERT(false);
   5839                    break;
   5840                }
   5841                break;
   5842          #endif
   5843          
   5844          #if defined(_CMU_HFBUSPRESC_MASK)
   5845              case CMU_HFBUSPRESC_REG:
   5846                EFM_ASSERT(presc <= _CMU_HFBUSPRESC_MASK >> _CMU_HFBUSPRESC_PRESC_SHIFT);
   5847                CMU->HFBUSPRESC = (CMU->HFBUSPRESC & ~_CMU_HFBUSPRESC_MASK)
   5848                                  | (presc << _CMU_HFBUSPRESC_PRESC_SHIFT);
   5849                break;
   5850          #endif
   5851          
   5852              default:
   5853                EFM_ASSERT(false);
   5854                break;
   5855            }
   5856          }
   5857          #endif
   5858          
   5859          /***************************************************************************//**
   5860           * @brief
   5861           *   Get the currently selected reference clock used for a clock branch.
   5862           *
   5863           * @param[in] clock
   5864           *   Clock branch to fetch selected ref. clock for. One of:
   5865           *   @li #cmuClock_HF
   5866           *   @li #cmuClock_LFA
   5867           *   @li #cmuClock_LFB @if _CMU_LFCLKSEL_LFAE_ULFRCO
   5868           *   @li #cmuClock_LFC
   5869           *   @endif            @if _SILICON_LABS_32B_SERIES_1
   5870           *   @li #cmuClock_LFE
   5871           *   @endif
   5872           *   @li #cmuClock_DBG @if DOXYDOC_USB_PRESENT
   5873           *   @li #cmuClock_USBC
   5874           *   @endif
   5875           *
   5876           * @return
   5877           *   The reference clock used for clocking the selected branch, #cmuSelect_Error if
   5878           *   invalid @p clock provided.
   5879           ******************************************************************************/
   5880          CMU_Select_TypeDef CMU_ClockSelectGet(CMU_Clock_TypeDef clock)
   5881          {
   5882            CMU_Select_TypeDef ret = cmuSelect_Disabled;
   5883            uint32_t selReg;
   5884          
   5885            selReg = ((unsigned)clock >> CMU_SEL_REG_POS) & CMU_SEL_REG_MASK;
   5886          
   5887            switch (selReg) {
   5888              case CMU_HFCLKSEL_REG:
   5889          #if defined(_CMU_HFCLKSTATUS_MASK)
   5890                switch (CMU->HFCLKSTATUS & _CMU_HFCLKSTATUS_SELECTED_MASK) {
   5891                  case CMU_HFCLKSTATUS_SELECTED_LFXO:
   5892                    ret = cmuSelect_LFXO;
   5893                    break;
   5894          
   5895                  case CMU_HFCLKSTATUS_SELECTED_LFRCO:
   5896                    ret = cmuSelect_LFRCO;
   5897                    break;
   5898          
   5899                  case CMU_HFCLKSTATUS_SELECTED_HFXO:
   5900                    ret = cmuSelect_HFXO;
   5901                    break;
   5902          
   5903          #if defined(CMU_HFCLKSTATUS_SELECTED_HFRCODIV2)
   5904                  case CMU_HFCLKSTATUS_SELECTED_HFRCODIV2:
   5905                    ret = cmuSelect_HFRCODIV2;
   5906                    break;
   5907          #endif
   5908          
   5909          #if defined(CMU_HFCLKSTATUS_SELECTED_CLKIN0)
   5910                  case CMU_HFCLKSTATUS_SELECTED_CLKIN0:
   5911                    ret = cmuSelect_CLKIN0;
   5912                    break;
   5913          #endif
   5914          
   5915          #if defined(CMU_HFCLKSTATUS_SELECTED_USHFRCO)
   5916                  case CMU_HFCLKSTATUS_SELECTED_USHFRCO:
   5917                    ret = cmuSelect_USHFRCO;
   5918                    break;
   5919          #endif
   5920          
   5921                  default:
   5922                    ret = cmuSelect_HFRCO;
   5923                    break;
   5924                }
   5925          #else
   5926                switch (CMU->STATUS
   5927                        & (CMU_STATUS_HFRCOSEL
   5928                           | CMU_STATUS_HFXOSEL
   5929                           | CMU_STATUS_LFRCOSEL
   5930          #if defined(CMU_STATUS_USHFRCODIV2SEL)
   5931                           | CMU_STATUS_USHFRCODIV2SEL
   5932          #endif
   5933                           | CMU_STATUS_LFXOSEL)) {
   5934                  case CMU_STATUS_LFXOSEL:
   5935                    ret = cmuSelect_LFXO;
   5936                    break;
   5937          
   5938                  case CMU_STATUS_LFRCOSEL:
   5939                    ret = cmuSelect_LFRCO;
   5940                    break;
   5941          
   5942                  case CMU_STATUS_HFXOSEL:
   5943                    ret = cmuSelect_HFXO;
   5944                    break;
   5945          
   5946          #if defined(CMU_STATUS_USHFRCODIV2SEL)
   5947                  case CMU_STATUS_USHFRCODIV2SEL:
   5948                    ret = cmuSelect_USHFRCODIV2;
   5949                    break;
   5950          #endif
   5951          
   5952                  default:
   5953                    ret = cmuSelect_HFRCO;
   5954                    break;
   5955                }
   5956          #endif
   5957                break;
   5958          
   5959          #if defined(_CMU_LFCLKSEL_MASK) || defined(_CMU_LFACLKSEL_MASK)
   5960              case CMU_LFACLKSEL_REG:
   5961          #if defined(_CMU_LFCLKSEL_MASK)
   5962                switch (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFA_MASK) {
   5963                  case CMU_LFCLKSEL_LFA_LFRCO:
   5964                    ret = cmuSelect_LFRCO;
   5965                    break;
   5966          
   5967                  case CMU_LFCLKSEL_LFA_LFXO:
   5968                    ret = cmuSelect_LFXO;
   5969                    break;
   5970          
   5971          #if defined(CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2)
   5972                  case CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2:
   5973                    ret = cmuSelect_HFCLKLE;
   5974                    break;
   5975          #endif
   5976          
   5977                  default:
   5978          #if defined(CMU_LFCLKSEL_LFAE)
   5979                    if (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFAE_MASK) {
   5980                      ret = cmuSelect_ULFRCO;
   5981                      break;
   5982                    }
   5983          #else
   5984                    ret = cmuSelect_Disabled;
   5985          #endif
   5986                    break;
   5987                }
   5988          
   5989          #elif defined(_CMU_LFACLKSEL_MASK)
   5990                switch (CMU->LFACLKSEL & _CMU_LFACLKSEL_LFA_MASK) {
   5991                  case CMU_LFACLKSEL_LFA_LFRCO:
   5992                    ret = cmuSelect_LFRCO;
   5993                    break;
   5994          
   5995                  case CMU_LFACLKSEL_LFA_LFXO:
   5996                    ret = cmuSelect_LFXO;
   5997                    break;
   5998          
   5999                  case CMU_LFACLKSEL_LFA_ULFRCO:
   6000                    ret = cmuSelect_ULFRCO;
   6001                    break;
   6002          
   6003          #if defined(_CMU_LFACLKSEL_LFA_HFCLKLE)
   6004                  case CMU_LFACLKSEL_LFA_HFCLKLE:
   6005                    ret = cmuSelect_HFCLKLE;
   6006                    break;
   6007          #endif
   6008          
   6009          #if defined(PLFRCO_PRESENT)
   6010                  case CMU_LFACLKSEL_LFA_PLFRCO:
   6011                    ret = cmuSelect_PLFRCO;
   6012                    break;
   6013          #endif
   6014          
   6015                  default:
   6016                    ret = cmuSelect_Disabled;
   6017                    break;
   6018                }
   6019          #endif
   6020                break;
   6021          #endif /* _CMU_LFCLKSEL_MASK || _CMU_LFACLKSEL_MASK */
   6022          
   6023          #if defined(_CMU_LFCLKSEL_MASK) || defined(_CMU_LFBCLKSEL_MASK)
   6024              case CMU_LFBCLKSEL_REG:
   6025          #if defined(_CMU_LFCLKSEL_MASK)
   6026                switch (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFB_MASK) {
   6027                  case CMU_LFCLKSEL_LFB_LFRCO:
   6028                    ret = cmuSelect_LFRCO;
   6029                    break;
   6030          
   6031                  case CMU_LFCLKSEL_LFB_LFXO:
   6032                    ret = cmuSelect_LFXO;
   6033                    break;
   6034          
   6035          #if defined(CMU_LFCLKSEL_LFB_HFCORECLKLEDIV2)
   6036                  case CMU_LFCLKSEL_LFB_HFCORECLKLEDIV2:
   6037                    ret = cmuSelect_HFCLKLE;
   6038                    break;
   6039          #endif
   6040          
   6041          #if defined(CMU_LFCLKSEL_LFB_HFCLKLE)
   6042                  case CMU_LFCLKSEL_LFB_HFCLKLE:
   6043                    ret = cmuSelect_HFCLKLE;
   6044                    break;
   6045          #endif
   6046          
   6047                  default:
   6048          #if defined(CMU_LFCLKSEL_LFBE)
   6049                    if (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFBE_MASK) {
   6050                      ret = cmuSelect_ULFRCO;
   6051                      break;
   6052                    }
   6053          #else
   6054                    ret = cmuSelect_Disabled;
   6055          #endif
   6056                    break;
   6057                }
   6058          
   6059          #elif defined(_CMU_LFBCLKSEL_MASK)
   6060                switch (CMU->LFBCLKSEL & _CMU_LFBCLKSEL_LFB_MASK) {
   6061                  case CMU_LFBCLKSEL_LFB_LFRCO:
   6062                    ret = cmuSelect_LFRCO;
   6063                    break;
   6064          
   6065                  case CMU_LFBCLKSEL_LFB_LFXO:
   6066                    ret = cmuSelect_LFXO;
   6067                    break;
   6068          
   6069                  case CMU_LFBCLKSEL_LFB_ULFRCO:
   6070                    ret = cmuSelect_ULFRCO;
   6071                    break;
   6072          
   6073                  case CMU_LFBCLKSEL_LFB_HFCLKLE:
   6074                    ret = cmuSelect_HFCLKLE;
   6075                    break;
   6076          
   6077          #if defined(PLFRCO_PRESENT)
   6078                  case CMU_LFBCLKSEL_LFB_PLFRCO:
   6079                    ret = cmuSelect_PLFRCO;
   6080                    break;
   6081          #endif
   6082          
   6083                  default:
   6084                    ret = cmuSelect_Disabled;
   6085                    break;
   6086                }
   6087          #endif
   6088                break;
   6089          #endif /* _CMU_LFCLKSEL_MASK || _CMU_LFBCLKSEL_MASK */
   6090          
   6091          #if defined(_CMU_LFCLKSEL_LFC_MASK)
   6092              case CMU_LFCCLKSEL_REG:
   6093                switch (CMU->LFCLKSEL & _CMU_LFCLKSEL_LFC_MASK) {
   6094                  case CMU_LFCLKSEL_LFC_LFRCO:
   6095                    ret = cmuSelect_LFRCO;
   6096                    break;
   6097          
   6098                  case CMU_LFCLKSEL_LFC_LFXO:
   6099                    ret = cmuSelect_LFXO;
   6100                    break;
   6101          
   6102                  default:
   6103                    ret = cmuSelect_Disabled;
   6104                    break;
   6105                }
   6106                break;
   6107          #endif
   6108          
   6109          #if defined(_CMU_LFECLKSEL_LFE_MASK)
   6110              case CMU_LFECLKSEL_REG:
   6111                switch (CMU->LFECLKSEL & _CMU_LFECLKSEL_LFE_MASK) {
   6112                  case CMU_LFECLKSEL_LFE_LFRCO:
   6113                    ret = cmuSelect_LFRCO;
   6114                    break;
   6115          
   6116                  case CMU_LFECLKSEL_LFE_LFXO:
   6117                    ret = cmuSelect_LFXO;
   6118                    break;
   6119          
   6120                  case CMU_LFECLKSEL_LFE_ULFRCO:
   6121                    ret = cmuSelect_ULFRCO;
   6122                    break;
   6123          
   6124          #if defined(_CMU_LFECLKSEL_LFE_HFCLKLE)
   6125                  case CMU_LFECLKSEL_LFE_HFCLKLE:
   6126                    ret = cmuSelect_HFCLKLE;
   6127                    break;
   6128          #endif
   6129          
   6130          #if defined(PLFRCO_PRESENT)
   6131                  case CMU_LFECLKSEL_LFE_PLFRCO:
   6132                    ret = cmuSelect_PLFRCO;
   6133                    break;
   6134          #endif
   6135          
   6136                  default:
   6137                    ret = cmuSelect_Disabled;
   6138                    break;
   6139                }
   6140                break;
   6141          #endif /* CMU_LFECLKSEL_REG */
   6142          
   6143          #if defined(_CMU_LFCCLKSEL_LFC_MASK)
   6144              case CMU_LFCCLKSEL_REG:
   6145                switch (CMU->LFCCLKSEL & _CMU_LFCCLKSEL_LFC_MASK) {
   6146                  case CMU_LFCCLKSEL_LFC_LFRCO:
   6147                    ret = cmuSelect_LFRCO;
   6148                    break;
   6149          
   6150                  case CMU_LFCCLKSEL_LFC_LFXO:
   6151                    ret = cmuSelect_LFXO;
   6152                    break;
   6153          
   6154                  case CMU_LFCCLKSEL_LFC_ULFRCO:
   6155                    ret = cmuSelect_ULFRCO;
   6156                    break;
   6157          
   6158                  default:
   6159                    ret = cmuSelect_Disabled;
   6160                    break;
   6161                }
   6162                break;
   6163          #endif /* CMU_LFCCLKSEL_REG */
   6164          
   6165              case CMU_DBGCLKSEL_REG:
   6166          #if defined(_CMU_DBGCLKSEL_DBG_MASK)
   6167                switch (CMU->DBGCLKSEL & _CMU_DBGCLKSEL_DBG_MASK) {
   6168                  case CMU_DBGCLKSEL_DBG_HFCLK:
   6169                    ret = cmuSelect_HFCLK;
   6170                    break;
   6171          
   6172                  case CMU_DBGCLKSEL_DBG_AUXHFRCO:
   6173                    ret = cmuSelect_AUXHFRCO;
   6174                    break;
   6175          
   6176                  default:
   6177                    ret = cmuSelect_Disabled;
   6178                    break;
   6179                }
   6180          
   6181          #elif defined(_CMU_CTRL_DBGCLK_MASK)
   6182                switch (CMU->CTRL & _CMU_CTRL_DBGCLK_MASK) {
   6183                  case CMU_CTRL_DBGCLK_AUXHFRCO:
   6184                    ret = cmuSelect_AUXHFRCO;
   6185                    break;
   6186          
   6187                  case CMU_CTRL_DBGCLK_HFCLK:
   6188                    ret = cmuSelect_HFCLK;
   6189                    break;
   6190                }
   6191          #else
   6192                ret = cmuSelect_AUXHFRCO;
   6193          #endif
   6194                break;
   6195          
   6196          #if defined(USBC_CLOCK_PRESENT)
   6197              case CMU_USBCCLKSEL_REG:
   6198                switch (CMU->STATUS
   6199                        & (CMU_STATUS_USBCLFXOSEL
   6200          #if defined(_CMU_STATUS_USBCHFCLKSEL_MASK)
   6201                           | CMU_STATUS_USBCHFCLKSEL
   6202          #endif
   6203          #if defined(_CMU_STATUS_USBCUSHFRCOSEL_MASK)
   6204                           | CMU_STATUS_USBCUSHFRCOSEL
   6205          #endif
   6206                           | CMU_STATUS_USBCLFRCOSEL)) {
   6207          #if defined(_CMU_STATUS_USBCHFCLKSEL_MASK)
   6208                  case CMU_STATUS_USBCHFCLKSEL:
   6209                    ret = cmuSelect_HFCLK;
   6210                    break;
   6211          #endif
   6212          
   6213          #if defined(_CMU_STATUS_USBCUSHFRCOSEL_MASK)
   6214                  case CMU_STATUS_USBCUSHFRCOSEL:
   6215                    ret = cmuSelect_USHFRCO;
   6216                    break;
   6217          #endif
   6218          
   6219                  case CMU_STATUS_USBCLFXOSEL:
   6220                    ret = cmuSelect_LFXO;
   6221                    break;
   6222          
   6223                  case CMU_STATUS_USBCLFRCOSEL:
   6224                    ret = cmuSelect_LFRCO;
   6225                    break;
   6226          
   6227                  default:
   6228                    ret = cmuSelect_Disabled;
   6229                    break;
   6230                }
   6231                break;
   6232          #endif
   6233          
   6234          #if defined(_CMU_ADCCTRL_ADC0CLKSEL_MASK)
   6235              case CMU_ADC0ASYNCSEL_REG:
   6236                switch (CMU->ADCCTRL & _CMU_ADCCTRL_ADC0CLKSEL_MASK) {
   6237                  case CMU_ADCCTRL_ADC0CLKSEL_DISABLED:
   6238                    ret = cmuSelect_Disabled;
   6239                    break;
   6240          
   6241                  case CMU_ADCCTRL_ADC0CLKSEL_AUXHFRCO:
   6242                    ret = cmuSelect_AUXHFRCO;
   6243                    break;
   6244          
   6245                  case CMU_ADCCTRL_ADC0CLKSEL_HFXO:
   6246                    ret = cmuSelect_HFXO;
   6247                    break;
   6248          
   6249                  case CMU_ADCCTRL_ADC0CLKSEL_HFSRCCLK:
   6250                    ret = cmuSelect_HFSRCCLK;
   6251                    break;
   6252          
   6253                  default:
   6254                    ret = cmuSelect_Disabled;
   6255                    break;
   6256                }
   6257                break;
   6258          #endif
   6259          
   6260          #if defined(_CMU_ADCCTRL_ADC1CLKSEL_MASK)
   6261              case CMU_ADC1ASYNCSEL_REG:
   6262                switch (CMU->ADCCTRL & _CMU_ADCCTRL_ADC1CLKSEL_MASK) {
   6263                  case CMU_ADCCTRL_ADC1CLKSEL_DISABLED:
   6264                    ret = cmuSelect_Disabled;
   6265                    break;
   6266          
   6267                  case CMU_ADCCTRL_ADC1CLKSEL_AUXHFRCO:
   6268                    ret = cmuSelect_AUXHFRCO;
   6269                    break;
   6270          
   6271                  case CMU_ADCCTRL_ADC1CLKSEL_HFXO:
   6272                    ret = cmuSelect_HFXO;
   6273                    break;
   6274          
   6275                  case CMU_ADCCTRL_ADC1CLKSEL_HFSRCCLK:
   6276                    ret = cmuSelect_HFSRCCLK;
   6277                    break;
   6278                }
   6279                break;
   6280          #endif
   6281          
   6282          #if defined(_CMU_SDIOCTRL_SDIOCLKSEL_MASK)
   6283              case CMU_SDIOREFSEL_REG:
   6284                switch (CMU->SDIOCTRL & _CMU_SDIOCTRL_SDIOCLKSEL_MASK) {
   6285                  case CMU_SDIOCTRL_SDIOCLKSEL_HFRCO:
   6286                    ret = cmuSelect_HFRCO;
   6287                    break;
   6288          
   6289                  case CMU_SDIOCTRL_SDIOCLKSEL_HFXO:
   6290                    ret = cmuSelect_HFXO;
   6291                    break;
   6292          
   6293                  case CMU_SDIOCTRL_SDIOCLKSEL_AUXHFRCO:
   6294                    ret = cmuSelect_AUXHFRCO;
   6295                    break;
   6296          
   6297                  case CMU_SDIOCTRL_SDIOCLKSEL_USHFRCO:
   6298                    ret = cmuSelect_USHFRCO;
   6299                    break;
   6300                }
   6301                break;
   6302          #endif
   6303          
   6304          #if defined(_CMU_QSPICTRL_QSPI0CLKSEL_MASK)
   6305              case CMU_QSPI0REFSEL_REG:
   6306                switch (CMU->QSPICTRL & _CMU_QSPICTRL_QSPI0CLKSEL_MASK) {
   6307                  case CMU_QSPICTRL_QSPI0CLKSEL_HFRCO:
   6308                    ret = cmuSelect_HFRCO;
   6309                    break;
   6310          
   6311                  case CMU_QSPICTRL_QSPI0CLKSEL_HFXO:
   6312                    ret = cmuSelect_HFXO;
   6313                    break;
   6314          
   6315                  case CMU_QSPICTRL_QSPI0CLKSEL_AUXHFRCO:
   6316                    ret = cmuSelect_AUXHFRCO;
   6317                    break;
   6318          
   6319                  case CMU_QSPICTRL_QSPI0CLKSEL_USHFRCO:
   6320                    ret = cmuSelect_USHFRCO;
   6321                    break;
   6322                }
   6323                break;
   6324          #endif
   6325          
   6326          #if defined(_CMU_USBCTRL_USBCLKSEL_MASK)
   6327              case CMU_USBRCLKSEL_REG:
   6328                switch (CMU->USBCTRL & _CMU_USBCTRL_USBCLKSEL_MASK) {
   6329                  case CMU_USBCTRL_USBCLKSEL_USHFRCO:
   6330                    ret = cmuSelect_USHFRCO;
   6331                    break;
   6332          
   6333                  case CMU_USBCTRL_USBCLKSEL_HFXO:
   6334                    ret = cmuSelect_HFXO;
   6335                    break;
   6336          
   6337                  case CMU_USBCTRL_USBCLKSEL_HFXOX2:
   6338                    ret = cmuSelect_HFXOX2;
   6339                    break;
   6340          
   6341                  case CMU_USBCTRL_USBCLKSEL_HFRCO:
   6342                    ret = cmuSelect_HFRCO;
   6343                    break;
   6344          
   6345                  case CMU_USBCTRL_USBCLKSEL_LFXO:
   6346                    ret = cmuSelect_LFXO;
   6347                    break;
   6348          
   6349                  case CMU_USBCTRL_USBCLKSEL_LFRCO:
   6350                    ret = cmuSelect_LFRCO;
   6351                    break;
   6352                }
   6353                break;
   6354          #endif
   6355          
   6356          #if defined(_CMU_PDMCTRL_PDMCLKSEL_MASK)
   6357              case CMU_PDMREFSEL_REG:
   6358                switch (CMU->PDMCTRL & _CMU_PDMCTRL_PDMCLKSEL_MASK) {
   6359                  case CMU_PDMCTRL_PDMCLKSEL_USHFRCO:
   6360                    ret = cmuSelect_USHFRCO;
   6361                    break;
   6362          
   6363                  case CMU_PDMCTRL_PDMCLKSEL_HFXO:
   6364                    ret = cmuSelect_HFXO;
   6365                    break;
   6366          
   6367                  case CMU_PDMCTRL_PDMCLKSEL_HFRCO:
   6368                    ret = cmuSelect_HFRCO;
   6369                    break;
   6370                }
   6371                break;
   6372          #endif
   6373          
   6374              default:
   6375                ret = cmuSelect_Error;
   6376                EFM_ASSERT(false);
   6377                break;
   6378            }
   6379          
   6380            return ret;
   6381          }
   6382          
   6383          /***************************************************************************//**
   6384           * @brief
   6385           *   Select the reference clock/oscillator used for a clock branch.
   6386           *
   6387           * @details
   6388           *   Notice that if a selected reference is not enabled prior to selecting its
   6389           *   use, it will be enabled and this function will wait for the selected
   6390           *   oscillator to be stable. It will however NOT be disabled if another
   6391           *   reference clock is selected later.
   6392           *
   6393           *   This feature is particularly important if selecting a new reference
   6394           *   clock for the clock branch clocking the core. Otherwise, the system
   6395           *   may halt.
   6396           *
   6397           * @note
   6398           *   HFCLKLE prescaler is automatically modified when peripherals with clock
   6399           *   domain HFBUSCLK is chosen based on the maximum HFLE frequency allowed.
   6400           *
   6401           * @param[in] clock
   6402           *   A clock branch to select reference clock for. One of:
   6403           *   @li #cmuClock_HF
   6404           *   @li #cmuClock_LFA
   6405           *   @li #cmuClock_LFB
   6406           *   @if _CMU_LFCCLKEN0_MASK
   6407           *   @li #cmuClock_LFC
   6408           *   @endif
   6409           *   @if _CMU_LFECLKEN0_MASK
   6410           *   @li #cmuClock_LFE
   6411           *   @endif
   6412           *   @li #cmuClock_DBG
   6413           *   @if _CMU_CMD_USBCLKSEL_MASK
   6414           *   @li #cmuClock_USBC
   6415           *   @endif
   6416           *   @if _CMU_USBCTRL_MASK
   6417           *   @li #cmuClock_USBR
   6418           *   @endif
   6419           *
   6420           * @param[in] ref
   6421           *   A reference selected for clocking. See the reference manual
   6422           *   for details about references available for a specific clock branch.
   6423           *   @li #cmuSelect_HFRCO
   6424           *   @li #cmuSelect_LFRCO
   6425           *   @li #cmuSelect_HFXO
   6426           *   @if _CMU_HFXOCTRL_HFXOX2EN_MASK
   6427           *   @li #cmuSelect_HFXOX2
   6428           *   @endif
   6429           *   @li #cmuSelect_LFXO
   6430           *   @li #cmuSelect_HFCLKLE
   6431           *   @li #cmuSelect_AUXHFRCO
   6432           *   @if _CMU_USHFRCOCTRL_MASK
   6433           *   @li #cmuSelect_USHFRCO
   6434           *   @endif
   6435           *   @li #cmuSelect_HFCLK
   6436           *   @ifnot DOXYDOC_EFM32_GECKO_FAMILY
   6437           *   @li #cmuSelect_ULFRCO
   6438           *   @endif
   6439           *   @if CMU_OSCENCMD_PLFRCOEN
   6440           *   @li #cmuSelect_PLFRCO
   6441           *   @endif
   6442           ******************************************************************************/
   6443          void CMU_ClockSelectSet(CMU_Clock_TypeDef clock, CMU_Select_TypeDef ref)
   6444          {
   6445            uint32_t              select = (uint32_t)cmuOsc_HFRCO;
   6446            CMU_Osc_TypeDef       osc    = cmuOsc_HFRCO;
   6447            uint32_t              freq;
   6448            uint32_t              tmp;
   6449            uint32_t              selRegId;
   6450          #if defined(_SILICON_LABS_32B_SERIES_1)
   6451            volatile uint32_t     *selReg = NULL;
   6452          #endif
   6453          #if defined(CMU_LFCLKSEL_LFAE_ULFRCO)
   6454            uint32_t              lfExtended = 0;
   6455          #endif
   6456          
   6457          #if defined(_EMU_CMD_EM01VSCALE0_MASK)
   6458            uint32_t              vScaleFrequency = 0; /* Use default. */
   6459          
   6460            /* Start voltage upscaling before the clock is set. */
   6461            if (clock == cmuClock_HF) {
   6462              if (ref == cmuSelect_HFXO) {
   6463                vScaleFrequency = SystemHFXOClockGet();
   6464              } else if ((ref == cmuSelect_HFRCO)
   6465                         && ((uint32_t)CMU_HFRCOBandGet()
   6466                             > CMU_VSCALEEM01_LOWPOWER_VOLTAGE_CLOCK_MAX)) {
   6467                vScaleFrequency = (uint32_t)CMU_HFRCOBandGet();
   6468              } else {
   6469                /* Use the default frequency. */
   6470              }
   6471              if (vScaleFrequency != 0UL) {
   6472                EMU_VScaleEM01ByClock(vScaleFrequency, false);
   6473              }
   6474            }
   6475          #endif
   6476          
   6477            selRegId = ((unsigned)clock >> CMU_SEL_REG_POS) & CMU_SEL_REG_MASK;
   6478          
   6479            switch (selRegId) {
   6480              case CMU_HFCLKSEL_REG:
   6481                switch (ref) {
   6482                  case cmuSelect_LFXO:
   6483          #if defined(_SILICON_LABS_32B_SERIES_1)
   6484                    select = CMU_HFCLKSEL_HF_LFXO;
   6485          #elif defined(_SILICON_LABS_32B_SERIES_0)
   6486                    select = CMU_CMD_HFCLKSEL_LFXO;
   6487          #endif
   6488                    osc = cmuOsc_LFXO;
   6489                    break;
   6490          
   6491                  case cmuSelect_LFRCO:
   6492          #if defined(_SILICON_LABS_32B_SERIES_1)
   6493                    select = CMU_HFCLKSEL_HF_LFRCO;
   6494          #elif defined(_SILICON_LABS_32B_SERIES_0)
   6495                    select = CMU_CMD_HFCLKSEL_LFRCO;
   6496          #endif
   6497                    osc = cmuOsc_LFRCO;
   6498                    break;
   6499          
   6500                  case cmuSelect_HFXO:
   6501          #if defined(CMU_HFCLKSEL_HF_HFXO)
   6502                    select = CMU_HFCLKSEL_HF_HFXO;
   6503          #elif defined(CMU_CMD_HFCLKSEL_HFXO)
   6504                    select = CMU_CMD_HFCLKSEL_HFXO;
   6505          #endif
   6506                    osc = cmuOsc_HFXO;
   6507          #if defined(CMU_MAX_FREQ_HFLE)
   6508                    /* Set 1 HFLE wait-state until the new HFCLKLE frequency is known.
   6509                       This is known after 'select' is written below. */
   6510                    setHfLeConfig(CMU_MAX_FREQ_HFLE + 1UL);
   6511          #endif
   6512          #if defined(CMU_CTRL_HFXOBUFCUR_BOOSTABOVE32MHZ)
   6513                    /* Adjust HFXO buffer current for frequencies above 32 MHz. */
   6514                    if (SystemHFXOClockGet() > 32000000) {
   6515                      CMU->CTRL = (CMU->CTRL & ~_CMU_CTRL_HFXOBUFCUR_MASK)
   6516                                  | CMU_CTRL_HFXOBUFCUR_BOOSTABOVE32MHZ;
   6517                    } else {
   6518                      CMU->CTRL = (CMU->CTRL & ~_CMU_CTRL_HFXOBUFCUR_MASK)
   6519                                  | CMU_CTRL_HFXOBUFCUR_BOOSTUPTO32MHZ;
   6520                    }
   6521          #endif
   6522                    break;
   6523          
   6524                  case cmuSelect_HFRCO:
   6525          #if defined(_SILICON_LABS_32B_SERIES_1)
   6526                    select = CMU_HFCLKSEL_HF_HFRCO;
   6527          #elif defined(_SILICON_LABS_32B_SERIES_0)
   6528                    select = CMU_CMD_HFCLKSEL_HFRCO;
   6529          #endif
   6530                    osc = cmuOsc_HFRCO;
   6531          #if defined(CMU_MAX_FREQ_HFLE)
   6532                    /* Set 1 HFLE wait-state until the new HFCLKLE frequency is known.
   6533                       This is known after 'select' is written below. */
   6534                    setHfLeConfig(CMU_MAX_FREQ_HFLE + 1UL);
   6535          #endif
   6536                    break;
   6537          
   6538          #if defined(CMU_CMD_HFCLKSEL_USHFRCODIV2)
   6539                  case cmuSelect_USHFRCODIV2:
   6540                    select = CMU_CMD_HFCLKSEL_USHFRCODIV2;
   6541                    osc = cmuOsc_USHFRCO;
   6542                    break;
   6543          #endif
   6544          
   6545          #if defined(CMU_HFCLKSTATUS_SELECTED_HFRCODIV2)
   6546                  case cmuSelect_HFRCODIV2:
   6547                    select = CMU_HFCLKSEL_HF_HFRCODIV2;
   6548                    osc = cmuOsc_HFRCO;
   6549                    break;
   6550          #endif
   6551          
   6552          #if defined(CMU_HFCLKSTATUS_SELECTED_CLKIN0)
   6553                  case cmuSelect_CLKIN0:
   6554                    select = CMU_HFCLKSEL_HF_CLKIN0;
   6555                    osc = cmuOsc_CLKIN0;
   6556                    break;
   6557          #endif
   6558          
   6559          #if defined(CMU_HFCLKSTATUS_SELECTED_USHFRCO)
   6560                  case cmuSelect_USHFRCO:
   6561                    select = CMU_HFCLKSEL_HF_USHFRCO;
   6562                    osc = cmuOsc_USHFRCO;
   6563                    break;
   6564          #endif
   6565          
   6566          #if defined(CMU_LFCLKSEL_LFAE_ULFRCO) || defined(CMU_LFACLKSEL_LFA_ULFRCO)
   6567                  case cmuSelect_ULFRCO:
   6568                    /* ULFRCO cannot be used as HFCLK.  */
   6569                    EFM_ASSERT(false);
   6570                    return;
   6571          #endif
   6572          
   6573                  default:
   6574                    EFM_ASSERT(false);
   6575                    return;
   6576                }
   6577          
   6578                /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   6579          #if defined(CMU_HFCLKSTATUS_SELECTED_CLKIN0)
   6580                if (osc != cmuOsc_CLKIN0) {
   6581                  CMU_OscillatorEnable(osc, true, true);
   6582                }
   6583          #else
   6584                CMU_OscillatorEnable(osc, true, true);
   6585          #endif
   6586          
   6587                /* Configure worst case wait-states for flash and set safe HFPER
   6588                   clock-tree prescalers. */
   6589                flashWaitStateMax();
   6590                hfperClkSafePrescaler();
   6591          
   6592          #if defined(_EMU_CMD_EM01VSCALE0_MASK)
   6593                /* Wait for voltage upscaling to complete before the clock is set. */
   6594                if (vScaleFrequency != 0UL) {
   6595                  EMU_VScaleWait();
   6596                }
   6597          #endif
   6598          
   6599                /* Switch to the selected oscillator. */
   6600          #if defined(_CMU_HFCLKSEL_MASK)
   6601                CMU->HFCLKSEL = select;
   6602          #else
   6603                CMU->CMD = select;
   6604          #endif
   6605          #if defined(CMU_MAX_FREQ_HFLE)
   6606                /* Update the HFLE configuration after 'select' is set.
   6607                   Note that the HFCLKLE clock is connected differently on platforms 1 and 2. */
   6608                setHfLeConfig(CMU_ClockFreqGet(cmuClock_HFLE));
   6609          #endif
   6610          
   6611                /* Update the CMSIS core clock variable. */
   6612                /* (The function will update the global variable). */
   6613                freq = SystemCoreClockGet();
   6614          
   6615                /* Optimize flash access wait state setting for the currently selected core clk. */
   6616                CMU_UpdateWaitStates(freq, (int)VSCALE_DEFAULT);
   6617          
   6618          #if defined(_EMU_CMD_EM01VSCALE0_MASK)
   6619                /* Keep EMU module informed on the source HF clock frequency. This will apply voltage
   6620                   downscaling after clock is set if downscaling is configured. */
   6621                if (vScaleFrequency == 0UL) {
   6622                  EMU_VScaleEM01ByClock(0, true);
   6623                }
   6624          #endif
   6625                /* Set optimized HFPER clock-tree prescalers. */
   6626                hfperClkOptimizedPrescaler();
   6627                break;
   6628          
   6629          #if defined(_SILICON_LABS_32B_SERIES_1)
   6630              case CMU_LFACLKSEL_REG:
   6631                selReg = &CMU->LFACLKSEL;
   6632          #if !defined(_CMU_LFACLKSEL_LFA_HFCLKLE)
   6633                /* HFCLKCLE can't be used as LFACLK. */
   6634                EFM_ASSERT(ref != cmuSelect_HFCLKLE);
   6635          #endif
   6636                SL_FALLTHROUGH
   6637                /* Fall through and select the clock source. */
   6638          
   6639          #if defined(_CMU_LFCCLKSEL_MASK)
   6640              case CMU_LFCCLKSEL_REG:
   6641                selReg = (selReg == NULL) ? &CMU->LFCCLKSEL : selReg;
   6642          #if !defined(_CMU_LFCCLKSEL_LFC_HFCLKLE)
   6643                /* HFCLKCLE can't be used as LFCCLK. */
   6644                EFM_ASSERT(ref != cmuSelect_HFCLKLE);
   6645          #endif
   6646                SL_FALLTHROUGH
   6647          #endif
   6648              /* Fall through and select the clock source. */
   6649          
   6650              case CMU_LFECLKSEL_REG:
   6651                selReg = (selReg == NULL) ? &CMU->LFECLKSEL : selReg;
   6652          #if !defined(_CMU_LFECLKSEL_LFE_HFCLKLE)
   6653                /* HFCLKCLE can't be used as LFECLK. */
   6654                EFM_ASSERT(ref != cmuSelect_HFCLKLE);
   6655          #endif
   6656                SL_FALLTHROUGH
   6657              /* Fall through and select the clock source. */
   6658          
   6659              case CMU_LFBCLKSEL_REG:
   6660                selReg = (selReg == NULL) ? &CMU->LFBCLKSEL : selReg;
   6661                switch (ref) {
   6662                  case cmuSelect_Disabled:
   6663                    tmp = _CMU_LFACLKSEL_LFA_DISABLED;
   6664                    break;
   6665          
   6666                  case cmuSelect_LFXO:
   6667                    /* Ensure that thes elected oscillator is enabled, waiting for it to stabilize. */
   6668                    CMU_OscillatorEnable(cmuOsc_LFXO, true, true);
   6669                    tmp = _CMU_LFACLKSEL_LFA_LFXO;
   6670                    break;
   6671          
   6672                  case cmuSelect_LFRCO:
   6673                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   6674                    CMU_OscillatorEnable(cmuOsc_LFRCO, true, true);
   6675                    tmp = _CMU_LFACLKSEL_LFA_LFRCO;
   6676                    break;
   6677          
   6678                  case cmuSelect_HFCLKLE:
   6679                    /* Ensure the correct HFLE wait-states and enable HFCLK to LE.*/
   6680                    setHfLeConfig(SystemCoreClockGet());
   6681                    BUS_RegBitWrite(&CMU->HFBUSCLKEN0, _CMU_HFBUSCLKEN0_LE_SHIFT, 1);
   6682                    tmp = _CMU_LFBCLKSEL_LFB_HFCLKLE;
   6683                    break;
   6684          
   6685                  case cmuSelect_ULFRCO:
   6686                    /* ULFRCO is always on, there is no need to enable it. */
   6687                    tmp = _CMU_LFACLKSEL_LFA_ULFRCO;
   6688                    break;
   6689          
   6690          #if defined(PLFRCO_PRESENT)
   6691                  case cmuSelect_PLFRCO:
   6692                    CMU_OscillatorEnable(cmuOsc_PLFRCO, true, true);
   6693                    tmp = _CMU_LFACLKSEL_LFA_PLFRCO;
   6694                    break;
   6695          #endif
   6696          
   6697                  default:
   6698                    EFM_ASSERT(false);
   6699                    return;
   6700                }
   6701                *selReg = tmp;
   6702                break;
   6703          
   6704          #elif defined(_SILICON_LABS_32B_SERIES_0)
   6705              case CMU_LFACLKSEL_REG:
   6706              case CMU_LFBCLKSEL_REG:
   6707                switch (ref) {
   6708                  case cmuSelect_Disabled:
   6709                    tmp = _CMU_LFCLKSEL_LFA_DISABLED;
   6710                    break;
   6711          
   6712                  case cmuSelect_LFXO:
   6713                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   6714                    CMU_OscillatorEnable(cmuOsc_LFXO, true, true);
   6715                    tmp = _CMU_LFCLKSEL_LFA_LFXO;
   6716                    break;
   6717          
   6718                  case cmuSelect_LFRCO:
   6719                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   6720                    CMU_OscillatorEnable(cmuOsc_LFRCO, true, true);
   6721                    tmp = _CMU_LFCLKSEL_LFA_LFRCO;
   6722                    break;
   6723          
   6724                  case cmuSelect_HFCLKLE:
   6725          #if defined(CMU_MAX_FREQ_HFLE)
   6726                    /* Set the HFLE wait-state and divider. */
   6727                    freq = SystemCoreClockGet();
   6728                    setHfLeConfig(freq);
   6729          #endif
   6730                    /* Ensure HFCORE to LE clocking is enabled. */
   6731                    BUS_RegBitWrite(&CMU->HFCORECLKEN0, _CMU_HFCORECLKEN0_LE_SHIFT, 1);
   6732                    tmp = _CMU_LFCLKSEL_LFA_HFCORECLKLEDIV2;
   6733                    break;
   6734          
   6735          #if defined(CMU_LFCLKSEL_LFAE_ULFRCO)
   6736                  case cmuSelect_ULFRCO:
   6737                    /* ULFRCO is always enabled. */
   6738                    tmp = _CMU_LFCLKSEL_LFA_DISABLED;
   6739                    lfExtended = 1;
   6740                    break;
   6741          #endif
   6742          
   6743                  default:
   6744                    /* An illegal clock source for LFA/LFB selected. */
   6745                    EFM_ASSERT(false);
   6746                    return;
   6747                }
   6748          
   6749                /* Apply select. */
   6750                if (selRegId == CMU_LFACLKSEL_REG) {
   6751          #if defined(_CMU_LFCLKSEL_LFAE_MASK)
   6752                  CMU->LFCLKSEL = (CMU->LFCLKSEL
   6753                                   & ~(_CMU_LFCLKSEL_LFA_MASK | _CMU_LFCLKSEL_LFAE_MASK))
   6754                                  | (tmp << _CMU_LFCLKSEL_LFA_SHIFT)
   6755                                  | (lfExtended << _CMU_LFCLKSEL_LFAE_SHIFT);
   6756          #else
   6757                  CMU->LFCLKSEL = (CMU->LFCLKSEL & ~_CMU_LFCLKSEL_LFA_MASK)
   6758                                  | (tmp << _CMU_LFCLKSEL_LFA_SHIFT);
   6759          #endif
   6760                } else {
   6761          #if defined(_CMU_LFCLKSEL_LFBE_MASK)
   6762                  CMU->LFCLKSEL = (CMU->LFCLKSEL
   6763                                   & ~(_CMU_LFCLKSEL_LFB_MASK | _CMU_LFCLKSEL_LFBE_MASK))
   6764                                  | (tmp << _CMU_LFCLKSEL_LFB_SHIFT)
   6765                                  | (lfExtended << _CMU_LFCLKSEL_LFBE_SHIFT);
   6766          #else
   6767                  CMU->LFCLKSEL = (CMU->LFCLKSEL & ~_CMU_LFCLKSEL_LFB_MASK)
   6768                                  | (tmp << _CMU_LFCLKSEL_LFB_SHIFT);
   6769          #endif
   6770                }
   6771                break;
   6772          
   6773          #if defined(_CMU_LFCLKSEL_LFC_MASK)
   6774              case CMU_LFCCLKSEL_REG:
   6775                switch (ref) {
   6776                  case cmuSelect_Disabled:
   6777                    tmp = _CMU_LFCLKSEL_LFA_DISABLED;
   6778                    break;
   6779          
   6780                  case cmuSelect_LFXO:
   6781                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   6782                    CMU_OscillatorEnable(cmuOsc_LFXO, true, true);
   6783                    tmp = _CMU_LFCLKSEL_LFC_LFXO;
   6784                    break;
   6785          
   6786                  case cmuSelect_LFRCO:
   6787                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   6788                    CMU_OscillatorEnable(cmuOsc_LFRCO, true, true);
   6789                    tmp = _CMU_LFCLKSEL_LFC_LFRCO;
   6790                    break;
   6791          
   6792                  default:
   6793                    /* An illegal clock source for LFC selected. */
   6794                    EFM_ASSERT(false);
   6795                    return;
   6796                }
   6797          
   6798                /* Apply select. */
   6799                CMU->LFCLKSEL = (CMU->LFCLKSEL & ~_CMU_LFCLKSEL_LFC_MASK)
   6800                                | (tmp << _CMU_LFCLKSEL_LFC_SHIFT);
   6801                break;
   6802          #endif
   6803          #endif
   6804          
   6805          #if defined(_CMU_DBGCLKSEL_DBG_MASK) || defined(CMU_CTRL_DBGCLK)
   6806              case CMU_DBGCLKSEL_REG:
   6807                switch (ref) {
   6808          #if defined(_CMU_DBGCLKSEL_DBG_MASK)
   6809                  case cmuSelect_AUXHFRCO:
   6810                    /* Select AUXHFRCO as a debug clock. */
   6811                    CMU->DBGCLKSEL = CMU_DBGCLKSEL_DBG_AUXHFRCO;
   6812                    break;
   6813          
   6814                  case cmuSelect_HFCLK:
   6815                    /* Select divided HFCLK as a debug clock. */
   6816                    CMU->DBGCLKSEL = CMU_DBGCLKSEL_DBG_HFCLK;
   6817                    break;
   6818          #endif
   6819          
   6820          #if defined(CMU_CTRL_DBGCLK)
   6821                  case cmuSelect_AUXHFRCO:
   6822                    /* Select AUXHFRCO as a debug clock. */
   6823                    CMU->CTRL = (CMU->CTRL & ~(_CMU_CTRL_DBGCLK_MASK))
   6824                                | CMU_CTRL_DBGCLK_AUXHFRCO;
   6825                    break;
   6826          
   6827                  case cmuSelect_HFCLK:
   6828                    /* Select divided HFCLK as a debug clock. */
   6829                    CMU->CTRL = (CMU->CTRL & ~(_CMU_CTRL_DBGCLK_MASK))
   6830                                | CMU_CTRL_DBGCLK_HFCLK;
   6831                    break;
   6832          #endif
   6833          
   6834                  default:
   6835                    /* An illegal clock source for debug selected. */
   6836                    EFM_ASSERT(false);
   6837                    return;
   6838                }
   6839                break;
   6840          #endif
   6841          
   6842          #if defined(USBC_CLOCK_PRESENT)
   6843              case CMU_USBCCLKSEL_REG:
   6844                switch (ref) {
   6845                  case cmuSelect_LFXO:
   6846                    /* Select LFXO as a clock source for USB. It can only be used in sleep mode. */
   6847                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   6848                    CMU_OscillatorEnable(cmuOsc_LFXO, true, true);
   6849          
   6850                    /* Switch the oscillator. */
   6851                    CMU->CMD = CMU_CMD_USBCCLKSEL_LFXO;
   6852          
   6853                    /* Wait until the clock is activated. */
   6854                    while ((CMU->STATUS & CMU_STATUS_USBCLFXOSEL) == 0) {
   6855                    }
   6856                    break;
   6857          
   6858                  case cmuSelect_LFRCO:
   6859                    /* Select LFRCO as a clock source for USB. It can only be used in sleep mode. */
   6860                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   6861                    CMU_OscillatorEnable(cmuOsc_LFRCO, true, true);
   6862          
   6863                    /* Switch the oscillator. */
   6864                    CMU->CMD = CMU_CMD_USBCCLKSEL_LFRCO;
   6865          
   6866                    /* Wait until the clock is activated. */
   6867                    while ((CMU->STATUS & CMU_STATUS_USBCLFRCOSEL) == 0) {
   6868                    }
   6869                    break;
   6870          
   6871          #if defined(CMU_STATUS_USBCHFCLKSEL)
   6872                  case cmuSelect_HFCLK:
   6873                    /* Select undivided HFCLK as a clock source for USB. */
   6874                    /* The oscillator must already be enabled to avoid a core lockup. */
   6875                    CMU->CMD = CMU_CMD_USBCCLKSEL_HFCLKNODIV;
   6876                    /* Wait until the clock is activated. */
   6877                    while ((CMU->STATUS & CMU_STATUS_USBCHFCLKSEL) == 0) {
   6878                    }
   6879                    break;
   6880          #endif
   6881          
   6882          #if defined(CMU_CMD_USBCCLKSEL_USHFRCO)
   6883                  case cmuSelect_USHFRCO:
   6884                    /* Select USHFRCO as a clock source for USB. */
   6885                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   6886                    CMU_OscillatorEnable(cmuOsc_USHFRCO, true, true);
   6887          
   6888                    /* Switch the oscillator. */
   6889                    CMU->CMD = CMU_CMD_USBCCLKSEL_USHFRCO;
   6890          
   6891                    /* Wait until the clock is activated. */
   6892                    while ((CMU->STATUS & CMU_STATUS_USBCUSHFRCOSEL) == 0) {
   6893                    }
   6894                    break;
   6895          #endif
   6896          
   6897                  default:
   6898                    /* An illegal clock source for USB. */
   6899                    EFM_ASSERT(false);
   6900                    return;
   6901                }
   6902                break;
   6903          #endif
   6904          
   6905          #if defined(_CMU_ADCCTRL_ADC0CLKSEL_MASK)
   6906              case CMU_ADC0ASYNCSEL_REG:
   6907                switch (ref) {
   6908                  case cmuSelect_Disabled:
   6909                    tmp = _CMU_ADCCTRL_ADC0CLKSEL_DISABLED;
   6910                    break;
   6911          
   6912                  case cmuSelect_AUXHFRCO:
   6913                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   6914                    CMU_OscillatorEnable(cmuOsc_AUXHFRCO, true, true);
   6915                    tmp = _CMU_ADCCTRL_ADC0CLKSEL_AUXHFRCO;
   6916                    break;
   6917          
   6918                  case cmuSelect_HFXO:
   6919                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   6920                    CMU_OscillatorEnable(cmuOsc_HFXO, true, true);
   6921                    tmp = _CMU_ADCCTRL_ADC0CLKSEL_HFXO;
   6922                    break;
   6923          
   6924                  case cmuSelect_HFSRCCLK:
   6925                    tmp = _CMU_ADCCTRL_ADC0CLKSEL_HFSRCCLK;
   6926                    break;
   6927          
   6928                  default:
   6929                    /* An illegal clock source for ADC0ASYNC selected. */
   6930                    EFM_ASSERT(false);
   6931                    return;
   6932                }
   6933          
   6934                /* Apply select. */
   6935                CMU->ADCCTRL = (CMU->ADCCTRL & ~_CMU_ADCCTRL_ADC0CLKSEL_MASK)
   6936                               | (tmp << _CMU_ADCCTRL_ADC0CLKSEL_SHIFT);
   6937                break;
   6938          #endif
   6939          
   6940          #if defined(_CMU_ADCCTRL_ADC1CLKSEL_MASK)
   6941              case CMU_ADC1ASYNCSEL_REG:
   6942                switch (ref) {
   6943                  case cmuSelect_Disabled:
   6944                    tmp = _CMU_ADCCTRL_ADC1CLKSEL_DISABLED;
   6945                    break;
   6946          
   6947                  case cmuSelect_AUXHFRCO:
   6948                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   6949                    CMU_OscillatorEnable(cmuOsc_AUXHFRCO, true, true);
   6950                    tmp = _CMU_ADCCTRL_ADC1CLKSEL_AUXHFRCO;
   6951                    break;
   6952          
   6953                  case cmuSelect_HFXO:
   6954                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   6955                    CMU_OscillatorEnable(cmuOsc_HFXO, true, true);
   6956                    tmp = _CMU_ADCCTRL_ADC1CLKSEL_HFXO;
   6957                    break;
   6958          
   6959                  case cmuSelect_HFSRCCLK:
   6960                    tmp = _CMU_ADCCTRL_ADC1CLKSEL_HFSRCCLK;
   6961                    break;
   6962          
   6963                  default:
   6964                    /* An illegal clock source for ADC1ASYNC selected. */
   6965                    EFM_ASSERT(false);
   6966                    return;
   6967                }
   6968          
   6969                /* Apply select. */
   6970                CMU->ADCCTRL = (CMU->ADCCTRL & ~_CMU_ADCCTRL_ADC1CLKSEL_MASK)
   6971                               | (tmp << _CMU_ADCCTRL_ADC1CLKSEL_SHIFT);
   6972                break;
   6973          #endif
   6974          
   6975          #if defined(_CMU_SDIOCTRL_SDIOCLKSEL_MASK)
   6976              case CMU_SDIOREFSEL_REG:
   6977                switch (ref) {
   6978                  case cmuSelect_HFRCO:
   6979                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   6980                    CMU_OscillatorEnable(cmuOsc_HFRCO, true, true);
   6981                    tmp = _CMU_SDIOCTRL_SDIOCLKSEL_HFRCO;
   6982                    break;
   6983          
   6984                  case cmuSelect_HFXO:
   6985                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   6986                    CMU_OscillatorEnable(cmuOsc_HFXO, true, true);
   6987                    tmp = _CMU_SDIOCTRL_SDIOCLKSEL_HFXO;
   6988                    break;
   6989          
   6990                  case cmuSelect_AUXHFRCO:
   6991                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   6992                    CMU_OscillatorEnable(cmuOsc_AUXHFRCO, true, true);
   6993                    tmp = _CMU_SDIOCTRL_SDIOCLKSEL_AUXHFRCO;
   6994                    break;
   6995          
   6996                  case cmuSelect_USHFRCO:
   6997                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   6998                    CMU_OscillatorEnable(cmuOsc_USHFRCO, true, true);
   6999                    tmp = _CMU_SDIOCTRL_SDIOCLKSEL_USHFRCO;
   7000                    break;
   7001          
   7002                  default:
   7003                    /* An illegal clock source for SDIOREF selected. */
   7004                    EFM_ASSERT(false);
   7005                    return;
   7006                }
   7007          
   7008                /* Apply select. */
   7009                CMU->SDIOCTRL = (CMU->SDIOCTRL & ~_CMU_SDIOCTRL_SDIOCLKSEL_MASK)
   7010                                | (tmp << _CMU_SDIOCTRL_SDIOCLKSEL_SHIFT);
   7011                break;
   7012          #endif
   7013          
   7014          #if defined(_CMU_QSPICTRL_QSPI0CLKSEL_MASK)
   7015              case CMU_QSPI0REFSEL_REG:
   7016                switch (ref) {
   7017                  case cmuSelect_HFRCO:
   7018                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   7019                    CMU_OscillatorEnable(cmuOsc_HFRCO, true, true);
   7020                    tmp = _CMU_QSPICTRL_QSPI0CLKSEL_HFRCO;
   7021                    break;
   7022          
   7023                  case cmuSelect_HFXO:
   7024                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   7025                    CMU_OscillatorEnable(cmuOsc_HFXO, true, true);
   7026                    tmp = _CMU_QSPICTRL_QSPI0CLKSEL_HFXO;
   7027                    break;
   7028          
   7029                  case cmuSelect_AUXHFRCO:
   7030                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   7031                    CMU_OscillatorEnable(cmuOsc_AUXHFRCO, true, true);
   7032                    tmp = _CMU_QSPICTRL_QSPI0CLKSEL_AUXHFRCO;
   7033                    break;
   7034          
   7035                  case cmuSelect_USHFRCO:
   7036                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   7037                    CMU_OscillatorEnable(cmuOsc_USHFRCO, true, true);
   7038                    tmp = _CMU_QSPICTRL_QSPI0CLKSEL_USHFRCO;
   7039                    break;
   7040          
   7041                  default:
   7042                    /* An illegal clock source for QSPI0REF selected. */
   7043                    EFM_ASSERT(false);
   7044                    return;
   7045                }
   7046          
   7047                /* Apply select. */
   7048                CMU->QSPICTRL = (CMU->QSPICTRL & ~_CMU_QSPICTRL_QSPI0CLKSEL_MASK)
   7049                                | (tmp << _CMU_QSPICTRL_QSPI0CLKSEL_SHIFT);
   7050                break;
   7051          #endif
   7052          
   7053          #if defined(_CMU_USBCTRL_USBCLKSEL_MASK)
   7054              case CMU_USBRCLKSEL_REG:
   7055                switch (ref) {
   7056                  case cmuSelect_USHFRCO:
   7057                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   7058                    CMU_OscillatorEnable(cmuOsc_USHFRCO, true, true);
   7059                    tmp = _CMU_USBCTRL_USBCLKSEL_USHFRCO;
   7060                    break;
   7061          
   7062                  case cmuSelect_HFXO:
   7063                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   7064                    CMU_OscillatorEnable(cmuOsc_HFXO, true, true);
   7065                    tmp = _CMU_USBCTRL_USBCLKSEL_HFXO;
   7066                    break;
   7067          
   7068                  case cmuSelect_HFXOX2:
   7069                    /* Only allowed for HFXO frequencies up to 25 MHz. */
   7070                    EFM_ASSERT(SystemHFXOClockGet() <= 25000000u);
   7071          
   7072                    /* Enable HFXO X2. */
   7073                    CMU->HFXOCTRL |= CMU_HFXOCTRL_HFXOX2EN;
   7074          
   7075                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   7076                    CMU_OscillatorEnable(cmuOsc_HFXO, true, true);
   7077          
   7078                    tmp = _CMU_USBCTRL_USBCLKSEL_HFXOX2;
   7079                    break;
   7080          
   7081                  case cmuSelect_HFRCO:
   7082                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   7083                    CMU_OscillatorEnable(cmuOsc_HFRCO, true, true);
   7084                    tmp = _CMU_USBCTRL_USBCLKSEL_HFRCO;
   7085                    break;
   7086          
   7087                  case cmuSelect_LFXO:
   7088                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   7089                    CMU_OscillatorEnable(cmuOsc_LFXO, true, true);
   7090                    tmp = _CMU_USBCTRL_USBCLKSEL_LFXO;
   7091                    break;
   7092          
   7093                  case cmuSelect_LFRCO:
   7094                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   7095                    CMU_OscillatorEnable(cmuOsc_LFRCO, true, true);
   7096                    tmp = _CMU_USBCTRL_USBCLKSEL_LFRCO;
   7097                    break;
   7098          
   7099                  default:
   7100                    /* An illegal clock source for USBR selected. */
   7101                    EFM_ASSERT(false);
   7102                    return;
   7103                }
   7104          
   7105                /* Apply select. */
   7106                CMU->USBCTRL = (CMU->USBCTRL & ~_CMU_USBCTRL_USBCLKSEL_MASK)
   7107                               | (tmp << _CMU_USBCTRL_USBCLKSEL_SHIFT);
   7108                break;
   7109          #endif
   7110          
   7111          #if defined(_CMU_PDMCTRL_PDMCLKSEL_MASK)
   7112              case CMU_PDMREFSEL_REG:
   7113                switch (ref) {
   7114                  case cmuSelect_USHFRCO:
   7115                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   7116                    CMU_OscillatorEnable(cmuOsc_USHFRCO, true, true);
   7117                    tmp = _CMU_PDMCTRL_PDMCLKSEL_USHFRCO;
   7118                    break;
   7119          
   7120                  case cmuSelect_HFXO:
   7121                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   7122                    CMU_OscillatorEnable(cmuOsc_HFXO, true, true);
   7123                    tmp = _CMU_PDMCTRL_PDMCLKSEL_HFXO;
   7124                    break;
   7125          
   7126                  case cmuSelect_HFRCO:
   7127                    /* Ensure that the selected oscillator is enabled, waiting for it to stabilize. */
   7128                    CMU_OscillatorEnable(cmuOsc_HFRCO, true, true);
   7129                    tmp = _CMU_PDMCTRL_PDMCLKSEL_HFRCO;
   7130                    break;
   7131          
   7132                  default:
   7133                    /* An illegal clock source for PDMREF selected. */
   7134                    EFM_ASSERT(false);
   7135                    return;
   7136                }
   7137          
   7138                /* Apply select. */
   7139                CMU->PDMCTRL = (CMU->PDMCTRL & ~_CMU_PDMCTRL_PDMCLKSEL_MASK)
   7140                               | (tmp << _CMU_PDMCTRL_PDMCLKSEL_SHIFT);
   7141                break;
   7142          #endif
   7143          
   7144              default:
   7145                EFM_ASSERT(false);
   7146                break;
   7147            }
   7148          }
   7149          
   7150          #if defined(CMU_OSCENCMD_DPLLEN)
   7151          /**************************************************************************//**
   7152           * @brief
   7153           *   Lock the DPLL to a given frequency.
   7154           *
   7155           *   The frequency is given by: Fout = Fref * (N+1) / (M+1).
   7156           *
   7157           * @note
   7158           *   This function does not check if the given N & M values will actually
   7159           *   produce the desired target frequency. @n
   7160           *   N & M limitations: @n
   7161           *     300 < N <= 4095 @n
   7162           *     0 <= M <= 4095 @n
   7163           *   Any peripheral running off HFRCO should be switched to HFRCODIV2 prior to
   7164           *   calling this function to avoid over-clocking.
   7165           *
   7166           *   HFCLKLE prescaler is automatically modified before updating HFRCO
   7167           *   based on the maximum HFLE frequency allowed.
   7168           *
   7169           * @param[in] init
   7170           *    DPLL setup parameters.
   7171           *
   7172           * @return
   7173           *   Returns false on invalid target frequency or DPLL locking error.
   7174           *****************************************************************************/
   7175          bool CMU_DPLLLock(const CMU_DPLLInit_TypeDef *init)
   7176          {
   7177            int index = 0;
   7178            unsigned int i;
   7179            bool hfrcoDiv2override = false;
   7180            uint32_t hfrcoCtrlVal, lockStatus, sysFreq;
   7181          
   7182            EFM_ASSERT(init->frequency >= hfrcoCtrlTable[0].minFreq);
   7183            EFM_ASSERT(init->frequency
   7184                       <= hfrcoCtrlTable[HFRCOCTRLTABLE_ENTRIES - 1U].maxFreq);
   7185            EFM_ASSERT(init->n > 300U);
   7186            EFM_ASSERT(init->n <= (_CMU_DPLLCTRL1_N_MASK >> _CMU_DPLLCTRL1_N_SHIFT));
   7187            EFM_ASSERT(init->m <= (_CMU_DPLLCTRL1_M_MASK >> _CMU_DPLLCTRL1_M_SHIFT));
   7188            EFM_ASSERT(init->ssInterval  <= (_CMU_HFRCOSS_SSINV_MASK
   7189                                             >> _CMU_HFRCOSS_SSINV_SHIFT));
   7190            EFM_ASSERT(init->ssAmplitude <= (_CMU_HFRCOSS_SSAMP_MASK
   7191                                             >> _CMU_HFRCOSS_SSAMP_SHIFT));
   7192          
   7193          #if defined(_EMU_STATUS_VSCALE_MASK)
   7194            if ((EMU_VScaleGet() == emuVScaleEM01_LowPower)
   7195                && (init->frequency > CMU_VSCALEEM01_LOWPOWER_VOLTAGE_CLOCK_MAX)) {
   7196              EFM_ASSERT(false);
   7197              return false;
   7198            }
   7199          #endif
   7200          
   7201            // Find the correct HFRCO band and retrieve a HFRCOCTRL value.
   7202            for (i = 0; i < HFRCOCTRLTABLE_ENTRIES; i++) {
   7203              if ((init->frequency    >= hfrcoCtrlTable[i].minFreq)
   7204                  && (init->frequency <= hfrcoCtrlTable[i].maxFreq)) {
   7205                index = (int)i;                       // Correct band found
   7206                break;
   7207              }
   7208            }
   7209            if ((uint32_t)index == HFRCOCTRLTABLE_ENTRIES) {
   7210              EFM_ASSERT(false);
   7211              return false;                           // Target frequency out of spec.
   7212            }
   7213            hfrcoCtrlVal = hfrcoCtrlTable[index].value;
   7214          
   7215            // Check if a calibrated HFRCOCTRL.TUNING value is in device DI page.
   7216            if (hfrcoCtrlTable[index].band != (CMU_HFRCOFreq_TypeDef)0) {
   7217              uint32_t tuning;
   7218          
   7219              tuning = (CMU_HFRCODevinfoGet(hfrcoCtrlTable[index].band)
   7220                        & _CMU_HFRCOCTRL_TUNING_MASK)
   7221                       >> _CMU_HFRCOCTRL_TUNING_SHIFT;
   7222          
   7223              // When HFRCOCTRL.FINETUNINGEN is enabled, the center frequency
   7224              // of the band shifts down by 5.8%. 9 is subtracted to compensate.
   7225              if (tuning > 9UL) {
   7226                tuning -= 9UL;
   7227              } else {
   7228                tuning = 0UL;
   7229              }
   7230          
   7231              hfrcoCtrlVal |= tuning << _CMU_HFRCOCTRL_TUNING_SHIFT;
   7232            }
   7233          
   7234            // Update the CMSIS frequency SystemHfrcoFreq value.
   7235            SystemHfrcoFreq = init->frequency;
   7236          
   7237            // Set maximum wait-states while changing the core clock.
   7238            if (CMU_ClockSelectGet(cmuClock_HF) == cmuSelect_HFRCO) {
   7239              flashWaitStateMax();
   7240            }
   7241          
   7242            // Update the HFLE configuration before updating HFRCO, use new DPLL frequency.
   7243            if (CMU_ClockSelectGet(cmuClock_HF) == cmuSelect_HFRCO) {
   7244              setHfLeConfig(init->frequency);
   7245          
   7246              // Switch to HFRCO/2 before setting DPLL to avoid over-clocking.
   7247              hfrcoDiv2override = true;
   7248              CMU->HFCLKSEL = CMU_HFCLKSEL_HF_HFRCODIV2;
   7249            }
   7250          
   7251            CMU->OSCENCMD  = CMU_OSCENCMD_DPLLDIS;
   7252            while ((CMU->STATUS & (CMU_STATUS_DPLLENS | CMU_STATUS_DPLLRDY)) != 0UL) {
   7253            }
   7254            CMU->IFC       = CMU_IFC_DPLLRDY | CMU_IFC_DPLLLOCKFAILLOW
   7255                             | CMU_IFC_DPLLLOCKFAILHIGH;
   7256            CMU->DPLLCTRL1 = ((uint32_t)init->n   << _CMU_DPLLCTRL1_N_SHIFT)
   7257                             | ((uint32_t)init->m << _CMU_DPLLCTRL1_M_SHIFT);
   7258            CMU->HFRCOCTRL = hfrcoCtrlVal;
   7259            CMU->DPLLCTRL  = ((uint32_t)init->refClk << _CMU_DPLLCTRL_REFSEL_SHIFT)
   7260                             | ((init->autoRecover ? 1UL : 0UL)
   7261                                << _CMU_DPLLCTRL_AUTORECOVER_SHIFT)
   7262                             | ((uint32_t)init->edgeSel << _CMU_DPLLCTRL_EDGESEL_SHIFT)
   7263                             | ((uint32_t)init->lockMode << _CMU_DPLLCTRL_MODE_SHIFT);
   7264            CMU->OSCENCMD  = CMU_OSCENCMD_DPLLEN;
   7265            while ((lockStatus = (CMU->IF & (CMU_IF_DPLLRDY
   7266                                             | CMU_IF_DPLLLOCKFAILLOW
   7267                                             | CMU_IF_DPLLLOCKFAILHIGH))) == 0UL) {
   7268            }
   7269          
   7270            // Restore to HFRCO
   7271            if ((CMU_ClockSelectGet(cmuClock_HF) == cmuSelect_HFRCODIV2)
   7272                && (hfrcoDiv2override == true)) {
   7273              CMU->HFCLKSEL = CMU_HFCLKSEL_HF_HFRCO;
   7274            }
   7275          
   7276            // If HFRCO is selected as an HF clock, optimize the flash access wait-state
   7277            // configuration for this frequency and update the CMSIS core clock variable.
   7278            if (CMU_ClockSelectGet(cmuClock_HF) == cmuSelect_HFRCO) {
   7279              // Call @ref SystemCoreClockGet() to update the CMSIS core clock variable.
   7280              sysFreq = SystemCoreClockGet();
   7281              EFM_ASSERT(sysFreq <= init->frequency);
   7282              EFM_ASSERT(sysFreq <= SystemHfrcoFreq);
   7283              EFM_ASSERT(init->frequency == SystemHfrcoFreq);
   7284              CMU_UpdateWaitStates(sysFreq, (int)VSCALE_DEFAULT);
   7285            }
   7286          
   7287            // Reduce HFLE frequency if possible.
   7288            setHfLeConfig(CMU_ClockFreqGet(cmuClock_HFLE));
   7289          
   7290          #if defined(_EMU_CMD_EM01VSCALE0_MASK)
   7291            // Update voltage scaling.
   7292            EMU_VScaleEM01ByClock(0, true);
   7293          #endif
   7294          
   7295            if (lockStatus == CMU_IF_DPLLRDY) {
   7296              return true;
   7297            }
   7298            return false;
   7299          }
   7300          #endif // CMU_OSCENCMD_DPLLEN
   7301          
   7302          /**************************************************************************//**
   7303           * @brief
   7304           *   CMU low frequency register synchronization freeze control.
   7305           *
   7306           * @details
   7307           *   Some CMU registers require synchronization into the low-frequency (LF)
   7308           *   domain. The freeze feature allows for several such registers to be
   7309           *   modified before passing them to the LF domain simultaneously (which
   7310           *   takes place when the freeze mode is disabled).
   7311           *
   7312           *   Another use case for this feature is using an API (such
   7313           *   as the CMU API) for modifying several bit fields consecutively in the
   7314           *   same register. If freeze mode is enabled during this sequence, stalling
   7315           *   can be avoided.
   7316           *
   7317           * @note
   7318           *   When enabling freeze mode, this function will wait for all current
   7319           *   ongoing CMU synchronization to LF domain to complete (normally
   7320           *   synchronization will not be in progress.) However, for this reason, when
   7321           *   using freeze mode, modifications of registers requiring LF synchronization
   7322           *   should be done within one freeze enable/disable block to avoid unnecessary
   7323           *   stalling.
   7324           *
   7325           * @param[in] enable
   7326           *   @li true - enable freeze, modified registers are not propagated to the
   7327           *       LF domain
   7328           *   @li false - disable freeze, modified registers are propagated to the LF
   7329           *       domain
   7330           *****************************************************************************/
   7331          void CMU_FreezeEnable(bool enable)
   7332          {
   7333            if (enable) {
   7334              /* Wait for any ongoing LF synchronizations to complete. This */
   7335              /* protects against the rare case when a user                            */
   7336              /* - modifies a register requiring LF sync                              */
   7337              /* - then enables freeze before LF sync completed                       */
   7338              /* - then modifies the same register again                              */
   7339              /* since modifying a register while it is in sync progress should be    */
   7340              /* avoided.                                                             */
   7341              while (CMU->SYNCBUSY != 0UL) {
   7342              }
   7343          
   7344              CMU->FREEZE = CMU_FREEZE_REGFREEZE;
   7345            } else {
   7346              CMU->FREEZE = 0;
   7347            }
   7348          }
   7349          
   7350          #if defined(_CMU_HFRCOCTRL_BAND_MASK)
   7351          /***************************************************************************//**
   7352           * @brief
   7353           *   Get HFRCO band in use.
   7354           *
   7355           * @return
   7356           *   HFRCO band in use.
   7357           ******************************************************************************/
   7358          CMU_HFRCOBand_TypeDef CMU_HFRCOBandGet(void)
   7359          {
   7360            return (CMU_HFRCOBand_TypeDef)((CMU->HFRCOCTRL & _CMU_HFRCOCTRL_BAND_MASK)
   7361                                           >> _CMU_HFRCOCTRL_BAND_SHIFT);
   7362          }
   7363          #endif /* _CMU_HFRCOCTRL_BAND_MASK */
   7364          
   7365          #if defined(_CMU_HFRCOCTRL_BAND_MASK)
   7366          /***************************************************************************//**
   7367           * @brief
   7368           *   Set HFRCO band and the tuning value based on the value in the calibration
   7369           *   table made during production.
   7370           *
   7371           * @note
   7372           *   HFCLKLE prescaler is automatically modified based on the maximum
   7373           *   HFLE frequency allowed.
   7374           *
   7375           * @param[in] band
   7376           *   HFRCO band to activate.
   7377           ******************************************************************************/
   7378          void CMU_HFRCOBandSet(CMU_HFRCOBand_TypeDef band)
   7379          {
   7380            uint32_t           tuning;
   7381            uint32_t           freq;
   7382            CMU_Select_TypeDef osc;
   7383          
   7384            /* Read the tuning value from the calibration table. */
   7385            switch (band) {
   7386              case cmuHFRCOBand_1MHz:
   7387                tuning = (DEVINFO->HFRCOCAL0 & _DEVINFO_HFRCOCAL0_BAND1_MASK)
   7388                         >> _DEVINFO_HFRCOCAL0_BAND1_SHIFT;
   7389                break;
   7390          
   7391              case cmuHFRCOBand_7MHz:
   7392                tuning = (DEVINFO->HFRCOCAL0 & _DEVINFO_HFRCOCAL0_BAND7_MASK)
   7393                         >> _DEVINFO_HFRCOCAL0_BAND7_SHIFT;
   7394                break;
   7395          
   7396              case cmuHFRCOBand_11MHz:
   7397                tuning = (DEVINFO->HFRCOCAL0 & _DEVINFO_HFRCOCAL0_BAND11_MASK)
   7398                         >> _DEVINFO_HFRCOCAL0_BAND11_SHIFT;
   7399                break;
   7400          
   7401              case cmuHFRCOBand_14MHz:
   7402                tuning = (DEVINFO->HFRCOCAL0 & _DEVINFO_HFRCOCAL0_BAND14_MASK)
   7403                         >> _DEVINFO_HFRCOCAL0_BAND14_SHIFT;
   7404                break;
   7405          
   7406              case cmuHFRCOBand_21MHz:
   7407                tuning = (DEVINFO->HFRCOCAL1 & _DEVINFO_HFRCOCAL1_BAND21_MASK)
   7408                         >> _DEVINFO_HFRCOCAL1_BAND21_SHIFT;
   7409                break;
   7410          
   7411          #if defined(_CMU_HFRCOCTRL_BAND_28MHZ)
   7412              case cmuHFRCOBand_28MHz:
   7413                tuning = (DEVINFO->HFRCOCAL1 & _DEVINFO_HFRCOCAL1_BAND28_MASK)
   7414                         >> _DEVINFO_HFRCOCAL1_BAND28_SHIFT;
   7415                break;
   7416          #endif
   7417          
   7418              default:
   7419                EFM_ASSERT(false);
   7420                return;
   7421            }
   7422          
   7423            /* If HFRCO is used for the core clock, flash access WS has to be considered. */
   7424            osc = CMU_ClockSelectGet(cmuClock_HF);
   7425            if (osc == cmuSelect_HFRCO) {
   7426              /* Configure worst case wait states for flash access before setting the divider. */
   7427              flashWaitStateMax();
   7428            }
   7429          
   7430            /* Set band/tuning. */
   7431            CMU->HFRCOCTRL = (CMU->HFRCOCTRL
   7432                              & ~(_CMU_HFRCOCTRL_BAND_MASK | _CMU_HFRCOCTRL_TUNING_MASK))
   7433                             | (band << _CMU_HFRCOCTRL_BAND_SHIFT)
   7434                             | (tuning << _CMU_HFRCOCTRL_TUNING_SHIFT);
   7435          
   7436            /* If HFRCO is used for the core clock, optimize flash WS. */
   7437            if (osc == cmuSelect_HFRCO) {
   7438              /* Call @ref SystemCoreClockGet() to update the CMSIS core clock variable. */
   7439              freq = SystemCoreClockGet();
   7440              CMU_UpdateWaitStates(freq, (int)VSCALE_DEFAULT);
   7441            }
   7442          
   7443          #if defined(CMU_MAX_FREQ_HFLE)
   7444            /* Reduce HFLE frequency if possible. */
   7445            setHfLeConfig(CMU_ClockFreqGet(cmuClock_HFLE));
   7446          #endif
   7447          }
   7448          #endif /* _CMU_HFRCOCTRL_BAND_MASK */
   7449          
   7450          #if defined(_CMU_HFRCOCTRL_FREQRANGE_MASK)
   7451          /**************************************************************************//**
   7452           * @brief
   7453           *   Get the HFRCO frequency calibration word in DEVINFO.
   7454           *
   7455           * @param[in] freq
   7456           *   Frequency in Hz.
   7457           *
   7458           * @return
   7459           *   HFRCO calibration word for a given frequency.
   7460           *****************************************************************************/
   7461          static uint32_t CMU_HFRCODevinfoGet(CMU_HFRCOFreq_TypeDef freq)
   7462          {
   7463            switch (freq) {
   7464              /* 1, 2, and 4 MHz share the same calibration word. */
   7465              case cmuHFRCOFreq_1M0Hz:
   7466              case cmuHFRCOFreq_2M0Hz:
   7467              case cmuHFRCOFreq_4M0Hz:
   7468                return DEVINFO->HFRCOCAL0;
   7469          
   7470              case cmuHFRCOFreq_7M0Hz:
   7471                return DEVINFO->HFRCOCAL3;
   7472          
   7473              case cmuHFRCOFreq_13M0Hz:
   7474                return DEVINFO->HFRCOCAL6;
   7475          
   7476              case cmuHFRCOFreq_16M0Hz:
   7477                return DEVINFO->HFRCOCAL7;
   7478          
   7479              case cmuHFRCOFreq_19M0Hz:
   7480                return DEVINFO->HFRCOCAL8;
   7481          
   7482              case cmuHFRCOFreq_26M0Hz:
   7483                return DEVINFO->HFRCOCAL10;
   7484          
   7485              case cmuHFRCOFreq_32M0Hz:
   7486                return DEVINFO->HFRCOCAL11;
   7487          
   7488              case cmuHFRCOFreq_38M0Hz:
   7489                return DEVINFO->HFRCOCAL12;
   7490          
   7491          #if defined(_DEVINFO_HFRCOCAL13_MASK)
   7492              case cmuHFRCOFreq_48M0Hz:
   7493                return DEVINFO->HFRCOCAL13;
   7494          #endif
   7495          
   7496          #if defined(_DEVINFO_HFRCOCAL14_MASK)
   7497              case cmuHFRCOFreq_56M0Hz:
   7498                return DEVINFO->HFRCOCAL14;
   7499          #endif
   7500          
   7501          #if defined(_DEVINFO_HFRCOCAL15_MASK)
   7502              case cmuHFRCOFreq_64M0Hz:
   7503                return DEVINFO->HFRCOCAL15;
   7504          #endif
   7505          
   7506          #if defined(_DEVINFO_HFRCOCAL16_MASK)
   7507              case cmuHFRCOFreq_72M0Hz:
   7508                return DEVINFO->HFRCOCAL16;
   7509          #endif
   7510          
   7511              default: /* cmuHFRCOFreq_UserDefined */
   7512                return 0;
   7513            }
   7514          }
   7515          
   7516          /***************************************************************************//**
   7517           * @brief
   7518           *   Get the current HFRCO frequency.
   7519           *
   7520           * @return
   7521           *   HFRCO frequency.
   7522           ******************************************************************************/
   7523          CMU_HFRCOFreq_TypeDef CMU_HFRCOBandGet(void)
   7524          {
   7525            return (CMU_HFRCOFreq_TypeDef)SystemHfrcoFreq;
   7526          }
   7527          
   7528          /***************************************************************************//**
   7529           * @brief
   7530           *   Set the HFRCO calibration for the selected target frequency.
   7531           *
   7532           * @note
   7533           *   HFCLKLE prescaler is automatically modified based on the maximum
   7534           *   HFLE frequency allowed.
   7535           *
   7536           * @param[in] setFreq
   7537           *   HFRCO frequency to set.
   7538           ******************************************************************************/
   7539          void CMU_HFRCOBandSet(CMU_HFRCOFreq_TypeDef setFreq)
   7540          {
   7541            uint32_t freqCal;
   7542            uint32_t sysFreq;
   7543            uint32_t prevFreq;
   7544          
   7545            /* Get the DEVINFO index and set the CMSIS frequency SystemHfrcoFreq. */
   7546            freqCal = CMU_HFRCODevinfoGet(setFreq);
   7547            EFM_ASSERT((freqCal != 0UL) && (freqCal != UINT_MAX));
   7548            prevFreq = SystemHfrcoFreq;
   7549            SystemHfrcoFreq = (uint32_t)setFreq;
   7550          
   7551            /* Set maximum wait-states and set safe HFPER clock-tree prescalers while
   7552               changing the core clock. */
   7553            if (CMU_ClockSelectGet(cmuClock_HF) == cmuSelect_HFRCO) {
   7554              flashWaitStateMax();
   7555              hfperClkSafePrescaler();
   7556            }
   7557          
   7558            /* Wait for any previous sync to complete and set calibration data
   7559               for the selected frequency.  */
   7560            while (BUS_RegBitRead(&CMU->SYNCBUSY, _CMU_SYNCBUSY_HFRCOBSY_SHIFT) != 0UL) {
   7561            }
   7562          
   7563            /* Check for valid calibration data. */
   7564            EFM_ASSERT(freqCal != UINT_MAX);
   7565          
   7566            /* Set divider in HFRCOCTRL for 1, 2, and 4 MHz. */
   7567            switch (setFreq) {
   7568              case cmuHFRCOFreq_1M0Hz:
   7569                freqCal = (freqCal & ~_CMU_HFRCOCTRL_CLKDIV_MASK)
   7570                          | CMU_HFRCOCTRL_CLKDIV_DIV4;
   7571                break;
   7572          
   7573              case cmuHFRCOFreq_2M0Hz:
   7574                freqCal = (freqCal & ~_CMU_HFRCOCTRL_CLKDIV_MASK)
   7575                          | CMU_HFRCOCTRL_CLKDIV_DIV2;
   7576                break;
   7577          
   7578              case cmuHFRCOFreq_4M0Hz:
   7579                freqCal = (freqCal & ~_CMU_HFRCOCTRL_CLKDIV_MASK)
   7580                          | CMU_HFRCOCTRL_CLKDIV_DIV1;
   7581                break;
   7582          
   7583              default:
   7584                break;
   7585            }
   7586          
   7587            /* Update HFLE configuration before updating HFRCO.
   7588               Use the new set frequency. */
   7589            if (CMU_ClockSelectGet(cmuClock_HF) == cmuSelect_HFRCO) {
   7590              /* setFreq is worst-case as dividers may reduce the HFLE frequency. */
   7591              setHfLeConfig((uint32_t)setFreq);
   7592            }
   7593          
   7594            if ((uint32_t)setFreq > prevFreq) {
   7595          #if defined(_EMU_CMD_EM01VSCALE0_MASK)
   7596              /* When increasing frequency voltage scale must be done before the change. */
   7597              EMU_VScaleEM01ByClock((uint32_t)setFreq, true);
   7598          #endif
   7599            }
   7600          
   7601            CMU->HFRCOCTRL = freqCal;
   7602          
   7603            /* If HFRCO is selected as an HF clock, optimize the flash access wait-state configuration
   7604               for this frequency and update the CMSIS core clock variable. */
   7605            if (CMU_ClockSelectGet(cmuClock_HF) == cmuSelect_HFRCO) {
   7606              /* Call @ref SystemCoreClockGet() to update the CMSIS core clock variable. */
   7607              sysFreq = SystemCoreClockGet();
   7608              EFM_ASSERT(sysFreq <= (uint32_t)setFreq);
   7609              EFM_ASSERT(sysFreq <= SystemHfrcoFreq);
   7610              EFM_ASSERT((uint32_t)setFreq == SystemHfrcoFreq);
   7611              CMU_UpdateWaitStates(sysFreq, (int)VSCALE_DEFAULT);
   7612            }
   7613          
   7614            /* Reduce HFLE frequency if possible. */
   7615            setHfLeConfig(CMU_ClockFreqGet(cmuClock_HFLE));
   7616          
   7617            if ((uint32_t)setFreq <= prevFreq) {
   7618          #if defined(_EMU_CMD_EM01VSCALE0_MASK)
   7619              /* When decreasing frequency voltage scale must be done after the change */
   7620              EMU_VScaleEM01ByClock(0, true);
   7621          #endif
   7622            }
   7623            if (CMU_ClockSelectGet(cmuClock_HF) == cmuSelect_HFRCO) {
   7624              /* Set optimized HFPER clock-tree prescalers. */
   7625              hfperClkOptimizedPrescaler();
   7626            }
   7627          }
   7628          #endif /* _CMU_HFRCOCTRL_FREQRANGE_MASK */
   7629          
   7630          #if defined(_CMU_HFRCOCTRL_SUDELAY_MASK)
   7631          /***************************************************************************//**
   7632           * @brief
   7633           *   Get the HFRCO startup delay.
   7634           *
   7635           * @details
   7636           *   See the reference manual for more details.
   7637           *
   7638           * @return
   7639           *   The startup delay in use.
   7640           ******************************************************************************/
   7641          uint32_t CMU_HFRCOStartupDelayGet(void)
   7642          {
   7643            return (CMU->HFRCOCTRL & _CMU_HFRCOCTRL_SUDELAY_MASK)
   7644                   >> _CMU_HFRCOCTRL_SUDELAY_SHIFT;
   7645          }
   7646          
   7647          /***************************************************************************//**
   7648           * @brief
   7649           *   Set the HFRCO startup delay.
   7650           *
   7651           * @details
   7652           *   See the reference manual for more details.
   7653           *
   7654           * @param[in] delay
   7655           *   The startup delay to set (<= 31).
   7656           ******************************************************************************/
   7657          void CMU_HFRCOStartupDelaySet(uint32_t delay)
   7658          {
   7659            EFM_ASSERT(delay <= 31);
   7660          
   7661            delay &= _CMU_HFRCOCTRL_SUDELAY_MASK >> _CMU_HFRCOCTRL_SUDELAY_SHIFT;
   7662            CMU->HFRCOCTRL = (CMU->HFRCOCTRL & ~(_CMU_HFRCOCTRL_SUDELAY_MASK))
   7663                             | (delay << _CMU_HFRCOCTRL_SUDELAY_SHIFT);
   7664          }
   7665          #endif
   7666          
   7667          #if defined(_CMU_USHFRCOCTRL_FREQRANGE_MASK)
   7668          /**************************************************************************//**
   7669           * @brief
   7670           *   Get the USHFRCO frequency calibration word in DEVINFO.
   7671           *
   7672           * @param[in] freq
   7673           *   Frequency in Hz.
   7674           *
   7675           * @return
   7676           *   USHFRCO calibration word for a given frequency.
   7677           *****************************************************************************/
   7678          static uint32_t CMU_USHFRCODevinfoGet(CMU_USHFRCOFreq_TypeDef freq)
   7679          {
   7680            switch (freq) {
   7681              case cmuUSHFRCOFreq_16M0Hz:
   7682                return DEVINFO->USHFRCOCAL7;
   7683          
   7684              case cmuUSHFRCOFreq_32M0Hz:
   7685                return DEVINFO->USHFRCOCAL11;
   7686          
   7687              case cmuUSHFRCOFreq_48M0Hz:
   7688                return DEVINFO->USHFRCOCAL13;
   7689          
   7690              case cmuUSHFRCOFreq_50M0Hz:
   7691                return DEVINFO->USHFRCOCAL14;
   7692          
   7693              default: /* cmuUSHFRCOFreq_UserDefined */
   7694                return 0;
   7695            }
   7696          }
   7697          
   7698          /***************************************************************************//**
   7699           * @brief
   7700           *   Get the current USHFRCO frequency.
   7701           *
   7702           * @return
   7703           *   HFRCO frequency.
   7704           ******************************************************************************/
   7705          CMU_USHFRCOFreq_TypeDef CMU_USHFRCOBandGet(void)
   7706          {
   7707            return (CMU_USHFRCOFreq_TypeDef) ushfrcoFreq;
   7708          }
   7709          
   7710          /***************************************************************************//**
   7711           * @brief
   7712           *   Get USHFRCO frequency.
   7713           *
   7714           * @return
   7715           *   USHFRCO frequency.
   7716           ******************************************************************************/
   7717          uint32_t CMU_USHFRCOFreqGet(void)
   7718          {
   7719            return ushfrcoFreq;
   7720          }
   7721          
   7722          /***************************************************************************//**
   7723           * @brief
   7724           *   Set the USHFRCO calibration for the selected target frequency.
   7725           *
   7726           * @param[in] setFreq
   7727           *   USHFRCO frequency to set.
   7728           ******************************************************************************/
   7729          void CMU_USHFRCOBandSet(CMU_USHFRCOFreq_TypeDef setFreq)
   7730          {
   7731            uint32_t freqCal;
   7732          
   7733            /* Get DEVINFO calibration values. */
   7734            freqCal = CMU_USHFRCODevinfoGet(setFreq);
   7735            EFM_ASSERT((freqCal != 0) && (freqCal != UINT_MAX));
   7736            ushfrcoFreq = (uint32_t)setFreq;
   7737          
   7738            /* Wait for any previous sync to complete and set calibration data
   7739               for the selected frequency.  */
   7740            while (BUS_RegBitRead(&CMU->SYNCBUSY, _CMU_SYNCBUSY_USHFRCOBSY_SHIFT)) ;
   7741          
   7742            CMU->USHFRCOCTRL = freqCal;
   7743          }
   7744          #endif /* _CMU_USHFRCOCTRL_FREQRANGE_MASK  */
   7745          
   7746          #if defined(_CMU_HFXOCTRL_AUTOSTARTEM0EM1_MASK)
   7747          /***************************************************************************//**
   7748           * @brief
   7749           *   Enable or disable HFXO autostart.
   7750           *
   7751           * @param[in] userSel
   7752           *   Additional user specified enable bit.
   7753           *
   7754           * @param[in] enEM0EM1Start
   7755           *   If true, HFXO is automatically started upon entering EM0/EM1 entry from
   7756           *   EM2/EM3. HFXO selection has to be handled by the user.
   7757           *   If false, HFXO is not started automatically when entering EM0/EM1.
   7758           *
   7759           * @param[in] enEM0EM1StartSel
   7760           *   If true, HFXO is automatically started and immediately selected upon
   7761           *   entering EM0/EM1 entry from EM2/EM3. Note that this option stalls the use of
   7762           *   HFSRCCLK until HFXO becomes ready. HFCLKLE prescaler is also automatically
   7763           *   modified if userSel is specified.
   7764           *   If false, HFXO is not started or selected automatically when entering
   7765           *   EM0/EM1.
   7766           ******************************************************************************/
   7767          void CMU_HFXOAutostartEnable(uint32_t userSel,
   7768                                       bool enEM0EM1Start,
   7769                                       bool enEM0EM1StartSel)
   7770          {
   7771            uint32_t hfxoFreq;
   7772            uint32_t hfxoCtrl;
   7773          
   7774          #if defined(_EMU_CTRL_EM23VSCALE_MASK)
   7775            if (enEM0EM1StartSel) {
   7776              /* Voltage scaling is not compatible with HFXO auto start and select. */
   7777              EFM_ASSERT((EMU->CTRL & _EMU_CTRL_EM23VSCALE_MASK) == EMU_CTRL_EM23VSCALE_VSCALE2);
   7778            }
   7779          #endif
   7780          
   7781            /* Mask supported enable bits. */
   7782          #if defined(_CMU_HFXOCTRL_AUTOSTARTRDYSELRAC_MASK)
   7783            userSel &= _CMU_HFXOCTRL_AUTOSTARTRDYSELRAC_MASK;
   7784          #else
   7785            userSel = 0;
   7786          #endif
   7787          
   7788            hfxoCtrl = CMU->HFXOCTRL & ~(userSel
   7789                                         | _CMU_HFXOCTRL_AUTOSTARTEM0EM1_MASK
   7790                                         | _CMU_HFXOCTRL_AUTOSTARTSELEM0EM1_MASK);
   7791          
   7792            hfxoCtrl |= userSel
   7793                        | (enEM0EM1Start ? CMU_HFXOCTRL_AUTOSTARTEM0EM1 : 0UL)
   7794                        | (enEM0EM1StartSel ? CMU_HFXOCTRL_AUTOSTARTSELEM0EM1 : 0UL);
   7795          
   7796            hfxoFreq = SystemHFXOClockGet();
   7797          #if defined(_EMU_CMD_EM01VSCALE0_MASK)
   7798            // Update voltage scaling.
   7799            EMU_VScaleEM01ByClock(hfxoFreq, true);
   7800          #endif
   7801            /* Set wait-states for HFXO if automatic start and select is configured. */
   7802            if ((userSel > 0UL) || enEM0EM1StartSel) {
   7803              CMU_UpdateWaitStates(hfxoFreq, (int)VSCALE_DEFAULT);
   7804              setHfLeConfig(hfxoFreq);
   7805            }
   7806          
   7807            if (enEM0EM1Start || enEM0EM1StartSel) {
   7808              /* Enable the HFXO once in order to finish first time calibrations. */
   7809              CMU_OscillatorEnable(cmuOsc_HFXO, true, true);
   7810            }
   7811          
   7812            /* Update HFXOCTRL after wait-states are updated as HF may automatically switch
   7813               to HFXO when automatic select is enabled . */
   7814            CMU->HFXOCTRL = hfxoCtrl;
   7815          }
   7816          #endif
   7817          
   7818          /**************************************************************************//**
   7819           * @brief
   7820           *   Set HFXO control registers.
   7821           *
   7822           * @note
   7823           *   HFXO configuration should be obtained from a configuration tool,
   7824           *   app note, or xtal data sheet. This function disables the HFXO to ensure
   7825           *   a valid state before update.
   7826           *
   7827           * @param[in] hfxoInit
   7828           *    HFXO setup parameters.
   7829           *****************************************************************************/
   7830          void CMU_HFXOInit(const CMU_HFXOInit_TypeDef *hfxoInit)
   7831          {
   7832            /* Do not disable HFXO if it is currently selected as the HF/Core clock. */
   7833            EFM_ASSERT(CMU_ClockSelectGet(cmuClock_HF) != cmuSelect_HFXO);
   7834          
   7835            /* HFXO must be disabled before reconfiguration. */
   7836            CMU_OscillatorEnable(cmuOsc_HFXO, false, true);
   7837          
   7838          #if defined(_SILICON_LABS_32B_SERIES_1) \
   7839            && (_SILICON_LABS_GECKO_INTERNAL_SDID >= 100)
   7840            uint32_t tmp = CMU_HFXOCTRL_MODE_XTAL;
   7841          
   7842            switch (hfxoInit->mode) {
   7843              case cmuOscMode_Crystal:
   7844                tmp = CMU_HFXOCTRL_MODE_XTAL;
   7845                break;
   7846              case cmuOscMode_External:
   7847                tmp = CMU_HFXOCTRL_MODE_DIGEXTCLK;
   7848                break;
   7849              case cmuOscMode_AcCoupled:
   7850                tmp = CMU_HFXOCTRL_MODE_ACBUFEXTCLK;
   7851                break;
   7852              default:
   7853                EFM_ASSERT(false); /* Unsupported configuration */
   7854                break;
   7855            }
   7856            CMU->HFXOCTRL = (CMU->HFXOCTRL & ~_CMU_HFXOCTRL_MODE_MASK) | tmp;
   7857          
   7858          #if defined(CMU_HFXOCTRL_HFXOX2EN)
   7859            /* HFXO Doubler can only be enabled on crystals up to max 25 MHz. */
   7860            tmp = 0;
   7861            if (SystemHFXOClockGet() <= 25000000) {
   7862              tmp |= CMU_HFXOCTRL_HFXOX2EN;
   7863            }
   7864          
   7865            CMU->HFXOCTRL = (CMU->HFXOCTRL & ~_CMU_HFXOCTRL_HFXOX2EN_MASK) | tmp;
   7866          #endif
   7867          
   7868            /* Set tuning for startup and steady state. */
   7869            CMU->HFXOSTARTUPCTRL = (hfxoInit->ctuneStartup
   7870                                    << _CMU_HFXOSTARTUPCTRL_CTUNE_SHIFT)
   7871                                   | (hfxoInit->xoCoreBiasTrimStartup
   7872                                      << _CMU_HFXOSTARTUPCTRL_IBTRIMXOCORE_SHIFT);
   7873          
   7874            CMU->HFXOSTEADYSTATECTRL = (CMU->HFXOSTEADYSTATECTRL
   7875                                        & ~(_CMU_HFXOSTEADYSTATECTRL_CTUNE_MASK
   7876                                            | _CMU_HFXOSTEADYSTATECTRL_IBTRIMXOCORE_MASK))
   7877                                       | (hfxoInit->ctuneSteadyState
   7878                                          << _CMU_HFXOSTEADYSTATECTRL_CTUNE_SHIFT)
   7879                                       | (hfxoInit->xoCoreBiasTrimSteadyState
   7880                                          << _CMU_HFXOSTEADYSTATECTRL_IBTRIMXOCORE_SHIFT);
   7881          
   7882            /* Set timeouts */
   7883            CMU->HFXOTIMEOUTCTRL = (hfxoInit->timeoutPeakDetect
   7884                                    << _CMU_HFXOTIMEOUTCTRL_PEAKDETTIMEOUT_SHIFT)
   7885                                   | (hfxoInit->timeoutSteady
   7886                                      << _CMU_HFXOTIMEOUTCTRL_STEADYTIMEOUT_SHIFT)
   7887                                   | (hfxoInit->timeoutStartup
   7888                                      << _CMU_HFXOTIMEOUTCTRL_STARTUPTIMEOUT_SHIFT);
   7889          
   7890          #elif defined(_CMU_HFXOCTRL_MASK)
   7891            /* Verify that the deprecated autostart fields are not used,
   7892             * @ref CMU_HFXOAutostartEnable must be used instead. */
   7893            EFM_ASSERT(!(hfxoInit->autoStartEm01
   7894                         || hfxoInit->autoSelEm01
   7895                         || hfxoInit->autoStartSelOnRacWakeup));
   7896          
   7897            uint32_t tmp = CMU_HFXOCTRL_MODE_XTAL;
   7898          
   7899            /* AC coupled external clock not supported. */
   7900            EFM_ASSERT(hfxoInit->mode != cmuOscMode_AcCoupled);
   7901            if (hfxoInit->mode == cmuOscMode_External) {
   7902              tmp = CMU_HFXOCTRL_MODE_DIGEXTCLK;
   7903            }
   7904          
   7905            /* Apply control settings. */
   7906            CMU->HFXOCTRL = (CMU->HFXOCTRL & ~_CMU_HFXOCTRL_MODE_MASK)
   7907                            | tmp;
   7908            BUS_RegBitWrite(&CMU->HFXOCTRL,
   7909                            _CMU_HFXOCTRL_LOWPOWER_SHIFT,
   7910                            (unsigned)hfxoInit->lowPowerMode);
   7911          
   7912            /* Set XTAL tuning parameters. */
   7913          
   7914          #if defined(_CMU_HFXOCTRL1_PEAKDETTHR_MASK)
   7915            /* Set peak detection threshold. */
   7916            CMU->HFXOCTRL1 = (CMU->HFXOCTRL1 & ~_CMU_HFXOCTRL1_PEAKDETTHR_MASK)
   7917                             | (hfxoInit->thresholdPeakDetect
   7918                                << _CMU_HFXOCTRL1_PEAKDETTHR_SHIFT);
   7919          #endif
   7920            /* Set tuning for startup and steady state. */
   7921            CMU->HFXOSTARTUPCTRL = ((uint32_t)hfxoInit->ctuneStartup
   7922                                    << _CMU_HFXOSTARTUPCTRL_CTUNE_SHIFT)
   7923                                   | ((uint32_t)hfxoInit->xoCoreBiasTrimStartup
   7924                                      << _CMU_HFXOSTARTUPCTRL_IBTRIMXOCORE_SHIFT);
   7925          
   7926            CMU->HFXOSTEADYSTATECTRL = (CMU->HFXOSTEADYSTATECTRL
   7927                                        & ~(_CMU_HFXOSTEADYSTATECTRL_CTUNE_MASK
   7928                                            | _CMU_HFXOSTEADYSTATECTRL_IBTRIMXOCORE_MASK
   7929                                            | _CMU_HFXOSTEADYSTATECTRL_REGISH_MASK
   7930                                            | _CMU_HFXOSTEADYSTATECTRL_REGISHUPPER_MASK))
   7931                                       | ((uint32_t)hfxoInit->ctuneSteadyState
   7932                                          << _CMU_HFXOSTEADYSTATECTRL_CTUNE_SHIFT)
   7933                                       | ((uint32_t)hfxoInit->xoCoreBiasTrimSteadyState
   7934                                          << _CMU_HFXOSTEADYSTATECTRL_IBTRIMXOCORE_SHIFT)
   7935                                       | ((uint32_t)hfxoInit->regIshSteadyState
   7936                                          << _CMU_HFXOSTEADYSTATECTRL_REGISH_SHIFT)
   7937                                       | getRegIshUpperVal(hfxoInit->regIshSteadyState);
   7938          
   7939            /* Set timeouts. */
   7940            CMU->HFXOTIMEOUTCTRL = ((uint32_t)hfxoInit->timeoutPeakDetect
   7941                                    << _CMU_HFXOTIMEOUTCTRL_PEAKDETTIMEOUT_SHIFT)
   7942                                   | ((uint32_t)hfxoInit->timeoutSteady
   7943                                      << _CMU_HFXOTIMEOUTCTRL_STEADYTIMEOUT_SHIFT)
   7944                                   | ((uint32_t)hfxoInit->timeoutStartup
   7945                                      << _CMU_HFXOTIMEOUTCTRL_STARTUPTIMEOUT_SHIFT)
   7946                                   | ((uint32_t)hfxoInit->timeoutShuntOptimization
   7947                                      << _CMU_HFXOTIMEOUTCTRL_SHUNTOPTTIMEOUT_SHIFT);
   7948          
   7949          #else
   7950            CMU->CTRL = (CMU->CTRL & ~(_CMU_CTRL_HFXOTIMEOUT_MASK
   7951                                       | _CMU_CTRL_HFXOBOOST_MASK
   7952                                       | _CMU_CTRL_HFXOMODE_MASK
   7953                                       | _CMU_CTRL_HFXOGLITCHDETEN_MASK))
   7954                        | (hfxoInit->timeout << _CMU_CTRL_HFXOTIMEOUT_SHIFT)
   7955                        | (hfxoInit->boost << _CMU_CTRL_HFXOBOOST_SHIFT)
   7956                        | (hfxoInit->mode << _CMU_CTRL_HFXOMODE_SHIFT)
   7957                        | (hfxoInit->glitchDetector ? CMU_CTRL_HFXOGLITCHDETEN : 0);
   7958          #endif
   7959          }
   7960          
   7961          /***************************************************************************//**
   7962           * @brief
   7963           *   Get the LCD framerate divisor (FDIV) setting.
   7964           *
   7965           * @return
   7966           *   The LCD framerate divisor.
   7967           ******************************************************************************/
   7968          uint32_t CMU_LCDClkFDIVGet(void)
   7969          {
   7970          #if defined(LCD_PRESENT) && defined(_CMU_LCDCTRL_MASK)
   7971            return (CMU->LCDCTRL & _CMU_LCDCTRL_FDIV_MASK) >> _CMU_LCDCTRL_FDIV_SHIFT;
   7972          #else
   7973            return 0;
   7974          #endif /* defined(LCD_PRESENT) */
   7975          }
   7976          
   7977          /***************************************************************************//**
   7978           * @brief
   7979           *   Set the LCD framerate divisor (FDIV) setting.
   7980           *
   7981           * @note
   7982           *   The FDIV field (CMU LCDCTRL register) should only be modified while the
   7983           *   LCD module is clock disabled (CMU LFACLKEN0.LCD bit is 0). This function
   7984           *   will NOT modify FDIV if the LCD module clock is enabled. See
   7985           *   @ref CMU_ClockEnable() for disabling/enabling LCD clock.
   7986           *
   7987           * @param[in] div
   7988           *   The FDIV setting to use.
   7989           ******************************************************************************/
   7990          void CMU_LCDClkFDIVSet(uint32_t div)
   7991          {
   7992          #if defined(LCD_PRESENT) && defined(_CMU_LCDCTRL_MASK)
   7993            EFM_ASSERT(div <= cmuClkDiv_128);
   7994          
   7995            /* Do not allow modification if LCD clock enabled. */
   7996            if (CMU->LFACLKEN0 & CMU_LFACLKEN0_LCD) {
   7997              return;
   7998            }
   7999          
   8000            div        <<= _CMU_LCDCTRL_FDIV_SHIFT;
   8001            div         &= _CMU_LCDCTRL_FDIV_MASK;
   8002            CMU->LCDCTRL = (CMU->LCDCTRL & ~_CMU_LCDCTRL_FDIV_MASK) | div;
   8003          #else
   8004            (void)div;  /* Unused parameter. */
   8005          #endif /* defined(LCD_PRESENT) */
   8006          }
   8007          
   8008          /**************************************************************************//**
   8009           * @brief
   8010           *   Set LFXO control registers.
   8011           *
   8012           * @note
   8013           *   LFXO configuration should be obtained from a configuration tool,
   8014           *   app note, or xtal data sheet. This function disables the LFXO when
   8015           *   necessary to ensure a valid state before update.
   8016           *
   8017           * @param[in] lfxoInit
   8018           *    LFXO setup parameters.
   8019           *****************************************************************************/
   8020          void CMU_LFXOInit(const CMU_LFXOInit_TypeDef *lfxoInit)
   8021          {
   8022            /* Do not disable LFXO if it is currently selected as the HF/Core clock. */
   8023            EFM_ASSERT(CMU_ClockSelectGet(cmuClock_HF) != cmuSelect_LFXO);
   8024          
   8025          #if defined(_SILICON_LABS_32B_SERIES_1)
   8026            uint32_t reg = (CMU->LFXOCTRL & ~(_CMU_LFXOCTRL_TUNING_MASK
   8027                                              | _CMU_LFXOCTRL_GAIN_MASK
   8028                                              | _CMU_LFXOCTRL_TIMEOUT_MASK
   8029                                              | _CMU_LFXOCTRL_MODE_MASK))
   8030                           | ((uint32_t)lfxoInit->ctune << _CMU_LFXOCTRL_TUNING_SHIFT)
   8031                           | ((uint32_t)lfxoInit->gain << _CMU_LFXOCTRL_GAIN_SHIFT)
   8032                           | ((uint32_t)lfxoInit->timeout << _CMU_LFXOCTRL_TIMEOUT_SHIFT)
   8033                           | ((uint32_t)lfxoInit->mode << _CMU_LFXOCTRL_MODE_SHIFT);
   8034          
   8035            /* If LFXO already contains the correct configuration then there is no need
   8036             * to stop the oscillator and apply new settings. The LFXO can be running out
   8037             * of reset, in which case we don't want to disable it unless necessary. */
   8038            if (reg != CMU->LFXOCTRL) {
   8039              CMU_OscillatorEnable(cmuOsc_LFXO, false, true);
   8040              CMU->LFXOCTRL = reg;
   8041            }
   8042          #elif defined(_SILICON_LABS_32B_SERIES_0)
   8043            /* LFXO must be disabled before reconfiguration. */
   8044            CMU_OscillatorEnable(cmuOsc_LFXO, false, true);
   8045          
   8046            bool cmuBoost  = (lfxoInit->boost & 0x2);
   8047            BUS_RegMaskedWrite(&CMU->CTRL,
   8048                               _CMU_CTRL_LFXOTIMEOUT_MASK
   8049                               | _CMU_CTRL_LFXOBOOST_MASK
   8050                               | _CMU_CTRL_LFXOMODE_MASK,
   8051                               ((uint32_t)lfxoInit->timeout
   8052                                << _CMU_CTRL_LFXOTIMEOUT_SHIFT)
   8053                               | ((cmuBoost ? 1 : 0) << _CMU_CTRL_LFXOBOOST_SHIFT)
   8054                               | ((uint32_t)lfxoInit->mode << _CMU_CTRL_LFXOMODE_SHIFT));
   8055          #if defined(_EMU_AUXCTRL_REDLFXOBOOST_MASK)
   8056            /* EFM32GG has a "reduce startup boost" field in the EMU */
   8057            bool emuReduce = (lfxoInit->boost & 0x1);
   8058            BUS_RegBitWrite(&EMU->AUXCTRL, _EMU_AUXCTRL_REDLFXOBOOST_SHIFT, emuReduce ? 1 : 0);
   8059          #endif
   8060          #endif
   8061          }
   8062          
   8063          /***************************************************************************//**
   8064           * @brief
   8065           *   Enable/disable oscillator.
   8066           *
   8067           * @note
   8068           *   WARNING: When this function is called to disable either cmuOsc_LFXO or
   8069           *   cmuOsc_HFXO, the LFXOMODE or HFXOMODE fields of the CMU_CTRL register
   8070           *   are reset to the reset value. In other words, if external clock sources are selected
   8071           *   in either LFXOMODE or HFXOMODE fields, the configuration will be cleared
   8072           *   and needs to be reconfigured if needed later.
   8073           *
   8074           * @param[in] osc
   8075           *   The oscillator to enable/disable.
   8076           *
   8077           * @param[in] enable
   8078           *   @li true - enable specified oscillator.
   8079           *   @li false - disable specified oscillator.
   8080           *
   8081           * @param[in] wait
   8082           *   Only used if @p enable is true.
   8083           *   @li true - wait for oscillator start-up time to timeout before returning.
   8084           *   @li false - do not wait for oscillator start-up time to timeout before
   8085           *     returning.
   8086           ******************************************************************************/
   8087          void CMU_OscillatorEnable(CMU_Osc_TypeDef osc, bool enable, bool wait)
   8088          {
   8089            uint32_t rdyBitPos;
   8090          #if defined(_SILICON_LABS_32B_SERIES_1)
   8091            uint32_t ensBitPos;
   8092          #endif
   8093          #if defined(_CMU_STATUS_HFXOPEAKDETRDY_MASK)
   8094            uint32_t hfxoTrimStatus;
   8095          #endif
   8096          
   8097            uint32_t enBit;
   8098            uint32_t disBit;
   8099          
   8100            switch (osc) {
   8101              case cmuOsc_HFRCO:
   8102                enBit  = CMU_OSCENCMD_HFRCOEN;
   8103                disBit = CMU_OSCENCMD_HFRCODIS;
   8104                rdyBitPos = _CMU_STATUS_HFRCORDY_SHIFT;
   8105          #if defined(_SILICON_LABS_32B_SERIES_1)
   8106                ensBitPos = _CMU_STATUS_HFRCOENS_SHIFT;
   8107          #endif
   8108                break;
   8109          
   8110              case cmuOsc_HFXO:
   8111                enBit  = CMU_OSCENCMD_HFXOEN;
   8112                disBit = CMU_OSCENCMD_HFXODIS;
   8113                rdyBitPos = _CMU_STATUS_HFXORDY_SHIFT;
   8114          #if defined(_SILICON_LABS_32B_SERIES_1)
   8115                ensBitPos = _CMU_STATUS_HFXOENS_SHIFT;
   8116          #endif
   8117                break;
   8118          
   8119              case cmuOsc_AUXHFRCO:
   8120                enBit  = CMU_OSCENCMD_AUXHFRCOEN;
   8121                disBit = CMU_OSCENCMD_AUXHFRCODIS;
   8122                rdyBitPos = _CMU_STATUS_AUXHFRCORDY_SHIFT;
   8123          #if defined(_SILICON_LABS_32B_SERIES_1)
   8124                ensBitPos = _CMU_STATUS_AUXHFRCOENS_SHIFT;
   8125          #endif
   8126                break;
   8127          
   8128              case cmuOsc_LFRCO:
   8129                enBit  = CMU_OSCENCMD_LFRCOEN;
   8130                disBit = CMU_OSCENCMD_LFRCODIS;
   8131                rdyBitPos = _CMU_STATUS_LFRCORDY_SHIFT;
   8132          #if defined(_SILICON_LABS_32B_SERIES_1)
   8133                ensBitPos = _CMU_STATUS_LFRCOENS_SHIFT;
   8134          #endif
   8135                break;
   8136          
   8137              case cmuOsc_LFXO:
   8138                enBit  = CMU_OSCENCMD_LFXOEN;
   8139                disBit = CMU_OSCENCMD_LFXODIS;
   8140                rdyBitPos = _CMU_STATUS_LFXORDY_SHIFT;
   8141          #if defined(_SILICON_LABS_32B_SERIES_1)
   8142                ensBitPos = _CMU_STATUS_LFXOENS_SHIFT;
   8143          #endif
   8144                break;
   8145          
   8146          #if defined(_CMU_STATUS_USHFRCOENS_MASK)
   8147              case cmuOsc_USHFRCO:
   8148                enBit  = CMU_OSCENCMD_USHFRCOEN;
   8149                disBit = CMU_OSCENCMD_USHFRCODIS;
   8150                rdyBitPos = _CMU_STATUS_USHFRCORDY_SHIFT;
   8151          #if defined(_SILICON_LABS_32B_SERIES_1)
   8152                ensBitPos = _CMU_STATUS_USHFRCOENS_SHIFT;
   8153          #endif
   8154                break;
   8155          #endif
   8156          
   8157          #if defined(PLFRCO_PRESENT)
   8158              case cmuOsc_PLFRCO:
   8159                if (!deviceHasPlfrco()) {
   8160                  while (true) { // PLFRCO is not available
   8161                    EFM_ASSERT(false);
   8162                  }
   8163                }
   8164                enBit = CMU_OSCENCMD_PLFRCOEN;
   8165                disBit = CMU_OSCENCMD_PLFRCODIS;
   8166                rdyBitPos = _CMU_STATUS_PLFRCORDY_SHIFT;
   8167                ensBitPos = _CMU_STATUS_PLFRCOENS_SHIFT;
   8168                break;
   8169          #endif
   8170          
   8171              default:
   8172                /* Undefined clock source, cmuOsc_CLKIN0 or cmuOsc_ULFRCO. ULFRCO is always enabled
   8173                   and cannot be disabled. In other words,the definition of cmuOsc_ULFRCO is primarily
   8174                   intended for information: the ULFRCO is always on.  */
   8175                EFM_ASSERT(false);
   8176                return;
   8177            }
   8178          
   8179            if (enable) {
   8180           #if defined(_CMU_HFXOCTRL_MASK)
   8181              bool firstHfxoEnable = false;
   8182          
   8183              /* Enabling the HFXO for the first time requires special handling.
   8184               * PEAKDETSHUTOPTMODE field of the HFXOCTRL register is used to see if this is the
   8185               * first time the HFXO is enabled. */
   8186              if (osc == cmuOsc_HFXO) {
   8187                if (getHfxoTuningMode() == HFXO_TUNING_MODE_AUTO) {
   8188                  /* REGPWRSEL must be set to DVDD before the HFXO can be enabled. */
   8189          #if defined(_EMU_PWRCTRL_REGPWRSEL_MASK)
   8190                  EFM_ASSERT((EMU->PWRCTRL & EMU_PWRCTRL_REGPWRSEL_DVDD) != 0UL);
   8191          #endif
   8192          
   8193                  firstHfxoEnable = true;
   8194                  /* The first time that an external clock is enabled, switch to CMD mode to make sure that
   8195                   * only SCO and not PDA tuning is performed. */
   8196                  if ((CMU->HFXOCTRL & (_CMU_HFXOCTRL_MODE_MASK)) == CMU_HFXOCTRL_MODE_DIGEXTCLK) {
   8197                    setHfxoTuningMode(HFXO_TUNING_MODE_CMD);
   8198                  }
   8199                }
   8200              }
   8201          #endif
   8202              CMU->OSCENCMD = enBit;
   8203          
   8204          #if defined(_SILICON_LABS_32B_SERIES_1)
   8205              /* Always wait for ENS to go high. */
   8206              while (BUS_RegBitRead(&CMU->STATUS, ensBitPos) == 0UL) {
   8207              }
   8208          #endif
   8209          
   8210              /* Wait for the clock to become ready after enable. */
   8211              if (wait) {
   8212                while (BUS_RegBitRead(&CMU->STATUS, rdyBitPos) == 0UL) {
   8213                }
   8214          #if defined(_SILICON_LABS_32B_SERIES_1)
   8215                if ((osc == cmuOsc_HFXO) && firstHfxoEnable) {
   8216                  if ((CMU->HFXOCTRL & _CMU_HFXOCTRL_MODE_MASK)
   8217                      == CMU_HFXOCTRL_MODE_DIGEXTCLK) {
   8218          #if defined(CMU_CMD_HFXOSHUNTOPTSTART)
   8219                    /* External clock mode should only do shunt current optimization. */
   8220                    (void)CMU_OscillatorTuningOptimize(cmuOsc_HFXO,
   8221                                                       cmuHFXOTuningMode_ShuntCommand,
   8222                                                       true);
   8223          #endif
   8224                  } else {
   8225                    /* Wait for the peak detection and shunt current optimization
   8226                       to complete. */
   8227                    (void)CMU_OscillatorTuningWait(cmuOsc_HFXO, cmuHFXOTuningMode_Auto);
   8228                  }
   8229          
   8230                  /* Disable the HFXO again to apply the trims. Apply trim from
   8231                     HFXOTRIMSTATUS when disabled. */
   8232                  hfxoTrimStatus = CMU_OscillatorTuningGet(cmuOsc_HFXO);
   8233                  CMU_OscillatorEnable(cmuOsc_HFXO, false, true);
   8234                  CMU_OscillatorTuningSet(cmuOsc_HFXO, hfxoTrimStatus);
   8235          
   8236                  /* Restart in CMD mode. */
   8237                  CMU->OSCENCMD = enBit;
   8238                  while (BUS_RegBitRead(&CMU->STATUS, rdyBitPos) == 0UL) {
   8239                  }
   8240                }
   8241          #endif
   8242              }
   8243            } else {
   8244              CMU->OSCENCMD = disBit;
   8245          
   8246          #if defined(_SILICON_LABS_32B_SERIES_1)
   8247              /* Always wait for ENS to go low. */
   8248              while ((CMU->STATUS & (0x1 << ensBitPos)) != 0U) {
   8249              }
   8250          
   8251              if (wait) {
   8252                /* Wait for RDY to go low as well. */
   8253                while ((CMU->STATUS & (0x1 << rdyBitPos)) != 0U) {
   8254                }
   8255              }
   8256          #endif
   8257            }
   8258          }
   8259          
   8260          /***************************************************************************//**
   8261           * @brief
   8262           *   Get the oscillator frequency tuning setting.
   8263           *
   8264           * @param[in] osc
   8265           *   An oscillator to get tuning value for, one of the following:
   8266           *   @li #cmuOsc_LFRCO
   8267           *   @li #cmuOsc_HFRCO @if _CMU_USHFRCOCTRL_TUNING_MASK
   8268           *   @li #cmuOsc_USHFRCO
   8269           *   @endif
   8270           *   @li #cmuOsc_AUXHFRCO
   8271           *   @li #cmuOsc_HFXO if CMU_HFXOCTRL_PEAKDETSHUNTOPTMODE is defined
   8272           *
   8273           * @return
   8274           *   The oscillator frequency tuning setting in use.
   8275           ******************************************************************************/
   8276          uint32_t CMU_OscillatorTuningGet(CMU_Osc_TypeDef osc)
   8277          {
   8278            uint32_t ret;
   8279          
   8280            switch (osc) {
   8281              case cmuOsc_LFRCO:
   8282                ret = (CMU->LFRCOCTRL & _CMU_LFRCOCTRL_TUNING_MASK)
   8283                      >> _CMU_LFRCOCTRL_TUNING_SHIFT;
   8284                break;
   8285          
   8286              case cmuOsc_HFRCO:
   8287                ret = (CMU->HFRCOCTRL & _CMU_HFRCOCTRL_TUNING_MASK)
   8288                      >> _CMU_HFRCOCTRL_TUNING_SHIFT;
   8289                break;
   8290          
   8291          #if defined (_CMU_USHFRCOCTRL_TUNING_MASK)
   8292              case cmuOsc_USHFRCO:
   8293                ret = (CMU->USHFRCOCTRL & _CMU_USHFRCOCTRL_TUNING_MASK)
   8294                      >> _CMU_USHFRCOCTRL_TUNING_SHIFT;
   8295                break;
   8296          #endif
   8297          
   8298              case cmuOsc_AUXHFRCO:
   8299                ret = (CMU->AUXHFRCOCTRL & _CMU_AUXHFRCOCTRL_TUNING_MASK)
   8300                      >> _CMU_AUXHFRCOCTRL_TUNING_SHIFT;
   8301                break;
   8302          
   8303          #if defined(_CMU_HFXOCTRL_PEAKDETSHUNTOPTMODE_MASK)
   8304              case cmuOsc_HFXO:
   8305                ret = CMU->HFXOTRIMSTATUS & (_CMU_HFXOTRIMSTATUS_IBTRIMXOCORE_MASK
   8306          #if defined(_CMU_HFXOTRIMSTATUS_REGISH_MASK)
   8307                                             | _CMU_HFXOTRIMSTATUS_REGISH_MASK
   8308          #endif
   8309                                             );
   8310                break;
   8311          #endif
   8312          
   8313              default:
   8314                ret = 0;
   8315                EFM_ASSERT(false);
   8316                break;
   8317            }
   8318          
   8319            return ret;
   8320          }
   8321          
   8322          /***************************************************************************//**
   8323           * @brief
   8324           *   Set the oscillator frequency tuning control.
   8325           *
   8326           * @note
   8327           *   Oscillator tuning is done during production and the tuning value is
   8328           *   automatically loaded after reset. Changing the tuning value from the
   8329           *   calibrated value is for more advanced use. Certain oscillators also have
   8330           *   build-in tuning optimization.
   8331           *
   8332           * @param[in] osc
   8333           *   An oscillator to set tuning value for, one of the following:
   8334           *   @li #cmuOsc_LFRCO
   8335           *   @li #cmuOsc_HFRCO @if _CMU_USHFRCOCTRL_TUNING_MASK
   8336           *   @li #cmuOsc_USHFRCO
   8337           *   @endif
   8338           *   @li #cmuOsc_AUXHFRCO
   8339           *   @li #cmuOsc_HFXO if PEAKDETSHUNTOPTMODE is available. Note that CMD mode is set.
   8340           *
   8341           * @param[in] val
   8342           *   The oscillator frequency tuning setting to use.
   8343           ******************************************************************************/
   8344          void CMU_OscillatorTuningSet(CMU_Osc_TypeDef osc, uint32_t val)
   8345          {
   8346          #if defined(_CMU_HFXOSTEADYSTATECTRL_REGISH_MASK)
   8347            uint32_t regIshUpper;
   8348          #endif
   8349          
   8350            switch (osc) {
   8351              case cmuOsc_LFRCO:
   8352                EFM_ASSERT(val <= (_CMU_LFRCOCTRL_TUNING_MASK
   8353                                   >> _CMU_LFRCOCTRL_TUNING_SHIFT));
   8354                val &= (_CMU_LFRCOCTRL_TUNING_MASK >> _CMU_LFRCOCTRL_TUNING_SHIFT);
   8355          #if defined(_SILICON_LABS_32B_SERIES_1)
   8356                while (BUS_RegBitRead(&CMU->SYNCBUSY,
   8357                                      _CMU_SYNCBUSY_LFRCOBSY_SHIFT) != 0UL) {
   8358                }
   8359          #endif
   8360                CMU->LFRCOCTRL = (CMU->LFRCOCTRL & ~(_CMU_LFRCOCTRL_TUNING_MASK))
   8361                                 | (val << _CMU_LFRCOCTRL_TUNING_SHIFT);
   8362                break;
   8363          
   8364              case cmuOsc_HFRCO:
   8365                EFM_ASSERT(val <= (_CMU_HFRCOCTRL_TUNING_MASK
   8366                                   >> _CMU_HFRCOCTRL_TUNING_SHIFT));
   8367                val &= (_CMU_HFRCOCTRL_TUNING_MASK >> _CMU_HFRCOCTRL_TUNING_SHIFT);
   8368          #if defined(_SILICON_LABS_32B_SERIES_1)
   8369                while (BUS_RegBitRead(&CMU->SYNCBUSY,
   8370                                      _CMU_SYNCBUSY_HFRCOBSY_SHIFT) != 0UL) {
   8371                }
   8372          #endif
   8373                CMU->HFRCOCTRL = (CMU->HFRCOCTRL & ~(_CMU_HFRCOCTRL_TUNING_MASK))
   8374                                 | (val << _CMU_HFRCOCTRL_TUNING_SHIFT);
   8375                break;
   8376          
   8377          #if defined (_CMU_USHFRCOCTRL_TUNING_MASK)
   8378              case cmuOsc_USHFRCO:
   8379                EFM_ASSERT(val <= (_CMU_USHFRCOCTRL_TUNING_MASK
   8380                                   >> _CMU_USHFRCOCTRL_TUNING_SHIFT));
   8381                val &= (_CMU_USHFRCOCTRL_TUNING_MASK >> _CMU_USHFRCOCTRL_TUNING_SHIFT);
   8382          #if defined(_SILICON_LABS_32B_SERIES_1)
   8383                while (BUS_RegBitRead(&CMU->SYNCBUSY, _CMU_SYNCBUSY_USHFRCOBSY_SHIFT)) {
   8384                }
   8385          #endif
   8386                CMU->USHFRCOCTRL = (CMU->USHFRCOCTRL & ~(_CMU_USHFRCOCTRL_TUNING_MASK))
   8387                                   | (val << _CMU_USHFRCOCTRL_TUNING_SHIFT);
   8388                break;
   8389          #endif
   8390          
   8391              case cmuOsc_AUXHFRCO:
   8392                EFM_ASSERT(val <= (_CMU_AUXHFRCOCTRL_TUNING_MASK
   8393                                   >> _CMU_AUXHFRCOCTRL_TUNING_SHIFT));
   8394                val &= (_CMU_AUXHFRCOCTRL_TUNING_MASK >> _CMU_AUXHFRCOCTRL_TUNING_SHIFT);
   8395          #if defined(_SILICON_LABS_32B_SERIES_1)
   8396                while (BUS_RegBitRead(&CMU->SYNCBUSY,
   8397                                      _CMU_SYNCBUSY_AUXHFRCOBSY_SHIFT) != 0UL) {
   8398                }
   8399          #endif
   8400                CMU->AUXHFRCOCTRL = (CMU->AUXHFRCOCTRL & ~(_CMU_AUXHFRCOCTRL_TUNING_MASK))
   8401                                    | (val << _CMU_AUXHFRCOCTRL_TUNING_SHIFT);
   8402                break;
   8403          
   8404          #if defined(_CMU_HFXOCTRL_PEAKDETSHUNTOPTMODE_MASK)
   8405              case cmuOsc_HFXO:
   8406          
   8407                /* Do set PEAKDETSHUNTOPTMODE or HFXOSTEADYSTATECTRL if HFXO is enabled. */
   8408                EFM_ASSERT((CMU->STATUS & CMU_STATUS_HFXOENS) == 0UL);
   8409          
   8410                /* Switch to command mode. Automatic SCO and PDA calibration is not done
   8411                   at the next enable. Set user REGISH, REGISHUPPER, and IBTRIMXOCORE. */
   8412                CMU->HFXOCTRL = (CMU->HFXOCTRL & ~_CMU_HFXOCTRL_PEAKDETSHUNTOPTMODE_MASK)
   8413                                | CMU_HFXOCTRL_PEAKDETSHUNTOPTMODE_CMD;
   8414          
   8415          #if defined(_CMU_HFXOSTEADYSTATECTRL_REGISH_MASK)
   8416                regIshUpper = getRegIshUpperVal((val & _CMU_HFXOSTEADYSTATECTRL_REGISH_MASK)
   8417                                                >> _CMU_HFXOSTEADYSTATECTRL_REGISH_SHIFT);
   8418                CMU->HFXOSTEADYSTATECTRL = (CMU->HFXOSTEADYSTATECTRL
   8419                                            & ~(_CMU_HFXOSTEADYSTATECTRL_IBTRIMXOCORE_MASK
   8420                                                | _CMU_HFXOSTEADYSTATECTRL_REGISH_MASK
   8421                                                | _CMU_HFXOSTEADYSTATECTRL_REGISHUPPER_MASK))
   8422                                           | val
   8423                                           | regIshUpper;
   8424          #else
   8425                CMU->HFXOSTEADYSTATECTRL = (CMU->HFXOSTEADYSTATECTRL
   8426                                            & ~_CMU_HFXOSTEADYSTATECTRL_IBTRIMXOCORE_MASK)
   8427                                           | val;
   8428          #endif
   8429          
   8430                break;
   8431          #endif
   8432          
   8433              default:
   8434                EFM_ASSERT(false);
   8435                break;
   8436            }
   8437          }
   8438          
   8439          #if defined(_CMU_HFXOCTRL_PEAKDETSHUNTOPTMODE_MASK) || defined(_CMU_HFXOCTRL_PEAKDETMODE_MASK)
   8440          /***************************************************************************//**
   8441           * @brief
   8442           *   Wait for the oscillator tuning optimization.
   8443           *
   8444           * @param[in] osc
   8445           *   An oscillator to set tuning value for, one of the following:
   8446           *   @li #cmuOsc_HFXO
   8447           *
   8448           * @param[in] mode
   8449           *   Tuning optimization mode.
   8450           *
   8451           * @return
   8452           *   Returns false on invalid parameters or oscillator error status.
   8453           ******************************************************************************/
   8454          bool CMU_OscillatorTuningWait(CMU_Osc_TypeDef osc,
   8455                                        CMU_HFXOTuningMode_TypeDef mode)
   8456          {
   8457            uint32_t waitFlags;
   8458            EFM_ASSERT(osc == cmuOsc_HFXO);
   8459          
   8460            /* Currently implemented for HFXO with PEAKDETSHUNTOPTMODE only. */
   8461            (void)osc;
   8462          
   8463            if (getHfxoTuningMode() == HFXO_TUNING_MODE_AUTO) {
   8464              waitFlags = HFXO_TUNING_READY_FLAGS;
   8465            } else {
   8466              /* Set wait flags for each command and wait. */
   8467              switch (mode) {
   8468          #if defined(_CMU_STATUS_HFXOSHUNTOPTRDY_MASK)
   8469                case cmuHFXOTuningMode_ShuntCommand:
   8470                  waitFlags = CMU_STATUS_HFXOSHUNTOPTRDY;
   8471                  break;
   8472          #endif
   8473                case cmuHFXOTuningMode_Auto:
   8474                  waitFlags = HFXO_TUNING_READY_FLAGS;
   8475                  break;
   8476          
   8477          #if defined(CMU_CMD_HFXOSHUNTOPTSTART)
   8478                case cmuHFXOTuningMode_PeakShuntCommand:
   8479                  waitFlags = HFXO_TUNING_READY_FLAGS;
   8480                  break;
   8481          #endif
   8482          
   8483                default:
   8484                  waitFlags = _CMU_STATUS_MASK;
   8485                  EFM_ASSERT(false);
   8486                  break;
   8487              }
   8488            }
   8489            while ((CMU->STATUS & waitFlags) != waitFlags) {
   8490            }
   8491          
   8492          #if defined(CMU_IF_HFXOPEAKDETERR)
   8493            /* Check error flags. */
   8494            if ((waitFlags & CMU_STATUS_HFXOPEAKDETRDY) != 0UL) {
   8495              return (CMU->IF & CMU_IF_HFXOPEAKDETERR) != 0UL ? true : false;
   8496            }
   8497          #endif
   8498            return true;
   8499          }
   8500          
   8501          /***************************************************************************//**
   8502           * @brief
   8503           *   Start and optionally wait for the oscillator tuning optimization.
   8504           *
   8505           * @param[in] osc
   8506           *   An oscillator to set tuning value for, one of the following:
   8507           *   @li #cmuOsc_HFXO
   8508           *
   8509           * @param[in] mode
   8510           *   Tuning optimization mode.
   8511           *
   8512           * @param[in] wait
   8513           *   Wait for tuning optimization to complete.
   8514           *   true - wait for tuning optimization to complete.
   8515           *   false - return without waiting.
   8516           *
   8517           * @return
   8518           *   Returns false on invalid parameters or oscillator error status.
   8519           ******************************************************************************/
   8520          bool CMU_OscillatorTuningOptimize(CMU_Osc_TypeDef osc,
   8521                                            CMU_HFXOTuningMode_TypeDef mode,
   8522                                            bool wait)
   8523          {
   8524            switch (osc) {
   8525              case cmuOsc_HFXO:
   8526                if ((unsigned)mode != 0U) {
   8527          #if defined(CMU_IF_HFXOPEAKDETERR)
   8528                  /* Clear the error flag before command write. */
   8529                  CMU->IFC = CMU_IFC_HFXOPEAKDETERR;
   8530          #endif
   8531                  CMU->CMD = (uint32_t)mode;
   8532                }
   8533                if (wait) {
   8534                  return CMU_OscillatorTuningWait(osc, mode);
   8535                }
   8536                break;
   8537          
   8538              default:
   8539                EFM_ASSERT(false);
   8540                break;
   8541            }
   8542            return true;
   8543          }
   8544          #endif
   8545          
   8546          /**************************************************************************//**
   8547           * @brief
   8548           *   Determine if the currently selected PCNTn clock used is external or LFBCLK.
   8549           *
   8550           * @param[in] instance
   8551           *   PCNT instance number to get currently selected clock source for.
   8552           *
   8553           * @return
   8554           *   @li true - selected clock is external clock.
   8555           *   @li false - selected clock is LFBCLK.
   8556           *****************************************************************************/
   8557          bool CMU_PCNTClockExternalGet(unsigned int instance)
   8558          {
   8559            uint32_t setting;
   8560          
   8561            switch (instance) {
   8562          #if defined(_CMU_PCNTCTRL_PCNT0CLKEN_MASK)
   8563              case 0:
   8564                setting = CMU->PCNTCTRL & CMU_PCNTCTRL_PCNT0CLKSEL_PCNT0S0;
   8565                break;
   8566          
   8567          #if defined(_CMU_PCNTCTRL_PCNT1CLKEN_MASK)
   8568              case 1:
   8569                setting = CMU->PCNTCTRL & CMU_PCNTCTRL_PCNT1CLKSEL_PCNT1S0;
   8570                break;
   8571          
   8572          #if defined(_CMU_PCNTCTRL_PCNT2CLKEN_MASK)
   8573              case 2:
   8574                setting = CMU->PCNTCTRL & CMU_PCNTCTRL_PCNT2CLKSEL_PCNT2S0;
   8575                break;
   8576          #endif
   8577          #endif
   8578          #endif
   8579          
   8580              default:
   8581                setting = 0;
   8582                break;
   8583            }
   8584            return setting > 0UL ? true : false;
   8585          }
   8586          
   8587          /**************************************************************************//**
   8588           * @brief
   8589           *   Select the PCNTn clock.
   8590           *
   8591           * @param[in] instance
   8592           *   PCNT instance number to set selected clock source for.
   8593           *
   8594           * @param[in] external
   8595           *   Set to true to select the external clock, false to select LFBCLK.
   8596           *****************************************************************************/
   8597          void CMU_PCNTClockExternalSet(unsigned int instance, bool external)
   8598          {
   8599          #if defined(PCNT_PRESENT)
   8600            uint32_t setting = 0;
   8601          
   8602            EFM_ASSERT(instance < (unsigned)PCNT_COUNT);
   8603          
   8604            if (external) {
   8605              setting = 1;
   8606            }
   8607          
   8608            BUS_RegBitWrite(&(CMU->PCNTCTRL), (instance * 2U) + 1U, setting);
   8609          
   8610          #else
   8611            (void)instance;  /* An unused parameter */
   8612            (void)external;  /* An unused parameter */
   8613          #endif
   8614          }
   8615          
   8616          #if defined(_CMU_USHFRCOCONF_BAND_MASK)
   8617          /***************************************************************************//**
   8618           * @brief
   8619           *   Get USHFRCO band in use.
   8620           *
   8621           * @return
   8622           *   USHFRCO band in use.
   8623           ******************************************************************************/
   8624          CMU_USHFRCOBand_TypeDef CMU_USHFRCOBandGet(void)
   8625          {
   8626            return (CMU_USHFRCOBand_TypeDef)((CMU->USHFRCOCONF
   8627                                              & _CMU_USHFRCOCONF_BAND_MASK)
   8628                                             >> _CMU_USHFRCOCONF_BAND_SHIFT);
   8629          }
   8630          
   8631          /***************************************************************************//**
   8632           * @brief
   8633           *   Get USHFRCO frequency.
   8634           *
   8635           * @return
   8636           *   USHFRCO frequency.
   8637           ******************************************************************************/
   8638          uint32_t CMU_USHFRCOFreqGet(void)
   8639          {
   8640            return ushfrcoFreq;
   8641          }
   8642          #endif
   8643          
   8644          #if defined(_CMU_USHFRCOCONF_BAND_MASK)
   8645          /***************************************************************************//**
   8646           * @brief
   8647           *   Set the USHFRCO band to use.
   8648           *
   8649           * @param[in] band
   8650           *   USHFRCO band to activate.
   8651           ******************************************************************************/
   8652          void CMU_USHFRCOBandSet(CMU_USHFRCOBand_TypeDef band)
   8653          {
   8654            uint32_t           tuning;
   8655            uint32_t           fineTuning;
   8656          
   8657            /* Cannot switch band if USHFRCO is already selected as HF clock. */
   8658            EFM_ASSERT(CMU_ClockSelectGet(cmuClock_HF) != cmuSelect_USHFRCO);
   8659          
   8660            /* Read tuning value from calibration table. */
   8661            switch (band) {
   8662              case cmuUSHFRCOBand_24MHz:
   8663                tuning = (DEVINFO->USHFRCOCAL0 & _DEVINFO_USHFRCOCAL0_BAND24_TUNING_MASK)
   8664                         >> _DEVINFO_USHFRCOCAL0_BAND24_TUNING_SHIFT;
   8665                fineTuning = (DEVINFO->USHFRCOCAL0
   8666                              & _DEVINFO_USHFRCOCAL0_BAND24_FINETUNING_MASK)
   8667                             >> _DEVINFO_USHFRCOCAL0_BAND24_FINETUNING_SHIFT;
   8668                ushfrcoFreq = 24000000UL;
   8669                break;
   8670          
   8671              case cmuUSHFRCOBand_48MHz:
   8672                tuning = (DEVINFO->USHFRCOCAL0 & _DEVINFO_USHFRCOCAL0_BAND48_TUNING_MASK)
   8673                         >> _DEVINFO_USHFRCOCAL0_BAND48_TUNING_SHIFT;
   8674                fineTuning = (DEVINFO->USHFRCOCAL0
   8675                              & _DEVINFO_USHFRCOCAL0_BAND48_FINETUNING_MASK)
   8676                             >> _DEVINFO_USHFRCOCAL0_BAND48_FINETUNING_SHIFT;
   8677                /* Enable the clock divider before switching the band from 24 to 48 MHz */
   8678                BUS_RegBitWrite(&CMU->USHFRCOCONF, _CMU_USHFRCOCONF_USHFRCODIV2DIS_SHIFT, 0);
   8679                ushfrcoFreq = 48000000UL;
   8680                break;
   8681          
   8682              default:
   8683                EFM_ASSERT(false);
   8684                return;
   8685            }
   8686          
   8687            /* Set band and tuning. */
   8688            CMU->USHFRCOCONF = (CMU->USHFRCOCONF & ~_CMU_USHFRCOCONF_BAND_MASK)
   8689                               | (band << _CMU_USHFRCOCONF_BAND_SHIFT);
   8690            CMU->USHFRCOCTRL = (CMU->USHFRCOCTRL & ~_CMU_USHFRCOCTRL_TUNING_MASK)
   8691                               | (tuning << _CMU_USHFRCOCTRL_TUNING_SHIFT);
   8692            CMU->USHFRCOTUNE = (CMU->USHFRCOTUNE & ~_CMU_USHFRCOTUNE_FINETUNING_MASK)
   8693                               | (fineTuning << _CMU_USHFRCOTUNE_FINETUNING_SHIFT);
   8694          
   8695            /* Disable the clock divider after switching the band from 48 to 24 MHz. */
   8696            if (band == cmuUSHFRCOBand_24MHz) {
   8697              BUS_RegBitWrite(&CMU->USHFRCOCONF, _CMU_USHFRCOCONF_USHFRCODIV2DIS_SHIFT, 1);
   8698            }
   8699          }
   8700          #endif
   8701          
   8702          #endif // defined(_SILICON_LABS_32B_SERIES_2)
   8703          
   8704          /** @} (end addtogroup CMU) */
   8705          /** @} (end addtogroup emlib) */
   8706          #endif /* defined(CMU_PRESENT) */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CMU_Calibrate
         8   -> CMU_CalibrateConfig
         0   -> CMU_CalibrateCountGet
       8   CMU_CalibrateConfig
       0   CMU_CalibrateCountGet
      16   CMU_ClkOutPinConfig
         0   -> GPIO_PinModeSet
       0   CMU_ClockDivGet
      16   CMU_ClockDivSet
        16   -> CMU_UpdateWaitStates
        16   -> SystemCoreClockGet
        16   -> pclkDivMax
         0   -> pclkDivOptimize
        16   -> waitStateMax
      16   CMU_ClockFreqGet
        16   -> CMU_ClockDivGet
        16   -> SystemHCLKGet
        16   -> SystemSYSCLKGet
        16   -> dpllRefClkGet
        16   -> em01GrpaClkGet
        16   -> em23GrpaClkGet
        16   -> em4GrpaClkGet
        16   -> iadcClkGet
        16   -> rtccClkGet
        16   -> traceClkGet
        16   -> wdog0ClkGet
        16   -> wdog1ClkGet
       8   CMU_ClockSelectGet
         8   -> dpllRefClkGet
         8   -> em01GrpaClkGet
         8   -> em23GrpaClkGet
         8   -> em4GrpaClkGet
         8   -> iadcClkGet
         8   -> rtccClkGet
         8   -> traceClkGet
         8   -> wdog0ClkGet
         8   -> wdog1ClkGet
      24   CMU_ClockSelectSet
        24   -> CMU_UpdateWaitStates
        24   -> SystemCoreClockGet
        24   -> pclkDivMax
        24   -> pclkDivOptimize
        24   -> waitStateMax
      24   CMU_DPLLLock
        24   -> CMU_ClockDivGet
        24   -> CMU_ClockDivSet
        24   -> CMU_ClockSelectGet
        24   -> CMU_ClockSelectSet
        24   -> CMU_UpdateWaitStates
        24   -> HFRCODPLLDevinfoGet
        24   -> SystemCoreClockGet
        24   -> SystemHFRCODPLLClockGet
        24   -> SystemHFRCODPLLClockSet
        24   -> pclkDivMax
        24   -> pclkDivOptimize
        24   -> waitStateMax
       0   CMU_HFRCODPLLBandGet
         0   -> SystemHFRCODPLLClockGet
      16   CMU_HFRCODPLLBandSet
        16   -> CMU_ClockSelectGet
        16   -> CMU_UpdateWaitStates
        16   -> HFRCODPLLDevinfoGet
        16   -> SystemCoreClockGet
        16   -> SystemHFRCODPLLClockSet
        16   -> pclkDivMax
         0   -> pclkDivOptimize
        16   -> waitStateMax
       0   CMU_HFRCOEM23BandGet
         0   -> SystemHFRCOEM23ClockGet
       8   CMU_HFRCOEM23BandSet
      24   CMU_HFXOInit
        24   -> CMU_ClockSelectGet
       0   CMU_LFRCOSetPrecision
      16   CMU_LFXOInit
       0   CMU_OscillatorTuningGet
       0   CMU_OscillatorTuningSet
       0   CMU_UpdateWaitStates
         0   -> flashWaitStateControl
       0   HFRCODPLLDevinfoGet
       0   SystemCoreClockGet
         0   -> SystemHCLKGet
      16   dpllRefClkGet
        16   -> SystemCLKIN0Get
        16   -> SystemHFXOClockGet
        16   -> SystemLFXOClockGet
      16   em01GrpaClkGet
        16   -> SystemFSRCOClockGet
        16   -> SystemHFRCODPLLClockGet
        16   -> SystemHFRCOEM23ClockGet
        16   -> SystemHFXOClockGet
      16   em23GrpaClkGet
        16   -> SystemLFRCOClockGet
        16   -> SystemLFXOClockGet
        16   -> SystemULFRCOClockGet
      16   em4GrpaClkGet
        16   -> SystemLFRCOClockGet
        16   -> SystemLFXOClockGet
        16   -> SystemULFRCOClockGet
      12   flashWaitStateControl
      16   iadcClkGet
        16   -> SystemFSRCOClockGet
        16   -> SystemHFRCOEM23ClockGet
        16   -> em01GrpaClkGet
       0   pclkDivMax
         0   -> CMU_ClockDivSet
       8   pclkDivOptimize
         0   -> CMU_ClockDivSet
         8   -> CMU_ClockFreqGet
      16   rtccClkGet
        16   -> SystemLFRCOClockGet
        16   -> SystemLFXOClockGet
        16   -> SystemULFRCOClockGet
      16   traceClkGet
        16   -> SystemHCLKGet
        16   -> SystemHFRCOEM23ClockGet
       8   waitStateMax
         8   -> SystemMaxCoreClockGet
         0   -> flashWaitStateControl
      16   wdog0ClkGet
        16   -> SystemHCLKGet
        16   -> SystemLFRCOClockGet
        16   -> SystemLFXOClockGet
        16   -> SystemULFRCOClockGet
      16   wdog1ClkGet
        16   -> SystemHCLKGet
        16   -> SystemLFRCOClockGet
        16   -> SystemLFXOClockGet
        16   -> SystemULFRCOClockGet


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_10
       4  ??DataTable27_11
       4  ??DataTable27_12
       4  ??DataTable27_13
       4  ??DataTable27_14
       4  ??DataTable27_15
       4  ??DataTable27_16
       4  ??DataTable27_17
       4  ??DataTable27_18
       4  ??DataTable27_19
       4  ??DataTable27_2
       4  ??DataTable27_20
       4  ??DataTable27_21
       4  ??DataTable27_22
       4  ??DataTable27_23
       4  ??DataTable27_24
       4  ??DataTable27_25
       4  ??DataTable27_26
       4  ??DataTable27_27
       4  ??DataTable27_28
       4  ??DataTable27_29
       4  ??DataTable27_3
       4  ??DataTable27_30
       4  ??DataTable27_31
       4  ??DataTable27_32
       4  ??DataTable27_33
       4  ??DataTable27_34
       4  ??DataTable27_35
       4  ??DataTable27_36
       4  ??DataTable27_37
       4  ??DataTable27_38
       4  ??DataTable27_39
       4  ??DataTable27_4
       4  ??DataTable27_40
       4  ??DataTable27_41
       4  ??DataTable27_42
       4  ??DataTable27_43
       4  ??DataTable27_44
       4  ??DataTable27_45
       4  ??DataTable27_46
       4  ??DataTable27_47
       4  ??DataTable27_48
       4  ??DataTable27_49
       4  ??DataTable27_5
       4  ??DataTable27_50
       4  ??DataTable27_51
       4  ??DataTable27_6
       4  ??DataTable27_7
       4  ??DataTable27_8
       4  ??DataTable27_9
      60  ?Subroutine0
      16  ?Subroutine1
      24  ?Subroutine2
      16  ?Subroutine3
      12  ?Subroutine4
       4  ?Subroutine5
       8  ?Subroutine6
       8  ?Subroutine7
      24  CMU_Calibrate
     172  CMU_CalibrateConfig
      20  CMU_CalibrateCountGet
     166  CMU_ClkOutPinConfig
      50  CMU_ClockDivGet
      74  CMU_ClockDivSet
     188  CMU_ClockFreqGet
     196  CMU_ClockSelectGet
     418  CMU_ClockSelectSet
     282  CMU_DPLLLock
       4  CMU_HFRCODPLLBandGet
     106  CMU_HFRCODPLLBandSet
       4  CMU_HFRCOEM23BandGet
     146  CMU_HFRCOEM23BandSet
     248  CMU_HFXOInit
       2  CMU_LFRCOSetPrecision
     106  CMU_LFXOInit
      46  CMU_OscillatorTuningGet
      76  CMU_OscillatorTuningSet
       2  CMU_UpdateWaitStates
     138  HFRCODPLLDevinfoGet
       4  SystemCoreClockGet
      54  dpllRefClkGet
      56  em01GrpaClkGet
       8  em23GrpaClkGet
       6  em4GrpaClkGet
      64  flashWaitStateControl
     400  hfrcoCalTable
      74  iadcClkGet
       8  pclkDivMax
      30  pclkDivOptimize
       8  rtccClkGet
      44  traceClkGet
      14  waitStateMax
      58  wdog0ClkGet
      62  wdog1ClkGet

 
   400 bytes in section .rodata
 3 362 bytes in section .text
 
 3 362 bytes of CODE  memory
   400 bytes of CONST memory

Errors: none
Warnings: none
