###############################################################################
#
# IAR ANSI C/C++ Compiler V8.32.2.178/W32 for ARM         14/Jun/2019  13:19:54
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\ssl_srv.c
#    Command line =  
#        -f C:\Users\alji\AppData\Local\Temp\EW49EE.tmp
#        (C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\ssl_srv.c
#        -D LOCAL_STORAGE_BTL -D CORTEXM3 -D CORTEXM3_EFR32 -D
#        CORTEXM3_EFR32_MICRO -D CORTEXM3_EFM32_MICRO -D
#        EFR32_SERIES2_CONFIG1_MICRO -D EFR32MG21 -D EFR32MG21A010F1024IM32 -D
#        "ATTRIBUTE_STORAGE_CONFIGURATION=\"z3_lite_timer_mg21_v660_endpoint_config.h\""
#        -D "CONFIGURATION_HEADER=\"app/framework/util/config.h\"" -D
#        "GENERATED_TOKEN_HEADER=\"z3_lite_timer_mg21_v660_tokens.h\"" -D
#        "PLATFORM_HEADER=\"platform/base/hal/micro/cortexm3/compiler/iar.h\""
#        -D "ZA_GENERATED_HEADER=\"z3_lite_timer_mg21_v660.h\"" -D
#        "__SOURCEFILE__=\"ssl_srv.c\"" -D PSSTORE_SIZE=0 -D LONGTOKEN_SIZE=0
#        -D LOCKBITS_IN_MAINFLASH_SIZE=8192 -D HAL_CONFIG=1 -D
#        EMBER_AF_USE_HWCONF -D LED_BLINK_PERIOD_MS=1000 -D NO_LED=1 -D
#        "EMBER_AF_API_EMBER_TYPES=\"stack/include/ember-types.h\"" -D
#        "EMBER_AF_API_DEBUG_PRINT=\"app/framework/util/print.h\"" -D
#        "EMBER_AF_API_AF_HEADER=\"app/framework/include/af.h\"" -D
#        "EMBER_AF_API_AF_SECURITY_HEADER=\"app/framework/security/af-security.h\""
#        -D EMBER_STACK_ZIGBEE -D
#        "MBEDTLS_CONFIG_FILE=\"mbedtls-config-generated.h\"" -D USE_NVM3 -D
#        NVM3_DEFAULT_NVM_SIZE=NVM3_FLASH_PAGES*FLASH_PAGE_SIZE -D
#        EMLIB_USER_CONFIG -D HAL_BULBPWM_ENABLE=1 -D
#        HAL_BULBPWM_FREQUENCY=1000 -D
#        "APPLICATION_TOKEN_HEADER=\"znet-token.h\"" -D
#        "APPLICATION_MFG_TOKEN_HEADER=\"znet-mfg-token.h\"" -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_FILE=\"configs/config-device-acceleration.h\""
#        -D
#        "MBEDTLS_DEVICE_ACCELERATION_CONFIG_APP_FILE=\"config-device-acceleration-app.h\""
#        -D NVM3_FLASH_PAGES=4 -D NVM3_DEFAULT_CACHE_SIZE=200 -D
#        NVM3_MAX_OBJECT_SIZE=254 -D NVM3_DEFAULT_REPACK_HEADROOM=0 -D
#        PHY_RAIL=1 -lC
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst
#        --diag_suppress Pa050 -o
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj
#        --no_unroll --no_clustering --debug --endian=little
#        --cpu=Cortex-M33.no_dsp --cmse --no_path_in_file_macros
#        --separate_cluster_for_initialized_variables -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.2\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\..\stack\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\..\util\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\protocol\zigbee\app\framework\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\micro\cortexm3\efm32\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\CMSIS\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\Device\SiliconLabs\efr32mg21\Include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\common\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\dmadrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\gpiointerrupt\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\rtcdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\sleep\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\spidrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\tempdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\uartdrv\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emdrv\ustimer\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\emlib\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\middleware\glib\glib\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\plugin\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\common\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\base\hal\..\..\radio\rail_lib\chip\efr32\rf\rfprotocol\ieee802154\cortex\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\halconfig\inc\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\module\config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\halconfig\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\hardware\kit\common\bsp\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\hal-config\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\bootloader\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\emdrv\nvm3\inc\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\chip\efr32\efr32xg2x\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\common\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\hal\efr32\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\plugin\coexistence\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ble\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\ieee802154\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\platform\radio\rail_lib\protocol\zwave\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\plugin\plugin-common\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\include\mbedtls\
#        -I
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\..\..\v2.6\util\third_party\mbedtls\sl_crypto\include\
#        -Ohz --use_c++_inline)
#    Locale       =  C
#    List file    =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\lst\ssl_srv.lst
#    Object file  =  
#        C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.5\z3_lite_timer_mg21_v660\build\obj\ssl_srv.o
#
###############################################################################

C:\SiliconLabs\SimplicityStudio\v4\developer\sdks\gecko_sdk_suite\v2.6\util\third_party\mbedtls\library\ssl_srv.c
      1          /***************************************************************************//**
      2           * # License
      3           *
      4           * The licensor of this software is Silicon Laboratories Inc. Your use of this
      5           * software is governed by the terms of Silicon Labs Master Software License
      6           * Agreement (MSLA) available at
      7           * www.silabs.com/about-us/legal/master-software-license-agreement. This
      8           * software is Third Party Software licensed by Silicon Labs from a third party
      9           * and is governed by the sections of the MSLA applicable to Third Party
     10           * Software and the additional terms set forth below.
     11           *
     12           ******************************************************************************/
     13          /*
     14           *  SSLv3/TLSv1 server-side functions
     15           *
     16           *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
     17           *  SPDX-License-Identifier: Apache-2.0
     18           *
     19           *  Licensed under the Apache License, Version 2.0 (the "License"); you may
     20           *  not use this file except in compliance with the License.
     21           *  You may obtain a copy of the License at
     22           *
     23           *  http://www.apache.org/licenses/LICENSE-2.0
     24           *
     25           *  Unless required by applicable law or agreed to in writing, software
     26           *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
     27           *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     28           *  See the License for the specific language governing permissions and
     29           *  limitations under the License.
     30           *
     31           *  This file is part of mbed TLS (https://tls.mbed.org)
     32           */
     33          
     34          #if !defined(MBEDTLS_CONFIG_FILE)
     35          #include "mbedtls/config.h"
     36          #else
     37          #include MBEDTLS_CONFIG_FILE
     38          #endif
     39          
     40          #if defined(MBEDTLS_SSL_SRV_C)
     41          
     42          #if defined(MBEDTLS_PLATFORM_C)
     43          #include "mbedtls/platform.h"
     44          #else
     45          #include <stdlib.h>
     46          #define mbedtls_calloc    calloc
     47          #define mbedtls_free      free
     48          #endif
     49          
     50          #include "mbedtls/debug.h"
     51          #include "mbedtls/ssl.h"
     52          #include "mbedtls/ssl_internal.h"
     53          
     54          #include <string.h>
     55          
     56          #if defined(MBEDTLS_ECP_C)
     57          #include "mbedtls/ecp.h"
     58          #endif
     59          
     60          #if defined(MBEDTLS_HAVE_TIME)
     61          #include "mbedtls/platform_time.h"
     62          #endif
     63          
     64          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
     65          /* Implementation that should never be optimized out by the compiler */
     66          static void mbedtls_zeroize( void *v, size_t n ) {
     67              volatile unsigned char *p = v; while( n-- ) *p++ = 0;
     68          }
     69          #endif
     70          
     71          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
     72          int mbedtls_ssl_set_client_transport_id( mbedtls_ssl_context *ssl,
     73                                           const unsigned char *info,
     74                                           size_t ilen )
     75          {
     76              if( ssl->conf->endpoint != MBEDTLS_SSL_IS_SERVER )
     77                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
     78          
     79              mbedtls_free( ssl->cli_id );
     80          
     81              if( ( ssl->cli_id = mbedtls_calloc( 1, ilen ) ) == NULL )
     82                  return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
     83          
     84              memcpy( ssl->cli_id, info, ilen );
     85              ssl->cli_id_len = ilen;
     86          
     87              return( 0 );
     88          }
     89          
     90          void mbedtls_ssl_conf_dtls_cookies( mbedtls_ssl_config *conf,
     91                                     mbedtls_ssl_cookie_write_t *f_cookie_write,
     92                                     mbedtls_ssl_cookie_check_t *f_cookie_check,
     93                                     void *p_cookie )
     94          {
     95              conf->f_cookie_write = f_cookie_write;
     96              conf->f_cookie_check = f_cookie_check;
     97              conf->p_cookie       = p_cookie;
     98          }
     99          #endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
    100          
    101          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
    102          static int ssl_parse_servername_ext( mbedtls_ssl_context *ssl,
    103                                               const unsigned char *buf,
    104                                               size_t len )
    105          {
    106              int ret;
    107              size_t servername_list_size, hostname_len;
    108              const unsigned char *p;
    109          
    110              MBEDTLS_SSL_DEBUG_MSG( 3, ( "parse ServerName extension" ) );
    111          
    112              if( len < 2 )
    113              {
    114                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    115                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    116                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    117                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    118              }
    119              servername_list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );
    120              if( servername_list_size + 2 != len )
    121              {
    122                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    123                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    124                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    125                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    126              }
    127          
    128              p = buf + 2;
    129              while( servername_list_size > 2 )
    130              {
    131                  hostname_len = ( ( p[1] << 8 ) | p[2] );
    132                  if( hostname_len + 3 > servername_list_size )
    133                  {
    134                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    135                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    136                                                      MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    137                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    138                  }
    139          
    140                  if( p[0] == MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME )
    141                  {
    142                      ret = ssl->conf->f_sni( ssl->conf->p_sni,
    143                                              ssl, p + 3, hostname_len );
    144                      if( ret != 0 )
    145                      {
    146                          MBEDTLS_SSL_DEBUG_RET( 1, "ssl_sni_wrapper", ret );
    147                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    148                                  MBEDTLS_SSL_ALERT_MSG_UNRECOGNIZED_NAME );
    149                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    150                      }
    151                      return( 0 );
    152                  }
    153          
    154                  servername_list_size -= hostname_len + 3;
    155                  p += hostname_len + 3;
    156              }
    157          
    158              if( servername_list_size != 0 )
    159              {
    160                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    161                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    162                                                  MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
    163                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    164              }
    165          
    166              return( 0 );
    167          }
    168          #endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
    169          
    170          static int ssl_parse_renegotiation_info( mbedtls_ssl_context *ssl,
    171                                                   const unsigned char *buf,
    172                                                   size_t len )
    173          {
    174          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    175              if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
    176              {
    177                  /* Check verify-data in constant-time. The length OTOH is no secret */
    178                  if( len    != 1 + ssl->verify_data_len ||
    179                      buf[0] !=     ssl->verify_data_len ||
    180                      mbedtls_ssl_safer_memcmp( buf + 1, ssl->peer_verify_data,
    181                                    ssl->verify_data_len ) != 0 )
    182                  {
    183                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "non-matching renegotiation info" ) );
    184                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    185                                                      MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
    186                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    187                  }
    188              }
    189              else
    190          #endif /* MBEDTLS_SSL_RENEGOTIATION */
    191              {
    192                  if( len != 1 || buf[0] != 0x0 )
    193                  {
    194                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "non-zero length renegotiation info" ) );
    195                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    196                                                      MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
    197                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    198                  }
    199          
    200                  ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;
    201              }
    202          
    203              return( 0 );
    204          }
    205          
    206          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
    207              defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
    208          
    209          /*
    210           * Status of the implementation of signature-algorithms extension:
    211           *
    212           * Currently, we are only considering the signature-algorithm extension
    213           * to pick a ciphersuite which allows us to send the ServerKeyExchange
    214           * message with a signature-hash combination that the user allows.
    215           *
    216           * We do *not* check whether all certificates in our certificate
    217           * chain are signed with an allowed signature-hash pair.
    218           * This needs to be done at a later stage.
    219           *
    220           */
    221          static int ssl_parse_signature_algorithms_ext( mbedtls_ssl_context *ssl,
    222                                                         const unsigned char *buf,
    223                                                         size_t len )
    224          {
    225              size_t sig_alg_list_size;
    226          
    227              const unsigned char *p;
    228              const unsigned char *end = buf + len;
    229          
    230              mbedtls_md_type_t md_cur;
    231              mbedtls_pk_type_t sig_cur;
    232          
    233              if ( len < 2 ) {
    234                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    235                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    236                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    237                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    238              }
    239              sig_alg_list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );
    240              if( sig_alg_list_size + 2 != len ||
    241                  sig_alg_list_size % 2 != 0 )
    242              {
    243                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    244                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    245                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    246                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    247              }
    248          
    249              /* Currently we only guarantee signing the ServerKeyExchange message according
    250               * to the constraints specified in this extension (see above), so it suffices
    251               * to remember only one suitable hash for each possible signature algorithm.
    252               *
    253               * This will change when we also consider certificate signatures,
    254               * in which case we will need to remember the whole signature-hash
    255               * pair list from the extension.
    256               */
    257          
    258              for( p = buf + 2; p < end; p += 2 )
    259              {
    260                  /* Silently ignore unknown signature or hash algorithms. */
    261          
    262                  if( ( sig_cur = mbedtls_ssl_pk_alg_from_sig( p[1] ) ) == MBEDTLS_PK_NONE )
    263                  {
    264                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, signature_algorithm ext"
    265                                                  " unknown sig alg encoding %d", p[1] ) );
    266                      continue;
    267                  }
    268          
    269                  /* Check if we support the hash the user proposes */
    270                  md_cur = mbedtls_ssl_md_alg_from_hash( p[0] );
    271                  if( md_cur == MBEDTLS_MD_NONE )
    272                  {
    273                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, signature_algorithm ext:"
    274                                                  " unknown hash alg encoding %d", p[0] ) );
    275                      continue;
    276                  }
    277          
    278                  if( mbedtls_ssl_check_sig_hash( ssl, md_cur ) == 0 )
    279                  {
    280                      mbedtls_ssl_sig_hash_set_add( &ssl->handshake->hash_algs, sig_cur, md_cur );
    281                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, signature_algorithm ext:"
    282                                                  " match sig %d and hash %d",
    283                                                  sig_cur, md_cur ) );
    284                  }
    285                  else
    286                  {
    287                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, signature_algorithm ext: "
    288                                                  "hash alg %d not supported", md_cur ) );
    289                  }
    290              }
    291          
    292              return( 0 );
    293          }
    294          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&
    295                    MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
    296          
    297          #if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \
    298              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    299          static int ssl_parse_supported_elliptic_curves( mbedtls_ssl_context *ssl,
    300                                                          const unsigned char *buf,
    301                                                          size_t len )
    302          {
    303              size_t list_size, our_size;
    304              const unsigned char *p;
    305              const mbedtls_ecp_curve_info *curve_info, **curves;
    306          
    307              if ( len < 2 ) {
    308                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    309                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    310                                                 MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    311                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    312              }
    313              list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );
    314              if( list_size + 2 != len ||
    315                  list_size % 2 != 0 )
    316              {
    317                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    318                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    319                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    320                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    321              }
    322          
    323              /* Should never happen unless client duplicates the extension */
    324              if( ssl->handshake->curves != NULL )
    325              {
    326                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    327                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    328                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    329                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    330              }
    331          
    332              /* Don't allow our peer to make us allocate too much memory,
    333               * and leave room for a final 0 */
    334              our_size = list_size / 2 + 1;
    335              if( our_size > MBEDTLS_ECP_DP_MAX )
    336                  our_size = MBEDTLS_ECP_DP_MAX;
    337          
    338              if( ( curves = mbedtls_calloc( our_size, sizeof( *curves ) ) ) == NULL )
    339              {
    340                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    341                                                  MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );
    342                  return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
    343              }
    344          
    345              ssl->handshake->curves = curves;
    346          
    347              p = buf + 2;
    348              while( list_size > 0 && our_size > 1 )
    349              {
    350                  curve_info = mbedtls_ecp_curve_info_from_tls_id( ( p[0] << 8 ) | p[1] );
    351          
    352                  if( curve_info != NULL )
    353                  {
    354                      *curves++ = curve_info;
    355                      our_size--;
    356                  }
    357          
    358                  list_size -= 2;
    359                  p += 2;
    360              }
    361          
    362              return( 0 );
    363          }
    364          
    365          static int ssl_parse_supported_point_formats( mbedtls_ssl_context *ssl,
    366                                                        const unsigned char *buf,
    367                                                        size_t len )
    368          {
    369              size_t list_size;
    370              const unsigned char *p;
    371          
    372              if( len == 0 || (size_t)( buf[0] + 1 ) != len )
    373              {
    374                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    375                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    376                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    377                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    378              }
    379              list_size = buf[0];
    380          
    381              p = buf + 1;
    382              while( list_size > 0 )
    383              {
    384                  if( p[0] == MBEDTLS_ECP_PF_UNCOMPRESSED ||
    385                      p[0] == MBEDTLS_ECP_PF_COMPRESSED )
    386                  {
    387          #if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C)
    388                      ssl->handshake->ecdh_ctx.point_format = p[0];
    389          #endif
    390          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    391                      ssl->handshake->ecjpake_ctx.point_format = p[0];
    392          #endif
    393                      MBEDTLS_SSL_DEBUG_MSG( 4, ( "point format selected: %d", p[0] ) );
    394                      return( 0 );
    395                  }
    396          
    397                  list_size--;
    398                  p++;
    399              }
    400          
    401              return( 0 );
    402          }
    403          #endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C ||
    404                    MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
    405          
    406          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    407          static int ssl_parse_ecjpake_kkpp( mbedtls_ssl_context *ssl,
    408                                             const unsigned char *buf,
    409                                             size_t len )
    410          {
    411              int ret;
    412          
    413              if( mbedtls_ecjpake_check( &ssl->handshake->ecjpake_ctx ) != 0 )
    414              {
    415                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "skip ecjpake kkpp extension" ) );
    416                  return( 0 );
    417              }
    418          
    419              if( ( ret = mbedtls_ecjpake_read_round_one( &ssl->handshake->ecjpake_ctx,
    420                                                          buf, len ) ) != 0 )
    421              {
    422                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecjpake_read_round_one", ret );
    423                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    424                                                  MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
    425                  return( ret );
    426              }
    427          
    428              /* Only mark the extension as OK when we're sure it is */
    429              ssl->handshake->cli_exts |= MBEDTLS_TLS_EXT_ECJPAKE_KKPP_OK;
    430          
    431              return( 0 );
    432          }
    433          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
    434          
    435          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
    436          static int ssl_parse_max_fragment_length_ext( mbedtls_ssl_context *ssl,
    437                                                        const unsigned char *buf,
    438                                                        size_t len )
    439          {
    440              if( len != 1 || buf[0] >= MBEDTLS_SSL_MAX_FRAG_LEN_INVALID )
    441              {
    442                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    443                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    444                                                  MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
    445                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    446              }
    447          
    448              ssl->session_negotiate->mfl_code = buf[0];
    449          
    450              return( 0 );
    451          }
    452          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
    453          
    454          #if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
    455          static int ssl_parse_truncated_hmac_ext( mbedtls_ssl_context *ssl,
    456                                                   const unsigned char *buf,
    457                                                   size_t len )
    458          {
    459              if( len != 0 )
    460              {
    461                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    462                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    463                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    464                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    465              }
    466          
    467              ((void) buf);
    468          
    469              if( ssl->conf->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_ENABLED )
    470                  ssl->session_negotiate->trunc_hmac = MBEDTLS_SSL_TRUNC_HMAC_ENABLED;
    471          
    472              return( 0 );
    473          }
    474          #endif /* MBEDTLS_SSL_TRUNCATED_HMAC */
    475          
    476          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
    477          static int ssl_parse_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,
    478                                                const unsigned char *buf,
    479                                                size_t len )
    480          {
    481              if( len != 0 )
    482              {
    483                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    484                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    485                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    486                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    487              }
    488          
    489              ((void) buf);
    490          
    491              if( ssl->conf->encrypt_then_mac == MBEDTLS_SSL_ETM_ENABLED &&
    492                  ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )
    493              {
    494                  ssl->session_negotiate->encrypt_then_mac = MBEDTLS_SSL_ETM_ENABLED;
    495              }
    496          
    497              return( 0 );
    498          }
    499          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
    500          
    501          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
    502          static int ssl_parse_extended_ms_ext( mbedtls_ssl_context *ssl,
    503                                                const unsigned char *buf,
    504                                                size_t len )
    505          {
    506              if( len != 0 )
    507              {
    508                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    509                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    510                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    511                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    512              }
    513          
    514              ((void) buf);
    515          
    516              if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_ENABLED &&
    517                  ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )
    518              {
    519                  ssl->handshake->extended_ms = MBEDTLS_SSL_EXTENDED_MS_ENABLED;
    520              }
    521          
    522              return( 0 );
    523          }
    524          #endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
    525          
    526          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
    527          static int ssl_parse_session_ticket_ext( mbedtls_ssl_context *ssl,
    528                                                   unsigned char *buf,
    529                                                   size_t len )
    530          {
    531              int ret;
    532              mbedtls_ssl_session session;
    533          
    534              mbedtls_ssl_session_init( &session );
    535          
    536              if( ssl->conf->f_ticket_parse == NULL ||
    537                  ssl->conf->f_ticket_write == NULL )
    538              {
    539                  return( 0 );
    540              }
    541          
    542              /* Remember the client asked us to send a new ticket */
    543              ssl->handshake->new_session_ticket = 1;
    544          
    545              MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket length: %d", len ) );
    546          
    547              if( len == 0 )
    548                  return( 0 );
    549          
    550          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    551              if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
    552              {
    553                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket rejected: renegotiating" ) );
    554                  return( 0 );
    555              }
    556          #endif /* MBEDTLS_SSL_RENEGOTIATION */
    557          
    558              /*
    559               * Failures are ok: just ignore the ticket and proceed.
    560               */
    561              if( ( ret = ssl->conf->f_ticket_parse( ssl->conf->p_ticket, &session,
    562                                                     buf, len ) ) != 0 )
    563              {
    564                  mbedtls_ssl_session_free( &session );
    565          
    566                  if( ret == MBEDTLS_ERR_SSL_INVALID_MAC )
    567                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket is not authentic" ) );
    568                  else if( ret == MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED )
    569                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket is expired" ) );
    570                  else
    571                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_ticket_parse", ret );
    572          
    573                  return( 0 );
    574              }
    575          
    576              /*
    577               * Keep the session ID sent by the client, since we MUST send it back to
    578               * inform them we're accepting the ticket  (RFC 5077 section 3.4)
    579               */
    580              session.id_len = ssl->session_negotiate->id_len;
    581              memcpy( &session.id, ssl->session_negotiate->id, session.id_len );
    582          
    583              mbedtls_ssl_session_free( ssl->session_negotiate );
    584              memcpy( ssl->session_negotiate, &session, sizeof( mbedtls_ssl_session ) );
    585          
    586              /* Zeroize instead of free as we copied the content */
    587              mbedtls_zeroize( &session, sizeof( mbedtls_ssl_session ) );
    588          
    589              MBEDTLS_SSL_DEBUG_MSG( 3, ( "session successfully restored from ticket" ) );
    590          
    591              ssl->handshake->resume = 1;
    592          
    593              /* Don't send a new ticket after all, this one is OK */
    594              ssl->handshake->new_session_ticket = 0;
    595          
    596              return( 0 );
    597          }
    598          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
    599          
    600          #if defined(MBEDTLS_SSL_ALPN)
    601          static int ssl_parse_alpn_ext( mbedtls_ssl_context *ssl,
    602                                         const unsigned char *buf, size_t len )
    603          {
    604              size_t list_len, cur_len, ours_len;
    605              const unsigned char *theirs, *start, *end;
    606              const char **ours;
    607          
    608              /* If ALPN not configured, just ignore the extension */
    609              if( ssl->conf->alpn_list == NULL )
    610                  return( 0 );
    611          
    612              /*
    613               * opaque ProtocolName<1..2^8-1>;
    614               *
    615               * struct {
    616               *     ProtocolName protocol_name_list<2..2^16-1>
    617               * } ProtocolNameList;
    618               */
    619          
    620              /* Min length is 2 (list_len) + 1 (name_len) + 1 (name) */
    621              if( len < 4 )
    622              {
    623                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    624                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    625                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    626              }
    627          
    628              list_len = ( buf[0] << 8 ) | buf[1];
    629              if( list_len != len - 2 )
    630              {
    631                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    632                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    633                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    634              }
    635          
    636              /*
    637               * Validate peer's list (lengths)
    638               */
    639              start = buf + 2;
    640              end = buf + len;
    641              for( theirs = start; theirs != end; theirs += cur_len )
    642              {
    643                  cur_len = *theirs++;
    644          
    645                  /* Current identifier must fit in list */
    646                  if( cur_len > (size_t)( end - theirs ) )
    647                  {
    648                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    649                                                      MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    650                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    651                  }
    652          
    653                  /* Empty strings MUST NOT be included */
    654                  if( cur_len == 0 )
    655                  {
    656                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    657                                                      MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
    658                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    659                  }
    660              }
    661          
    662              /*
    663               * Use our order of preference
    664               */
    665              for( ours = ssl->conf->alpn_list; *ours != NULL; ours++ )
    666              {
    667                  ours_len = strlen( *ours );
    668                  for( theirs = start; theirs != end; theirs += cur_len )
    669                  {
    670                      cur_len = *theirs++;
    671          
    672                      if( cur_len == ours_len &&
    673                          memcmp( theirs, *ours, cur_len ) == 0 )
    674                      {
    675                          ssl->alpn_chosen = *ours;
    676                          return( 0 );
    677                      }
    678                  }
    679              }
    680          
    681              /* If we get there, no match was found */
    682              mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    683                                      MBEDTLS_SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL );
    684              return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    685          }
    686          #endif /* MBEDTLS_SSL_ALPN */
    687          
    688          /*
    689           * Auxiliary functions for ServerHello parsing and related actions
    690           */
    691          
    692          #if defined(MBEDTLS_X509_CRT_PARSE_C)
    693          /*
    694           * Return 0 if the given key uses one of the acceptable curves, -1 otherwise
    695           */
    696          #if defined(MBEDTLS_ECDSA_C)
    697          static int ssl_check_key_curve( mbedtls_pk_context *pk,
    698                                          const mbedtls_ecp_curve_info **curves )
    699          {
    700              const mbedtls_ecp_curve_info **crv = curves;
    701              mbedtls_ecp_group_id grp_id = mbedtls_pk_ec( *pk )->grp.id;
    702          
    703              while( *crv != NULL )
    704              {
    705                  if( (*crv)->grp_id == grp_id )
    706                      return( 0 );
    707                  crv++;
    708              }
    709          
    710              return( -1 );
    711          }
    712          #endif /* MBEDTLS_ECDSA_C */
    713          
    714          /*
    715           * Try picking a certificate for this ciphersuite,
    716           * return 0 on success and -1 on failure.
    717           */
    718          static int ssl_pick_cert( mbedtls_ssl_context *ssl,
    719                                    const mbedtls_ssl_ciphersuite_t * ciphersuite_info )
    720          {
    721              mbedtls_ssl_key_cert *cur, *list, *fallback = NULL;
    722              mbedtls_pk_type_t pk_alg =
    723                  mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );
    724              uint32_t flags;
    725          
    726          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
    727              if( ssl->handshake->sni_key_cert != NULL )
    728                  list = ssl->handshake->sni_key_cert;
    729              else
    730          #endif
    731                  list = ssl->conf->key_cert;
    732          
    733              if( pk_alg == MBEDTLS_PK_NONE )
    734                  return( 0 );
    735          
    736              MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite requires certificate" ) );
    737          
    738              if( list == NULL )
    739              {
    740                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "server has no certificate" ) );
    741                  return( -1 );
    742              }
    743          
    744              for( cur = list; cur != NULL; cur = cur->next )
    745              {
    746                  MBEDTLS_SSL_DEBUG_CRT( 3, "candidate certificate chain, certificate",
    747                                    cur->cert );
    748          
    749                  if( ! mbedtls_pk_can_do( cur->key, pk_alg ) )
    750                  {
    751                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "certificate mismatch: key type" ) );
    752                      continue;
    753                  }
    754          
    755                  /*
    756                   * This avoids sending the client a cert it'll reject based on
    757                   * keyUsage or other extensions.
    758                   *
    759                   * It also allows the user to provision different certificates for
    760                   * different uses based on keyUsage, eg if they want to avoid signing
    761                   * and decrypting with the same RSA key.
    762                   */
    763                  if( mbedtls_ssl_check_cert_usage( cur->cert, ciphersuite_info,
    764                                            MBEDTLS_SSL_IS_SERVER, &flags ) != 0 )
    765                  {
    766                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "certificate mismatch: "
    767                                          "(extended) key usage extension" ) );
    768                      continue;
    769                  }
    770          
    771          #if defined(MBEDTLS_ECDSA_C)
    772                  if( pk_alg == MBEDTLS_PK_ECDSA &&
    773                      ssl_check_key_curve( cur->key, ssl->handshake->curves ) != 0 )
    774                  {
    775                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "certificate mismatch: elliptic curve" ) );
    776                      continue;
    777                  }
    778          #endif
    779          
    780                  /*
    781                   * Try to select a SHA-1 certificate for pre-1.2 clients, but still
    782                   * present them a SHA-higher cert rather than failing if it's the only
    783                   * one we got that satisfies the other conditions.
    784                   */
    785                  if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 &&
    786                      cur->cert->sig_md != MBEDTLS_MD_SHA1 )
    787                  {
    788                      if( fallback == NULL )
    789                          fallback = cur;
    790                      {
    791                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "certificate not preferred: "
    792                                              "sha-2 with pre-TLS 1.2 client" ) );
    793                      continue;
    794                      }
    795                  }
    796          
    797                  /* If we get there, we got a winner */
    798                  break;
    799              }
    800          
    801              if( cur == NULL )
    802                  cur = fallback;
    803          
    804              /* Do not update ssl->handshake->key_cert unless there is a match */
    805              if( cur != NULL )
    806              {
    807                  ssl->handshake->key_cert = cur;
    808                  MBEDTLS_SSL_DEBUG_CRT( 3, "selected certificate chain, certificate",
    809                                    ssl->handshake->key_cert->cert );
    810                  return( 0 );
    811              }
    812          
    813              return( -1 );
    814          }
    815          #endif /* MBEDTLS_X509_CRT_PARSE_C */
    816          
    817          /*
    818           * Check if a given ciphersuite is suitable for use with our config/keys/etc
    819           * Sets ciphersuite_info only if the suite matches.
    820           */
    821          static int ssl_ciphersuite_match( mbedtls_ssl_context *ssl, int suite_id,
    822                                            const mbedtls_ssl_ciphersuite_t **ciphersuite_info )
    823          {
    824              const mbedtls_ssl_ciphersuite_t *suite_info;
    825          
    826          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
    827              defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
    828              mbedtls_pk_type_t sig_type;
    829          #endif
    830          
    831              suite_info = mbedtls_ssl_ciphersuite_from_id( suite_id );
    832              if( suite_info == NULL )
    833              {
    834                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
    835                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
    836              }
    837          
    838              MBEDTLS_SSL_DEBUG_MSG( 3, ( "trying ciphersuite: %s", suite_info->name ) );
    839          
    840              if( suite_info->min_minor_ver > ssl->minor_ver ||
    841                  suite_info->max_minor_ver < ssl->minor_ver )
    842              {
    843                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: version" ) );
    844                  return( 0 );
    845              }
    846          
    847          #if defined(MBEDTLS_SSL_PROTO_DTLS)
    848              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
    849                  ( suite_info->flags & MBEDTLS_CIPHERSUITE_NODTLS ) )
    850                  return( 0 );
    851          #endif
    852          
    853          #if defined(MBEDTLS_ARC4_C)
    854              if( ssl->conf->arc4_disabled == MBEDTLS_SSL_ARC4_DISABLED &&
    855                      suite_info->cipher == MBEDTLS_CIPHER_ARC4_128 )
    856              {
    857                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: rc4" ) );
    858                  return( 0 );
    859              }
    860          #endif
    861          
    862          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
    863              if( suite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE &&
    864                  ( ssl->handshake->cli_exts & MBEDTLS_TLS_EXT_ECJPAKE_KKPP_OK ) == 0 )
    865              {
    866                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: ecjpake "
    867                                              "not configured or ext missing" ) );
    868                  return( 0 );
    869              }
    870          #endif
    871          
    872          
    873          #if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C)
    874              if( mbedtls_ssl_ciphersuite_uses_ec( suite_info ) &&
    875                  ( ssl->handshake->curves == NULL ||
    876                    ssl->handshake->curves[0] == NULL ) )
    877              {
    878                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: "
    879                                      "no common elliptic curve" ) );
    880                  return( 0 );
    881              }
    882          #endif
    883          
    884          #if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)
    885              /* If the ciphersuite requires a pre-shared key and we don't
    886               * have one, skip it now rather than failing later */
    887              if( mbedtls_ssl_ciphersuite_uses_psk( suite_info ) &&
    888                  ssl->conf->f_psk == NULL &&
    889                  ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||
    890                    ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )
    891              {
    892                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: no pre-shared key" ) );
    893                  return( 0 );
    894              }
    895          #endif
    896          
    897          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
    898              defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
    899              /* If the ciphersuite requires signing, check whether
    900               * a suitable hash algorithm is present. */
    901              if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
    902              {
    903                  sig_type = mbedtls_ssl_get_ciphersuite_sig_alg( suite_info );
    904                  if( sig_type != MBEDTLS_PK_NONE &&
    905                      mbedtls_ssl_sig_hash_set_find( &ssl->handshake->hash_algs, sig_type ) == MBEDTLS_MD_NONE )
    906                  {
    907                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: no suitable hash algorithm "
    908                                                  "for signature algorithm %d", sig_type ) );
    909                      return( 0 );
    910                  }
    911              }
    912          
    913          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&
    914                    MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
    915          
    916          #if defined(MBEDTLS_X509_CRT_PARSE_C)
    917              /*
    918               * Final check: if ciphersuite requires us to have a
    919               * certificate/key of a particular type:
    920               * - select the appropriate certificate if we have one, or
    921               * - try the next ciphersuite if we don't
    922               * This must be done last since we modify the key_cert list.
    923               */
    924              if( ssl_pick_cert( ssl, suite_info ) != 0 )
    925              {
    926                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: "
    927                                      "no suitable certificate" ) );
    928                  return( 0 );
    929              }
    930          #endif
    931          
    932              *ciphersuite_info = suite_info;
    933              return( 0 );
    934          }
    935          
    936          #if defined(MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO)
    937          static int ssl_parse_client_hello_v2( mbedtls_ssl_context *ssl )
    938          {
    939              int ret, got_common_suite;
    940              unsigned int i, j;
    941              size_t n;
    942              unsigned int ciph_len, sess_len, chal_len;
    943              unsigned char *buf, *p;
    944              const int *ciphersuites;
    945              const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
    946          
    947              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse client hello v2" ) );
    948          
    949          #if defined(MBEDTLS_SSL_RENEGOTIATION)
    950              if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
    951              {
    952                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "client hello v2 illegal for renegotiation" ) );
    953                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
    954                                                  MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
    955                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    956              }
    957          #endif /* MBEDTLS_SSL_RENEGOTIATION */
    958          
    959              buf = ssl->in_hdr;
    960          
    961              MBEDTLS_SSL_DEBUG_BUF( 4, "record header", buf, 5 );
    962          
    963              MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v2, message type: %d",
    964                             buf[2] ) );
    965              MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v2, message len.: %d",
    966                             ( ( buf[0] & 0x7F ) << 8 ) | buf[1] ) );
    967              MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v2, max. version: [%d:%d]",
    968                             buf[3], buf[4] ) );
    969          
    970              /*
    971               * SSLv2 Client Hello
    972               *
    973               * Record layer:
    974               *     0  .   1   message length
    975               *
    976               * SSL layer:
    977               *     2  .   2   message type
    978               *     3  .   4   protocol version
    979               */
    980              if( buf[2] != MBEDTLS_SSL_HS_CLIENT_HELLO ||
    981                  buf[3] != MBEDTLS_SSL_MAJOR_VERSION_3 )
    982              {
    983                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    984                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    985              }
    986          
    987              n = ( ( buf[0] << 8 ) | buf[1] ) & 0x7FFF;
    988          
    989              if( n < 17 || n > 512 )
    990              {
    991                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    992                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
    993              }
    994          
    995              ssl->major_ver = MBEDTLS_SSL_MAJOR_VERSION_3;
    996              ssl->minor_ver = ( buf[4] <= ssl->conf->max_minor_ver )
    997                               ? buf[4]  : ssl->conf->max_minor_ver;
    998          
    999              if( ssl->minor_ver < ssl->conf->min_minor_ver )
   1000              {
   1001                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "client only supports ssl smaller than minimum"
   1002                                      " [%d:%d] < [%d:%d]",
   1003                                      ssl->major_ver, ssl->minor_ver,
   1004                                      ssl->conf->min_major_ver, ssl->conf->min_minor_ver ) );
   1005          
   1006                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1007                                               MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );
   1008                  return( MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION );
   1009              }
   1010          
   1011              ssl->handshake->max_major_ver = buf[3];
   1012              ssl->handshake->max_minor_ver = buf[4];
   1013          
   1014              if( ( ret = mbedtls_ssl_fetch_input( ssl, 2 + n ) ) != 0 )
   1015              {
   1016                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
   1017                  return( ret );
   1018              }
   1019          
   1020              ssl->handshake->update_checksum( ssl, buf + 2, n );
   1021          
   1022              buf = ssl->in_msg;
   1023              n = ssl->in_left - 5;
   1024          
   1025              /*
   1026               *    0  .   1   ciphersuitelist length
   1027               *    2  .   3   session id length
   1028               *    4  .   5   challenge length
   1029               *    6  .  ..   ciphersuitelist
   1030               *   ..  .  ..   session id
   1031               *   ..  .  ..   challenge
   1032               */
   1033              MBEDTLS_SSL_DEBUG_BUF( 4, "record contents", buf, n );
   1034          
   1035              ciph_len = ( buf[0] << 8 ) | buf[1];
   1036              sess_len = ( buf[2] << 8 ) | buf[3];
   1037              chal_len = ( buf[4] << 8 ) | buf[5];
   1038          
   1039              MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciph_len: %d, sess_len: %d, chal_len: %d",
   1040                             ciph_len, sess_len, chal_len ) );
   1041          
   1042              /*
   1043               * Make sure each parameter length is valid
   1044               */
   1045              if( ciph_len < 3 || ( ciph_len % 3 ) != 0 )
   1046              {
   1047                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1048                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1049              }
   1050          
   1051              if( sess_len > 32 )
   1052              {
   1053                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1054                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1055              }
   1056          
   1057              if( chal_len < 8 || chal_len > 32 )
   1058              {
   1059                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1060                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1061              }
   1062          
   1063              if( n != 6 + ciph_len + sess_len + chal_len )
   1064              {
   1065                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1066                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1067              }
   1068          
   1069              MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, ciphersuitelist",
   1070                             buf + 6, ciph_len );
   1071              MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, session id",
   1072                             buf + 6 + ciph_len, sess_len );
   1073              MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, challenge",
   1074                             buf + 6 + ciph_len + sess_len, chal_len );
   1075          
   1076              p = buf + 6 + ciph_len;
   1077              ssl->session_negotiate->id_len = sess_len;
   1078              memset( ssl->session_negotiate->id, 0,
   1079                      sizeof( ssl->session_negotiate->id ) );
   1080              memcpy( ssl->session_negotiate->id, p, ssl->session_negotiate->id_len );
   1081          
   1082              p += sess_len;
   1083              memset( ssl->handshake->randbytes, 0, 64 );
   1084              memcpy( ssl->handshake->randbytes + 32 - chal_len, p, chal_len );
   1085          
   1086              /*
   1087               * Check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV
   1088               */
   1089              for( i = 0, p = buf + 6; i < ciph_len; i += 3, p += 3 )
   1090              {
   1091                  if( p[0] == 0 && p[1] == 0 && p[2] == MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO )
   1092                  {
   1093                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "received TLS_EMPTY_RENEGOTIATION_INFO " ) );
   1094          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1095                      if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
   1096                      {
   1097                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "received RENEGOTIATION SCSV "
   1098                                              "during renegotiation" ) );
   1099          
   1100                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1101                                                          MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
   1102                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1103                      }
   1104          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   1105                      ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;
   1106                      break;
   1107                  }
   1108              }
   1109          
   1110          #if defined(MBEDTLS_SSL_FALLBACK_SCSV)
   1111              for( i = 0, p = buf + 6; i < ciph_len; i += 3, p += 3 )
   1112              {
   1113                  if( p[0] == 0 &&
   1114                      p[1] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE >> 8 ) & 0xff ) &&
   1115                      p[2] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE      ) & 0xff ) )
   1116                  {
   1117                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "received FALLBACK_SCSV" ) );
   1118          
   1119                      if( ssl->minor_ver < ssl->conf->max_minor_ver )
   1120                      {
   1121                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "inapropriate fallback" ) );
   1122          
   1123                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1124                                                  MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK );
   1125          
   1126                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1127                      }
   1128          
   1129                      break;
   1130                  }
   1131              }
   1132          #endif /* MBEDTLS_SSL_FALLBACK_SCSV */
   1133          
   1134              got_common_suite = 0;
   1135              ciphersuites = ssl->conf->ciphersuite_list[ssl->minor_ver];
   1136              ciphersuite_info = NULL;
   1137          #if defined(MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE)
   1138              for( j = 0, p = buf + 6; j < ciph_len; j += 3, p += 3 )
   1139                  for( i = 0; ciphersuites[i] != 0; i++ )
   1140          #else
   1141              for( i = 0; ciphersuites[i] != 0; i++ )
   1142                  for( j = 0, p = buf + 6; j < ciph_len; j += 3, p += 3 )
   1143          #endif
   1144                  {
   1145                      if( p[0] != 0 ||
   1146                          p[1] != ( ( ciphersuites[i] >> 8 ) & 0xFF ) ||
   1147                          p[2] != ( ( ciphersuites[i]      ) & 0xFF ) )
   1148                          continue;
   1149          
   1150                      got_common_suite = 1;
   1151          
   1152                      if( ( ret = ssl_ciphersuite_match( ssl, ciphersuites[i],
   1153                                                         &ciphersuite_info ) ) != 0 )
   1154                          return( ret );
   1155          
   1156                      if( ciphersuite_info != NULL )
   1157                          goto have_ciphersuite_v2;
   1158                  }
   1159          
   1160              if( got_common_suite )
   1161              {
   1162                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "got ciphersuites in common, "
   1163                                      "but none of them usable" ) );
   1164                  return( MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE );
   1165              }
   1166              else
   1167              {
   1168                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no ciphersuites in common" ) );
   1169                  return( MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN );
   1170              }
   1171          
   1172          have_ciphersuite_v2:
   1173              MBEDTLS_SSL_DEBUG_MSG( 2, ( "selected ciphersuite: %s", ciphersuite_info->name ) );
   1174          
   1175              ssl->session_negotiate->ciphersuite = ciphersuites[i];
   1176              ssl->transform_negotiate->ciphersuite_info = ciphersuite_info;
   1177          
   1178              /*
   1179               * SSLv2 Client Hello relevant renegotiation security checks
   1180               */
   1181              if( ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
   1182                  ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE )
   1183              {
   1184                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "legacy renegotiation, breaking off handshake" ) );
   1185                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1186                                                  MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
   1187                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1188              }
   1189          
   1190              ssl->in_left = 0;
   1191              ssl->state++;
   1192          
   1193              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse client hello v2" ) );
   1194          
   1195              return( 0 );
   1196          }
   1197          #endif /* MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO */
   1198          
   1199          /* This function doesn't alert on errors that happen early during
   1200             ClientHello parsing because they might indicate that the client is
   1201             not talking SSL/TLS at all and would not understand our alert. */
   1202          static int ssl_parse_client_hello( mbedtls_ssl_context *ssl )
   1203          {
   1204              int ret, got_common_suite;
   1205              size_t i, j;
   1206              size_t ciph_offset, comp_offset, ext_offset;
   1207              size_t msg_len, ciph_len, sess_len, comp_len, ext_len;
   1208          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1209              size_t cookie_offset, cookie_len;
   1210          #endif
   1211              unsigned char *buf, *p, *ext;
   1212          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1213              int renegotiation_info_seen = 0;
   1214          #endif
   1215              int handshake_failure = 0;
   1216              const int *ciphersuites;
   1217              const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
   1218              int major, minor;
   1219          
   1220              /* If there is no signature-algorithm extension present,
   1221               * we need to fall back to the default values for allowed
   1222               * signature-hash pairs. */
   1223          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
   1224              defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
   1225              int sig_hash_alg_ext_present = 0;
   1226          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&
   1227                    MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
   1228          
   1229              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse client hello" ) );
   1230          
   1231          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   1232          read_record_header:
   1233          #endif
   1234              /*
   1235               * If renegotiating, then the input was read with mbedtls_ssl_read_record(),
   1236               * otherwise read it ourselves manually in order to support SSLv2
   1237               * ClientHello, which doesn't use the same record layer format.
   1238               */
   1239          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1240              if( ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE )
   1241          #endif
   1242              {
   1243                  if( ( ret = mbedtls_ssl_fetch_input( ssl, 5 ) ) != 0 )
   1244                  {
   1245                      /* No alert on a read error. */
   1246                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
   1247                      return( ret );
   1248                  }
   1249              }
   1250          
   1251              buf = ssl->in_hdr;
   1252          
   1253          #if defined(MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO)
   1254          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1255              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_STREAM )
   1256          #endif
   1257                  if( ( buf[0] & 0x80 ) != 0 )
   1258                      return( ssl_parse_client_hello_v2( ssl ) );
   1259          #endif
   1260          
   1261              MBEDTLS_SSL_DEBUG_BUF( 4, "record header", buf, mbedtls_ssl_hdr_len( ssl ) );
   1262          
   1263              /*
   1264               * SSLv3/TLS Client Hello
   1265               *
   1266               * Record layer:
   1267               *     0  .   0   message type
   1268               *     1  .   2   protocol version
   1269               *     3  .   11  DTLS: epoch + record sequence number
   1270               *     3  .   4   message length
   1271               */
   1272              MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, message type: %d",
   1273                             buf[0] ) );
   1274          
   1275              if( buf[0] != MBEDTLS_SSL_MSG_HANDSHAKE )
   1276              {
   1277                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1278                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1279              }
   1280          
   1281              MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, message len.: %d",
   1282                             ( ssl->in_len[0] << 8 ) | ssl->in_len[1] ) );
   1283          
   1284              MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, protocol version: [%d:%d]",
   1285                             buf[1], buf[2] ) );
   1286          
   1287              mbedtls_ssl_read_version( &major, &minor, ssl->conf->transport, buf + 1 );
   1288          
   1289              /* According to RFC 5246 Appendix E.1, the version here is typically
   1290               * "{03,00}, the lowest version number supported by the client, [or] the
   1291               * value of ClientHello.client_version", so the only meaningful check here
   1292               * is the major version shouldn't be less than 3 */
   1293              if( major < MBEDTLS_SSL_MAJOR_VERSION_3 )
   1294              {
   1295                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1296                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1297              }
   1298          
   1299              /* For DTLS if this is the initial handshake, remember the client sequence
   1300               * number to use it in our next message (RFC 6347 4.2.1) */
   1301          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1302              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM
   1303          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1304                  && ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE
   1305          #endif
   1306                  )
   1307              {
   1308                  /* Epoch should be 0 for initial handshakes */
   1309                  if( ssl->in_ctr[0] != 0 || ssl->in_ctr[1] != 0 )
   1310                  {
   1311                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1312                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1313                  }
   1314          
   1315                  memcpy( ssl->out_ctr + 2, ssl->in_ctr + 2, 6 );
   1316          
   1317          #if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
   1318                  if( mbedtls_ssl_dtls_replay_check( ssl ) != 0 )
   1319                  {
   1320                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "replayed record, discarding" ) );
   1321                      ssl->next_record_offset = 0;
   1322                      ssl->in_left = 0;
   1323                      goto read_record_header;
   1324                  }
   1325          
   1326                  /* No MAC to check yet, so we can update right now */
   1327                  mbedtls_ssl_dtls_replay_update( ssl );
   1328          #endif
   1329              }
   1330          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   1331          
   1332              msg_len = ( ssl->in_len[0] << 8 ) | ssl->in_len[1];
   1333          
   1334          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1335              if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
   1336              {
   1337                  /* Set by mbedtls_ssl_read_record() */
   1338                  msg_len = ssl->in_hslen;
   1339              }
   1340              else
   1341          #endif
   1342              {
   1343                  if( msg_len > MBEDTLS_SSL_MAX_CONTENT_LEN )
   1344                  {
   1345                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1346                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1347                  }
   1348          
   1349                  if( ( ret = mbedtls_ssl_fetch_input( ssl,
   1350                                 mbedtls_ssl_hdr_len( ssl ) + msg_len ) ) != 0 )
   1351                  {
   1352                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
   1353                      return( ret );
   1354                  }
   1355          
   1356              /* Done reading this record, get ready for the next one */
   1357          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1358                  if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   1359                      ssl->next_record_offset = msg_len + mbedtls_ssl_hdr_len( ssl );
   1360                  else
   1361          #endif
   1362                      ssl->in_left = 0;
   1363              }
   1364          
   1365              buf = ssl->in_msg;
   1366          
   1367              MBEDTLS_SSL_DEBUG_BUF( 4, "record contents", buf, msg_len );
   1368          
   1369              ssl->handshake->update_checksum( ssl, buf, msg_len );
   1370          
   1371              /*
   1372               * Handshake layer:
   1373               *     0  .   0   handshake type
   1374               *     1  .   3   handshake length
   1375               *     4  .   5   DTLS only: message seqence number
   1376               *     6  .   8   DTLS only: fragment offset
   1377               *     9  .  11   DTLS only: fragment length
   1378               */
   1379              if( msg_len < mbedtls_ssl_hs_hdr_len( ssl ) )
   1380              {
   1381                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1382                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1383              }
   1384          
   1385              MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, handshake type: %d", buf[0] ) );
   1386          
   1387              if( buf[0] != MBEDTLS_SSL_HS_CLIENT_HELLO )
   1388              {
   1389                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1390                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1391              }
   1392          
   1393              MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, handshake len.: %d",
   1394                             ( buf[1] << 16 ) | ( buf[2] << 8 ) | buf[3] ) );
   1395          
   1396              /* We don't support fragmentation of ClientHello (yet?) */
   1397              if( buf[1] != 0 ||
   1398                  msg_len != mbedtls_ssl_hs_hdr_len( ssl ) + ( ( buf[2] << 8 ) | buf[3] ) )
   1399              {
   1400                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1401                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1402              }
   1403          
   1404          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1405              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   1406              {
   1407                  /*
   1408                   * Copy the client's handshake message_seq on initial handshakes,
   1409                   * check sequence number on renego.
   1410                   */
   1411          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1412                  if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
   1413                  {
   1414                      /* This couldn't be done in ssl_prepare_handshake_record() */
   1415                      unsigned int cli_msg_seq = ( ssl->in_msg[4] << 8 ) |
   1416                                                   ssl->in_msg[5];
   1417          
   1418                      if( cli_msg_seq != ssl->handshake->in_msg_seq )
   1419                      {
   1420                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message_seq: "
   1421                                              "%d (expected %d)", cli_msg_seq,
   1422                                              ssl->handshake->in_msg_seq ) );
   1423                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1424                      }
   1425          
   1426                      ssl->handshake->in_msg_seq++;
   1427                  }
   1428                  else
   1429          #endif
   1430                  {
   1431                      unsigned int cli_msg_seq = ( ssl->in_msg[4] << 8 ) |
   1432                                                   ssl->in_msg[5];
   1433                      ssl->handshake->out_msg_seq = cli_msg_seq;
   1434                      ssl->handshake->in_msg_seq  = cli_msg_seq + 1;
   1435                  }
   1436          
   1437                  /*
   1438                   * For now we don't support fragmentation, so make sure
   1439                   * fragment_offset == 0 and fragment_length == length
   1440                   */
   1441                  if( ssl->in_msg[6] != 0 || ssl->in_msg[7] != 0 || ssl->in_msg[8] != 0 ||
   1442                      memcmp( ssl->in_msg + 1, ssl->in_msg + 9, 3 ) != 0 )
   1443                  {
   1444                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "ClientHello fragmentation not supported" ) );
   1445                      return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
   1446                  }
   1447              }
   1448          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   1449          
   1450              buf += mbedtls_ssl_hs_hdr_len( ssl );
   1451              msg_len -= mbedtls_ssl_hs_hdr_len( ssl );
   1452          
   1453              /*
   1454               * ClientHello layer:
   1455               *     0  .   1   protocol version
   1456               *     2  .  33   random bytes (starting with 4 bytes of Unix time)
   1457               *    34  .  35   session id length (1 byte)
   1458               *    35  . 34+x  session id
   1459               *   35+x . 35+x  DTLS only: cookie length (1 byte)
   1460               *   36+x .  ..   DTLS only: cookie
   1461               *    ..  .  ..   ciphersuite list length (2 bytes)
   1462               *    ..  .  ..   ciphersuite list
   1463               *    ..  .  ..   compression alg. list length (1 byte)
   1464               *    ..  .  ..   compression alg. list
   1465               *    ..  .  ..   extensions length (2 bytes, optional)
   1466               *    ..  .  ..   extensions (optional)
   1467               */
   1468          
   1469              /*
   1470               * Minimal length (with everything empty and extensions ommitted) is
   1471               * 2 + 32 + 1 + 2 + 1 = 38 bytes. Check that first, so that we can
   1472               * read at least up to session id length without worrying.
   1473               */
   1474              if( msg_len < 38 )
   1475              {
   1476                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1477                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1478              }
   1479          
   1480              /*
   1481               * Check and save the protocol version
   1482               */
   1483              MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, version", buf, 2 );
   1484          
   1485              mbedtls_ssl_read_version( &ssl->major_ver, &ssl->minor_ver,
   1486                                ssl->conf->transport, buf );
   1487          
   1488              ssl->handshake->max_major_ver = ssl->major_ver;
   1489              ssl->handshake->max_minor_ver = ssl->minor_ver;
   1490          
   1491              if( ssl->major_ver < ssl->conf->min_major_ver ||
   1492                  ssl->minor_ver < ssl->conf->min_minor_ver )
   1493              {
   1494                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "client only supports ssl smaller than minimum"
   1495                                      " [%d:%d] < [%d:%d]",
   1496                                      ssl->major_ver, ssl->minor_ver,
   1497                                      ssl->conf->min_major_ver, ssl->conf->min_minor_ver ) );
   1498                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1499                                               MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );
   1500                  return( MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION );
   1501              }
   1502          
   1503              if( ssl->major_ver > ssl->conf->max_major_ver )
   1504              {
   1505                  ssl->major_ver = ssl->conf->max_major_ver;
   1506                  ssl->minor_ver = ssl->conf->max_minor_ver;
   1507              }
   1508              else if( ssl->minor_ver > ssl->conf->max_minor_ver )
   1509                  ssl->minor_ver = ssl->conf->max_minor_ver;
   1510          
   1511              /*
   1512               * Save client random (inc. Unix time)
   1513               */
   1514              MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, random bytes", buf + 2, 32 );
   1515          
   1516              memcpy( ssl->handshake->randbytes, buf + 2, 32 );
   1517          
   1518              /*
   1519               * Check the session ID length and save session ID
   1520               */
   1521              sess_len = buf[34];
   1522          
   1523              if( sess_len > sizeof( ssl->session_negotiate->id ) ||
   1524                  sess_len + 34 + 2 > msg_len ) /* 2 for cipherlist length field */
   1525              {
   1526                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1527                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1528                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   1529                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1530              }
   1531          
   1532              MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, session id", buf + 35, sess_len );
   1533          
   1534              ssl->session_negotiate->id_len = sess_len;
   1535              memset( ssl->session_negotiate->id, 0,
   1536                      sizeof( ssl->session_negotiate->id ) );
   1537              memcpy( ssl->session_negotiate->id, buf + 35,
   1538                      ssl->session_negotiate->id_len );
   1539          
   1540              /*
   1541               * Check the cookie length and content
   1542               */
   1543          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1544              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   1545              {
   1546                  cookie_offset = 35 + sess_len;
   1547                  cookie_len = buf[cookie_offset];
   1548          
   1549                  if( cookie_offset + 1 + cookie_len + 2 > msg_len )
   1550                  {
   1551                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1552                      mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1553                                                      MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );
   1554                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1555                  }
   1556          
   1557                  MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, cookie",
   1558                                 buf + cookie_offset + 1, cookie_len );
   1559          
   1560          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
   1561                  if( ssl->conf->f_cookie_check != NULL
   1562          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1563                      && ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE
   1564          #endif
   1565                      )
   1566                  {
   1567                      if( ssl->conf->f_cookie_check( ssl->conf->p_cookie,
   1568                                               buf + cookie_offset + 1, cookie_len,
   1569                                               ssl->cli_id, ssl->cli_id_len ) != 0 )
   1570                      {
   1571                          MBEDTLS_SSL_DEBUG_MSG( 2, ( "cookie verification failed" ) );
   1572                          ssl->handshake->verify_cookie_len = 1;
   1573                      }
   1574                      else
   1575                      {
   1576                          MBEDTLS_SSL_DEBUG_MSG( 2, ( "cookie verification passed" ) );
   1577                          ssl->handshake->verify_cookie_len = 0;
   1578                      }
   1579                  }
   1580                  else
   1581          #endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
   1582                  {
   1583                      /* We know we didn't send a cookie, so it should be empty */
   1584                      if( cookie_len != 0 )
   1585                      {
   1586                          /* This may be an attacker's probe, so don't send an alert */
   1587                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1588                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1589                      }
   1590          
   1591                      MBEDTLS_SSL_DEBUG_MSG( 2, ( "cookie verification skipped" ) );
   1592                  }
   1593          
   1594              /*
   1595               * Check the ciphersuitelist length (will be parsed later)
   1596               */
   1597                  ciph_offset = cookie_offset + 1 + cookie_len;
   1598              }
   1599              else
   1600          #endif /* MBEDTLS_SSL_PROTO_DTLS */
   1601                  ciph_offset = 35 + sess_len;
   1602          
   1603              ciph_len = ( buf[ciph_offset + 0] << 8 )
   1604                       | ( buf[ciph_offset + 1]      );
   1605          
   1606              if( ciph_len < 2 ||
   1607                  ciph_len + 2 + ciph_offset + 1 > msg_len || /* 1 for comp. alg. len */
   1608                  ( ciph_len % 2 ) != 0 )
   1609              {
   1610                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1611                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1612                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   1613                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1614              }
   1615          
   1616              MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, ciphersuitelist",
   1617                             buf + ciph_offset + 2,  ciph_len );
   1618          
   1619              /*
   1620               * Check the compression algorithms length and pick one
   1621               */
   1622              comp_offset = ciph_offset + 2 + ciph_len;
   1623          
   1624              comp_len = buf[comp_offset];
   1625          
   1626              if( comp_len < 1 ||
   1627                  comp_len > 16 ||
   1628                  comp_len + comp_offset + 1 > msg_len )
   1629              {
   1630                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1631                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1632                                                  MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   1633                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1634              }
   1635          
   1636              MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, compression",
   1637                                buf + comp_offset + 1, comp_len );
   1638          
   1639              ssl->session_negotiate->compression = MBEDTLS_SSL_COMPRESS_NULL;
   1640          #if defined(MBEDTLS_ZLIB_SUPPORT)
   1641              for( i = 0; i < comp_len; ++i )
   1642              {
   1643                  if( buf[comp_offset + 1 + i] == MBEDTLS_SSL_COMPRESS_DEFLATE )
   1644                  {
   1645                      ssl->session_negotiate->compression = MBEDTLS_SSL_COMPRESS_DEFLATE;
   1646                      break;
   1647                  }
   1648              }
   1649          #endif
   1650          
   1651              /* See comments in ssl_write_client_hello() */
   1652          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   1653              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   1654                  ssl->session_negotiate->compression = MBEDTLS_SSL_COMPRESS_NULL;
   1655          #endif
   1656          
   1657              /* Do not parse the extensions if the protocol is SSLv3 */
   1658          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   1659              if( ( ssl->major_ver != 3 ) || ( ssl->minor_ver != 0 ) )
   1660              {
   1661          #endif
   1662                  /*
   1663                   * Check the extension length
   1664                   */
   1665                  ext_offset = comp_offset + 1 + comp_len;
   1666                  if( msg_len > ext_offset )
   1667                  {
   1668                      if( msg_len < ext_offset + 2 )
   1669                      {
   1670                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1671                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1672                                                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   1673                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1674                      }
   1675          
   1676                      ext_len = ( buf[ext_offset + 0] << 8 )
   1677                              | ( buf[ext_offset + 1]      );
   1678          
   1679                      if( ( ext_len > 0 && ext_len < 4 ) ||
   1680                          msg_len != ext_offset + 2 + ext_len )
   1681                      {
   1682                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1683                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1684                                                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   1685                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1686                      }
   1687                  }
   1688                  else
   1689                      ext_len = 0;
   1690          
   1691                  ext = buf + ext_offset + 2;
   1692                  MBEDTLS_SSL_DEBUG_BUF( 3, "client hello extensions", ext, ext_len );
   1693          
   1694                  while( ext_len != 0 )
   1695                  {
   1696                      unsigned int ext_id;
   1697                      unsigned int ext_size;
   1698                      if ( ext_len < 4 ) {
   1699                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1700                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1701                                                         MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   1702                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1703                      }
   1704                      ext_id   = ( ( ext[0] <<  8 ) | ( ext[1] ) );
   1705                      ext_size = ( ( ext[2] <<  8 ) | ( ext[3] ) );
   1706          
   1707                      if( ext_size + 4 > ext_len )
   1708                      {
   1709                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1710                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1711                                                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   1712                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1713                      }
   1714                      switch( ext_id )
   1715                      {
   1716          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   1717                      case MBEDTLS_TLS_EXT_SERVERNAME:
   1718                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found ServerName extension" ) );
   1719                          if( ssl->conf->f_sni == NULL )
   1720                              break;
   1721          
   1722                          ret = ssl_parse_servername_ext( ssl, ext + 4, ext_size );
   1723                          if( ret != 0 )
   1724                              return( ret );
   1725                          break;
   1726          #endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
   1727          
   1728                      case MBEDTLS_TLS_EXT_RENEGOTIATION_INFO:
   1729                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found renegotiation extension" ) );
   1730          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1731                          renegotiation_info_seen = 1;
   1732          #endif
   1733          
   1734                          ret = ssl_parse_renegotiation_info( ssl, ext + 4, ext_size );
   1735                          if( ret != 0 )
   1736                              return( ret );
   1737                          break;
   1738          
   1739          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
   1740              defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
   1741                      case MBEDTLS_TLS_EXT_SIG_ALG:
   1742                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found signature_algorithms extension" ) );
   1743          
   1744                          ret = ssl_parse_signature_algorithms_ext( ssl, ext + 4, ext_size );
   1745                          if( ret != 0 )
   1746                              return( ret );
   1747          
   1748                          sig_hash_alg_ext_present = 1;
   1749                          break;
   1750          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&
   1751                    MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
   1752          
   1753          #if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \
   1754              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   1755                      case MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES:
   1756                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found supported elliptic curves extension" ) );
   1757          
   1758                          ret = ssl_parse_supported_elliptic_curves( ssl, ext + 4, ext_size );
   1759                          if( ret != 0 )
   1760                              return( ret );
   1761                          break;
   1762          
   1763                      case MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS:
   1764                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found supported point formats extension" ) );
   1765                          ssl->handshake->cli_exts |= MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS_PRESENT;
   1766          
   1767                          ret = ssl_parse_supported_point_formats( ssl, ext + 4, ext_size );
   1768                          if( ret != 0 )
   1769                              return( ret );
   1770                          break;
   1771          #endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C ||
   1772                    MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   1773          
   1774          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   1775                      case MBEDTLS_TLS_EXT_ECJPAKE_KKPP:
   1776                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found ecjpake kkpp extension" ) );
   1777          
   1778                          ret = ssl_parse_ecjpake_kkpp( ssl, ext + 4, ext_size );
   1779                          if( ret != 0 )
   1780                              return( ret );
   1781                          break;
   1782          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   1783          
   1784          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   1785                      case MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH:
   1786                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found max fragment length extension" ) );
   1787          
   1788                          ret = ssl_parse_max_fragment_length_ext( ssl, ext + 4, ext_size );
   1789                          if( ret != 0 )
   1790                              return( ret );
   1791                          break;
   1792          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
   1793          
   1794          #if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
   1795                      case MBEDTLS_TLS_EXT_TRUNCATED_HMAC:
   1796                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found truncated hmac extension" ) );
   1797          
   1798                          ret = ssl_parse_truncated_hmac_ext( ssl, ext + 4, ext_size );
   1799                          if( ret != 0 )
   1800                              return( ret );
   1801                          break;
   1802          #endif /* MBEDTLS_SSL_TRUNCATED_HMAC */
   1803          
   1804          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   1805                      case MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC:
   1806                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found encrypt then mac extension" ) );
   1807          
   1808                          ret = ssl_parse_encrypt_then_mac_ext( ssl, ext + 4, ext_size );
   1809                          if( ret != 0 )
   1810                              return( ret );
   1811                          break;
   1812          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
   1813          
   1814          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
   1815                      case MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET:
   1816                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found extended master secret extension" ) );
   1817          
   1818                          ret = ssl_parse_extended_ms_ext( ssl, ext + 4, ext_size );
   1819                          if( ret != 0 )
   1820                              return( ret );
   1821                          break;
   1822          #endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
   1823          
   1824          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   1825                      case MBEDTLS_TLS_EXT_SESSION_TICKET:
   1826                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found session ticket extension" ) );
   1827          
   1828                          ret = ssl_parse_session_ticket_ext( ssl, ext + 4, ext_size );
   1829                          if( ret != 0 )
   1830                              return( ret );
   1831                          break;
   1832          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   1833          
   1834          #if defined(MBEDTLS_SSL_ALPN)
   1835                      case MBEDTLS_TLS_EXT_ALPN:
   1836                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "found alpn extension" ) );
   1837          
   1838                          ret = ssl_parse_alpn_ext( ssl, ext + 4, ext_size );
   1839                          if( ret != 0 )
   1840                              return( ret );
   1841                          break;
   1842          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   1843          
   1844                      default:
   1845                          MBEDTLS_SSL_DEBUG_MSG( 3, ( "unknown extension found: %d (ignoring)",
   1846                                         ext_id ) );
   1847                      }
   1848          
   1849                      ext_len -= 4 + ext_size;
   1850                      ext += 4 + ext_size;
   1851          
   1852                      if( ext_len > 0 && ext_len < 4 )
   1853                      {
   1854                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
   1855                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1856                                                          MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
   1857                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1858                      }
   1859                  }
   1860          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   1861              }
   1862          #endif
   1863          
   1864          #if defined(MBEDTLS_SSL_FALLBACK_SCSV)
   1865              for( i = 0, p = buf + ciph_offset + 2; i < ciph_len; i += 2, p += 2 )
   1866              {
   1867                  if( p[0] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE >> 8 ) & 0xff ) &&
   1868                      p[1] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE      ) & 0xff ) )
   1869                  {
   1870                      MBEDTLS_SSL_DEBUG_MSG( 2, ( "received FALLBACK_SCSV" ) );
   1871          
   1872                      if( ssl->minor_ver < ssl->conf->max_minor_ver )
   1873                      {
   1874                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "inapropriate fallback" ) );
   1875          
   1876                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1877                                                  MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK );
   1878          
   1879                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1880                      }
   1881          
   1882                      break;
   1883                  }
   1884              }
   1885          #endif /* MBEDTLS_SSL_FALLBACK_SCSV */
   1886          
   1887          #if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
   1888              defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
   1889          
   1890              /*
   1891               * Try to fall back to default hash SHA1 if the client
   1892               * hasn't provided any preferred signature-hash combinations.
   1893               */
   1894              if( sig_hash_alg_ext_present == 0 )
   1895              {
   1896                  mbedtls_md_type_t md_default = MBEDTLS_MD_SHA1;
   1897          
   1898                  if( mbedtls_ssl_check_sig_hash( ssl, md_default ) != 0 )
   1899                      md_default = MBEDTLS_MD_NONE;
   1900          
   1901                  mbedtls_ssl_sig_hash_set_const_hash( &ssl->handshake->hash_algs, md_default );
   1902              }
   1903          
   1904          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&
   1905                    MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
   1906          
   1907              /*
   1908               * Check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV
   1909               */
   1910              for( i = 0, p = buf + ciph_offset + 2; i < ciph_len; i += 2, p += 2 )
   1911              {
   1912                  if( p[0] == 0 && p[1] == MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO )
   1913                  {
   1914                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "received TLS_EMPTY_RENEGOTIATION_INFO " ) );
   1915          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1916                      if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
   1917                      {
   1918                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "received RENEGOTIATION SCSV "
   1919                                                      "during renegotiation" ) );
   1920                          mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1921                                                          MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
   1922                          return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1923                      }
   1924          #endif
   1925                      ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;
   1926                      break;
   1927                  }
   1928              }
   1929          
   1930              /*
   1931               * Renegotiation security checks
   1932               */
   1933              if( ssl->secure_renegotiation != MBEDTLS_SSL_SECURE_RENEGOTIATION &&
   1934                  ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE )
   1935              {
   1936                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "legacy renegotiation, breaking off handshake" ) );
   1937                  handshake_failure = 1;
   1938              }
   1939          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   1940              else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
   1941                       ssl->secure_renegotiation == MBEDTLS_SSL_SECURE_RENEGOTIATION &&
   1942                       renegotiation_info_seen == 0 )
   1943              {
   1944                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "renegotiation_info extension missing (secure)" ) );
   1945                  handshake_failure = 1;
   1946              }
   1947              else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
   1948                       ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
   1949                       ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION )
   1950              {
   1951                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "legacy renegotiation not allowed" ) );
   1952                  handshake_failure = 1;
   1953              }
   1954              else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
   1955                       ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
   1956                       renegotiation_info_seen == 1 )
   1957              {
   1958                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "renegotiation_info extension present (legacy)" ) );
   1959                  handshake_failure = 1;
   1960              }
   1961          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   1962          
   1963              if( handshake_failure == 1 )
   1964              {
   1965                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   1966                                                  MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
   1967                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
   1968              }
   1969          
   1970              /*
   1971               * Search for a matching ciphersuite
   1972               * (At the end because we need information from the EC-based extensions
   1973               * and certificate from the SNI callback triggered by the SNI extension.)
   1974               */
   1975              got_common_suite = 0;
   1976              ciphersuites = ssl->conf->ciphersuite_list[ssl->minor_ver];
   1977              ciphersuite_info = NULL;
   1978          #if defined(MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE)
   1979              for( j = 0, p = buf + ciph_offset + 2; j < ciph_len; j += 2, p += 2 )
   1980                  for( i = 0; ciphersuites[i] != 0; i++ )
   1981          #else
   1982              for( i = 0; ciphersuites[i] != 0; i++ )
   1983                  for( j = 0, p = buf + ciph_offset + 2; j < ciph_len; j += 2, p += 2 )
   1984          #endif
   1985                  {
   1986                      if( p[0] != ( ( ciphersuites[i] >> 8 ) & 0xFF ) ||
   1987                          p[1] != ( ( ciphersuites[i]      ) & 0xFF ) )
   1988                          continue;
   1989          
   1990                      got_common_suite = 1;
   1991          
   1992                      if( ( ret = ssl_ciphersuite_match( ssl, ciphersuites[i],
   1993                                                         &ciphersuite_info ) ) != 0 )
   1994                          return( ret );
   1995          
   1996                      if( ciphersuite_info != NULL )
   1997                          goto have_ciphersuite;
   1998                  }
   1999          
   2000              if( got_common_suite )
   2001              {
   2002                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "got ciphersuites in common, "
   2003                                      "but none of them usable" ) );
   2004                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2005                                                  MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
   2006                  return( MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE );
   2007              }
   2008              else
   2009              {
   2010                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no ciphersuites in common" ) );
   2011                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   2012                                                  MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
   2013                  return( MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN );
   2014              }
   2015          
   2016          have_ciphersuite:
   2017              MBEDTLS_SSL_DEBUG_MSG( 2, ( "selected ciphersuite: %s", ciphersuite_info->name ) );
   2018          
   2019              ssl->session_negotiate->ciphersuite = ciphersuites[i];
   2020              ssl->transform_negotiate->ciphersuite_info = ciphersuite_info;
   2021          
   2022              ssl->state++;
   2023          
   2024          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   2025              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   2026                  mbedtls_ssl_recv_flight_completed( ssl );
   2027          #endif
   2028          
   2029              /* Debugging-only output for testsuite */
   2030          #if defined(MBEDTLS_DEBUG_C)                         && \
   2031              defined(MBEDTLS_SSL_PROTO_TLS1_2)                && \
   2032              defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
   2033              if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
   2034              {
   2035                  mbedtls_pk_type_t sig_alg = mbedtls_ssl_get_ciphersuite_sig_alg( ciphersuite_info );
   2036                  if( sig_alg != MBEDTLS_PK_NONE )
   2037                  {
   2038                      mbedtls_md_type_t md_alg = mbedtls_ssl_sig_hash_set_find( &ssl->handshake->hash_algs,
   2039                                                                            sig_alg );
   2040                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, signature_algorithm ext: %d",
   2041                                                  mbedtls_ssl_hash_from_md_alg( md_alg ) ) );
   2042                  }
   2043                  else
   2044                  {
   2045                      MBEDTLS_SSL_DEBUG_MSG( 3, ( "no hash algorithm for signature algorithm "
   2046                                                  "%d - should not happen", sig_alg ) );
   2047                  }
   2048              }
   2049          #endif
   2050          
   2051              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse client hello" ) );
   2052          
   2053              return( 0 );
   2054          }
   2055          
   2056          #if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
   2057          static void ssl_write_truncated_hmac_ext( mbedtls_ssl_context *ssl,
   2058                                                    unsigned char *buf,
   2059                                                    size_t *olen )
   2060          {
   2061              unsigned char *p = buf;
   2062          
   2063              if( ssl->session_negotiate->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_DISABLED )
   2064              {
   2065                  *olen = 0;
   2066                  return;
   2067              }
   2068          
   2069              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding truncated hmac extension" ) );
   2070          
   2071              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC >> 8 ) & 0xFF );
   2072              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC      ) & 0xFF );
   2073          
   2074              *p++ = 0x00;
   2075              *p++ = 0x00;
   2076          
   2077              *olen = 4;
   2078          }
   2079          #endif /* MBEDTLS_SSL_TRUNCATED_HMAC */
   2080          
   2081          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   2082          static void ssl_write_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,
   2083                                                      unsigned char *buf,
   2084                                                      size_t *olen )
   2085          {
   2086              unsigned char *p = buf;
   2087              const mbedtls_ssl_ciphersuite_t *suite = NULL;
   2088              const mbedtls_cipher_info_t *cipher = NULL;
   2089          
   2090              if( ssl->session_negotiate->encrypt_then_mac == MBEDTLS_SSL_ETM_DISABLED ||
   2091                  ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
   2092              {
   2093                  *olen = 0;
   2094                  return;
   2095              }
   2096          
   2097              /*
   2098               * RFC 7366: "If a server receives an encrypt-then-MAC request extension
   2099               * from a client and then selects a stream or Authenticated Encryption
   2100               * with Associated Data (AEAD) ciphersuite, it MUST NOT send an
   2101               * encrypt-then-MAC response extension back to the client."
   2102               */
   2103              if( ( suite = mbedtls_ssl_ciphersuite_from_id(
   2104                              ssl->session_negotiate->ciphersuite ) ) == NULL ||
   2105                  ( cipher = mbedtls_cipher_info_from_type( suite->cipher ) ) == NULL ||
   2106                  cipher->mode != MBEDTLS_MODE_CBC )
   2107              {
   2108                  *olen = 0;
   2109                  return;
   2110              }
   2111          
   2112              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding encrypt then mac extension" ) );
   2113          
   2114              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC >> 8 ) & 0xFF );
   2115              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC      ) & 0xFF );
   2116          
   2117              *p++ = 0x00;
   2118              *p++ = 0x00;
   2119          
   2120              *olen = 4;
   2121          }
   2122          #endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
   2123          
   2124          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
   2125          static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
   2126                                                 unsigned char *buf,
   2127                                                 size_t *olen )
   2128          {
   2129              unsigned char *p = buf;
   2130          
   2131              if( ssl->handshake->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
   2132                  ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
   2133              {
   2134                  *olen = 0;
   2135                  return;
   2136              }
   2137          
   2138              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding extended master secret "
   2139                                  "extension" ) );
   2140          
   2141              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
   2142              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );
   2143          
   2144              *p++ = 0x00;
   2145              *p++ = 0x00;
   2146          
   2147              *olen = 4;
   2148          }
   2149          #endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
   2150          
   2151          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   2152          static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
   2153                                                    unsigned char *buf,
   2154                                                    size_t *olen )
   2155          {
   2156              unsigned char *p = buf;
   2157          
   2158              if( ssl->handshake->new_session_ticket == 0 )
   2159              {
   2160                  *olen = 0;
   2161                  return;
   2162              }
   2163          
   2164              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding session ticket extension" ) );
   2165          
   2166              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET >> 8 ) & 0xFF );
   2167              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET      ) & 0xFF );
   2168          
   2169              *p++ = 0x00;
   2170              *p++ = 0x00;
   2171          
   2172              *olen = 4;
   2173          }
   2174          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   2175          
   2176          static void ssl_write_renegotiation_ext( mbedtls_ssl_context *ssl,
   2177                                                   unsigned char *buf,
   2178                                                   size_t *olen )
   2179          {
   2180              unsigned char *p = buf;
   2181          
   2182              if( ssl->secure_renegotiation != MBEDTLS_SSL_SECURE_RENEGOTIATION )
   2183              {
   2184                  *olen = 0;
   2185                  return;
   2186              }
   2187          
   2188              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, secure renegotiation extension" ) );
   2189          
   2190              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO >> 8 ) & 0xFF );
   2191              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO      ) & 0xFF );
   2192          
   2193          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   2194              if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
   2195              {
   2196                  *p++ = 0x00;
   2197                  *p++ = ( ssl->verify_data_len * 2 + 1 ) & 0xFF;
   2198                  *p++ = ssl->verify_data_len * 2 & 0xFF;
   2199          
   2200                  memcpy( p, ssl->peer_verify_data, ssl->verify_data_len );
   2201                  p += ssl->verify_data_len;
   2202                  memcpy( p, ssl->own_verify_data, ssl->verify_data_len );
   2203                  p += ssl->verify_data_len;
   2204              }
   2205              else
   2206          #endif /* MBEDTLS_SSL_RENEGOTIATION */
   2207              {
   2208                  *p++ = 0x00;
   2209                  *p++ = 0x01;
   2210                  *p++ = 0x00;
   2211              }
   2212          
   2213              *olen = p - buf;
   2214          }
   2215          
   2216          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   2217          static void ssl_write_max_fragment_length_ext( mbedtls_ssl_context *ssl,
   2218                                                         unsigned char *buf,
   2219                                                         size_t *olen )
   2220          {
   2221              unsigned char *p = buf;
   2222          
   2223              if( ssl->session_negotiate->mfl_code == MBEDTLS_SSL_MAX_FRAG_LEN_NONE )
   2224              {
   2225                  *olen = 0;
   2226                  return;
   2227              }
   2228          
   2229              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, max_fragment_length extension" ) );
   2230          
   2231              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH >> 8 ) & 0xFF );
   2232              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH      ) & 0xFF );
   2233          
   2234              *p++ = 0x00;
   2235              *p++ = 1;
   2236          
   2237              *p++ = ssl->session_negotiate->mfl_code;
   2238          
   2239              *olen = 5;
   2240          }
   2241          #endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
   2242          
   2243          #if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \
   2244              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   2245          static void ssl_write_supported_point_formats_ext( mbedtls_ssl_context *ssl,
   2246                                                             unsigned char *buf,
   2247                                                             size_t *olen )
   2248          {
   2249              unsigned char *p = buf;
   2250              ((void) ssl);
   2251          
   2252              if( ( ssl->handshake->cli_exts &
   2253                    MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS_PRESENT ) == 0 )
   2254              {
   2255                  *olen = 0;
   2256                  return;
   2257              }
   2258          
   2259              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, supported_point_formats extension" ) );
   2260          
   2261              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS >> 8 ) & 0xFF );
   2262              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS      ) & 0xFF );
   2263          
   2264              *p++ = 0x00;
   2265              *p++ = 2;
   2266          
   2267              *p++ = 1;
   2268              *p++ = MBEDTLS_ECP_PF_UNCOMPRESSED;
   2269          
   2270              *olen = 6;
   2271          }
   2272          #endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C || MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   2273          
   2274          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   2275          static void ssl_write_ecjpake_kkpp_ext( mbedtls_ssl_context *ssl,
   2276                                                  unsigned char *buf,
   2277                                                  size_t *olen )
   2278          {
   2279              int ret;
   2280              unsigned char *p = buf;
   2281              const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
   2282              size_t kkpp_len;
   2283          
   2284              *olen = 0;
   2285          
   2286              /* Skip costly computation if not needed */
   2287              if( ssl->transform_negotiate->ciphersuite_info->key_exchange !=
   2288                  MBEDTLS_KEY_EXCHANGE_ECJPAKE )
   2289                  return;
   2290          
   2291              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, ecjpake kkpp extension" ) );
   2292          
   2293              if( end - p < 4 )
   2294              {
   2295                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "buffer too small" ) );
   2296                  return;
   2297              }
   2298          
   2299              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ECJPAKE_KKPP >> 8 ) & 0xFF );
   2300              *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ECJPAKE_KKPP      ) & 0xFF );
   2301          
   2302              ret = mbedtls_ecjpake_write_round_one( &ssl->handshake->ecjpake_ctx,
   2303                                                  p + 2, end - p - 2, &kkpp_len,
   2304                                                  ssl->conf->f_rng, ssl->conf->p_rng );
   2305              if( ret != 0 )
   2306              {
   2307                  MBEDTLS_SSL_DEBUG_RET( 1 , "mbedtls_ecjpake_write_round_one", ret );
   2308                  return;
   2309              }
   2310          
   2311              *p++ = (unsigned char)( ( kkpp_len >> 8 ) & 0xFF );
   2312              *p++ = (unsigned char)( ( kkpp_len      ) & 0xFF );
   2313          
   2314              *olen = kkpp_len + 4;
   2315          }
   2316          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   2317          
   2318          #if defined(MBEDTLS_SSL_ALPN )
   2319          static void ssl_write_alpn_ext( mbedtls_ssl_context *ssl,
   2320                                          unsigned char *buf, size_t *olen )
   2321          {
   2322              if( ssl->alpn_chosen == NULL )
   2323              {
   2324                  *olen = 0;
   2325                  return;
   2326              }
   2327          
   2328              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding alpn extension" ) );
   2329          
   2330              /*
   2331               * 0 . 1    ext identifier
   2332               * 2 . 3    ext length
   2333               * 4 . 5    protocol list length
   2334               * 6 . 6    protocol name length
   2335               * 7 . 7+n  protocol name
   2336               */
   2337              buf[0] = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN >> 8 ) & 0xFF );
   2338              buf[1] = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN      ) & 0xFF );
   2339          
   2340              *olen = 7 + strlen( ssl->alpn_chosen );
   2341          
   2342              buf[2] = (unsigned char)( ( ( *olen - 4 ) >> 8 ) & 0xFF );
   2343              buf[3] = (unsigned char)( ( ( *olen - 4 )      ) & 0xFF );
   2344          
   2345              buf[4] = (unsigned char)( ( ( *olen - 6 ) >> 8 ) & 0xFF );
   2346              buf[5] = (unsigned char)( ( ( *olen - 6 )      ) & 0xFF );
   2347          
   2348              buf[6] = (unsigned char)( ( ( *olen - 7 )      ) & 0xFF );
   2349          
   2350              memcpy( buf + 7, ssl->alpn_chosen, *olen - 7 );
   2351          }
   2352          #endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C */
   2353          
   2354          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
   2355          static int ssl_write_hello_verify_request( mbedtls_ssl_context *ssl )
   2356          {
   2357              int ret;
   2358              unsigned char *p = ssl->out_msg + 4;
   2359              unsigned char *cookie_len_byte;
   2360          
   2361              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write hello verify request" ) );
   2362          
   2363              /*
   2364               * struct {
   2365               *   ProtocolVersion server_version;
   2366               *   opaque cookie<0..2^8-1>;
   2367               * } HelloVerifyRequest;
   2368               */
   2369          
   2370              /* The RFC is not clear on this point, but sending the actual negotiated
   2371               * version looks like the most interoperable thing to do. */
   2372              mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
   2373                                 ssl->conf->transport, p );
   2374              MBEDTLS_SSL_DEBUG_BUF( 3, "server version", p, 2 );
   2375              p += 2;
   2376          
   2377              /* If we get here, f_cookie_check is not null */
   2378              if( ssl->conf->f_cookie_write == NULL )
   2379              {
   2380                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "inconsistent cookie callbacks" ) );
   2381                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   2382              }
   2383          
   2384              /* Skip length byte until we know the length */
   2385              cookie_len_byte = p++;
   2386          
   2387              if( ( ret = ssl->conf->f_cookie_write( ssl->conf->p_cookie,
   2388                                               &p, ssl->out_buf + MBEDTLS_SSL_BUFFER_LEN,
   2389                                               ssl->cli_id, ssl->cli_id_len ) ) != 0 )
   2390              {
   2391                  MBEDTLS_SSL_DEBUG_RET( 1, "f_cookie_write", ret );
   2392                  return( ret );
   2393              }
   2394          
   2395              *cookie_len_byte = (unsigned char)( p - ( cookie_len_byte + 1 ) );
   2396          
   2397              MBEDTLS_SSL_DEBUG_BUF( 3, "cookie sent", cookie_len_byte + 1, *cookie_len_byte );
   2398          
   2399              ssl->out_msglen  = p - ssl->out_msg;
   2400              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   2401              ssl->out_msg[0]  = MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST;
   2402          
   2403              ssl->state = MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT;
   2404          
   2405              if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
   2406              {
   2407                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
   2408                  return( ret );
   2409              }
   2410          
   2411              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write hello verify request" ) );
   2412          
   2413              return( 0 );
   2414          }
   2415          #endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
   2416          
   2417          static int ssl_write_server_hello( mbedtls_ssl_context *ssl )
   2418          {
   2419          #if defined(MBEDTLS_HAVE_TIME)
   2420              mbedtls_time_t t;
   2421          #endif
   2422              int ret;
   2423              size_t olen, ext_len = 0, n;
   2424              unsigned char *buf, *p;
   2425          
   2426              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write server hello" ) );
   2427          
   2428          #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
   2429              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   2430                  ssl->handshake->verify_cookie_len != 0 )
   2431              {
   2432                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "client hello was not authenticated" ) );
   2433                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write server hello" ) );
   2434          
   2435                  return( ssl_write_hello_verify_request( ssl ) );
   2436              }
   2437          #endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
   2438          
   2439              if( ssl->conf->f_rng == NULL )
   2440              {
   2441                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "no RNG provided") );
   2442                  return( MBEDTLS_ERR_SSL_NO_RNG );
   2443              }
   2444          
   2445              /*
   2446               *     0  .   0   handshake type
   2447               *     1  .   3   handshake length
   2448               *     4  .   5   protocol version
   2449               *     6  .   9   UNIX time()
   2450               *    10  .  37   random bytes
   2451               */
   2452              buf = ssl->out_msg;
   2453              p = buf + 4;
   2454          
   2455              mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
   2456                                 ssl->conf->transport, p );
   2457              p += 2;
   2458          
   2459              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, chosen version: [%d:%d]",
   2460                                  buf[4], buf[5] ) );
   2461          
   2462          #if defined(MBEDTLS_HAVE_TIME)
   2463              t = mbedtls_time( NULL );
   2464              *p++ = (unsigned char)( t >> 24 );
   2465              *p++ = (unsigned char)( t >> 16 );
   2466              *p++ = (unsigned char)( t >>  8 );
   2467              *p++ = (unsigned char)( t       );
   2468          
   2469              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, current time: %lu", t ) );
   2470          #else
   2471              if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 4 ) ) != 0 )
   2472                  return( ret );
   2473          
   2474              p += 4;
   2475          #endif /* MBEDTLS_HAVE_TIME */
   2476          
   2477              if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 28 ) ) != 0 )
   2478                  return( ret );
   2479          
   2480              p += 28;
   2481          
   2482              memcpy( ssl->handshake->randbytes + 32, buf + 6, 32 );
   2483          
   2484              MBEDTLS_SSL_DEBUG_BUF( 3, "server hello, random bytes", buf + 6, 32 );
   2485          
   2486              /*
   2487               * Resume is 0  by default, see ssl_handshake_init().
   2488               * It may be already set to 1 by ssl_parse_session_ticket_ext().
   2489               * If not, try looking up session ID in our cache.
   2490               */
   2491              if( ssl->handshake->resume == 0 &&
   2492          #if defined(MBEDTLS_SSL_RENEGOTIATION)
   2493                  ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE &&
   2494          #endif
   2495                  ssl->session_negotiate->id_len != 0 &&
   2496                  ssl->conf->f_get_cache != NULL &&
   2497                  ssl->conf->f_get_cache( ssl->conf->p_cache, ssl->session_negotiate ) == 0 )
   2498              {
   2499                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "session successfully restored from cache" ) );
   2500                  ssl->handshake->resume = 1;
   2501              }
   2502          
   2503              if( ssl->handshake->resume == 0 )
   2504              {
   2505                  /*
   2506                   * New session, create a new session id,
   2507                   * unless we're about to issue a session ticket
   2508                   */
   2509                  ssl->state++;
   2510          
   2511          #if defined(MBEDTLS_HAVE_TIME)
   2512                  ssl->session_negotiate->start = mbedtls_time( NULL );
   2513          #endif
   2514          
   2515          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   2516                  if( ssl->handshake->new_session_ticket != 0 )
   2517                  {
   2518                      ssl->session_negotiate->id_len = n = 0;
   2519                      memset( ssl->session_negotiate->id, 0, 32 );
   2520                  }
   2521                  else
   2522          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   2523                  {
   2524                      ssl->session_negotiate->id_len = n = 32;
   2525                      if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, ssl->session_negotiate->id,
   2526                                              n ) ) != 0 )
   2527                          return( ret );
   2528                  }
   2529              }
   2530              else
   2531              {
   2532                  /*
   2533                   * Resuming a session
   2534                   */
   2535                  n = ssl->session_negotiate->id_len;
   2536                  ssl->state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;
   2537          
   2538                  if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )
   2539                  {
   2540                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_derive_keys", ret );
   2541                      return( ret );
   2542                  }
   2543              }
   2544          
   2545              /*
   2546               *    38  .  38     session id length
   2547               *    39  . 38+n    session id
   2548               *   39+n . 40+n    chosen ciphersuite
   2549               *   41+n . 41+n    chosen compression alg.
   2550               *   42+n . 43+n    extensions length
   2551               *   44+n . 43+n+m  extensions
   2552               */
   2553              *p++ = (unsigned char) ssl->session_negotiate->id_len;
   2554              memcpy( p, ssl->session_negotiate->id, ssl->session_negotiate->id_len );
   2555              p += ssl->session_negotiate->id_len;
   2556          
   2557              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, session id len.: %d", n ) );
   2558              MBEDTLS_SSL_DEBUG_BUF( 3,   "server hello, session id", buf + 39, n );
   2559              MBEDTLS_SSL_DEBUG_MSG( 3, ( "%s session has been resumed",
   2560                             ssl->handshake->resume ? "a" : "no" ) );
   2561          
   2562              *p++ = (unsigned char)( ssl->session_negotiate->ciphersuite >> 8 );
   2563              *p++ = (unsigned char)( ssl->session_negotiate->ciphersuite      );
   2564              *p++ = (unsigned char)( ssl->session_negotiate->compression      );
   2565          
   2566              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, chosen ciphersuite: %s",
   2567                     mbedtls_ssl_get_ciphersuite_name( ssl->session_negotiate->ciphersuite ) ) );
   2568              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, compress alg.: 0x%02X",
   2569                             ssl->session_negotiate->compression ) );
   2570          
   2571              /* Do not write the extensions if the protocol is SSLv3 */
   2572          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   2573              if( ( ssl->major_ver != 3 ) || ( ssl->minor_ver != 0 ) )
   2574              {
   2575          #endif
   2576          
   2577              /*
   2578               *  First write extensions, then the total length
   2579               */
   2580              ssl_write_renegotiation_ext( ssl, p + 2 + ext_len, &olen );
   2581              ext_len += olen;
   2582          
   2583          #if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
   2584              ssl_write_max_fragment_length_ext( ssl, p + 2 + ext_len, &olen );
   2585              ext_len += olen;
   2586          #endif
   2587          
   2588          #if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
   2589              ssl_write_truncated_hmac_ext( ssl, p + 2 + ext_len, &olen );
   2590              ext_len += olen;
   2591          #endif
   2592          
   2593          #if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
   2594              ssl_write_encrypt_then_mac_ext( ssl, p + 2 + ext_len, &olen );
   2595              ext_len += olen;
   2596          #endif
   2597          
   2598          #if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
   2599              ssl_write_extended_ms_ext( ssl, p + 2 + ext_len, &olen );
   2600              ext_len += olen;
   2601          #endif
   2602          
   2603          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   2604              ssl_write_session_ticket_ext( ssl, p + 2 + ext_len, &olen );
   2605              ext_len += olen;
   2606          #endif
   2607          
   2608          #if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \
   2609              defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   2610              if ( mbedtls_ssl_ciphersuite_uses_ec(
   2611                   mbedtls_ssl_ciphersuite_from_id( ssl->session_negotiate->ciphersuite ) ) )
   2612              {
   2613                  ssl_write_supported_point_formats_ext( ssl, p + 2 + ext_len, &olen );
   2614                  ext_len += olen;
   2615              }
   2616          #endif
   2617          
   2618          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   2619              ssl_write_ecjpake_kkpp_ext( ssl, p + 2 + ext_len, &olen );
   2620              ext_len += olen;
   2621          #endif
   2622          
   2623          #if defined(MBEDTLS_SSL_ALPN)
   2624              ssl_write_alpn_ext( ssl, p + 2 + ext_len, &olen );
   2625              ext_len += olen;
   2626          #endif
   2627          
   2628              MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, total extension length: %d", ext_len ) );
   2629          
   2630              if( ext_len > 0 )
   2631              {
   2632                  *p++ = (unsigned char)( ( ext_len >> 8 ) & 0xFF );
   2633                  *p++ = (unsigned char)( ( ext_len      ) & 0xFF );
   2634                  p += ext_len;
   2635              }
   2636          
   2637          #if defined(MBEDTLS_SSL_PROTO_SSL3)
   2638              }
   2639          #endif
   2640          
   2641              ssl->out_msglen  = p - buf;
   2642              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   2643              ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO;
   2644          
   2645              ret = mbedtls_ssl_write_record( ssl );
   2646          
   2647              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write server hello" ) );
   2648          
   2649              return( ret );
   2650          }
   2651          
   2652          #if !defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)       && \
   2653              !defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)   && \
   2654              !defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)  && \
   2655              !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) && \
   2656              !defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)&& \
   2657              !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
   2658          static int ssl_write_certificate_request( mbedtls_ssl_context *ssl )
   2659          {
   2660              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   2661                  ssl->transform_negotiate->ciphersuite_info;
   2662          
   2663              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write certificate request" ) );
   2664          
   2665              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
   2666                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
   2667                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
   2668                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
   2669                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
   2670              {
   2671                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate request" ) );
   2672                  ssl->state++;
   2673                  return( 0 );
   2674              }
   2675          
   2676              MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   2677              return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   2678          }
   2679          #else
   2680          static int ssl_write_certificate_request( mbedtls_ssl_context *ssl )
   2681          {
   2682              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   2683              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   2684                  ssl->transform_negotiate->ciphersuite_info;
   2685              size_t dn_size, total_dn_size; /* excluding length bytes */
   2686              size_t ct_len, sa_len; /* including length bytes */
   2687              unsigned char *buf, *p;
   2688              const unsigned char * const end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
   2689              const mbedtls_x509_crt *crt;
   2690              int authmode;
   2691          
   2692              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write certificate request" ) );
   2693          
   2694              ssl->state++;
   2695          
   2696          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   2697              if( ssl->handshake->sni_authmode != MBEDTLS_SSL_VERIFY_UNSET )
   2698                  authmode = ssl->handshake->sni_authmode;
   2699              else
   2700          #endif
   2701                  authmode = ssl->conf->authmode;
   2702          
   2703              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
   2704                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
   2705                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
   2706                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
   2707                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE ||
   2708                  authmode == MBEDTLS_SSL_VERIFY_NONE )
   2709              {
   2710                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate request" ) );
   2711                  return( 0 );
   2712              }
   2713          
   2714              /*
   2715               *     0  .   0   handshake type
   2716               *     1  .   3   handshake length
   2717               *     4  .   4   cert type count
   2718               *     5  .. m-1  cert types
   2719               *     m  .. m+1  sig alg length (TLS 1.2 only)
   2720               *    m+1 .. n-1  SignatureAndHashAlgorithms (TLS 1.2 only)
   2721               *     n  .. n+1  length of all DNs
   2722               *    n+2 .. n+3  length of DN 1
   2723               *    n+4 .. ...  Distinguished Name #1
   2724               *    ... .. ...  length of DN 2, etc.
   2725               */
   2726              buf = ssl->out_msg;
   2727              p = buf + 4;
   2728          
   2729              /*
   2730               * Supported certificate types
   2731               *
   2732               *     ClientCertificateType certificate_types<1..2^8-1>;
   2733               *     enum { (255) } ClientCertificateType;
   2734               */
   2735              ct_len = 0;
   2736          
   2737          #if defined(MBEDTLS_RSA_C)
   2738              p[1 + ct_len++] = MBEDTLS_SSL_CERT_TYPE_RSA_SIGN;
   2739          #endif
   2740          #if defined(MBEDTLS_ECDSA_C)
   2741              p[1 + ct_len++] = MBEDTLS_SSL_CERT_TYPE_ECDSA_SIGN;
   2742          #endif
   2743          
   2744              p[0] = (unsigned char) ct_len++;
   2745              p += ct_len;
   2746          
   2747              sa_len = 0;
   2748          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   2749              /*
   2750               * Add signature_algorithms for verify (TLS 1.2)
   2751               *
   2752               *     SignatureAndHashAlgorithm supported_signature_algorithms<2..2^16-2>;
   2753               *
   2754               *     struct {
   2755               *           HashAlgorithm hash;
   2756               *           SignatureAlgorithm signature;
   2757               *     } SignatureAndHashAlgorithm;
   2758               *
   2759               *     enum { (255) } HashAlgorithm;
   2760               *     enum { (255) } SignatureAlgorithm;
   2761               */
   2762              if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
   2763              {
   2764                  const int *cur;
   2765          
   2766                  /*
   2767                   * Supported signature algorithms
   2768                   */
   2769                  for( cur = ssl->conf->sig_hashes; *cur != MBEDTLS_MD_NONE; cur++ )
   2770                  {
   2771                      unsigned char hash = mbedtls_ssl_hash_from_md_alg( *cur );
   2772          
   2773                      if( MBEDTLS_SSL_HASH_NONE == hash || mbedtls_ssl_set_calc_verify_md( ssl, hash ) )
   2774                          continue;
   2775          
   2776          #if defined(MBEDTLS_RSA_C)
   2777                      p[2 + sa_len++] = hash;
   2778                      p[2 + sa_len++] = MBEDTLS_SSL_SIG_RSA;
   2779          #endif
   2780          #if defined(MBEDTLS_ECDSA_C)
   2781                      p[2 + sa_len++] = hash;
   2782                      p[2 + sa_len++] = MBEDTLS_SSL_SIG_ECDSA;
   2783          #endif
   2784                  }
   2785          
   2786                  p[0] = (unsigned char)( sa_len >> 8 );
   2787                  p[1] = (unsigned char)( sa_len      );
   2788                  sa_len += 2;
   2789                  p += sa_len;
   2790              }
   2791          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   2792          
   2793              /*
   2794               * DistinguishedName certificate_authorities<0..2^16-1>;
   2795               * opaque DistinguishedName<1..2^16-1>;
   2796               */
   2797              p += 2;
   2798          
   2799              total_dn_size = 0;
   2800          
   2801              if( ssl->conf->cert_req_ca_list ==  MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED )
   2802              {
   2803          #if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
   2804                  if( ssl->handshake->sni_ca_chain != NULL )
   2805                      crt = ssl->handshake->sni_ca_chain;
   2806                  else
   2807          #endif
   2808                      crt = ssl->conf->ca_chain;
   2809          
   2810                  while( crt != NULL && crt->version != 0 )
   2811                  {
   2812                      dn_size = crt->subject_raw.len;
   2813          
   2814                      if( end < p ||
   2815                          (size_t)( end - p ) < dn_size ||
   2816                          (size_t)( end - p ) < 2 + dn_size )
   2817                      {
   2818                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "skipping CAs: buffer too short" ) );
   2819                          break;
   2820                      }
   2821          
   2822                      *p++ = (unsigned char)( dn_size >> 8 );
   2823                      *p++ = (unsigned char)( dn_size      );
   2824                      memcpy( p, crt->subject_raw.p, dn_size );
   2825                      p += dn_size;
   2826          
   2827                      MBEDTLS_SSL_DEBUG_BUF( 3, "requested DN", p - dn_size, dn_size );
   2828          
   2829                      total_dn_size += 2 + dn_size;
   2830                      crt = crt->next;
   2831                  }
   2832              }
   2833          
   2834              ssl->out_msglen  = p - buf;
   2835              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   2836              ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE_REQUEST;
   2837              ssl->out_msg[4 + ct_len + sa_len] = (unsigned char)( total_dn_size  >> 8 );
   2838              ssl->out_msg[5 + ct_len + sa_len] = (unsigned char)( total_dn_size       );
   2839          
   2840              ret = mbedtls_ssl_write_record( ssl );
   2841          
   2842              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write certificate request" ) );
   2843          
   2844              return( ret );
   2845          }
   2846          #endif /* !MBEDTLS_KEY_EXCHANGE_RSA_ENABLED &&
   2847                    !MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED &&
   2848                    !MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED &&
   2849                    !MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED &&
   2850                    !MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED &&
   2851                    !MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */
   2852          
   2853          #if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \
   2854              defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
   2855          static int ssl_get_ecdh_params_from_cert( mbedtls_ssl_context *ssl )
   2856          {
   2857              int ret;
   2858          
   2859              if( ! mbedtls_pk_can_do( mbedtls_ssl_own_key( ssl ), MBEDTLS_PK_ECKEY ) )
   2860              {
   2861                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "server key not ECDH capable" ) );
   2862                  return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );
   2863              }
   2864          
   2865              if( ( ret = mbedtls_ecdh_get_params( &ssl->handshake->ecdh_ctx,
   2866                                           mbedtls_pk_ec( *mbedtls_ssl_own_key( ssl ) ),
   2867                                           MBEDTLS_ECDH_OURS ) ) != 0 )
   2868              {
   2869                  MBEDTLS_SSL_DEBUG_RET( 1, ( "mbedtls_ecdh_get_params" ), ret );
   2870                  return( ret );
   2871              }
   2872          
   2873              return( 0 );
   2874          }
   2875          #endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||
   2876                    MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
   2877          
   2878          static int ssl_write_server_key_exchange( mbedtls_ssl_context *ssl )
   2879          {
   2880              int ret;
   2881              size_t n = 0;
   2882              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   2883                                      ssl->transform_negotiate->ciphersuite_info;
   2884          
   2885          #if defined(MBEDTLS_KEY_EXCHANGE__SOME_PFS__ENABLED)
   2886              unsigned char *p = ssl->out_msg + 4;
   2887              size_t len = 0;
   2888          #if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)
   2889              unsigned char *dig_signed = p;
   2890              size_t dig_signed_len = 0;
   2891          #endif /* MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED */
   2892          #endif /* MBEDTLS_KEY_EXCHANGE__SOME_PFS__ENABLED */
   2893          
   2894              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write server key exchange" ) );
   2895          
   2896              /*
   2897               *
   2898               * Part 1: Extract static ECDH parameters and abort
   2899               *         if ServerKeyExchange not needed.
   2900               *
   2901               */
   2902          
   2903              /* For suites involving ECDH, extract DH parameters
   2904               * from certificate at this point. */
   2905          #if defined(MBEDTLS_KEY_EXCHANGE__SOME__ECDH_ENABLED)
   2906              if( mbedtls_ssl_ciphersuite_uses_ecdh( ciphersuite_info ) )
   2907              {
   2908                  ssl_get_ecdh_params_from_cert( ssl );
   2909              }
   2910          #endif /* MBEDTLS_KEY_EXCHANGE__SOME__ECDH_ENABLED */
   2911          
   2912              /* Key exchanges not involving ephemeral keys don't use
   2913               * ServerKeyExchange, so end here. */
   2914          #if defined(MBEDTLS_KEY_EXCHANGE__SOME_NON_PFS__ENABLED)
   2915              if( mbedtls_ssl_ciphersuite_no_pfs( ciphersuite_info ) )
   2916              {
   2917                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write server key exchange" ) );
   2918                  ssl->state++;
   2919                  return( 0 );
   2920              }
   2921          #endif /* MBEDTLS_KEY_EXCHANGE__NON_PFS__ENABLED */
   2922          
   2923              /*
   2924               *
   2925               * Part 2: Provide key exchange parameters for chosen ciphersuite.
   2926               *
   2927               */
   2928          
   2929              /*
   2930               * - ECJPAKE key exchanges
   2931               */
   2932          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   2933              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
   2934              {
   2935                  const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
   2936          
   2937                  ret = mbedtls_ecjpake_write_round_two( &ssl->handshake->ecjpake_ctx,
   2938                          p, end - p, &len, ssl->conf->f_rng, ssl->conf->p_rng );
   2939                  if( ret != 0 )
   2940                  {
   2941                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecjpake_write_round_two", ret );
   2942                      return( ret );
   2943                  }
   2944          
   2945                  p += len;
   2946                  n += len;
   2947              }
   2948          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   2949          
   2950              /*
   2951               * For (EC)DHE key exchanges with PSK, parameters are prefixed by support
   2952               * identity hint (RFC 4279, Sec. 3). Until someone needs this feature,
   2953               * we use empty support identity hints here.
   2954               **/
   2955          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)   || \
   2956              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
   2957              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
   2958                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )
   2959              {
   2960                  *(p++) = 0x00;
   2961                  *(p++) = 0x00;
   2962          
   2963                  n += 2;
   2964              }
   2965          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED ||
   2966                    MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
   2967          
   2968              /*
   2969               * - DHE key exchanges
   2970               */
   2971          #if defined(MBEDTLS_KEY_EXCHANGE__SOME__DHE_ENABLED)
   2972              if( mbedtls_ssl_ciphersuite_uses_dhe( ciphersuite_info ) )
   2973              {
   2974                  if( ssl->conf->dhm_P.p == NULL || ssl->conf->dhm_G.p == NULL )
   2975                  {
   2976                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "no DH parameters set" ) );
   2977                      return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   2978                  }
   2979          
   2980                  /*
   2981                   * Ephemeral DH parameters:
   2982                   *
   2983                   * struct {
   2984                   *     opaque dh_p<1..2^16-1>;
   2985                   *     opaque dh_g<1..2^16-1>;
   2986                   *     opaque dh_Ys<1..2^16-1>;
   2987                   * } ServerDHParams;
   2988                   */
   2989                  if( ( ret = mbedtls_dhm_set_group( &ssl->handshake->dhm_ctx,
   2990                                                     &ssl->conf->dhm_P,
   2991                                                     &ssl->conf->dhm_G ) ) != 0 )
   2992                  {
   2993                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_dhm_set_group", ret );
   2994                      return( ret );
   2995                  }
   2996          
   2997                  if( ( ret = mbedtls_dhm_make_params( &ssl->handshake->dhm_ctx,
   2998                                  (int) mbedtls_mpi_size( &ssl->handshake->dhm_ctx.P ),
   2999                                  p, &len, ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
   3000                  {
   3001                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_dhm_make_params", ret );
   3002                      return( ret );
   3003                  }
   3004          
   3005          #if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)
   3006                  dig_signed = p;
   3007                  dig_signed_len = len;
   3008          #endif
   3009          
   3010                  p += len;
   3011                  n += len;
   3012          
   3013                  MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: X ", &ssl->handshake->dhm_ctx.X  );
   3014                  MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: P ", &ssl->handshake->dhm_ctx.P  );
   3015                  MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: G ", &ssl->handshake->dhm_ctx.G  );
   3016                  MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: GX", &ssl->handshake->dhm_ctx.GX );
   3017              }
   3018          #endif /* MBEDTLS_KEY_EXCHANGE__SOME__DHE_ENABLED */
   3019          
   3020              /*
   3021               * - ECDHE key exchanges
   3022               */
   3023          #if defined(MBEDTLS_KEY_EXCHANGE__SOME__ECDHE_ENABLED)
   3024              if( mbedtls_ssl_ciphersuite_uses_ecdhe( ciphersuite_info ) )
   3025              {
   3026                  /*
   3027                   * Ephemeral ECDH parameters:
   3028                   *
   3029                   * struct {
   3030                   *     ECParameters curve_params;
   3031                   *     ECPoint      public;
   3032                   * } ServerECDHParams;
   3033                   */
   3034                  const mbedtls_ecp_curve_info **curve = NULL;
   3035                  const mbedtls_ecp_group_id *gid;
   3036          
   3037                  /* Match our preference list against the offered curves */
   3038                  for( gid = ssl->conf->curve_list; *gid != MBEDTLS_ECP_DP_NONE; gid++ )
   3039                      for( curve = ssl->handshake->curves; *curve != NULL; curve++ )
   3040                          if( (*curve)->grp_id == *gid )
   3041                              goto curve_matching_done;
   3042          
   3043          curve_matching_done:
   3044                  if( curve == NULL || *curve == NULL )
   3045                  {
   3046                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "no matching curve for ECDHE" ) );
   3047                      return( MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN );
   3048                  }
   3049          
   3050                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "ECDHE curve: %s", (*curve)->name ) );
   3051          
   3052                  if( ( ret = mbedtls_ecp_group_load( &ssl->handshake->ecdh_ctx.grp,
   3053                                                 (*curve)->grp_id ) ) != 0 )
   3054                  {
   3055                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecp_group_load", ret );
   3056                      return( ret );
   3057                  }
   3058          
   3059                  if( ( ret = mbedtls_ecdh_make_params( &ssl->handshake->ecdh_ctx, &len,
   3060                                                p, MBEDTLS_SSL_MAX_CONTENT_LEN - n,
   3061                                                ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
   3062                  {
   3063                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_make_params", ret );
   3064                      return( ret );
   3065                  }
   3066          
   3067          #if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)
   3068                  dig_signed     = p;
   3069                  dig_signed_len = len;
   3070          #endif
   3071          
   3072                  p += len;
   3073                  n += len;
   3074          
   3075                  MBEDTLS_SSL_DEBUG_ECP( 3, "ECDH: Q ", &ssl->handshake->ecdh_ctx.Q );
   3076              }
   3077          #endif /* MBEDTLS_KEY_EXCHANGE__SOME__ECDHE_ENABLED */
   3078          
   3079              /*
   3080               *
   3081               * Part 3: For key exchanges involving the server signing the
   3082               *         exchange parameters, compute and add the signature here.
   3083               *
   3084               */
   3085          #if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)
   3086              if( mbedtls_ssl_ciphersuite_uses_server_signature( ciphersuite_info ) )
   3087              {
   3088                  size_t signature_len = 0;
   3089                  unsigned int hashlen = 0;
   3090                  unsigned char hash[64];
   3091          
   3092                  /*
   3093                   * 3.1: Choose hash algorithm:
   3094                   * A: For TLS 1.2, obey signature-hash-algorithm extension
   3095                   *    to choose appropriate hash.
   3096                   * B: For SSL3, TLS1.0, TLS1.1 and ECDHE_ECDSA, use SHA1
   3097                   *    (RFC 4492, Sec. 5.4)
   3098                   * C: Otherwise, use MD5 + SHA1 (RFC 4346, Sec. 7.4.3)
   3099                   */
   3100          
   3101                  mbedtls_md_type_t md_alg;
   3102          
   3103          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   3104                  mbedtls_pk_type_t sig_alg =
   3105                      mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );
   3106                  if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
   3107                  {
   3108                      /* A: For TLS 1.2, obey signature-hash-algorithm extension
   3109                       *    (RFC 5246, Sec. 7.4.1.4.1). */
   3110                      if( sig_alg == MBEDTLS_PK_NONE ||
   3111                          ( md_alg = mbedtls_ssl_sig_hash_set_find( &ssl->handshake->hash_algs,
   3112                                                                    sig_alg ) ) == MBEDTLS_MD_NONE )
   3113                      {
   3114                          MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   3115                          /* (... because we choose a cipher suite
   3116                           *      only if there is a matching hash.) */
   3117                          return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   3118                      }
   3119                  }
   3120                  else
   3121          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   3122          #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
   3123              defined(MBEDTLS_SSL_PROTO_TLS1_1)
   3124                  if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA )
   3125                  {
   3126                      /* B: Default hash SHA1 */
   3127                      md_alg = MBEDTLS_MD_SHA1;
   3128                  }
   3129                  else
   3130          #endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \
   3131                    MBEDTLS_SSL_PROTO_TLS1_1 */
   3132                  {
   3133                      /* C: MD5 + SHA1 */
   3134                      md_alg = MBEDTLS_MD_NONE;
   3135                  }
   3136          
   3137                  MBEDTLS_SSL_DEBUG_MSG( 3, ( "pick hash algorithm %d for signing", md_alg ) );
   3138          
   3139                  /*
   3140                   * 3.2: Compute the hash to be signed
   3141                   */
   3142          #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
   3143              defined(MBEDTLS_SSL_PROTO_TLS1_1)
   3144                  if( md_alg == MBEDTLS_MD_NONE )
   3145                  {
   3146                      hashlen = 36;
   3147                      ret = mbedtls_ssl_get_key_exchange_md_ssl_tls( ssl, hash,
   3148                                                                     dig_signed,
   3149                                                                     dig_signed_len );
   3150                      if( ret != 0 )
   3151                          return( ret );
   3152                  }
   3153                  else
   3154          #endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \
   3155                    MBEDTLS_SSL_PROTO_TLS1_1 */
   3156          #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \
   3157              defined(MBEDTLS_SSL_PROTO_TLS1_2)
   3158                  if( md_alg != MBEDTLS_MD_NONE )
   3159                  {
   3160                      /* Info from md_alg will be used instead */
   3161                      hashlen = 0;
   3162                      ret = mbedtls_ssl_get_key_exchange_md_tls1_2( ssl, hash,
   3163                                                                    dig_signed,
   3164                                                                    dig_signed_len,
   3165                                                                    md_alg );
   3166                      if( ret != 0 )
   3167                          return( ret );
   3168                  }
   3169                  else
   3170          #endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \
   3171                    MBEDTLS_SSL_PROTO_TLS1_2 */
   3172                  {
   3173                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   3174                      return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   3175                  }
   3176          
   3177                  MBEDTLS_SSL_DEBUG_BUF( 3, "parameters hash", hash, hashlen != 0 ? hashlen :
   3178                      (unsigned int) ( mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) ) ) );
   3179          
   3180                  /*
   3181                   * 3.3: Compute and add the signature
   3182                   */
   3183                  if( mbedtls_ssl_own_key( ssl ) == NULL )
   3184                  {
   3185                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no private key" ) );
   3186                      return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );
   3187                  }
   3188          
   3189          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   3190                  if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
   3191                  {
   3192                      /*
   3193                       * For TLS 1.2, we need to specify signature and hash algorithm
   3194                       * explicitly through a prefix to the signature.
   3195                       *
   3196                       * struct {
   3197                       *    HashAlgorithm hash;
   3198                       *    SignatureAlgorithm signature;
   3199                       * } SignatureAndHashAlgorithm;
   3200                       *
   3201                       * struct {
   3202                       *    SignatureAndHashAlgorithm algorithm;
   3203                       *    opaque signature<0..2^16-1>;
   3204                       * } DigitallySigned;
   3205                       *
   3206                       */
   3207          
   3208                      *(p++) = mbedtls_ssl_hash_from_md_alg( md_alg );
   3209                      *(p++) = mbedtls_ssl_sig_from_pk_alg( sig_alg );
   3210          
   3211                      n += 2;
   3212                  }
   3213          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   3214          
   3215                  if( ( ret = mbedtls_pk_sign( mbedtls_ssl_own_key( ssl ), md_alg, hash, hashlen,
   3216                                  p + 2 , &signature_len, ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
   3217                  {
   3218                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_pk_sign", ret );
   3219                      return( ret );
   3220                  }
   3221          
   3222                  *(p++) = (unsigned char)( signature_len >> 8 );
   3223                  *(p++) = (unsigned char)( signature_len      );
   3224                  n += 2;
   3225          
   3226                  MBEDTLS_SSL_DEBUG_BUF( 3, "my signature", p, signature_len );
   3227          
   3228                  n += signature_len;
   3229              }
   3230          #endif /* MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED */
   3231          
   3232              /* Done with actual work; add header and send. */
   3233          
   3234              ssl->out_msglen  = 4 + n;
   3235              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   3236              ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE;
   3237          
   3238              ssl->state++;
   3239          
   3240              if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
   3241              {
   3242                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
   3243                  return( ret );
   3244              }
   3245          
   3246              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write server key exchange" ) );
   3247          
   3248              return( 0 );
   3249          }
   3250          
   3251          static int ssl_write_server_hello_done( mbedtls_ssl_context *ssl )
   3252          {
   3253              int ret;
   3254          
   3255              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write server hello done" ) );
   3256          
   3257              ssl->out_msglen  = 4;
   3258              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   3259              ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO_DONE;
   3260          
   3261              ssl->state++;
   3262          
   3263          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   3264              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
   3265                  mbedtls_ssl_send_flight_completed( ssl );
   3266          #endif
   3267          
   3268              if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
   3269              {
   3270                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
   3271                  return( ret );
   3272              }
   3273          
   3274              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write server hello done" ) );
   3275          
   3276              return( 0 );
   3277          }
   3278          
   3279          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \
   3280              defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
   3281          static int ssl_parse_client_dh_public( mbedtls_ssl_context *ssl, unsigned char **p,
   3282                                                 const unsigned char *end )
   3283          {
   3284              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   3285              size_t n;
   3286          
   3287              /*
   3288               * Receive G^Y mod P, premaster = (G^Y)^X mod P
   3289               */
   3290              if( *p + 2 > end )
   3291              {
   3292                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3293                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3294              }
   3295          
   3296              n = ( (*p)[0] << 8 ) | (*p)[1];
   3297              *p += 2;
   3298          
   3299              if( *p + n > end )
   3300              {
   3301                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3302                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3303              }
   3304          
   3305              if( ( ret = mbedtls_dhm_read_public( &ssl->handshake->dhm_ctx, *p, n ) ) != 0 )
   3306              {
   3307                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_dhm_read_public", ret );
   3308                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP );
   3309              }
   3310          
   3311              *p += n;
   3312          
   3313              MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: GY", &ssl->handshake->dhm_ctx.GY );
   3314          
   3315              return( ret );
   3316          }
   3317          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||
   3318                    MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
   3319          
   3320          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) ||                           \
   3321              defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
   3322          static int ssl_parse_encrypted_pms( mbedtls_ssl_context *ssl,
   3323                                              const unsigned char *p,
   3324                                              const unsigned char *end,
   3325                                              size_t pms_offset )
   3326          {
   3327              int ret;
   3328              size_t len = mbedtls_pk_get_len( mbedtls_ssl_own_key( ssl ) );
   3329              unsigned char *pms = ssl->handshake->premaster + pms_offset;
   3330              unsigned char ver[2];
   3331              unsigned char fake_pms[48], peer_pms[48];
   3332              unsigned char mask;
   3333              size_t i, peer_pmslen;
   3334              unsigned int diff;
   3335          
   3336              if( ! mbedtls_pk_can_do( mbedtls_ssl_own_key( ssl ), MBEDTLS_PK_RSA ) )
   3337              {
   3338                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no RSA private key" ) );
   3339                  return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );
   3340              }
   3341          
   3342              /*
   3343               * Decrypt the premaster using own private RSA key
   3344               */
   3345          #if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \
   3346              defined(MBEDTLS_SSL_PROTO_TLS1_2)
   3347              if( ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )
   3348              {
   3349                  if ( p + 2 > end ) {
   3350                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3351                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3352                  }
   3353                  if( *p++ != ( ( len >> 8 ) & 0xFF ) ||
   3354                      *p++ != ( ( len      ) & 0xFF ) )
   3355                  {
   3356                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3357                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3358                  }
   3359              }
   3360          #endif
   3361          
   3362              if( p + len != end )
   3363              {
   3364                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3365                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3366              }
   3367          
   3368              mbedtls_ssl_write_version( ssl->handshake->max_major_ver,
   3369                                 ssl->handshake->max_minor_ver,
   3370                                 ssl->conf->transport, ver );
   3371          
   3372              /*
   3373               * Protection against Bleichenbacher's attack: invalid PKCS#1 v1.5 padding
   3374               * must not cause the connection to end immediately; instead, send a
   3375               * bad_record_mac later in the handshake.
   3376               * Also, avoid data-dependant branches here to protect against
   3377               * timing-based variants.
   3378               */
   3379              ret = ssl->conf->f_rng( ssl->conf->p_rng, fake_pms, sizeof( fake_pms ) );
   3380              if( ret != 0 )
   3381                  return( ret );
   3382          
   3383              ret = mbedtls_pk_decrypt( mbedtls_ssl_own_key( ssl ), p, len,
   3384                                peer_pms, &peer_pmslen,
   3385                                sizeof( peer_pms ),
   3386                                ssl->conf->f_rng, ssl->conf->p_rng );
   3387          
   3388              diff  = (unsigned int) ret;
   3389              diff |= peer_pmslen ^ 48;
   3390              diff |= peer_pms[0] ^ ver[0];
   3391              diff |= peer_pms[1] ^ ver[1];
   3392          
   3393          #if defined(MBEDTLS_SSL_DEBUG_ALL)
   3394              if( diff != 0 )
   3395                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3396          #endif
   3397          
   3398              if( sizeof( ssl->handshake->premaster ) < pms_offset ||
   3399                  sizeof( ssl->handshake->premaster ) - pms_offset < 48 )
   3400              {
   3401                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   3402                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   3403              }
   3404              ssl->handshake->pmslen = 48;
   3405          
   3406              /* mask = diff ? 0xff : 0x00 using bit operations to avoid branches */
   3407              /* MSVC has a warning about unary minus on unsigned, but this is
   3408               * well-defined and precisely what we want to do here */
   3409          #if defined(_MSC_VER)
   3410          #pragma warning( push )
   3411          #pragma warning( disable : 4146 )
   3412          #endif
   3413              mask = - ( ( diff | - diff ) >> ( sizeof( unsigned int ) * 8 - 1 ) );
   3414          #if defined(_MSC_VER)
   3415          #pragma warning( pop )
   3416          #endif
   3417          
   3418              for( i = 0; i < ssl->handshake->pmslen; i++ )
   3419                  pms[i] = ( mask & fake_pms[i] ) | ( (~mask) & peer_pms[i] );
   3420          
   3421              return( 0 );
   3422          }
   3423          #endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED ||
   3424                    MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */
   3425          
   3426          #if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)
   3427          static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,
   3428                                                    const unsigned char *end )
   3429          {
   3430              int ret = 0;
   3431              size_t n;
   3432          
   3433              if( ssl->conf->f_psk == NULL &&
   3434                  ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||
   3435                    ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )
   3436              {
   3437                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no pre-shared key" ) );
   3438                  return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );
   3439              }
   3440          
   3441              /*
   3442               * Receive client pre-shared key identity name
   3443               */
   3444              if( end - *p < 2 )
   3445              {
   3446                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3447                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3448              }
   3449          
   3450              n = ( (*p)[0] << 8 ) | (*p)[1];
   3451              *p += 2;
   3452          
   3453              if( n < 1 || n > 65535 || n > (size_t) ( end - *p ) )
   3454              {
   3455                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3456                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3457              }
   3458          
   3459              if( ssl->conf->f_psk != NULL )
   3460              {
   3461                  if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )
   3462                      ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;
   3463              }
   3464              else
   3465              {
   3466                  /* Identity is not a big secret since clients send it in the clear,
   3467                   * but treat it carefully anyway, just in case */
   3468                  if( n != ssl->conf->psk_identity_len ||
   3469                      mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )
   3470                  {
   3471                      ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;
   3472                  }
   3473              }
   3474          
   3475              if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )
   3476              {
   3477                  MBEDTLS_SSL_DEBUG_BUF( 3, "Unknown PSK identity", *p, n );
   3478                  mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
   3479                                                  MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );
   3480                  return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );
   3481              }
   3482          
   3483              *p += n;
   3484          
   3485              return( 0 );
   3486          }
   3487          #endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */
   3488          
   3489          static int ssl_parse_client_key_exchange( mbedtls_ssl_context *ssl )
   3490          {
   3491              int ret;
   3492              const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
   3493              unsigned char *p, *end;
   3494          
   3495              ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
   3496          
   3497              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse client key exchange" ) );
   3498          
   3499              if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
   3500              {
   3501                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
   3502                  return( ret );
   3503              }
   3504          
   3505              p = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );
   3506              end = ssl->in_msg + ssl->in_hslen;
   3507          
   3508              if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
   3509              {
   3510                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3511                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3512              }
   3513          
   3514              if( ssl->in_msg[0] != MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE )
   3515              {
   3516                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
   3517                  return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3518              }
   3519          
   3520          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)
   3521              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA )
   3522              {
   3523                  if( ( ret = ssl_parse_client_dh_public( ssl, &p, end ) ) != 0 )
   3524                  {
   3525                      MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_dh_public" ), ret );
   3526                      return( ret );
   3527                  }
   3528          
   3529                  if( p != end )
   3530                  {
   3531                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange" ) );
   3532                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3533                  }
   3534          
   3535                  if( ( ret = mbedtls_dhm_calc_secret( &ssl->handshake->dhm_ctx,
   3536                                                ssl->handshake->premaster,
   3537                                                MBEDTLS_PREMASTER_SIZE,
   3538                                               &ssl->handshake->pmslen,
   3539                                                ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
   3540                  {
   3541                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_dhm_calc_secret", ret );
   3542                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS );
   3543                  }
   3544          
   3545                  MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: K ", &ssl->handshake->dhm_ctx.K  );
   3546              }
   3547              else
   3548          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED */
   3549          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \
   3550              defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \
   3551              defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||                      \
   3552              defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
   3553              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||
   3554                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA ||
   3555                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||
   3556                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )
   3557              {
   3558                  if( ( ret = mbedtls_ecdh_read_public( &ssl->handshake->ecdh_ctx,
   3559                                                p, end - p) ) != 0 )
   3560                  {
   3561                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_read_public", ret );
   3562                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP );
   3563                  }
   3564          
   3565                  MBEDTLS_SSL_DEBUG_ECP( 3, "ECDH: Qp ", &ssl->handshake->ecdh_ctx.Qp );
   3566          
   3567                  if( ( ret = mbedtls_ecdh_calc_secret( &ssl->handshake->ecdh_ctx,
   3568                                                &ssl->handshake->pmslen,
   3569                                                 ssl->handshake->premaster,
   3570                                                 MBEDTLS_MPI_MAX_SIZE,
   3571                                                 ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
   3572                  {
   3573                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_calc_secret", ret );
   3574                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS );
   3575                  }
   3576          
   3577                  MBEDTLS_SSL_DEBUG_MPI( 3, "ECDH: z  ", &ssl->handshake->ecdh_ctx.z );
   3578              }
   3579              else
   3580          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||
   3581                    MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||
   3582                    MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||
   3583                    MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
   3584          #if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED)
   3585              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK )
   3586              {
   3587                  if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )
   3588                  {
   3589                      MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_psk_identity" ), ret );
   3590                      return( ret );
   3591                  }
   3592          
   3593                  if( p != end )
   3594                  {
   3595                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange" ) );
   3596                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3597                  }
   3598          
   3599                  if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,
   3600                                  ciphersuite_info->key_exchange ) ) != 0 )
   3601                  {
   3602                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_psk_derive_premaster", ret );
   3603                      return( ret );
   3604                  }
   3605              }
   3606              else
   3607          #endif /* MBEDTLS_KEY_EXCHANGE_PSK_ENABLED */
   3608          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
   3609              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )
   3610              {
   3611                  if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )
   3612                  {
   3613                      MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_psk_identity" ), ret );
   3614                      return( ret );
   3615                  }
   3616          
   3617                  if( ( ret = ssl_parse_encrypted_pms( ssl, p, end, 2 ) ) != 0 )
   3618                  {
   3619                      MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_encrypted_pms" ), ret );
   3620                      return( ret );
   3621                  }
   3622          
   3623                  if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,
   3624                                  ciphersuite_info->key_exchange ) ) != 0 )
   3625                  {
   3626                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_psk_derive_premaster", ret );
   3627                      return( ret );
   3628                  }
   3629              }
   3630              else
   3631          #endif /* MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */
   3632          #if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
   3633              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )
   3634              {
   3635                  if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )
   3636                  {
   3637                      MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_psk_identity" ), ret );
   3638                      return( ret );
   3639                  }
   3640                  if( ( ret = ssl_parse_client_dh_public( ssl, &p, end ) ) != 0 )
   3641                  {
   3642                      MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_dh_public" ), ret );
   3643                      return( ret );
   3644                  }
   3645          
   3646                  if( p != end )
   3647                  {
   3648                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange" ) );
   3649                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
   3650                  }
   3651          
   3652                  if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,
   3653                                  ciphersuite_info->key_exchange ) ) != 0 )
   3654                  {
   3655                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_psk_derive_premaster", ret );
   3656                      return( ret );
   3657                  }
   3658              }
   3659              else
   3660          #endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
   3661          #if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
   3662              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )
   3663              {
   3664                  if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )
   3665                  {
   3666                      MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_psk_identity" ), ret );
   3667                      return( ret );
   3668                  }
   3669          
   3670                  if( ( ret = mbedtls_ecdh_read_public( &ssl->handshake->ecdh_ctx,
   3671                                                 p, end - p ) ) != 0 )
   3672                  {
   3673                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_read_public", ret );
   3674                      return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP );
   3675                  }
   3676          
   3677                  MBEDTLS_SSL_DEBUG_ECP( 3, "ECDH: Qp ", &ssl->handshake->ecdh_ctx.Qp );
   3678          
   3679                  if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,
   3680                                  ciphersuite_info->key_exchange ) ) != 0 )
   3681                  {
   3682                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_psk_derive_premaster", ret );
   3683                      return( ret );
   3684                  }
   3685              }
   3686              else
   3687          #endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
   3688          #if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)
   3689              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )
   3690              {
   3691                  if( ( ret = ssl_parse_encrypted_pms( ssl, p, end, 0 ) ) != 0 )
   3692                  {
   3693                      MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_parse_encrypted_pms_secret" ), ret );
   3694                      return( ret );
   3695                  }
   3696              }
   3697              else
   3698          #endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED */
   3699          #if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
   3700              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
   3701              {
   3702                  ret = mbedtls_ecjpake_read_round_two( &ssl->handshake->ecjpake_ctx,
   3703                                                        p, end - p );
   3704                  if( ret != 0 )
   3705                  {
   3706                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecjpake_read_round_two", ret );
   3707                      return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
   3708                  }
   3709          
   3710                  ret = mbedtls_ecjpake_derive_secret( &ssl->handshake->ecjpake_ctx,
   3711                          ssl->handshake->premaster, 32, &ssl->handshake->pmslen,
   3712                          ssl->conf->f_rng, ssl->conf->p_rng );
   3713                  if( ret != 0 )
   3714                  {
   3715                      MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecjpake_derive_secret", ret );
   3716                      return( ret );
   3717                  }
   3718              }
   3719              else
   3720          #endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
   3721              {
   3722                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   3723                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   3724              }
   3725          
   3726              if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )
   3727              {
   3728                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_derive_keys", ret );
   3729                  return( ret );
   3730              }
   3731          
   3732              ssl->state++;
   3733          
   3734              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse client key exchange" ) );
   3735          
   3736              return( 0 );
   3737          }
   3738          
   3739          #if !defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)       && \
   3740              !defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)   && \
   3741              !defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)  && \
   3742              !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) && \
   3743              !defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)&& \
   3744              !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
   3745          static int ssl_parse_certificate_verify( mbedtls_ssl_context *ssl )
   3746          {
   3747              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   3748                  ssl->transform_negotiate->ciphersuite_info;
   3749          
   3750              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse certificate verify" ) );
   3751          
   3752              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
   3753                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
   3754                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
   3755                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
   3756                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
   3757              {
   3758                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate verify" ) );
   3759                  ssl->state++;
   3760                  return( 0 );
   3761              }
   3762          
   3763              MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   3764              return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   3765          }
   3766          #else
   3767          static int ssl_parse_certificate_verify( mbedtls_ssl_context *ssl )
   3768          {
   3769              int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
   3770              size_t i, sig_len;
   3771              unsigned char hash[48];
   3772              unsigned char *hash_start = hash;
   3773              size_t hashlen;
   3774          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   3775              mbedtls_pk_type_t pk_alg;
   3776          #endif
   3777              mbedtls_md_type_t md_alg;
   3778              const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
   3779                  ssl->transform_negotiate->ciphersuite_info;
   3780          
   3781              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse certificate verify" ) );
   3782          
   3783              if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
   3784                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
   3785                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
   3786                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
   3787                  ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE ||
   3788                  ssl->session_negotiate->peer_cert == NULL )
   3789              {
   3790                  MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate verify" ) );
   3791                  ssl->state++;
   3792                  return( 0 );
   3793              }
   3794          
   3795              /* Read the message without adding it to the checksum */
   3796              do {
   3797          
   3798                  if( ( ret = mbedtls_ssl_read_record_layer( ssl ) ) != 0 )
   3799                  {
   3800                      MBEDTLS_SSL_DEBUG_RET( 1, ( "mbedtls_ssl_read_record_layer" ), ret );
   3801                      return( ret );
   3802                  }
   3803          
   3804                  ret = mbedtls_ssl_handle_message_type( ssl );
   3805          
   3806              } while( MBEDTLS_ERR_SSL_NON_FATAL == ret );
   3807          
   3808              if( 0 != ret )
   3809              {
   3810                  MBEDTLS_SSL_DEBUG_RET( 1, ( "mbedtls_ssl_handle_message_type" ), ret );
   3811                  return( ret );
   3812              }
   3813          
   3814              ssl->state++;
   3815          
   3816              /* Process the message contents */
   3817              if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE ||
   3818                  ssl->in_msg[0] != MBEDTLS_SSL_HS_CERTIFICATE_VERIFY )
   3819              {
   3820                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate verify message" ) );
   3821                  return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
   3822              }
   3823          
   3824              i = mbedtls_ssl_hs_hdr_len( ssl );
   3825          
   3826              /*
   3827               *  struct {
   3828               *     SignatureAndHashAlgorithm algorithm; -- TLS 1.2 only
   3829               *     opaque signature<0..2^16-1>;
   3830               *  } DigitallySigned;
   3831               */
   3832          #if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
   3833              defined(MBEDTLS_SSL_PROTO_TLS1_1)
   3834              if( ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_3 )
   3835              {
   3836                  md_alg = MBEDTLS_MD_NONE;
   3837                  hashlen = 36;
   3838          
   3839                  /* For ECDSA, use SHA-1, not MD-5 + SHA-1 */
   3840                  if( mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk,
   3841                                  MBEDTLS_PK_ECDSA ) )
   3842                  {
   3843                      hash_start += 16;
   3844                      hashlen -= 16;
   3845                      md_alg = MBEDTLS_MD_SHA1;
   3846                  }
   3847              }
   3848              else
   3849          #endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 ||
   3850                    MBEDTLS_SSL_PROTO_TLS1_1 */
   3851          #if defined(MBEDTLS_SSL_PROTO_TLS1_2)
   3852              if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
   3853              {
   3854                  if( i + 2 > ssl->in_hslen )
   3855                  {
   3856                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate verify message" ) );
   3857                      return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
   3858                  }
   3859          
   3860                  /*
   3861                   * Hash
   3862                   */
   3863                  md_alg = mbedtls_ssl_md_alg_from_hash( ssl->in_msg[i] );
   3864          
   3865                  if( md_alg == MBEDTLS_MD_NONE || mbedtls_ssl_set_calc_verify_md( ssl, ssl->in_msg[i] ) )
   3866                  {
   3867                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "peer not adhering to requested sig_alg"
   3868                                          " for verify message" ) );
   3869                      return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
   3870                  }
   3871          
   3872          #if !defined(MBEDTLS_MD_SHA1)
   3873                  if( MBEDTLS_MD_SHA1 == md_alg )
   3874                      hash_start += 16;
   3875          #endif
   3876          
   3877                  /* Info from md_alg will be used instead */
   3878                  hashlen = 0;
   3879          
   3880                  i++;
   3881          
   3882                  /*
   3883                   * Signature
   3884                   */
   3885                  if( ( pk_alg = mbedtls_ssl_pk_alg_from_sig( ssl->in_msg[i] ) )
   3886                                  == MBEDTLS_PK_NONE )
   3887                  {
   3888                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "peer not adhering to requested sig_alg"
   3889                                          " for verify message" ) );
   3890                      return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
   3891                  }
   3892          
   3893                  /*
   3894                   * Check the certificate's key type matches the signature alg
   3895                   */
   3896                  if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk, pk_alg ) )
   3897                  {
   3898                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "sig_alg doesn't match cert key" ) );
   3899                      return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
   3900                  }
   3901          
   3902                  i++;
   3903              }
   3904              else
   3905          #endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
   3906              {
   3907                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
   3908                  return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
   3909              }
   3910          
   3911              if( i + 2 > ssl->in_hslen )
   3912              {
   3913                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate verify message" ) );
   3914                  return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
   3915              }
   3916          
   3917              sig_len = ( ssl->in_msg[i] << 8 ) | ssl->in_msg[i+1];
   3918              i += 2;
   3919          
   3920              if( i + sig_len != ssl->in_hslen )
   3921              {
   3922                  MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate verify message" ) );
   3923                  return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
   3924              }
   3925          
   3926              /* Calculate hash and verify signature */
   3927              ssl->handshake->calc_verify( ssl, hash );
   3928          
   3929              if( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk,
   3930                                     md_alg, hash_start, hashlen,
   3931                                     ssl->in_msg + i, sig_len ) ) != 0 )
   3932              {
   3933                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_pk_verify", ret );
   3934                  return( ret );
   3935              }
   3936          
   3937              mbedtls_ssl_update_handshake_status( ssl );
   3938          
   3939              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse certificate verify" ) );
   3940          
   3941              return( ret );
   3942          }
   3943          #endif /* !MBEDTLS_KEY_EXCHANGE_RSA_ENABLED &&
   3944                    !MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED &&
   3945                    !MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED &&
   3946                    !MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED &&
   3947                    !MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED &&
   3948                    !MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */
   3949          
   3950          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   3951          static int ssl_write_new_session_ticket( mbedtls_ssl_context *ssl )
   3952          {
   3953              int ret;
   3954              size_t tlen;
   3955              uint32_t lifetime;
   3956          
   3957              MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write new session ticket" ) );
   3958          
   3959              ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
   3960              ssl->out_msg[0]  = MBEDTLS_SSL_HS_NEW_SESSION_TICKET;
   3961          
   3962              /*
   3963               * struct {
   3964               *     uint32 ticket_lifetime_hint;
   3965               *     opaque ticket<0..2^16-1>;
   3966               * } NewSessionTicket;
   3967               *
   3968               * 4  .  7   ticket_lifetime_hint (0 = unspecified)
   3969               * 8  .  9   ticket_len (n)
   3970               * 10 .  9+n ticket content
   3971               */
   3972          
   3973              if( ( ret = ssl->conf->f_ticket_write( ssl->conf->p_ticket,
   3974                                          ssl->session_negotiate,
   3975                                          ssl->out_msg + 10,
   3976                                          ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN,
   3977                                          &tlen, &lifetime ) ) != 0 )
   3978              {
   3979                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_ticket_write", ret );
   3980                  tlen = 0;
   3981              }
   3982          
   3983              ssl->out_msg[4] = ( lifetime >> 24 ) & 0xFF;
   3984              ssl->out_msg[5] = ( lifetime >> 16 ) & 0xFF;
   3985              ssl->out_msg[6] = ( lifetime >>  8 ) & 0xFF;
   3986              ssl->out_msg[7] = ( lifetime       ) & 0xFF;
   3987          
   3988              ssl->out_msg[8] = (unsigned char)( ( tlen >> 8 ) & 0xFF );
   3989              ssl->out_msg[9] = (unsigned char)( ( tlen      ) & 0xFF );
   3990          
   3991              ssl->out_msglen = 10 + tlen;
   3992          
   3993              /*
   3994               * Morally equivalent to updating ssl->state, but NewSessionTicket and
   3995               * ChangeCipherSpec share the same state.
   3996               */
   3997              ssl->handshake->new_session_ticket = 0;
   3998          
   3999              if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
   4000              {
   4001                  MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
   4002                  return( ret );
   4003              }
   4004          
   4005              MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write new session ticket" ) );
   4006          
   4007              return( 0 );
   4008          }
   4009          #endif /* MBEDTLS_SSL_SESSION_TICKETS */
   4010          
   4011          /*
   4012           * SSL handshake -- server side -- single step
   4013           */
   4014          int mbedtls_ssl_handshake_server_step( mbedtls_ssl_context *ssl )
   4015          {
   4016              int ret = 0;
   4017          
   4018              if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER || ssl->handshake == NULL )
   4019                  return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   4020          
   4021              MBEDTLS_SSL_DEBUG_MSG( 2, ( "server state: %d", ssl->state ) );
   4022          
   4023              if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )
   4024                  return( ret );
   4025          
   4026          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4027              if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
   4028                  ssl->handshake->retransmit_state == MBEDTLS_SSL_RETRANS_SENDING )
   4029              {
   4030                  if( ( ret = mbedtls_ssl_resend( ssl ) ) != 0 )
   4031                      return( ret );
   4032              }
   4033          #endif
   4034          
   4035              switch( ssl->state )
   4036              {
   4037                  case MBEDTLS_SSL_HELLO_REQUEST:
   4038                      ssl->state = MBEDTLS_SSL_CLIENT_HELLO;
   4039                      break;
   4040          
   4041                  /*
   4042                   *  <==   ClientHello
   4043                   */
   4044                  case MBEDTLS_SSL_CLIENT_HELLO:
   4045                      ret = ssl_parse_client_hello( ssl );
   4046                      break;
   4047          
   4048          #if defined(MBEDTLS_SSL_PROTO_DTLS)
   4049                  case MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT:
   4050                      return( MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED );
   4051          #endif
   4052          
   4053                  /*
   4054                   *  ==>   ServerHello
   4055                   *        Certificate
   4056                   *      ( ServerKeyExchange  )
   4057                   *      ( CertificateRequest )
   4058                   *        ServerHelloDone
   4059                   */
   4060                  case MBEDTLS_SSL_SERVER_HELLO:
   4061                      ret = ssl_write_server_hello( ssl );
   4062                      break;
   4063          
   4064                  case MBEDTLS_SSL_SERVER_CERTIFICATE:
   4065                      ret = mbedtls_ssl_write_certificate( ssl );
   4066                      break;
   4067          
   4068                  case MBEDTLS_SSL_SERVER_KEY_EXCHANGE:
   4069                      ret = ssl_write_server_key_exchange( ssl );
   4070                      break;
   4071          
   4072                  case MBEDTLS_SSL_CERTIFICATE_REQUEST:
   4073                      ret = ssl_write_certificate_request( ssl );
   4074                      break;
   4075          
   4076                  case MBEDTLS_SSL_SERVER_HELLO_DONE:
   4077                      ret = ssl_write_server_hello_done( ssl );
   4078                      break;
   4079          
   4080                  /*
   4081                   *  <== ( Certificate/Alert  )
   4082                   *        ClientKeyExchange
   4083                   *      ( CertificateVerify  )
   4084                   *        ChangeCipherSpec
   4085                   *        Finished
   4086                   */
   4087                  case MBEDTLS_SSL_CLIENT_CERTIFICATE:
   4088                      ret = mbedtls_ssl_parse_certificate( ssl );
   4089                      break;
   4090          
   4091                  case MBEDTLS_SSL_CLIENT_KEY_EXCHANGE:
   4092                      ret = ssl_parse_client_key_exchange( ssl );
   4093                      break;
   4094          
   4095                  case MBEDTLS_SSL_CERTIFICATE_VERIFY:
   4096                      ret = ssl_parse_certificate_verify( ssl );
   4097                      break;
   4098          
   4099                  case MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC:
   4100                      ret = mbedtls_ssl_parse_change_cipher_spec( ssl );
   4101                      break;
   4102          
   4103                  case MBEDTLS_SSL_CLIENT_FINISHED:
   4104                      ret = mbedtls_ssl_parse_finished( ssl );
   4105                      break;
   4106          
   4107                  /*
   4108                   *  ==> ( NewSessionTicket )
   4109                   *        ChangeCipherSpec
   4110                   *        Finished
   4111                   */
   4112                  case MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC:
   4113          #if defined(MBEDTLS_SSL_SESSION_TICKETS)
   4114                      if( ssl->handshake->new_session_ticket != 0 )
   4115                          ret = ssl_write_new_session_ticket( ssl );
   4116                      else
   4117          #endif
   4118                          ret = mbedtls_ssl_write_change_cipher_spec( ssl );
   4119                      break;
   4120          
   4121                  case MBEDTLS_SSL_SERVER_FINISHED:
   4122                      ret = mbedtls_ssl_write_finished( ssl );
   4123                      break;
   4124          
   4125                  case MBEDTLS_SSL_FLUSH_BUFFERS:
   4126                      MBEDTLS_SSL_DEBUG_MSG( 2, ( "handshake: done" ) );
   4127                      ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
   4128                      break;
   4129          
   4130                  case MBEDTLS_SSL_HANDSHAKE_WRAPUP:
   4131                      mbedtls_ssl_handshake_wrapup( ssl );
   4132                      break;
   4133          
   4134                  default:
   4135                      MBEDTLS_SSL_DEBUG_MSG( 1, ( "invalid state %d", ssl->state ) );
   4136                      return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
   4137              }
   4138          
   4139              return( ret );
   4140          }
   4141          #endif /* MBEDTLS_SSL_SRV_C */


 
 
 0 bytes of memory

Errors: none
Warnings: none
